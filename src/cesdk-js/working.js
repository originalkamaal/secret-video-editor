import {
  defineGetter,
  hasCurrentProperty,
} from "../cesdk-common/others/createLazyModule";
import { extractInitialAndAnimateProps } from "./possible-hooks";
import {
  _streams,
  _getBlockStream,
  _makeEngineChannel,
  _makeValueChannel,
  isSpotColor,
  isCMYKColor,
  isRGBAColor,
  LogLevel,
  MimeType,
  supportsVideoExport,
  supportsBrowser,
  supportsWasm,
  supportsVideo,
} from "@/cesdk-engine";
import { emotionIsPropValid } from "../cesdk-common/emotion";
import {
  framerAppearId,
  generateSlug,
  hasAnimationProperties,
  hasVariants,
  isObjHasStartFunc,
  isString,
  isStringOrArray,
  Qg,
  setupRenderingProcessor,
  xh,
} from "./utils";
import {
  _m,
  allAnimationStates,
  Am,
  animationEventProps,
  Bm,
  Cm,
  customColorsMap,
  dimensionalProperties,
  Em,
  interactionStates,
  JC,
  jm,
  km,
  Lm,
  Om,
  Pm,
  Sm,
  SOME_CONSTANTS_KEYS,
  unknownBool1,
  unknownBool2,
  vm,
  wm,
} from "./constants/constants";
import { EventEmitter } from "./classes/EventEmitter";
import { CreativeEditorSDK } from "./classes/CreativeEditorSDK/CreativeEditorSDK";
import { CompCustomIcon } from "./CompCustomIcon";
import { CompCustomButton } from "./CompCustomButton";
import { ComponentController } from "./classes/ComponentController";
import { translations } from "./constants/translations";
import { CompCustomShapes } from "./CompCustomShapes";
import { ColorRelatedSomething } from "./classes/ColorRelatedSomething";
import { PercentageHelper } from "./PercentageHelper";
import {
  react10,
  react3,
  react4,
  react5,
  react6,
  react7,
  react9,
  reactJsx1,
  react13,
  react14,
  ox,
  context1,
  pagePointContext,
  context4,
  context3,
  layoutContext,
  context6,
  Di,
  Fi,
  jo,
  Fo,
  Ho,
  QL,
  _d,
  Ed,
  Ld,
  Pd,
  Bd,
  Md,
  Od,
  Td,
  Id,
  Ud,
  fp,
  _h,
  Vh,
  Uh,
  am,
  em,
  im,
  Kh,
  nm,
  Xh,
  gm,
  hm,
  ym,
  Ig,
  Ug,
  zg,
  lx,
  context9,
  Aae,
  Ble,
  Cae,
  Dae,
  Lae,
  Lle,
  Nle,
  Oae,
  Ole,
  Rle,
  Tae,
  Ule,
  Wae,
  Wle,
  _ae,
  cle,
  gae,
  hae,
  jae,
  oce,
  ole,
  pae,
  tle,
  ule,
  yle,
  $ie,
  $re,
  Aoe,
  Ase,
  Bie,
  Boe,
  Bre,
  Cie,
  Doe,
  Dre,
  Dse,
  Ere,
  Ese,
  Foe,
  Hoe,
  Hse,
  Iie,
  Ise,
  Jie,
  Moe,
  Mse,
  Nie,
  Noe,
  Oie,
  Ooe,
  Pie,
  Pse,
  Qie,
  Qre,
  Rse,
  Sie,
  Sre,
  Sse,
  Tie,
  Ure,
  Use,
  Wie,
  Xre,
  Zoe,
  Zre,
  _oe,
  _se,
  aoe,
  are,
  boe,
  cie,
  cre,
  doe,
  eae,
  fie,
  fre,
  hoe,
  joe,
  jse,
  lae,
  mie,
  mse,
  nre,
  qoe,
  rae,
  soe,
  tae,
  uae,
  uie,
  vie,
  vse,
  woe,
  xse,
  yre,
  zoe,
  $$,
  $1,
  $3,
  $H,
  $K,
  $Z,
  $b,
  A$,
  A2,
  A6,
  A9,
  AS,
  AX,
  Ab,
  Ane,
  Av,
  B7,
  BG,
  BW,
  B_,
  Bv,
  C3,
  CG,
  CQ,
  CW,
  Cne,
  Cw,
  Cz,
  D4,
  D7,
  DI,
  DJ,
  DS,
  DZ,
  Dv,
  Dy,
  Dz,
  E4,
  E7,
  Ej,
  Ene,
  Ev,
  Ew,
  F2,
  FE,
  FS,
  Fb,
  Fee,
  Fj,
  Fk,
  Fne,
  G4,
  G6,
  GH,
  GW,
  Gz,
  H1,
  H7,
  HK,
  HR,
  Hb,
  Hq,
  Hz,
  I2,
  I6,
  IH,
  II,
  IX,
  Iy,
  J4,
  J8,
  JF,
  JG,
  JS,
  J_,
  Jee,
  Jw,
  K$,
  K2,
  K5,
  KQ,
  KS,
  Ky,
  L1,
  L6,
  LI,
  LJ,
  LW,
  Lb,
  Lj,
  M$,
  M2,
  M6,
  M7,
  ME,
  MG,
  MI,
  MS,
  MZ,
  M_,
  Mv,
  N0,
  N4,
  N6,
  NE,
  NF,
  NG,
  NI,
  NW,
  NX,
  NZ,
  Nb,
  Nee,
  Nv,
  O0,
  O4,
  O5,
  OE,
  OI,
  Oy,
  P4,
  P5,
  PG,
  PJ,
  PK,
  P_,
  Pee,
  Pte,
  Py,
  Q$,
  Q0,
  Q3,
  Q6,
  Q7,
  QC,
  QZ,
  Qte,
  Qv,
  Qw,
  Qy,
  Qz,
  R7,
  R9,
  RF,
  RG,
  RS,
  RW,
  Ree,
  Rk,
  Rne,
  Rte,
  Ry,
  S0,
  S1,
  S2,
  S4,
  S6,
  SQ,
  Sx,
  T5,
  T9,
  TJ,
  TS,
  T_,
  Tee,
  Tw,
  U3,
  U7,
  U9,
  UK,
  UZ,
  Ute,
  Uw,
  V$,
  V4,
  V5,
  V6,
  VW,
  Vte,
  Vv,
  Vy,
  W0,
  W1,
  W3,
  W7,
  WW,
  WX,
  Wb,
  Wj,
  Wy,
  X0,
  X2,
  X4,
  X6,
  XC,
  XQ,
  Xee,
  Xj,
  Xne,
  Xte,
  Xz,
  Y$,
  Y0,
  Y2,
  Y4,
  Y7,
  YZ,
  Y_,
  Yz,
  Z$,
  Z3,
  Z5,
  Z7,
  ZG,
  ZS,
  ZX,
  Zb,
  Zj,
  Zte,
  Zv,
  _2,
  _8,
  _9,
  _I,
  _K,
  _S,
  _W,
  __,
  a2,
  a5,
  a7,
  aG,
  aq,
  b2,
  b3,
  b5,
  b6,
  b7,
  b8,
  bI,
  bX,
  bk,
  bte,
  bv,
  by,
  c9,
  cH,
  cI,
  cN,
  cW,
  cZ,
  cne,
  d1,
  d3,
  d9,
  dC,
  dN,
  dS,
  dee,
  dq,
  dse,
  dv,
  dy,
  e1,
  e2,
  eE,
  eK,
  eW,
  eY,
  ene,
  ev,
  f1,
  f2,
  f4,
  fE,
  fJ,
  fK,
  fW,
  fb,
  fee,
  fj,
  fne,
  fse,
  fy,
  g4,
  g6,
  g9,
  gG,
  gQ,
  gne,
  gv,
  gw,
  gy,
  h5,
  h8,
  hI,
  hQ,
  hS,
  h_,
  hb,
  hq,
  hy,
  iD,
  iH,
  iJ,
  iQ,
  ik,
  iv,
  j7,
  j9,
  jJ,
  jZ,
  jee,
  k1,
  k8,
  kE,
  kJ,
  kK,
  kQ,
  kX,
  kZ,
  kee,
  kj,
  kre,
  l7,
  l9,
  lN,
  lW,
  lY,
  lj,
  lse,
  lte,
  m3,
  m9,
  mC,
  mE,
  mG,
  mJ,
  mS,
  mZ,
  mj,
  mte,
  nC,
  nG,
  nN,
  nQ,
  nj,
  o$,
  oC,
  oS,
  oW,
  oX,
  ote,
  ow,
  p$,
  pK,
  pj,
  qC,
  qF,
  qI,
  qJ,
  qk,
  r$,
  r2,
  r4,
  r5,
  r8,
  r9,
  rD,
  rE,
  rK,
  rL,
  rS,
  rj,
  rk,
  s8,
  s9,
  sC,
  sH,
  sS,
  sW,
  sZ,
  sv,
  sw,
  t0,
  t5,
  t9,
  tD,
  tH,
  tL,
  tS,
  tZ,
  t_,
  tq,
  tv,
  u3,
  u7,
  uC,
  uE,
  uY,
  u_,
  uk,
  uw,
  v1,
  v6,
  vS,
  vj,
  vte,
  vw,
  w4,
  w5,
  w6,
  wS,
  wZ,
  w_,
  wne,
  wv,
  ww,
  wy,
  x8,
  xQ,
  xW,
  xX,
  x_,
  xk,
  xne,
  y5,
  y7,
  y9,
  yW,
  yX,
  yee,
  yw,
  z2,
  z4,
  zE,
  zQ,
  zZ,
  zee,
  zw,
  zz,
  $7,
  A3,
  Ate,
  B8,
  F9,
  H3,
  H9,
  L8,
  M8,
  Qee,
  V8,
  Wee,
  Yne,
  c0,
  f5,
  ise,
  n4,
  o1,
  o2,
  p3,
  s1,
  tse,
  ute,
  w9,
  zJ,
  C1,
  jx,
  BJ,
  DW,
  EG,
  FW,
  KX,
  KY,
  LG,
  OG,
  PX,
  QH,
  R$,
  SJ,
  UW,
  XY,
  YG,
  ZH,
  cY,
  iq,
  j$,
  jz,
  rN,
  uN,
  ED,
  FO,
  FV,
  F_,
  JR,
  MF,
  NL,
  Q_,
  SI,
  TO,
  UR,
  XE,
  XF,
  ZF,
  ZV,
  aH,
  dD,
  dL,
  dO,
  eL,
  fI,
  hD,
  oH,
  oL,
  oV,
  pD,
  pL,
  qE,
  sD,
  sL,
  tO,
  uL,
  vD,
  wV,
  zI,
  Gv,
  IS,
  Jy,
  Kv,
  L_,
  Wv,
  _v,
  aS,
  gS,
  ifUseStateNoAvailable,
  iw,
  nv,
  pC,
  vy,
  wj,
  xv,
  yy,
  Xx,
} from "./reacts";
import { WF } from "./reacts";
import { UIComponents } from "./UIComponents";
import {
  CanvasMenuBuilder,
  UIComponentBuilder,
  reactJsx2,
} from "./UIComponentBuilder";
import { NamespaceHelper } from "./NamespaceHelper";
import { CompPlainToggleButton } from "./CompPlainToggleButton";
import { CompTooltip } from "./CompTooltip";
import {
  isDOMAvailable,
  uploadHandler,
} from "./classes/CreativeEditorSDK/utils/uploadHandler";
import {
  EditorModes,
  StandardResolutions,
  CanvasSizeConfig,
  DefaultViewMode,
  NavigationPanelConfig,
  BleedMarginConfig,
  ImageLibraryConfig,
  VideoLibraryConfig,
  AudioLibraryConfig,
  ResolutionOptions,
  PlaybackSpeedOptions,
  FontSizeOptions,
  InspectorPanelConfig,
  AssetLibraryPanelConfig,
  MediaSourceIds,
} from "./constants/configs";
import { FrameRenderer } from "./FrameRenderer";
import { CompButtonGroup } from "./CompButtonGroup";
import { CompLayout1 } from "./CompLayout1";
import { IconUndo } from "./IconUndo.jsx";
import { IconRedo } from "./IconRedo.jsx";
import { SizeProvider } from "./ContextWrapper2";
import { ContextWrapper6 } from "./ContextWrapper6";
import { ContextWrapper5 } from "./ContextWrapper5";
import { ContextWrapper4 } from "./ContextWrapper4";
import { DockBuilder } from "./DockBuilder";
import { isValidElementType } from "./isValidElementType";
import {
  $5,
  $8,
  $ne,
  _te,
  a3,
  a6,
  aQ,
  Are,
  ase,
  aY,
  AZ,
  B0,
  bE,
  BY,
  bZ,
  c3,
  c6,
  CC,
  cQ,
  CY,
  d6,
  DK,
  dQ,
  Dw,
  DY,
  e$,
  e7,
  EJ,
  EY,
  F0,
  f6,
  FG,
  fle,
  Fle,
  fQ,
  FX,
  G9,
  Gae,
  gk,
  Gq,
  gW,
  gX,
  GY,
  H0,
  H8,
  h9,
  hG,
  HG,
  Hle,
  hte,
  HZ,
  i$,
  i7,
  iie,
  ite,
  Iw,
  IY,
  J9,
  Jq,
  jte,
  K8,
  kae,
  Kne,
  Lee,
  lie,
  Lie,
  lne,
  Lte,
  lZ,
  M0,
  mle,
  mv,
  MY,
  mY,
  n$,
  n7,
  n8,
  Nae,
  Nne,
  nte,
  Nw,
  NY,
  o3,
  o6,
  Ore,
  OW,
  OX,
  p8,
  pte,
  PY,
  Q5,
  Q8,
  q9,
  qae,
  Qne,
  qq,
  Qse,
  qv,
  qY,
  r7,
  rie,
  RK,
  rne,
  Rw,
  RY,
  rZ,
  s3,
  s6,
  SY,
  t3,
  t6,
  tQ,
  TX,
  u8,
  U8,
  uee,
  uK,
  Une,
  V0,
  Vre,
  VX,
  vZ,
  W9,
  wC,
  wQ,
  Wq,
  wY,
  WY,
  x5,
  xE,
  xle,
  xre,
  xY,
  Y9,
  Yb,
  yE,
  yQ,
  Yq,
  Yre,
  yS,
  yY,
  Z8,
  zae,
  Zne,
  zq,
  Zse,
  zY,
} from "./icons/Icons";
import { IconPhoto } from "./icons/IconPhoto.jsx";
import { IconUpload } from "./icons/IconUpload.jsx";
import { IconCheckmark } from "./icons/IconCheckmark.jsx";
import { IconPlayOutline } from "./icons/IconPlayOutline.jsx";
import { IconFontT } from "./icons/IconFontT.jsx";
import { IconSticker } from "./icons/IconSticker.jsx";
import { IconShapes } from "./icons/IconShapes.jsx";
import { IconMusic } from "./icons/IconMusic.jsx";
import { IconChevronDown } from "./icons/IconChevronDown.jsx";
import { IconChevronUp } from "./icons/IconChevronUp.jsx";
import {
  Eh,
  Lh,
  Ph,
  Ah,
  Bh,
  Th,
  Mh,
  Oh,
  Rh,
  Nh,
  Yh,
  tm,
  jb,
  Sb,
  _b,
  Eb,
  Bb,
  Tb,
  Mb,
  Ob,
  Rb,
  Db,
  Vb,
  Ub,
  zb,
  Xb,
  Jb,
  ey,
  ay,
  ly,
  uy,
  cy,
  ry,
  oy,
  ty,
  ny,
  sy,
  my,
  Fy,
  Uy,
  zy,
  $y,
  qy,
  lv,
  cv,
  uv,
  Tv,
  kw,
  Xw,
  sk,
  nk,
  kk,
  jk,
  Sk,
  Mk,
  _k,
  Ak,
  Lk,
  Pk,
  Bk,
  Tk,
  Ck,
  Ok,
  Ik,
  Hk,
  Nk,
  Uk,
  zk,
  $k,
  fC,
  hC,
  GC,
  KC,
  WC,
  ZC,
  YC,
  aj,
  Pj,
  Tj,
  Dj,
  Aj,
  Bj,
  Mj,
  Rj,
  Oj,
  Vj,
  Kj,
  Yj,
  nS,
  kS,
  SS,
  CS,
  jS,
  HS,
  NS,
  $S,
  QS,
  GS,
  zS,
  US,
  qS,
  d_,
  p_,
  f_,
  k_,
  C_,
  j_,
  S_,
  tE,
  nE,
  sE,
  oE,
  iE,
  dE,
  pE,
  RE,
  VE,
  DE,
  EI,
  FH,
  MH,
  WH,
  XH,
  tN,
  KH,
  YH,
  eN,
  JH,
  c$,
  u$,
  d$,
  P$,
  D$,
  I$,
  H$,
  N$,
  U$,
  z$,
  F$,
  TI,
  uq,
  fq,
  sQ,
  MQ,
  OQ,
  RQ,
  DQ,
  FQ,
  IQ,
  VQ,
  HQ,
  yG,
  wG,
  kG,
  vG,
  UG,
  zG,
  $G,
  qG,
  QG,
  GG,
  fZ,
  uZ,
  dZ,
  pZ,
  BZ,
  TZ,
  RZ,
  VZ,
  WZ,
  KZ,
  uW,
  dW,
  pW,
  aW,
  hZ,
  EW,
  AW,
  zW,
  $W,
  JW,
  oK,
  iK,
  hK,
  gK,
  mK,
  xK,
  vK,
  yK,
  wK,
  FK,
  IK,
  JK,
  fY,
  pY,
  vX,
  wX,
  XX,
  eJ,
  JX,
  nJ,
  tJ,
  sJ,
  YX,
  C0,
  j0,
  k0,
  U0,
  z0,
  q0,
  $0,
  u1,
  j1,
  Y1,
  X1,
  J1,
  K1,
  k5,
  C5,
  S5,
  _5,
  E5,
  L5,
  G5,
  h4,
  m4,
  C4,
  j4,
  L4,
  B4,
  T4,
  M4,
  Q4,
  y3,
  v3,
  w3,
  k3,
  z3,
  v7,
  w7,
  k7,
  V7,
  I7,
  J7,
  e9,
  b9,
  P9,
  h6,
  m6,
  k6,
  C6,
  j6,
  f8,
  Uee,
  ate,
  rte,
  Ite,
  Nte,
  Hte,
  qte,
  Kte,
  Wte,
  mne,
  _ne,
  OH,
  gse,
  die,
  pie,
  nie,
  Wse,
  Kse,
  Xse,
  eie,
  Yse,
  Jse,
  tie,
  yie,
  kie,
  bie,
  Fie,
  Die,
  zie,
  Zie,
  noe,
  roe,
  uoe,
  foe,
  voe,
  Coe,
  $oe,
  Goe,
  bre,
  wre,
  Vae,
  ile,
  sle,
  Ale,
  Zle,
  dY,
  Kx,
  C7,
} from "./vh";
import { ClickOutsideContextProvider } from "./ClickOutsideContextProvider";
import { ContextPortalContextProvider } from "./ContextPortalContextProvider";
import { PopoverWrapper, cC, gC, Jx, Kk, tC, Ux, Wx, yx } from "./components/AllComponents";
import { lb } from "./lb";
import { ContextWrapper8 } from "./ContextWrapper8";
import { CanvasZooming } from "./CanvasZooming";
import { TimelineZooming } from "./TimelineZooming";
import { useShortcutScope } from "./useShortcutScope";

export var isDocumentDefined = "undefined" != typeof document;
export var dynamicUseEffect = isDocumentDefined
  ? react6.useLayoutEffect
  : react6.useEffect;
export var {
  schedule: renderingProcessorSchedule,
  cancel: renderingProcessorCancel,
} = setupRenderingProcessor(queueMicrotask, false);
export var Li = {};
for (const e in animationEventProps)
  Li[e] = { isEnabled: (t) => animationEventProps[e].some((e) => !!t[e]) };
export var motionComponentSymbol = Symbol.for("motionComponentSymbol");

export function ContextProviderContext1({
  preloadedFeatures: preloadedFeatures,
  createVisualElement: createVisualElement,
  useRender: useRender,
  useVisualState: useVisualState,
  Component: Component,
}) {
  preloadedFeatures &&
    (function (e) {
      for (const t in e) Li[t] = { ...Li[t], ...e[t] };
    })(preloadedFeatures);
  const o = (0, react4.forwardRef)(function (o, r) {
    let a;
    const l = {
      ...(0, react4.useContext)(pagePointContext),
      ...o,
      layoutId: Mi(o),
    };
    const { isStatic: c } = l;
    var u = extractInitialAndAnimateProps(o);
    var d = useVisualState(o, c);
    if (!c && isDocumentDefined) {
      u.visualElement = (function (e, t, n, s) {
        const { visualElement: i } = (0, react5.useContext)(context1),
          o = (0, react5.useContext)(context3),
          r = (0, react5.useContext)(context4),
          a = (0, react5.useContext)(pagePointContext)?.reducedMotion,
          l = (0, react5.useRef)();
        (s = s || o.renderer),
          !l.current &&
            s &&
            (l.current = s(e, {
              visualState: t,
              parent: i,
              props: n,
              presenceContext: r,
              blockInitialAnimation: !!r && false === r.initial,
              reducedMotionConfig: a,
            }));
        const c = l.current;
        (0, react5.useInsertionEffect)(() => {
          c && c.update(n, r);
        });
        const u = (0, react5.useRef)(
          Boolean(n[framerAppearId] && !window.HandoffComplete)
        );
        return (
          dynamicUseEffect(() => {
            c &&
              (renderingProcessorSchedule.postRender(c.render),
              u.current &&
                c.animationState &&
                c.animationState.animateChanges());
          }),
          (0, react5.useEffect)(() => {
            c &&
              (c.updateFeatures(),
              !u.current &&
                c.animationState &&
                c.animationState.animateChanges(),
              u.current &&
                ((u.current = false), (window.HandoffComplete = true)));
          }),
          c
        );
      })(Component, d, l, createVisualElement);
      const n = (0, react4.useContext)(context6),
        s = (0, react4.useContext)(context3).strict;
      u.visualElement &&
        (a = u.visualElement.loadFeatures(l, s, preloadedFeatures, n));
    }
    return react3.createElement(
      context1.Provider,
      { value: u },
      a && u.visualElement
        ? react3.createElement(a, { visualElement: u.visualElement, ...l })
        : null,
      useRender(
        Component,
        o,
        (function (e, t, n) {
          return (0, react7.useCallback)(
            (s) => {
              s && e.mount && e.mount(s),
                t && (s ? t.mount(s) : t.unmount()),
                n &&
                  ("function" == typeof n
                    ? n(s)
                    : hasCurrentProperty(n) && (n.current = s));
            },
            [t]
          );
        })(d, u.visualElement, r),
        d,
        c,
        u.visualElement
      )
    );
  });
  return (o[motionComponentSymbol] = Component), o;
}

export function Mi({ layoutId: e }) {
  const t = (0, react4.useContext)(layoutContext).id;
  return t && undefined !== e ? t + "-" + e : e;
}
export function Oi(e) {
  function t(t, n = {}) {
    return ContextProviderContext1(e(t, n));
  }
  if ("undefined" == typeof Proxy) return t;
  const n = new Map();
  return new Proxy(t, {
    get: (e, s) => (n.has(s) || n.set(s, t(s)), n.get(s)),
  });
}
export var dimentionalPropsState = {};
export var dimensionalPropertiesSet = new Set(dimensionalProperties);
export function Ui(property, { layout, layoutId }) {
  return (
    dimensionalPropertiesSet.has(property) ||
    property.startsWith("origin") ||
    ((layout || undefined !== layoutId) &&
      (!!dimentionalPropsState[property] || "opacity" === property))
  );
}
export var zi = (e) => Boolean(e && e.getVelocity);
export var $i = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective",
};
export var qi = dimensionalProperties.length;
export var Qi = (e) => (t) => "string" == typeof t && t.startsWith(e);
export var Gi = Qi("--");
export var Zi = Qi("var(--");
export var Wi = (e, t) => (t && "number" == typeof e ? t.transform(e) : e);
export var Ki = (e, t, n) => Math.min(Math.max(n, e), t);
export var Yi = {
  test: (e) => "number" == typeof e,
  parse: parseFloat,
  transform: (e) => e,
};
export var Xi = { ...Yi, transform: (e) => Ki(0, 1, e) };
export var Ji = { ...Yi, default: 1 };
export var eo = (e) => Math.round(1e5 * e) / 1e5;
export var to = /(-)?([\d]*\.?[\d])+/g;
export var no =
  /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
export var so =
  /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
export var suffixValidator = (suffix) => ({
  test: (inputStr) =>
    isString(inputStr) &&
    inputStr.endsWith(suffix) &&
    1 === inputStr.split(" ").length,
  parse: parseFloat,
  transform: (value) => `${value}${suffix}`,
});
export var degUnit = suffixValidator("deg");
export var percentUnit = suffixValidator("%");
export var pixelUnit = suffixValidator("px");
export var vhUnit = suffixValidator("vh");
export var vwUnit = suffixValidator("vw");
export var po = {
  ...percentUnit,
  parse: (e) => percentUnit.parse(e) / 100,
  transform: (e) => percentUnit.transform(100 * e),
};
export var fo = { ...Yi, transform: Math.round };
export var ho = {
  borderWidth: pixelUnit,
  borderTopWidth: pixelUnit,
  borderRightWidth: pixelUnit,
  borderBottomWidth: pixelUnit,
  borderLeftWidth: pixelUnit,
  borderRadius: pixelUnit,
  radius: pixelUnit,
  borderTopLeftRadius: pixelUnit,
  borderTopRightRadius: pixelUnit,
  borderBottomRightRadius: pixelUnit,
  borderBottomLeftRadius: pixelUnit,
  width: pixelUnit,
  maxWidth: pixelUnit,
  height: pixelUnit,
  maxHeight: pixelUnit,
  size: pixelUnit,
  top: pixelUnit,
  right: pixelUnit,
  bottom: pixelUnit,
  left: pixelUnit,
  padding: pixelUnit,
  paddingTop: pixelUnit,
  paddingRight: pixelUnit,
  paddingBottom: pixelUnit,
  paddingLeft: pixelUnit,
  margin: pixelUnit,
  marginTop: pixelUnit,
  marginRight: pixelUnit,
  marginBottom: pixelUnit,
  marginLeft: pixelUnit,
  rotate: degUnit,
  rotateX: degUnit,
  rotateY: degUnit,
  rotateZ: degUnit,
  scale: Ji,
  scaleX: Ji,
  scaleY: Ji,
  scaleZ: Ji,
  skew: degUnit,
  skewX: degUnit,
  skewY: degUnit,
  distance: pixelUnit,
  translateX: pixelUnit,
  translateY: pixelUnit,
  translateZ: pixelUnit,
  x: pixelUnit,
  y: pixelUnit,
  z: pixelUnit,
  perspective: pixelUnit,
  transformPerspective: pixelUnit,
  opacity: Xi,
  originX: po,
  originY: po,
  originZ: pixelUnit,
  zIndex: fo,
  fillOpacity: Xi,
  strokeOpacity: Xi,
  numOctaves: fo,
};
export function mo(e, t, n, s) {
  const { style: i, vars: o, transform: r, transformOrigin: a } = e;
  let l = false,
    c = false,
    u = true;
  for (const e in t) {
    const n = t[e];
    if (Gi(e)) {
      o[e] = n;
      continue;
    }
    const s = ho[e],
      d = Wi(n, s);
    if (dimensionalPropertiesSet.has(e)) {
      if (((l = true), (r[e] = d), !u)) continue;
      n !== (s.default || 0) && (u = false);
    } else e.startsWith("origin") ? ((c = true), (a[e] = d)) : (i[e] = d);
  }
  if (
    (t.transform ||
      (l || s
        ? (i.transform = (function (
            e,
            {
              enableHardwareAcceleration: t = true,
              allowTransformNone: n = true,
            },
            s,
            i
          ) {
            let o = "";
            for (let t = 0; t < qi; t++) {
              const n = dimensionalProperties[t];
              undefined !== e[n] && (o += `${$i[n] || n}(${e[n]}) `);
            }
            return (
              t && !e.z && (o += "translateZ(0)"),
              (o = o.trim()),
              i ? (o = i(e, s ? "" : o)) : n && s && (o = "none"),
              o
            );
          })(e.transform, n, u, s))
        : i.transform && (i.transform = "none")),
    c)
  ) {
    const { originX: e = "50%", originY: t = "50%", originZ: n = 0 } = a;
    i.transformOrigin = `${e} ${t} ${n}`;
  }
}
export var go = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {},
});
export function xo(e, t, n) {
  for (const s in t) zi(t[s]) || Ui(s, n) || (e[s] = t[s]);
}
export function bo(e, t, n) {
  const s = {};
  return (
    xo(s, e.style || {}, e),
    Object.assign(
      s,
      (function ({ transformTemplate: e }, t, n) {
        return (0, Fi.useMemo)(() => {
          const s = go();
          return (
            mo(s, t, { enableHardwareAcceleration: !n }, e),
            Object.assign({}, s.vars, s.style)
          );
        }, [t]);
      })(e, t, n)
    ),
    s
  );
}
export function yo(e, t, n) {
  const s = {},
    i = bo(e, t, n);
  return (
    e.drag &&
      false !== e.dragListener &&
      ((s.draggable = false),
      (i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none"),
      (i.touchAction =
        true === e.drag ? "none" : "pan-" + ("x" === e.drag ? "y" : "x"))),
    undefined === e.tabIndex &&
      (e.onTap || e.onTapStart || e.whileTap) &&
      (s.tabIndex = 0),
    (s.style = i),
    s
  );
}
export function wo(e) {
  return (
    e.startsWith("while") ||
    (e.startsWith("drag") && "draggable" !== e) ||
    e.startsWith("layout") ||
    e.startsWith("onTap") ||
    e.startsWith("onPan") ||
    e.startsWith("onLayout") ||
    SOME_CONSTANTS_KEYS.has(e)
  );
}
export var ko;
export var Co = (e) => !wo(e);
try {
  (ko = emotionIsPropValid().default) &&
    (Co = (e) => (e.startsWith("on") ? !wo(e) : ko(e)));
} catch (e) {}
export function So(e, t, n) {
  return "string" == typeof e ? e : pixelUnit.transform(t + n * e);
}
export var _o = { offset: "stroke-dashoffset", array: "stroke-dasharray" };
export var Eo = { offset: "strokeDashoffset", array: "strokeDasharray" };
export function Lo(
  e,
  {
    attrX: t,
    attrY: n,
    attrScale: s,
    originX: i,
    originY: o,
    pathLength: r,
    pathSpacing: a = 1,
    pathOffset: l = 0,
    ...c
  },
  u,
  d,
  p
) {
  if ((mo(e, c, u, p), d))
    return void (e.style.viewBox && (e.attrs.viewBox = e.style.viewBox));
  (e.attrs = e.style), (e.style = {});
  const { attrs: f, style: h, dimensions: m } = e;
  f.transform && (m && (h.transform = f.transform), delete f.transform),
    m &&
      (undefined !== i || undefined !== o || h.transform) &&
      (h.transformOrigin = (function (e, t, n) {
        return `${So(t, e.x, e.width)} ${So(n, e.y, e.height)}`;
      })(m, undefined !== i ? i : 0.5, undefined !== o ? o : 0.5)),
    undefined !== t && (f.x = t),
    undefined !== n && (f.y = n),
    undefined !== s && (f.scale = s),
    undefined !== r &&
      (function (e, t, n = 1, s = 0, i = true) {
        e.pathLength = 1;
        const o = i ? _o : Eo;
        e[o.offset] = pixelUnit.transform(-s);
        const r = pixelUnit.transform(t),
          a = pixelUnit.transform(n);
        e[o.array] = `${r} ${a}`;
      })(f, r, a, l, false);
}
export var Po = () => ({ ...go(), attrs: {} });
export var Ao = (e) => "string" == typeof e && "svg" === e.toLowerCase();
export function Bo(e, t, n, s) {
  const i = (0, jo.useMemo)(() => {
    const n = Po();
    return (
      Lo(
        n,
        t,
        { enableHardwareAcceleration: false },
        Ao(s),
        e.transformTemplate
      ),
      { ...n.attrs, style: { ...n.style } }
    );
  }, [t]);
  if (e.style) {
    const t = {};
    xo(t, e.style, e), (i.style = { ...t, ...i.style });
  }
  return i;
}
export function To(e = false) {
  return (t, n, s, { latestValues: i }, o) => {
    const r = (isValidElementType(t) ? Bo : yo)(n, i, o, t),
      a = (function (e, t, n) {
        const s = {};
        for (const i in e)
          ("values" === i && "object" == typeof e.values) ||
            ((Co(i) ||
              (true === n && wo(i)) ||
              (!t && !wo(i)) ||
              (e.draggable && i.startsWith("onDrag"))) &&
              (s[i] = e[i]));
        return s;
      })(n, "string" == typeof t, e),
      l = { ...a, ...r, ref: s },
      { children: c } = n,
      u = (0, Di.useMemo)(() => (zi(c) ? c.get() : c), [c]);
    return (0, Di.createElement)(t, { ...l, children: u });
  };
}
export function Mo(e, { style: t, vars: n }, s, i) {
  Object.assign(e.style, t, i && i.getProjectionStyles(s));
  for (const t in n) e.style.setProperty(t, n[t]);
}
export var Oo = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
export function Ro(e, t, n, s) {
  Mo(e, t, undefined, s);
  for (const n in t.attrs)
    e.setAttribute(Oo.has(n) ? n : generateSlug(n), t.attrs[n]);
}
export function Vo(e, t) {
  const { style: n } = e,
    s = {};
  for (const i in n)
    (zi(n[i]) || (t.style && zi(t.style[i])) || Ui(i, e)) && (s[i] = n[i]);
  return s;
}
export function Do(e, t) {
  const n = Vo(e, t);
  for (const s in e)
    if (zi(e[s]) || zi(t[s])) {
      n[
        -1 !== dimensionalProperties.indexOf(s)
          ? "attr" + s.charAt(0).toUpperCase() + s.substring(1)
          : s
      ] = e[s];
    }
  return n;
}
export function Io(e, t, n, s = {}, i = {}) {
  return (
    "function" == typeof t && (t = t(undefined !== n ? n : e.custom, s, i)),
    "string" == typeof t && (t = e.variants && e.variants[t]),
    "function" == typeof t && (t = t(undefined !== n ? n : e.custom, s, i)),
    t
  );
}
export function No(e) {
  const t = (0, Ho.useRef)(null);
  return null === t.current && (t.current = e()), t.current;
}
export var Uo = (e) => Array.isArray(e);
export var zo = (e) => Boolean(e && "object" == typeof e && e.mix && e.toValue);
export var $o = (e) => (Uo(e) ? e[e.length - 1] || 0 : e);
export function qo(e) {
  const t = zi(e) ? e.get() : e;
  return zo(t) ? t.toValue() : t;
}
export var Qo = (e) => (t, n) => {
  const s = (0, Fo.useContext)(context1),
    i = (0, Fo.useContext)(context4),
    o = () =>
      (function (
        { scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n },
        s,
        i,
        o
      ) {
        const r = { latestValues: Go(s, i, o, e), renderState: t() };
        return n && (r.mount = (e) => n(s, e, r)), r;
      })(e, t, s, i);
  return n ? o() : No(o);
};
export function Go(e, t, n, s) {
  const i = {},
    o = s(e, {});
  for (const e in o) i[e] = qo(o[e]);
  let { initial: r, animate: a } = e;
  const l = hasAnimationProperties(e),
    c = hasVariants(e);
  t &&
    c &&
    !l &&
    false !== e.inherit &&
    (undefined === r && (r = t.initial), undefined === a && (a = t.animate));
  let u = !!n && false === n.initial;
  u = u || false === r;
  const d = u ? a : r;
  if (d && "boolean" != typeof d && !isObjHasStartFunc(d)) {
    (Array.isArray(d) ? d : [d]).forEach((t) => {
      const n = Io(e, t);
      if (!n) return;
      const { transitionEnd: s, transition: o, ...r } = n;
      for (const e in r) {
        let t = r[e];
        if (Array.isArray(t)) {
          t = t[u ? t.length - 1 : 0];
        }
        null !== t && (i[e] = t);
      }
      for (const e in s) i[e] = s[e];
    });
  }
  return i;
}
export var Zo = (e) => e,
  {
    schedule: Wo,
    cancel: Ko,
    state: Yo,
    steps: Xo,
  } = setupRenderingProcessor(
    "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : Zo,
    true
  );
export var Jo = {
  useVisualState: Qo({
    scrapeMotionValuesFromProps: Do,
    createRenderState: Po,
    onMount: (e, t, { renderState: n, latestValues: s }) => {
      Wo.read(() => {
        try {
          n.dimensions =
            "function" == typeof t.getBBox
              ? t.getBBox()
              : t.getBoundingClientRect();
        } catch (e) {
          n.dimensions = { x: 0, y: 0, width: 0, height: 0 };
        }
      }),
        Wo.render(() => {
          Lo(
            n,
            s,
            { enableHardwareAcceleration: false },
            Ao(t.tagName),
            e.transformTemplate
          ),
            Ro(t, n);
        });
    },
  }),
};
export var er = {
  useVisualState: Qo({
    scrapeMotionValuesFromProps: Vo,
    createRenderState: go,
  }),
};
export function addEventListenerWithCleanup(
  element,
  eventType,
  listener,
  options = { passive: true }
) {
  return (
    element.addEventListener(eventType, listener, options),
    () => element.removeEventListener(eventType, listener)
  );
}
export var nr = (e) =>
  "mouse" === e.pointerType
    ? "number" != typeof e.button || e.button <= 0
    : false !== e.isPrimary;
export function sr(e, t = "page") {
  return { point: { x: e[t + "X"], y: e[t + "Y"] } };
}
export var ir = (e) => (t) => nr(t) && e(t, sr(t));
export function or(e, t, n, s) {
  return addEventListenerWithCleanup(e, t, ir(n), s);
}
export var rr = (e, t) => (n) => t(e(n));
export var ar = (...e) => e.reduce(rr);
export function lr(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return null === t && ((t = e), n);
  };
}
export var cr = lr("dragHorizontal");
export var ur = lr("dragVertical");
export function dr(e) {
  let t = false;
  if ("y" === e) t = ur();
  else if ("x" === e) t = cr();
  else {
    const e = cr(),
      n = ur();
    e && n
      ? (t = () => {
          e(), n();
        })
      : (e && e(), n && n());
  }
  return t;
}
export function pr() {
  const e = dr(true);
  return !e || (e(), false);
}

export function hr(e, t) {
  const n = "pointer" + (t ? "enter" : "leave"),
    s = "onHover" + (t ? "Start" : "End");
  return or(
    e.current,
    n,
    (n, i) => {
      if ("touch" === n.pointerType || pr()) return;
      const o = e.getProps();
      e.animationState &&
        o.whileHover &&
        e.animationState.setActive("whileHover", t),
        o[s] && Wo.update(() => o[s](n, i));
    },
    { passive: !e.getProps()[s] }
  );
}
export var mr = (e, t) => !!t && (e === t || mr(e, t.parentElement));
export function gr(e, t) {
  if (!t) return;
  const n = new PointerEvent("pointer" + e);
  t(n, sr(n));
}
export var xr = new WeakMap();
export var br = new WeakMap();
export var yr = (e) => {
  const t = xr.get(e.target);
  t && t(e);
};
export var vr = (e) => {
  e.forEach(yr);
};
export function wr(e, t, n) {
  const s = (function ({ root: e, ...t }) {
    const n = e || document;
    br.has(n) || br.set(n, {});
    const s = br.get(n),
      i = JSON.stringify(t);
    return (
      s[i] || (s[i] = new IntersectionObserver(vr, { root: e, ...t })), s[i]
    );
  })(t);
  return (
    xr.set(e, n),
    s.observe(e),
    () => {
      xr.delete(e), s.unobserve(e);
    }
  );
}
export var kr = { some: 0, all: 1 };
export var Cr = {
  inView: {
    Feature: class extends FrameRenderer {
      constructor() {
        super(...arguments),
          (this.hasEnteredView = false),
          (this.isInView = false);
      }
      startObserver() {
        this.unmount();
        const { viewport: e = {} } = this.node.getProps(),
          { root: t, margin: n, amount: s = "some", once: i } = e,
          o = {
            root: t ? t.current : undefined,
            rootMargin: n,
            threshold: "number" == typeof s ? s : kr[s],
          };
        return wr(this.node.current, o, (e) => {
          const { isIntersecting: t } = e;
          if (this.isInView === t) return;
          if (((this.isInView = t), i && !t && this.hasEnteredView)) return;
          t && (this.hasEnteredView = true),
            this.node.animationState &&
              this.node.animationState.setActive("whileInView", t);
          const { onViewportEnter: n, onViewportLeave: s } =
              this.node.getProps(),
            o = t ? n : s;
          o && o(e);
        });
      }
      mount() {
        this.startObserver();
      }
      update() {
        if ("undefined" == typeof IntersectionObserver) return;
        const { props: e, prevProps: t } = this.node;
        ["amount", "margin", "root"].some(
          (function ({ viewport: e = {} }, { viewport: t = {} } = {}) {
            return (n) => e[n] !== t[n];
          })(e, t)
        ) && this.startObserver();
      }
      unmount() {}
    },
  },
  tap: {
    Feature: class extends FrameRenderer {
      constructor() {
        super(...arguments),
          (this.removeStartListeners = Zo),
          (this.removeEndListeners = Zo),
          (this.removeAccessibleListeners = Zo),
          (this.startPointerPress = (e, t) => {
            if (this.isPressing) return;
            this.removeEndListeners();
            const n = this.node.getProps(),
              s = or(
                window,
                "pointerup",
                (e, t) => {
                  if (!this.checkPressEnd()) return;
                  const {
                    onTap: n,
                    onTapCancel: s,
                    globalTapTarget: i,
                  } = this.node.getProps();
                  Wo.update(() => {
                    i || mr(this.node.current, e.target)
                      ? n && n(e, t)
                      : s && s(e, t);
                  });
                },
                { passive: !(n.onTap || n.onPointerUp) }
              ),
              i = or(
                window,
                "pointercancel",
                (e, t) => this.cancelPress(e, t),
                { passive: !(n.onTapCancel || n.onPointerCancel) }
              );
            (this.removeEndListeners = ar(s, i)), this.startPress(e, t);
          }),
          (this.startAccessiblePress = () => {
            const e = addEventListenerWithCleanup(
                this.node.current,
                "keydown",
                (e) => {
                  if ("Enter" !== e.key || this.isPressing) return;
                  this.removeEndListeners(),
                    (this.removeEndListeners = addEventListenerWithCleanup(
                      this.node.current,
                      "keyup",
                      (e) => {
                        "Enter" === e.key &&
                          this.checkPressEnd() &&
                          gr("up", (e, t) => {
                            const { onTap: n } = this.node.getProps();
                            n && Wo.update(() => n(e, t));
                          });
                      }
                    )),
                    gr("down", (e, t) => {
                      this.startPress(e, t);
                    });
                }
              ),
              t = addEventListenerWithCleanup(this.node.current, "blur", () => {
                this.isPressing &&
                  gr("cancel", (e, t) => this.cancelPress(e, t));
              });
            this.removeAccessibleListeners = ar(e, t);
          });
      }
      startPress(e, t) {
        this.isPressing = true;
        const { onTapStart: n, whileTap: s } = this.node.getProps();
        s &&
          this.node.animationState &&
          this.node.animationState.setActive("whileTap", true),
          n && Wo.update(() => n(e, t));
      }
      checkPressEnd() {
        this.removeEndListeners(), (this.isPressing = false);
        return (
          this.node.getProps().whileTap &&
            this.node.animationState &&
            this.node.animationState.setActive("whileTap", false),
          !pr()
        );
      }
      cancelPress(e, t) {
        if (!this.checkPressEnd()) return;
        const { onTapCancel: n } = this.node.getProps();
        n && Wo.update(() => n(e, t));
      }
      mount() {
        const e = this.node.getProps(),
          t = or(
            e.globalTapTarget ? window : this.node.current,
            "pointerdown",
            this.startPointerPress,
            { passive: !(e.onTapStart || e.onPointerStart) }
          ),
          n = addEventListenerWithCleanup(
            this.node.current,
            "focus",
            this.startAccessiblePress
          );
        this.removeStartListeners = ar(t, n);
      }
      unmount() {
        this.removeStartListeners(),
          this.removeEndListeners(),
          this.removeAccessibleListeners();
      }
    },
  },
  focus: {
    Feature: class extends FrameRenderer {
      constructor() {
        super(...arguments), (this.isActive = false);
      }
      onFocus() {
        let e = false;
        try {
          e = this.node.current.matches(":focus-visible");
        } catch (t) {
          e = true;
        }
        e &&
          this.node.animationState &&
          (this.node.animationState.setActive("whileFocus", true),
          (this.isActive = true));
      }
      onBlur() {
        this.isActive &&
          this.node.animationState &&
          (this.node.animationState.setActive("whileFocus", false),
          (this.isActive = false));
      }
      mount() {
        this.unmount = ar(
          addEventListenerWithCleanup(this.node.current, "focus", () =>
            this.onFocus()
          ),
          addEventListenerWithCleanup(this.node.current, "blur", () =>
            this.onBlur()
          )
        );
      }
      unmount() {}
    },
  },
  hover: {
    Feature: class extends FrameRenderer {
      mount() {
        this.unmount = ar(hr(this.node, true), hr(this.node, false));
      }
      unmount() {}
    },
  },
};
export function jr(e, t) {
  if (!Array.isArray(t)) return false;
  const n = t.length;
  if (n !== e.length) return false;
  for (let s = 0; s < n; s++) if (t[s] !== e[s]) return false;
  return true;
}
export function Sr(e, t, n) {
  const s = e.getProps();
  return Io(
    s,
    t,
    undefined !== n ? n : s.custom,
    (function (e) {
      const t = {};
      return e.values.forEach((e, n) => (t[n] = e.get())), t;
    })(e),
    (function (e) {
      const t = {};
      return e.values.forEach((e, n) => (t[n] = e.getVelocity())), t;
    })(e)
  );
}
export var _r = Zo;
export var Er = Zo;
export var Lr = (e) => 1e3 * e;
export var Pr = (e) => e / 1e3;
export var Ar = false;
export var Br = (e) => Array.isArray(e) && "number" == typeof e[0];
export function Tr(e) {
  return Boolean(
    !e ||
      ("string" == typeof e && Or[e]) ||
      Br(e) ||
      (Array.isArray(e) && e.every(Tr))
  );
}
export var Mr = ([e, t, n, s]) => `cubic-bezier(${e}, ${t}, ${n}, ${s})`;
export var Or = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: Mr([0, 0.65, 0.55, 1]),
  circOut: Mr([0.55, 0, 1, 0.45]),
  backIn: Mr([0.31, 0.01, 0.66, -0.59]),
  backOut: Mr([0.33, 1.53, 0.69, 0.99]),
};
export function Rr(e) {
  if (e) return Br(e) ? Mr(e) : Array.isArray(e) ? e.map(Rr) : Or[e];
}
export var Vr = (e, t, n) =>
  (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e;
export var Dr = 1e-7;
export var Fr = 12;
export function Ir(e, t, n, s) {
  if (e === t && n === s) return Zo;
  const i = (t) =>
    (function (e, t, n, s, i) {
      let o,
        r,
        a = 0;
      do {
        (r = t + (n - t) / 2), (o = Vr(r, s, i) - e), o > 0 ? (n = r) : (t = r);
      } while (Math.abs(o) > Dr && ++a < Fr);
      return r;
    })(t, 0, 1, e, n);
  return (e) => (0 === e || 1 === e ? e : Vr(i(e), t, s));
}
export var Hr = Ir(0.42, 0, 1, 1);
export var Nr = Ir(0, 0, 0.58, 1);
export var Ur = Ir(0.42, 0, 0.58, 1);
export var zr = (e) => Array.isArray(e) && "number" != typeof e[0];
export var $r = (e) => (t) =>
  t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2;
export var qr = (e) => (t) => 1 - e(1 - t);
export var Qr = (e) => 1 - Math.sin(Math.acos(e));
export var Gr = qr(Qr);
export var Zr = $r(Qr);
export var Wr = Ir(0.33, 1.53, 0.69, 0.99);
export var Kr = qr(Wr);
export var Yr = $r(Kr);
export var Xr = {
  linear: Zo,
  easeIn: Hr,
  easeInOut: Ur,
  easeOut: Nr,
  circIn: Qr,
  circInOut: Zr,
  circOut: Gr,
  backIn: Kr,
  backInOut: Yr,
  backOut: Wr,
  anticipate: (e) =>
    (e *= 2) < 1 ? 0.5 * Kr(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))),
};
export var Jr = (e) => {
  if (Array.isArray(e)) {
    Er(
      4 === e.length,
      "Cubic bezier arrays must contain four numerical values."
    );
    const [t, n, s, i] = e;
    return Ir(t, n, s, i);
  }
  return "string" == typeof e
    ? (Er(undefined !== Xr[e], `Invalid easing type '${e}'`), Xr[e])
    : e;
};
export var ea = (e, t) => (n) =>
  Boolean(
    (isString(n) && so.test(n) && n.startsWith(e)) ||
      (t && Object.prototype.hasOwnProperty.call(n, t))
  );
export var ta = (e, t, n) => (s) => {
  if (!isString(s)) return s;
  const [i, o, r, a] = s.match(to);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(o),
    [n]: parseFloat(r),
    alpha: undefined !== a ? parseFloat(a) : 1,
  };
};
export var na = {
  ...Yi,
  transform: (e) => Math.round(((e) => Ki(0, 255, e))(e)),
};
export var sa = {
  test: ea("rgb", "red"),
  parse: ta("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: s = 1 }) =>
    "rgba(" +
    na.transform(e) +
    ", " +
    na.transform(t) +
    ", " +
    na.transform(n) +
    ", " +
    eo(Xi.transform(s)) +
    ")",
};
export var ia = {
  test: ea("#"),
  parse: function (e) {
    let t = "",
      n = "",
      s = "",
      i = "";
    return (
      e.length > 5
        ? ((t = e.substring(1, 3)),
          (n = e.substring(3, 5)),
          (s = e.substring(5, 7)),
          (i = e.substring(7, 9)))
        : ((t = e.substring(1, 2)),
          (n = e.substring(2, 3)),
          (s = e.substring(3, 4)),
          (i = e.substring(4, 5)),
          (t += t),
          (n += n),
          (s += s),
          (i += i)),
      {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(s, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1,
      }
    );
  },
  transform: sa.transform,
};
export var oa = {
  test: ea("hsl", "hue"),
  parse: ta("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: s = 1 }) =>
    "hsla(" +
    Math.round(e) +
    ", " +
    percentUnit.transform(eo(t)) +
    ", " +
    percentUnit.transform(eo(n)) +
    ", " +
    eo(Xi.transform(s)) +
    ")",
};
export var ra = {
  test: (e) => sa.test(e) || ia.test(e) || oa.test(e),
  parse: (e) =>
    sa.test(e) ? sa.parse(e) : oa.test(e) ? oa.parse(e) : ia.parse(e),
  transform: (e) =>
    isString(e)
      ? e
      : e.hasOwnProperty("red")
      ? sa.transform(e)
      : oa.transform(e),
};
export var aa = (e, t, n) => -n * e + n * t + e;
export function la(e, t, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? e + 6 * (t - e) * n
      : n < 0.5
      ? t
      : n < 2 / 3
      ? e + (t - e) * (2 / 3 - n) * 6
      : e
  );
}
export var ca = (e, t, n) => {
  const s = e * e;
  return Math.sqrt(Math.max(0, n * (t * t - s) + s));
};
export var ua = [ia, sa, oa];
export function da(e) {
  const t = ((n = e), ua.find((e) => e.test(n)));
  var n;
  Er(
    Boolean(t),
    `'${e}' is not an animatable color. Use the equivalent color code instead.`
  );
  let s = t.parse(e);
  return (
    t === oa &&
      (s = (function ({ hue: e, saturation: t, lightness: n, alpha: s }) {
        (e /= 360), (n /= 100);
        let i = 0,
          o = 0,
          r = 0;
        if ((t /= 100)) {
          const s = n < 0.5 ? n * (1 + t) : n + t - n * t,
            a = 2 * n - s;
          (i = la(a, s, e + 1 / 3)),
            (o = la(a, s, e)),
            (r = la(a, s, e - 1 / 3));
        } else i = o = r = n;
        return {
          red: Math.round(255 * i),
          green: Math.round(255 * o),
          blue: Math.round(255 * r),
          alpha: s,
        };
      })(s)),
    s
  );
}
export var pa = (e, t) => {
  const n = da(e),
    s = da(t),
    i = { ...n };
  return (e) => (
    (i.red = ca(n.red, s.red, e)),
    (i.green = ca(n.green, s.green, e)),
    (i.blue = ca(n.blue, s.blue, e)),
    (i.alpha = aa(n.alpha, s.alpha, e)),
    sa.transform(i)
  );
};
export var fa = {
  regex:
    /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
  countKey: "Vars",
  token: "${v}",
  parse: Zo,
};
export var ha = {
  regex: no,
  countKey: "Colors",
  token: "${c}",
  parse: ra.parse,
};
export var ma = {
  regex: to,
  countKey: "Numbers",
  token: "${n}",
  parse: Yi.parse,
};
export function ga(e, { regex: t, countKey: n, token: s, parse: i }) {
  const o = e.tokenised.match(t);
  o &&
    ((e["num" + n] = o.length),
    (e.tokenised = e.tokenised.replace(t, s)),
    e.values.push(...o.map(i)));
}
export function xa(e) {
  const t = e.toString(),
    n = {
      value: t,
      tokenised: t,
      values: [],
      numVars: 0,
      numColors: 0,
      numNumbers: 0,
    };
  return n.value.includes("var(--") && ga(n, fa), ga(n, ha), ga(n, ma), n;
}
export function ba(e) {
  return xa(e).values;
}
export function ya(e) {
  const { values: t, numColors: n, numVars: s, tokenised: i } = xa(e),
    o = t.length;
  return (e) => {
    let t = i;
    for (let i = 0; i < o; i++)
      t =
        i < s
          ? t.replace(fa.token, e[i])
          : i < s + n
          ? t.replace(ha.token, ra.transform(e[i]))
          : t.replace(ma.token, eo(e[i]));
    return t;
  };
}
export var va = (e) => ("number" == typeof e ? 0 : e);
export var wa = {
  test: function (e) {
    var t, n;
    return (
      isNaN(e) &&
      isString(e) &&
      ((null === (t = e.match(to)) || undefined === t ? undefined : t.length) ||
        0) +
        ((null === (n = e.match(no)) || undefined === n
          ? undefined
          : n.length) || 0) >
        0
    );
  },
  parse: ba,
  createTransformer: ya,
  getAnimatableNone: function (e) {
    const t = ba(e);
    return ya(e)(t.map(va));
  },
};
export var ka = (e, t) => (n) => `${n > 0 ? t : e}`;
export function Ca(e, t) {
  return "number" == typeof e
    ? (n) => aa(e, t, n)
    : ra.test(e)
    ? pa(e, t)
    : e.startsWith("var(")
    ? ka(e, t)
    : _a(e, t);
}
export var ja = (e, t) => {
  const n = [...e],
    s = n.length,
    i = e.map((e, n) => Ca(e, t[n]));
  return (e) => {
    for (let t = 0; t < s; t++) n[t] = i[t](e);
    return n;
  };
};
export var Sa = (e, t) => {
  const n = { ...e, ...t },
    s = {};
  for (const i in n)
    undefined !== e[i] && undefined !== t[i] && (s[i] = Ca(e[i], t[i]));
  return (e) => {
    for (const t in s) n[t] = s[t](e);
    return n;
  };
};
export var _a = (e, t) => {
  const n = wa.createTransformer(t),
    s = xa(e),
    i = xa(t);
  return s.numVars === i.numVars &&
    s.numColors === i.numColors &&
    s.numNumbers >= i.numNumbers
    ? ar(ja(s.values, i.values), n)
    : (_r(
        true,
        `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`
      ),
      ka(e, t));
};
export var Ea = (e, t, n) => {
  const s = t - e;
  return 0 === s ? 1 : (n - e) / s;
};
export var La = (e, t) => (n) => aa(e, t, n);
export function Pa(e, t, n) {
  const s = [],
    i =
      n ||
      ("number" == typeof (o = e[0])
        ? La
        : "string" == typeof o
        ? ra.test(o)
          ? pa
          : _a
        : Array.isArray(o)
        ? ja
        : "object" == typeof o
        ? Sa
        : La);
  var o;
  const r = e.length - 1;
  for (let n = 0; n < r; n++) {
    let o = i(e[n], e[n + 1]);
    if (t) {
      const e = Array.isArray(t) ? t[n] || Zo : t;
      o = ar(e, o);
    }
    s.push(o);
  }
  return s;
}
export function Aa(e, t, { clamp: n = true, ease: s, mixer: i } = {}) {
  const o = e.length;
  if (
    (Er(o === t.length, "Both input and output ranges must be the same length"),
    1 === o)
  )
    return () => t[0];
  e[0] > e[o - 1] && ((e = [...e].reverse()), (t = [...t].reverse()));
  const r = Pa(t, s, i),
    a = r.length,
    l = (t) => {
      let n = 0;
      if (a > 1) for (; n < e.length - 2 && !(t < e[n + 1]); n++);
      const s = Ea(e[n], e[n + 1], t);
      return r[n](s);
    };
  return n ? (t) => l(Ki(e[0], e[o - 1], t)) : l;
}
export function Ba(e, t) {
  const n = e[e.length - 1];
  for (let s = 1; s <= t; s++) {
    const i = Ea(0, t, s);
    e.push(aa(n, 1, i));
  }
}
export function Ta(e) {
  const t = [0];
  return Ba(t, e.length - 1), t;
}
export function Ma({
  duration: e = 300,
  keyframes: t,
  times: n,
  ease: s = "easeInOut",
}) {
  const i = zr(s) ? s.map(Jr) : Jr(s),
    o = { done: false, value: t[0] },
    r = (function (e, t) {
      return e.map((e) => e * t);
    })(n && n.length === t.length ? n : Ta(t), e),
    a = Aa(r, t, {
      ease: Array.isArray(i)
        ? i
        : ((l = t), (c = i), l.map(() => c || Ur).splice(0, l.length - 1)),
    });
  var l, c;
  return {
    calculatedDuration: e,
    next: (t) => ((o.value = a(t)), (o.done = t >= e), o),
  };
}
export function Oa(e, t) {
  return t ? e * (1e3 / t) : 0;
}
export var Ra = 5;
export function Va(e, t, n) {
  const s = Math.max(t - Ra, 0);
  return Oa(n - e(s), t - s);
}
export var Da = 0.001;
export var Fa = 0.01;
export var Ia = 10;
export var Ha = 0.05;
export var Na = 1;
export function Ua({
  duration: e = 800,
  bounce: t = 0.25,
  velocity: n = 0,
  mass: s = 1,
}) {
  let i, o;
  _r(e <= Lr(Ia), "Spring duration must be 10 seconds or less");
  let r = 1 - t;
  (r = Ki(Ha, Na, r)),
    (e = Ki(Fa, Ia, Pr(e))),
    r < 1
      ? ((i = (t) => {
          const s = t * r,
            i = s * e,
            o = s - n,
            a = $a(t, r),
            l = Math.exp(-i);
          return Da - (o / a) * l;
        }),
        (o = (t) => {
          const s = t * r * e,
            o = s * n + n,
            a = Math.pow(r, 2) * Math.pow(t, 2) * e,
            l = Math.exp(-s),
            c = $a(Math.pow(t, 2), r);
          return ((-i(t) + Da > 0 ? -1 : 1) * ((o - a) * l)) / c;
        }))
      : ((i = (t) => Math.exp(-t * e) * ((t - n) * e + 1) - Da),
        (o = (t) => Math.exp(-t * e) * (e * e * (n - t))));
  const a = (function (e, t, n) {
    let s = n;
    for (let n = 1; n < za; n++) s -= e(s) / t(s);
    return s;
  })(i, o, 5 / e);
  if (((e = Lr(e)), isNaN(a)))
    return { stiffness: 100, damping: 10, duration: e };
  {
    const t = Math.pow(a, 2) * s;
    return { stiffness: t, damping: 2 * r * Math.sqrt(s * t), duration: e };
  }
}
export var za = 12;
export function $a(e, t) {
  return e * Math.sqrt(1 - t * t);
}
export var qa;
export var Qa = ["duration", "bounce"];
export var Ga = ["stiffness", "damping", "mass"];
export function Za(e, t) {
  return t.some((t) => undefined !== e[t]);
}
export function Wa({ keyframes: e, restDelta: t, restSpeed: n, ...s }) {
  const i = e[0],
    o = e[e.length - 1],
    r = { done: false, value: i },
    {
      stiffness: a,
      damping: l,
      mass: c,
      duration: u,
      velocity: d,
      isResolvedFromDuration: p,
    } = (function (e) {
      let t = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: false,
        ...e,
      };
      if (!Za(e, Ga) && Za(e, Qa)) {
        const n = Ua(e);
        (t = { ...t, ...n, mass: 1 }), (t.isResolvedFromDuration = true);
      }
      return t;
    })({ ...s, velocity: -Pr(s.velocity || 0) }),
    f = d || 0,
    h = l / (2 * Math.sqrt(a * c)),
    m = o - i,
    g = Pr(Math.sqrt(a / c)),
    x = Math.abs(m) < 5;
  let b;
  if ((n || (n = x ? 0.01 : 2), t || (t = x ? 0.005 : 0.5), h < 1)) {
    const e = $a(g, h);
    b = (t) => {
      const n = Math.exp(-h * g * t);
      return (
        o - n * (((f + h * g * m) / e) * Math.sin(e * t) + m * Math.cos(e * t))
      );
    };
  } else if (1 === h) b = (e) => o - Math.exp(-g * e) * (m + (f + g * m) * e);
  else {
    const e = g * Math.sqrt(h * h - 1);
    b = (t) => {
      const n = Math.exp(-h * g * t),
        s = Math.min(e * t, 300);
      return (
        o - (n * ((f + h * g * m) * Math.sinh(s) + e * m * Math.cosh(s))) / e
      );
    };
  }
  return {
    calculatedDuration: (p && u) || null,
    next: (e) => {
      const s = b(e);
      if (p) r.done = e >= u;
      else {
        let i = f;
        0 !== e && (i = h < 1 ? Va(b, e, s) : 0);
        const a = Math.abs(i) <= n,
          l = Math.abs(o - s) <= t;
        r.done = a && l;
      }
      return (r.value = r.done ? o : s), r;
    },
  };
}
export function Ka({
  keyframes: e,
  velocity: t = 0,
  power: n = 0.8,
  timeConstant: s = 325,
  bounceDamping: i = 10,
  bounceStiffness: o = 500,
  modifyTarget: r,
  min: a,
  max: l,
  restDelta: c = 0.5,
  restSpeed: u,
}) {
  const d = e[0],
    p = { done: false, value: d },
    f = (e) =>
      undefined === a
        ? l
        : undefined === l || Math.abs(a - e) < Math.abs(l - e)
        ? a
        : l;
  let h = n * t;
  const m = d + h,
    g = undefined === r ? m : r(m);
  g !== m && (h = g - d);
  const x = (e) => -h * Math.exp(-e / s),
    b = (e) => g + x(e),
    y = (e) => {
      const t = x(e),
        n = b(e);
      (p.done = Math.abs(t) <= c), (p.value = p.done ? g : n);
    };
  let v, w;
  const k = (e) => {
    var t;
    ((t = p.value), (undefined !== a && t < a) || (undefined !== l && t > l)) &&
      ((v = e),
      (w = Wa({
        keyframes: [p.value, f(p.value)],
        velocity: Va(b, e, p.value),
        damping: i,
        stiffness: o,
        restDelta: c,
        restSpeed: u,
      })));
  };
  return (
    k(0),
    {
      calculatedDuration: null,
      next: (e) => {
        let t = false;
        return (
          w || undefined !== v || ((t = true), y(e), k(e)),
          undefined !== v && e > v ? w.next(e - v) : (!t && y(e), p)
        );
      },
    }
  );
}
export function Ya() {
  qa = undefined;
}
export var Xa = {
  now: () => (
    undefined === qa &&
      Xa.set(
        Yo.isProcessing || unknownBool2 ? Yo.timestamp : performance.now()
      ),
    qa
  ),
  set: (e) => {
    (qa = e), queueMicrotask(Ya);
  },
};
export var Ja = (e) => {
  const t = ({ timestamp: t }) => e(t);
  return {
    start: () => Wo.update(t, true),
    stop: () => Ko(t),
    now: () => (Yo.isProcessing ? Yo.timestamp : Xa.now()),
  };
};
export var el = 2e4;
export function tl(e) {
  let t = 0;
  let n = e.next(t);
  for (; !n.done && t < el; ) (t += 50), (n = e.next(t));
  return t >= el ? 1 / 0 : t;
}
export var nl = {
  decay: Ka,
  inertia: Ka,
  tween: Ma,
  keyframes: Ma,
  spring: Wa,
};
export function sl({
  autoplay: e = true,
  delay: t = 0,
  driver: n = Ja,
  keyframes: s,
  type: i = "keyframes",
  repeat: o = 0,
  repeatDelay: r = 0,
  repeatType: a = "loop",
  onPlay: l,
  onStop: c,
  onComplete: u,
  onUpdate: d,
  ...p
}) {
  let f,
    h,
    m = 1,
    g = false;
  const x = () => {
    h = new Promise((e) => {
      f = e;
    });
  };
  let b;
  x();
  const y = nl[i] || Ma;
  let v;
  y !== Ma &&
    "number" != typeof s[0] &&
    ((v = Aa([0, 100], s, { clamp: false })), (s = [0, 100]));
  const w = y({ ...p, keyframes: s });
  let k;
  "mirror" === a &&
    (k = y({
      ...p,
      keyframes: [...s].reverse(),
      velocity: -(p.velocity || 0),
    }));
  let C = "idle",
    j = null,
    S = null,
    _ = null;
  null === w.calculatedDuration && o && (w.calculatedDuration = tl(w));
  const { calculatedDuration: E } = w;
  let L = 1 / 0,
    P = 1 / 0;
  null !== E && ((L = E + r), (P = L * (o + 1) - r));
  let A = 0;
  const B = (e) => {
      if (null === S) return;
      m > 0 && (S = Math.min(S, e)),
        m < 0 && (S = Math.min(e - P / m, S)),
        (A = null !== j ? j : Math.round(e - S) * m);
      const n = A - t * (m >= 0 ? 1 : -1),
        i = m >= 0 ? n < 0 : n > P;
      (A = Math.max(n, 0)), "finished" === C && null === j && (A = P);
      let l = A,
        c = w;
      if (o) {
        const e = Math.min(A, P) / L;
        let t = Math.floor(e),
          n = e % 1;
        !n && e >= 1 && (n = 1), 1 === n && t--, (t = Math.min(t, o + 1));
        Boolean(t % 2) &&
          ("reverse" === a
            ? ((n = 1 - n), r && (n -= r / L))
            : "mirror" === a && (c = k)),
          (l = Ki(0, 1, n) * L);
      }
      const u = i ? { done: false, value: s[0] } : c.next(l);
      v && (u.value = v(u.value));
      let { done: p } = u;
      i || null === E || (p = m >= 0 ? A >= P : A <= 0);
      const f = null === j && ("finished" === C || ("running" === C && p));
      return d && d(u.value), f && O(), u;
    },
    T = () => {
      b && b.stop(), (b = undefined);
    },
    M = () => {
      (C = "idle"), T(), f(), x(), (S = _ = null);
    },
    O = () => {
      (C = "finished"), u && u(), T(), f();
    },
    R = () => {
      if (g) return;
      b || (b = n(B));
      const e = b.now();
      l && l(),
        null !== j ? (S = e - j) : (S && "finished" !== C) || (S = e),
        "finished" === C && x(),
        (_ = S),
        (j = null),
        (C = "running"),
        b.start();
    };
  e && R();
  const V = {
    then: (e, t) => h.then(e, t),
    get time() {
      return Pr(A);
    },
    set time(e) {
      (e = Lr(e)),
        (A = e),
        null === j && b && 0 !== m ? (S = b.now() - e / m) : (j = e);
    },
    get duration() {
      const e = null === w.calculatedDuration ? tl(w) : w.calculatedDuration;
      return Pr(e);
    },
    get speed() {
      return m;
    },
    set speed(e) {
      e !== m && b && ((m = e), (V.time = Pr(A)));
    },
    get state() {
      return C;
    },
    play: R,
    pause: () => {
      (C = "paused"), (j = A);
    },
    stop: () => {
      (g = true), "idle" !== C && ((C = "idle"), c && c(), M());
    },
    cancel: () => {
      null !== _ && B(_), M();
    },
    complete: () => {
      C = "finished";
    },
    sample: (e) => ((S = 0), B(e)),
  };
  return V;
}
export function il(e) {
  let t;
  return () => (undefined === t && (t = e()), t);
}
export var ol = il(() =>
  Object.hasOwnProperty.call(Element.prototype, "animate")
);
export var rl = new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor",
]);
export function al(e, t, { onUpdate: n, onComplete: s, ...i }) {
  if (
    !(
      ol() &&
      rl.has(t) &&
      !i.repeatDelay &&
      "mirror" !== i.repeatType &&
      0 !== i.damping &&
      "inertia" !== i.type
    )
  )
    return false;
  let o,
    r,
    a = false,
    l = false;
  const c = () => {
    r = new Promise((e) => {
      o = e;
    });
  };
  c();
  let { keyframes: u, duration: d = 300, ease: p, times: f } = i;
  if (
    ((e, t) => "spring" === t.type || "backgroundColor" === e || !Tr(t.ease))(
      t,
      i
    )
  ) {
    const e = sl({ ...i, repeat: 0, delay: 0 });
    let t = { done: false, value: u[0] };
    const n = [];
    let s = 0;
    for (; !t.done && s < 2e4; ) (t = e.sample(s)), n.push(t.value), (s += 10);
    (f = undefined), (u = n), (d = s - 10), (p = "linear");
  }
  const h = (function (
      e,
      t,
      n,
      {
        delay: s = 0,
        duration: i,
        repeat: o = 0,
        repeatType: r = "loop",
        ease: a,
        times: l,
      } = {}
    ) {
      const c = { [t]: n };
      l && (c.offset = l);
      const u = Rr(a);
      return (
        Array.isArray(u) && (c.easing = u),
        e.animate(c, {
          delay: s,
          duration: i,
          easing: Array.isArray(u) ? "linear" : u,
          fill: "both",
          iterations: o + 1,
          direction: "reverse" === r ? "alternate" : "normal",
        })
      );
    })(e.owner.current, t, u, { ...i, duration: d, ease: p, times: f }),
    m = () => {
      (l = false), h.cancel();
    },
    g = () => {
      (l = true), Wo.update(m), o(), c();
    };
  h.onfinish = () => {
    l ||
      (e.set(
        (function (e, { repeat: t, repeatType: n = "loop" }) {
          return e[t && "loop" !== n && t % 2 == 1 ? 0 : e.length - 1];
        })(u, i)
      ),
      s && s(),
      g());
  };
  return {
    then: (e, t) => r.then(e, t),
    attachTimeline: (e) => ((h.timeline = e), (h.onfinish = null), Zo),
    get time() {
      return Pr(h.currentTime || 0);
    },
    set time(e) {
      h.currentTime = Lr(e);
    },
    get speed() {
      return h.playbackRate;
    },
    set speed(e) {
      h.playbackRate = e;
    },
    get duration() {
      return Pr(d);
    },
    play: () => {
      a || (h.play(), Ko(m));
    },
    pause: () => h.pause(),
    stop: () => {
      if (((a = true), "idle" === h.playState)) return;
      const { currentTime: t } = h;
      if (t) {
        const n = sl({ ...i, autoplay: false });
        e.setWithVelocity(n.sample(t - 10).value, n.sample(t).value, 10);
      }
      g();
    },
    complete: () => {
      l || h.finish();
    },
    cancel: g,
  };
}
export var ll = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 };
export var cl = { type: "keyframes", duration: 0.8 };
export var ul = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3,
};
export var dl = (e, { keyframes: t }) =>
  t.length > 2
    ? cl
    : dimensionalPropertiesSet.has(e)
    ? e.startsWith("scale")
      ? {
          type: "spring",
          stiffness: 550,
          damping: 0 === t[1] ? 2 * Math.sqrt(550) : 30,
          restSpeed: 10,
        }
      : ll
    : ul;
export var pl = (e, t) =>
  "zIndex" !== e &&
  (!("number" != typeof t && !Array.isArray(t)) ||
    !(
      "string" != typeof t ||
      (!wa.test(t) && "0" !== t) ||
      t.startsWith("url(")
    ));
export var fl = new Set(["brightness", "contrast", "saturate", "opacity"]);
export function hl(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if ("drop-shadow" === t) return e;
  const [s] = n.match(to) || [];
  if (!s) return e;
  const i = n.replace(s, "");
  let o = fl.has(t) ? 1 : 0;
  return s !== n && (o *= 100), t + "(" + o + i + ")";
}
export var ml = /([a-z-]*)\(.*?\)/g;
export var gl = {
  ...wa,
  getAnimatableNone: (e) => {
    const t = e.match(ml);
    return t ? t.map(hl).join(" ") : e;
  },
};
export var xl = {
  ...ho,
  color: ra,
  backgroundColor: ra,
  outlineColor: ra,
  fill: ra,
  stroke: ra,
  borderColor: ra,
  borderTopColor: ra,
  borderRightColor: ra,
  borderBottomColor: ra,
  borderLeftColor: ra,
  filter: gl,
  WebkitFilter: gl,
};
export var bl = (e) => xl[e];
export function yl(e, t) {
  let n = bl(e);
  return (
    n !== gl && (n = wa),
    n.getAnimatableNone ? n.getAnimatableNone(t) : undefined
  );
}
export var vl = (e) => /^0[^.\s]+$/.test(e);
export function wl(e) {
  return "number" == typeof e
    ? 0 === e
    : null !== e
    ? "none" === e || "0" === e || vl(e)
    : undefined;
}
export function kl(e, t) {
  return e[t] || e.default || e;
}
export var Cl =
  (e, t, n, s = {}) =>
  (i) => {
    const o = kl(s, e) || {},
      r = o.delay || s.delay || 0;
    let { elapsed: a = 0 } = s;
    a -= Lr(r);
    const l = (function (e, t, n, s) {
        const i = pl(t, n);
        let o;
        o = Array.isArray(n) ? [...n] : [null, n];
        const r = undefined !== s.from ? s.from : e.get();
        let a;
        const l = [];
        for (let e = 0; e < o.length; e++)
          null === o[e] && (o[e] = 0 === e ? r : o[e - 1]),
            wl(o[e]) && l.push(e),
            "string" == typeof o[e] &&
              "none" !== o[e] &&
              "0" !== o[e] &&
              (a = o[e]);
        if (i && l.length && a)
          for (let e = 0; e < l.length; e++) o[l[e]] = yl(t, a);
        return o;
      })(t, e, n, o),
      c = l[0],
      u = l[l.length - 1],
      d = pl(e, c),
      p = pl(e, u);
    _r(
      d === p,
      `You are trying to animate ${e} from "${c}" to "${u}". ${c} is not an animatable value - to enable this animation set ${c} to a value animatable to ${u} via the \`style\` property.`
    );
    let f = {
      keyframes: l,
      velocity: t.getVelocity(),
      ease: "easeOut",
      ...o,
      delay: -a,
      onUpdate: (e) => {
        t.set(e), o.onUpdate && o.onUpdate(e);
      },
      onComplete: () => {
        i(), o.onComplete && o.onComplete();
      },
    };
    if (
      ((function ({
        when: e,
        delay: t,
        delayChildren: n,
        staggerChildren: s,
        staggerDirection: i,
        repeat: o,
        repeatType: r,
        repeatDelay: a,
        from: l,
        elapsed: c,
        ...u
      }) {
        return !!Object.keys(u).length;
      })(o) || (f = { ...f, ...dl(e, f) }),
      f.duration && (f.duration = Lr(f.duration)),
      f.repeatDelay && (f.repeatDelay = Lr(f.repeatDelay)),
      !d || !p || Ar || false === o.type || unknownBool1)
    )
      return (function ({
        keyframes: e,
        delay: t,
        onUpdate: n,
        onComplete: s,
      }) {
        const i = () => (
          n && n(e[e.length - 1]),
          s && s(),
          {
            time: 0,
            speed: 1,
            duration: 0,
            play: Zo,
            pause: Zo,
            stop: Zo,
            then: (e) => (e(), Promise.resolve()),
            cancel: Zo,
            complete: Zo,
          }
        );
        return t
          ? sl({ keyframes: [0, 1], duration: 0, delay: t, onComplete: i })
          : i();
      })(Ar ? { ...f, delay: 0 } : f);
    if (
      !s.isHandoff &&
      t.owner &&
      t.owner.current instanceof HTMLElement &&
      !t.owner.getProps().onUpdate
    ) {
      const n = al(t, e, f);
      if (n) return n;
    }
    return sl(f);
  };
export function jl(e) {
  return Boolean(zi(e) && e.add);
}
export var Sl = (e) => /^\-?\d*\.?\d+$/.test(e);
export function _l(e, t) {
  -1 === e.indexOf(t) && e.push(t);
}
export function El(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
export var Ll = class {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return _l(this.subscriptions, e), () => El(this.subscriptions, e);
  }
  notify(e, t, n) {
    const s = this.subscriptions.length;
    if (s)
      if (1 === s) this.subscriptions[0](e, t, n);
      else
        for (let i = 0; i < s; i++) {
          const s = this.subscriptions[i];
          s && s(e, t, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
export var Pl = { current: undefined };
export var Al = class {
  constructor(e, t = {}) {
    var n;
    (this.version = "11.0.3"),
      (this.canTrackVelocity = false),
      (this.events = {}),
      (this.updateAndNotify = (e, t = true) => {
        const n = Xa.now();
        this.updatedAt !== n && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(e),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          t &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.hasAnimated = false),
      this.setCurrent(e),
      (this.canTrackVelocity = ((n = this.current), !isNaN(parseFloat(n)))),
      (this.owner = t.owner);
  }
  setCurrent(e) {
    (this.current = e), (this.updatedAt = Xa.now());
  }
  setPrevFrameValue(e = this.current) {
    (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new Ll());
    const n = this.events[e].add(t);
    return "change" === e
      ? () => {
          n(),
            Wo.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : n;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e, t = true) {
    t && this.passiveEffect
      ? this.passiveEffect(e, this.updateAndNotify)
      : this.updateAndNotify(e, t);
  }
  setWithVelocity(e, t, n) {
    this.set(t),
      (this.prev = undefined),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - n);
  }
  jump(e) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = undefined),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return Pl.current && Pl.current.push(this), this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = Xa.now();
    if (
      !this.canTrackVelocity ||
      undefined === this.prevFrameValue ||
      e - this.updatedAt > 30
    )
      return 0;
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
    return Oa(parseFloat(this.current) - parseFloat(this.prevFrameValue), t);
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = true),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
};
export function Bl(e, t) {
  return new Al(e, t);
}
export var Tl = (e) => (t) => t.test(e);
export var Ml = [
  Yi,
  pixelUnit,
  percentUnit,
  degUnit,
  vwUnit,
  vhUnit,
  { test: (e) => "auto" === e, parse: (e) => e },
];
export var Ol = (e) => Ml.find(Tl(e));
export var Rl = [...Ml, ra, wa];
export function Vl(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Bl(n));
}
export function Dl(e, t) {
  if (!t) return;
  return (t[e] || t.default || t).from;
}
export function Fl({ protectedKeys: e, needsAnimating: t }, n) {
  const s = e.hasOwnProperty(n) && true !== t[n];
  return (t[n] = false), s;
}
export function Il(e, t) {
  const n = e.get();
  if (!Array.isArray(t)) return n !== t;
  for (let e = 0; e < t.length; e++) if (t[e] !== n) return true;
}
export function Hl(
  e,
  t,
  { delay: n = 0, transitionOverride: s, type: i } = {}
) {
  let {
    transition: o = e.getDefaultTransition(),
    transitionEnd: r,
    ...a
  } = e.makeTargetAnimatable(t);
  const l = e.getValue("willChange");
  s && (o = s);
  const c = [],
    u = i && e.animationState && e.animationState.getState()[i];
  for (const t in a) {
    const s = e.getValue(t),
      i = a[t];
    if (!s || undefined === i || (u && Fl(u, t))) continue;
    const r = { delay: n, elapsed: 0, ...kl(o || {}, t) };
    if (window.HandoffAppearAnimations) {
      const n = e.getProps()[framerAppearId];
      if (n) {
        const e = window.HandoffAppearAnimations(n, t, s, Wo);
        null !== e && ((r.elapsed = e), (r.isHandoff = true));
      }
    }
    let d = !r.isHandoff && !Il(s, i);
    if (
      ("spring" === r.type && (s.getVelocity() || r.velocity) && (d = false),
      s.animation && (d = false),
      d)
    )
      continue;
    s.start(
      Cl(
        t,
        s,
        i,
        e.shouldReduceMotion && dimensionalPropertiesSet.has(t)
          ? { type: false }
          : r
      )
    );
    const p = s.animation;
    jl(l) && (l.add(t), p.then(() => l.remove(t))), c.push(p);
  }
  return (
    r &&
      Promise.all(c).then(() => {
        r &&
          (function (e, t) {
            const n = Sr(e, t);
            let {
              transitionEnd: s = {},
              transition: i = {},
              ...o
            } = n ? e.makeTargetAnimatable(n, false) : {};
            o = { ...o, ...s };
            for (const t in o) Vl(e, t, $o(o[t]));
          })(e, r);
      }),
    c
  );
}
export function Nl(e, t, n = {}) {
  const s = Sr(e, t, n.custom);
  let { transition: i = e.getDefaultTransition() || {} } = s || {};
  n.transitionOverride && (i = n.transitionOverride);
  const o = s ? () => Promise.all(Hl(e, s, n)) : () => Promise.resolve(),
    r =
      e.variantChildren && e.variantChildren.size
        ? (s = 0) => {
            const {
              delayChildren: o = 0,
              staggerChildren: r,
              staggerDirection: a,
            } = i;
            return (function (e, t, n = 0, s = 0, i = 1, o) {
              const r = [],
                a = (e.variantChildren.size - 1) * s,
                l = 1 === i ? (e = 0) => e * s : (e = 0) => a - e * s;
              return (
                Array.from(e.variantChildren)
                  .sort(Ul)
                  .forEach((e, s) => {
                    e.notify("AnimationStart", t),
                      r.push(
                        Nl(e, t, { ...o, delay: n + l(s) }).then(() =>
                          e.notify("AnimationComplete", t)
                        )
                      );
                  }),
                Promise.all(r)
              );
            })(e, t, o + s, r, a, n);
          }
        : () => Promise.resolve(),
    { when: a } = i;
  if (a) {
    const [e, t] = "beforeChildren" === a ? [o, r] : [r, o];
    return e().then(() => t());
  }
  return Promise.all([o(), r(n.delay)]);
}
export function Ul(e, t) {
  return e.sortNodePosition(t);
}
export var zl = [...interactionStates].reverse();
export var $l = interactionStates.length;
export function ql(e) {
  return (t) =>
    Promise.all(
      t.map(({ animation: t, options: n }) =>
        (function (e, t, n = {}) {
          let s;
          if ((e.notify("AnimationStart", t), Array.isArray(t))) {
            const i = t.map((t) => Nl(e, t, n));
            s = Promise.all(i);
          } else if ("string" == typeof t) s = Nl(e, t, n);
          else {
            const i = "function" == typeof t ? Sr(e, t, n.custom) : t;
            s = Promise.all(Hl(e, i, n));
          }
          return s.then(() => e.notify("AnimationComplete", t));
        })(e, t, n)
      )
    );
}
export function Ql(e) {
  let t = ql(e);
  const n = {
    animate: Zl(true),
    whileInView: Zl(),
    whileHover: Zl(),
    whileTap: Zl(),
    whileDrag: Zl(),
    whileFocus: Zl(),
    exit: Zl(),
  };
  let s = true;
  const i = (t, n) => {
    const s = Sr(e, n);
    if (s) {
      const { transition: e, transitionEnd: n, ...i } = s;
      t = { ...t, ...i, ...n };
    }
    return t;
  };
  function o(o, r) {
    const a = e.getProps(),
      l = e.getVariantContext(true) || {},
      c = [],
      u = new Set();
    let d = {},
      p = 1 / 0;
    for (let t = 0; t < $l; t++) {
      const f = zl[t],
        h = n[f],
        m = undefined !== a[f] ? a[f] : l[f],
        g = isStringOrArray(m),
        x = f === r ? h.isActive : null;
      false === x && (p = t);
      let b = m === l[f] && m !== a[f] && g;
      if (
        (b && s && e.manuallyAnimateOnMount && (b = false),
        (h.protectedKeys = { ...d }),
        (!h.isActive && null === x) ||
          (!m && !h.prevProp) ||
          isObjHasStartFunc(m) ||
          "boolean" == typeof m)
      )
        continue;
      let y =
          Gl(h.prevProp, m) ||
          (f === r && h.isActive && !b && g) ||
          (t > p && g),
        v = false;
      const w = Array.isArray(m) ? m : [m];
      let k = w.reduce(i, {});
      false === x && (k = {});
      const { prevResolvedValues: C = {} } = h,
        j = { ...C, ...k },
        S = (e) => {
          (y = true),
            u.has(e) && ((v = true), u.delete(e)),
            (h.needsAnimating[e] = true);
        };
      for (const e in j) {
        const t = k[e],
          n = C[e];
        if (d.hasOwnProperty(e)) continue;
        let s = false;
        (s = Uo(t) && Uo(n) ? !jr(t, n) : t !== n),
          s
            ? undefined !== t
              ? S(e)
              : u.add(e)
            : undefined !== t && u.has(e)
            ? S(e)
            : (h.protectedKeys[e] = true);
      }
      (h.prevProp = m),
        (h.prevResolvedValues = k),
        h.isActive && (d = { ...d, ...k }),
        s && e.blockInitialAnimation && (y = false),
        !y ||
          (b && !v) ||
          c.push(
            ...w.map((e) => ({ animation: e, options: { type: f, ...o } }))
          );
    }
    if (u.size) {
      const t = {};
      u.forEach((n) => {
        const s = e.getBaseTarget(n);
        undefined !== s && (t[n] = s);
      }),
        c.push({ animation: t });
    }
    let f = Boolean(c.length);
    return (
      !s ||
        (false !== a.initial && a.initial !== a.animate) ||
        e.manuallyAnimateOnMount ||
        (f = false),
      (s = false),
      f ? t(c) : Promise.resolve()
    );
  }
  return {
    animateChanges: o,
    setActive: function (t, s, i) {
      var r;
      if (n[t].isActive === s) return Promise.resolve();
      null === (r = e.variantChildren) ||
        undefined === r ||
        r.forEach((e) => {
          var n;
          return null === (n = e.animationState) || undefined === n
            ? undefined
            : n.setActive(t, s);
        }),
        (n[t].isActive = s);
      const a = o(i, t);
      for (const e in n) n[e].protectedKeys = {};
      return a;
    },
    setAnimateFunction: function (n) {
      t = n(e);
    },
    getState: () => n,
  };
}
export function Gl(e, t) {
  return "string" == typeof t ? t !== e : !!Array.isArray(t) && !jr(t, e);
}
export function Zl(e = false) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
export var Wl = 0;
export var Kl = {
  animation: {
    Feature: class extends FrameRenderer {
      constructor(e) {
        super(e), e.animationState || (e.animationState = Ql(e));
      }
      updateAnimationControlsSubscription() {
        const { animate: e } = this.node.getProps();
        this.unmount(),
          isObjHasStartFunc(e) && (this.unmount = e.subscribe(this.node));
      }
      mount() {
        this.updateAnimationControlsSubscription();
      }
      update() {
        const { animate: e } = this.node.getProps(),
          { animate: t } = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription();
      }
      unmount() {}
    },
  },
  exit: {
    Feature: class extends FrameRenderer {
      constructor() {
        super(...arguments), (this.id = Wl++);
      }
      update() {
        if (!this.node.presenceContext) return;
        const {
            isPresent: e,
            onExitComplete: t,
            custom: n,
          } = this.node.presenceContext,
          { isPresent: s } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === s) return;
        const i = this.node.animationState.setActive("exit", !e, {
          custom: null != n ? n : this.node.getProps().custom,
        });
        t && !e && i.then(() => t(this.id));
      }
      mount() {
        const { register: e } = this.node.presenceContext || {};
        e && (this.unmount = e(this.id));
      }
      unmount() {}
    },
  },
};
export var Yl = (e, t) => Math.abs(e - t);
export var Xl = class {
  constructor(
    e,
    t,
    {
      transformPagePoint: n,
      contextWindow: s,
      dragSnapToOrigin: i = false,
    } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!this.lastMoveEvent || !this.lastMoveEventInfo) return;
        const e = tc(this.lastMoveEventInfo, this.history),
          t = null !== this.startEvent,
          n =
            (function (e, t) {
              const n = Yl(e.x, t.x),
                s = Yl(e.y, t.y);
              return Math.sqrt(n ** 2 + s ** 2);
            })(e.offset, { x: 0, y: 0 }) >= 3;
        if (!t && !n) return;
        const { point: s } = e,
          { timestamp: i } = Yo;
        this.history.push({ ...s, timestamp: i });
        const { onStart: o, onMove: r } = this.handlers;
        t ||
          (o && o(this.lastMoveEvent, e),
          (this.startEvent = this.lastMoveEvent)),
          r && r(this.lastMoveEvent, e);
      }),
      (this.handlePointerMove = (e, t) => {
        (this.lastMoveEvent = e),
          (this.lastMoveEventInfo = Jl(t, this.transformPagePoint)),
          Wo.update(this.updatePoint, true);
      }),
      (this.handlePointerUp = (e, t) => {
        this.end();
        const { onEnd: n, onSessionEnd: s, resumeAnimation: i } = this.handlers;
        if (
          (this.dragSnapToOrigin && i && i(),
          !this.lastMoveEvent || !this.lastMoveEventInfo)
        )
          return;
        const o = tc(
          "pointercancel" === e.type
            ? this.lastMoveEventInfo
            : Jl(t, this.transformPagePoint),
          this.history
        );
        this.startEvent && n && n(e, o), s && s(e, o);
      }),
      !nr(e))
    )
      return;
    (this.dragSnapToOrigin = i),
      (this.handlers = t),
      (this.transformPagePoint = n),
      (this.contextWindow = s || window);
    const o = Jl(sr(e), this.transformPagePoint),
      { point: r } = o,
      { timestamp: a } = Yo;
    this.history = [{ ...r, timestamp: a }];
    const { onSessionStart: l } = t;
    l && l(e, tc(o, this.history)),
      (this.removeListeners = ar(
        or(this.contextWindow, "pointermove", this.handlePointerMove),
        or(this.contextWindow, "pointerup", this.handlePointerUp),
        or(this.contextWindow, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Ko(this.updatePoint);
  }
};
export function Jl(e, t) {
  return t ? { point: t(e.point) } : e;
}
export function ec(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
export function tc({ point: e }, t) {
  return {
    point: e,
    delta: ec(e, sc(t)),
    offset: ec(e, nc(t)),
    velocity: ic(t, 0.1),
  };
}
export function nc(e) {
  return e[0];
}
export function sc(e) {
  return e[e.length - 1];
}
export function ic(e, t) {
  if (e.length < 2) return { x: 0, y: 0 };
  let n = e.length - 1,
    s = null;
  const i = sc(e);
  for (; n >= 0 && ((s = e[n]), !(i.timestamp - s.timestamp > Lr(t))); ) n--;
  if (!s) return { x: 0, y: 0 };
  const o = Pr(i.timestamp - s.timestamp);
  if (0 === o) return { x: 0, y: 0 };
  const r = { x: (i.x - s.x) / o, y: (i.y - s.y) / o };
  return r.x === 1 / 0 && (r.x = 0), r.y === 1 / 0 && (r.y = 0), r;
}
export function oc(e) {
  return e.max - e.min;
}
export function rc(e, t = 0, n = 0.01) {
  return Math.abs(e - t) <= n;
}
export function ac(e, t, n, s = 0.5) {
  (e.origin = s),
    (e.originPoint = aa(t.min, t.max, e.origin)),
    (e.scale = oc(n) / oc(t)),
    (rc(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1),
    (e.translate = aa(n.min, n.max, e.origin) - e.originPoint),
    (rc(e.translate) || isNaN(e.translate)) && (e.translate = 0);
}
export function lc(e, t, n, s) {
  ac(e.x, t.x, n.x, s ? s.originX : undefined),
    ac(e.y, t.y, n.y, s ? s.originY : undefined);
}
export function cc(e, t, n) {
  (e.min = n.min + t.min), (e.max = e.min + oc(t));
}
export function uc(e, t, n) {
  (e.min = t.min - n.min), (e.max = e.min + oc(t));
}
export function dc(e, t, n) {
  uc(e.x, t.x, n.x), uc(e.y, t.y, n.y);
}
export function pc(e, t, n) {
  return {
    min: undefined !== t ? e.min + t : undefined,
    max: undefined !== n ? e.max + n - (e.max - e.min) : undefined,
  };
}
export function fc(e, t) {
  let n = t.min - e.min,
    s = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, s] = [s, n]), { min: n, max: s };
}
export var hc = 0.35;
export function mc(e, t, n) {
  return { min: gc(e, t), max: gc(e, n) };
}
export function gc(e, t) {
  return "number" == typeof e ? e : e[t] || 0;
}
export var xc = () => ({
  x: { translate: 0, scale: 1, origin: 0, originPoint: 0 },
  y: { translate: 0, scale: 1, origin: 0, originPoint: 0 },
});
export var bc = () => ({ x: { min: 0, max: 0 }, y: { min: 0, max: 0 } });
export function yc(e) {
  return [e("x"), e("y")];
}
export function vc({ top: e, left: t, right: n, bottom: s }) {
  return { x: { min: t, max: n }, y: { min: e, max: s } };
}
export function wc(e) {
  return undefined === e || 1 === e;
}
export function kc({ scale: e, scaleX: t, scaleY: n }) {
  return !wc(e) || !wc(t) || !wc(n);
}
export function Cc(e) {
  return kc(e) || jc(e) || e.z || e.rotate || e.rotateX || e.rotateY;
}
export function jc(e) {
  return Sc(e.x) || Sc(e.y);
}
export function Sc(e) {
  return e && "0%" !== e;
}
export function _c(e, t, n) {
  return n + t * (e - n);
}
export function Ec(e, t, n, s, i) {
  return undefined !== i && (e = _c(e, i, s)), _c(e, n, s) + t;
}
export function Lc(e, t = 0, n = 1, s, i) {
  (e.min = Ec(e.min, t, n, s, i)), (e.max = Ec(e.max, t, n, s, i));
}
export function Pc(e, { x: t, y: n }) {
  Lc(e.x, t.translate, t.scale, t.originPoint),
    Lc(e.y, n.translate, n.scale, n.originPoint);
}
export function Ac(e) {
  return Number.isInteger(e) || e > 1.0000000000001 || e < 0.999999999999
    ? e
    : 1;
}
export function Bc(e, t) {
  (e.min = e.min + t), (e.max = e.max + t);
}
export function Tc(e, t, [n, s, i]) {
  const o = undefined !== t[i] ? t[i] : 0.5,
    r = aa(e.min, e.max, o);
  Lc(e, t[n], t[s], r, t.scale);
}
export var Mc = ["x", "scaleX", "originX"];
export var Oc = ["y", "scaleY", "originY"];
export function Rc(e, t) {
  Tc(e.x, t, Mc), Tc(e.y, t, Oc);
}
export function Vc(e, t) {
  return vc(
    (function (e, t) {
      if (!t) return e;
      const n = t({ x: e.left, y: e.top }),
        s = t({ x: e.right, y: e.bottom });
      return { top: n.y, left: n.x, bottom: s.y, right: s.x };
    })(e.getBoundingClientRect(), t)
  );
}
export var Dc = ({ current: e }) => (e ? e.ownerDocument.defaultView : null);
export var Fc = new WeakMap();
export var Ic = class {
  constructor(e) {
    (this.openGlobalLock = null),
      (this.isDragging = false),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = false),
      (this.hasMutatedConstraints = false),
      (this.elastic = bc()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = false } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && false === n.isPresent) return;
    const { dragSnapToOrigin: s } = this.getProps();
    this.panSession = new Xl(
      e,
      {
        onSessionStart: (e) => {
          const { dragSnapToOrigin: n } = this.getProps();
          n ? this.pauseAnimation() : this.stopAnimation(),
            t && this.snapToCursor(sr(e, "page").point);
        },
        onStart: (e, t) => {
          const {
            drag: n,
            dragPropagation: s,
            onDragStart: i,
          } = this.getProps();
          if (
            n &&
            !s &&
            (this.openGlobalLock && this.openGlobalLock(),
            (this.openGlobalLock = dr(n)),
            !this.openGlobalLock)
          )
            return;
          (this.isDragging = true),
            (this.currentDirection = null),
            this.resolveConstraints(),
            this.visualElement.projection &&
              ((this.visualElement.projection.isAnimationBlocked = true),
              (this.visualElement.projection.target = undefined)),
            yc((e) => {
              let t = this.getAxisMotionValue(e).get() || 0;
              if (percentUnit.test(t)) {
                const { projection: n } = this.visualElement;
                if (n && n.layout) {
                  const s = n.layout.layoutBox[e];
                  if (s) {
                    t = oc(s) * (parseFloat(t) / 100);
                  }
                }
              }
              this.originPoint[e] = t;
            }),
            i && Wo.update(() => i(e, t), false, true);
          const { animationState: o } = this.visualElement;
          o && o.setActive("whileDrag", true);
        },
        onMove: (e, t) => {
          const {
            dragPropagation: n,
            dragDirectionLock: s,
            onDirectionLock: i,
            onDrag: o,
          } = this.getProps();
          if (!n && !this.openGlobalLock) return;
          const { offset: r } = t;
          if (s && null === this.currentDirection)
            return (
              (this.currentDirection = (function (e, t = 10) {
                let n = null;
                Math.abs(e.y) > t ? (n = "y") : Math.abs(e.x) > t && (n = "x");
                return n;
              })(r)),
              void (
                null !== this.currentDirection &&
                i &&
                i(this.currentDirection)
              )
            );
          this.updateAxis("x", t.point, r),
            this.updateAxis("y", t.point, r),
            this.visualElement.render(),
            o && o(e, t);
        },
        onSessionEnd: (e, t) => this.stop(e, t),
        resumeAnimation: () =>
          yc((e) => {
            var t;
            return (
              "paused" === this.getAnimationState(e) &&
              (null === (t = this.getAxisMotionValue(e).animation) ||
              undefined === t
                ? undefined
                : t.play())
            );
          }),
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: s,
        contextWindow: Dc(this.visualElement),
      }
    );
  }
  stop(e, t) {
    const n = this.isDragging;
    if ((this.cancel(), !n)) return;
    const { velocity: s } = t;
    this.startAnimation(s);
    const { onDragEnd: i } = this.getProps();
    i && Wo.update(() => i(e, t));
  }
  cancel() {
    this.isDragging = false;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = false),
      this.panSession && this.panSession.end(),
      (this.panSession = undefined);
    const { dragPropagation: n } = this.getProps();
    !n &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      t && t.setActive("whileDrag", false);
  }
  updateAxis(e, t, n) {
    const { drag: s } = this.getProps();
    if (!n || !Hc(e, s, this.currentDirection)) return;
    const i = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + n[e];
    this.constraints &&
      this.constraints[e] &&
      (o = (function (e, { min: t, max: n }, s) {
        return (
          undefined !== t && e < t
            ? (e = s ? aa(t, e, s.min) : Math.max(e, t))
            : undefined !== n &&
              e > n &&
              (e = s ? aa(n, e, s.max) : Math.min(e, n)),
          e
        );
      })(o, this.constraints[e], this.elastic[e])),
      i.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: t, dragElastic: n } = this.getProps(),
      s =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(false)
          : null === (e = this.visualElement.projection) || undefined === e
          ? undefined
          : e.layout,
      i = this.constraints;
    t && hasCurrentProperty(t)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : (this.constraints =
          !(!t || !s) &&
          (function (e, { top: t, left: n, bottom: s, right: i }) {
            return { x: pc(e.x, n, i), y: pc(e.y, t, s) };
          })(s.layoutBox, t)),
      (this.elastic = (function (e = hc) {
        return (
          false === e ? (e = 0) : true === e && (e = hc),
          { x: mc(e, "left", "right"), y: mc(e, "top", "bottom") }
        );
      })(n)),
      i !== this.constraints &&
        s &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        yc((e) => {
          this.getAxisMotionValue(e) &&
            (this.constraints[e] = (function (e, t) {
              const n = {};
              return (
                undefined !== t.min && (n.min = t.min - e.min),
                undefined !== t.max && (n.max = t.max - e.min),
                n
              );
            })(s.layoutBox[e], this.constraints[e]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !hasCurrentProperty(e)) return false;
    const n = e.current;
    Er(
      null !== n,
      "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."
    );
    const { projection: s } = this.visualElement;
    if (!s || !s.layout) return false;
    const i = (function (e, t, n) {
      const s = Vc(e, n),
        { scroll: i } = t;
      return i && (Bc(s.x, i.offset.x), Bc(s.y, i.offset.y)), s;
    })(n, s.root, this.visualElement.getTransformPagePoint());
    let o = (function (e, t) {
      return { x: fc(e.x, t.x), y: fc(e.y, t.y) };
    })(s.layout.layoutBox, i);
    if (t) {
      const e = t(
        (function ({ x: e, y: t }) {
          return { top: t.min, right: e.max, bottom: t.max, left: e.min };
        })(o)
      );
      (this.hasMutatedConstraints = !!e), e && (o = vc(e));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: n,
        dragElastic: s,
        dragTransition: i,
        dragSnapToOrigin: o,
        onDragTransitionEnd: r,
      } = this.getProps(),
      a = this.constraints || {},
      l = yc((r) => {
        if (!Hc(r, t, this.currentDirection)) return;
        let l = (a && a[r]) || {};
        o && (l = { min: 0, max: 0 });
        const c = s ? 200 : 1e6,
          u = s ? 40 : 1e7,
          d = {
            type: "inertia",
            velocity: n ? e[r] : 0,
            bounceStiffness: c,
            bounceDamping: u,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...i,
            ...l,
          };
        return this.startAxisValueAnimation(r, d);
      });
    return Promise.all(l).then(r);
  }
  startAxisValueAnimation(e, t) {
    const n = this.getAxisMotionValue(e);
    return n.start(Cl(e, n, 0, t));
  }
  stopAnimation() {
    yc((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    yc((e) => {
      var t;
      return null === (t = this.getAxisMotionValue(e).animation) ||
        undefined === t
        ? undefined
        : t.pause();
    });
  }
  getAnimationState(e) {
    var t;
    return null === (t = this.getAxisMotionValue(e).animation) ||
      undefined === t
      ? undefined
      : t.state;
  }
  getAxisMotionValue(e) {
    const t = "_drag" + e.toUpperCase(),
      n = this.visualElement.getProps(),
      s = n[t];
    return (
      s ||
      this.visualElement.getValue(
        e,
        (n.initial ? n.initial[e] : undefined) || 0
      )
    );
  }
  snapToCursor(e) {
    yc((t) => {
      const { drag: n } = this.getProps();
      if (!Hc(t, n, this.currentDirection)) return;
      const { projection: s } = this.visualElement,
        i = this.getAxisMotionValue(t);
      if (s && s.layout) {
        const { min: n, max: o } = s.layout.layoutBox[t];
        i.set(e[t] - aa(n, o, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: n } = this.visualElement;
    if (!hasCurrentProperty(t) || !n || !this.constraints) return;
    this.stopAnimation();
    const s = { x: 0, y: 0 };
    yc((e) => {
      const t = this.getAxisMotionValue(e);
      if (t) {
        const n = t.get();
        s[e] = (function (e, t) {
          let n = 0.5;
          const s = oc(e),
            i = oc(t);
          return (
            i > s
              ? (n = Ea(t.min, t.max - s, e.min))
              : s > i && (n = Ea(e.min, e.max - i, t.min)),
            Ki(0, 1, n)
          );
        })({ min: n, max: n }, this.constraints[e]);
      }
    });
    const { transformTemplate: i } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = i ? i({}, "") : "none"),
      n.root && n.root.updateScroll(),
      n.updateLayout(),
      this.resolveConstraints(),
      yc((t) => {
        if (!Hc(t, e, null)) return;
        const n = this.getAxisMotionValue(t),
          { min: i, max: o } = this.constraints[t];
        n.set(aa(i, o, s[t]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    Fc.set(this.visualElement, this);
    const e = or(this.visualElement.current, "pointerdown", (e) => {
        const { drag: t, dragListener: n = true } = this.getProps();
        t && n && this.start(e);
      }),
      t = () => {
        const { dragConstraints: e } = this.getProps();
        hasCurrentProperty(e) &&
          (this.constraints = this.resolveRefConstraints());
      },
      { projection: n } = this.visualElement,
      s = n.addEventListener("measure", t);
    n && !n.layout && (n.root && n.root.updateScroll(), n.updateLayout()), t();
    const i = addEventListenerWithCleanup(window, "resize", () =>
        this.scalePositionWithinConstraints()
      ),
      o = n.addEventListener(
        "didUpdate",
        ({ delta: e, hasLayoutChanged: t }) => {
          this.isDragging &&
            t &&
            (yc((t) => {
              const n = this.getAxisMotionValue(t);
              n &&
                ((this.originPoint[t] += e[t].translate),
                n.set(n.get() + e[t].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      i(), e(), s(), o && o();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = false,
        dragDirectionLock: n = false,
        dragPropagation: s = false,
        dragConstraints: i = false,
        dragElastic: o = hc,
        dragMomentum: r = true,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: n,
      dragPropagation: s,
      dragConstraints: i,
      dragElastic: o,
      dragMomentum: r,
    };
  }
};
export function Hc(e, t, n) {
  return !((true !== t && t !== e) || (null !== n && n !== e));
}
export var Nc = (e) => (t, n) => {
  e && Wo.update(() => e(t, n));
};
export var $c = { hasAnimatedSinceResize: true, hasEverUpdated: false };
export function qc(e, t) {
  return t.max === t.min ? 0 : (e / (t.max - t.min)) * 100;
}
export var Qc = {
  correct: (e, t) => {
    if (!t.target) return e;
    if ("string" == typeof e) {
      if (!pixelUnit.test(e)) return e;
      e = parseFloat(e);
    }
    return `${qc(e, t.target.x)}% ${qc(e, t.target.y)}%`;
  },
};
export var Gc = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const s = e,
      i = wa.parse(e);
    if (i.length > 5) return s;
    const o = wa.createTransformer(e),
      r = "number" != typeof i[0] ? 1 : 0,
      a = n.x.scale * t.x,
      l = n.y.scale * t.y;
    (i[0 + r] /= a), (i[1 + r] /= l);
    const c = aa(a, l, 0.5);
    return (
      "number" == typeof i[2 + r] && (i[2 + r] /= c),
      "number" == typeof i[3 + r] && (i[3 + r] /= c),
      o(i)
    );
  },
};
export var ClassComponentWrapper = class extends react9.default.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: n,
        layoutId: s,
      } = this.props,
      { projection: i } = e;
    var o;
    (o = Kc),
      Object.assign(dimentionalPropsState, o),
      i &&
        (t.group && t.group.add(i),
        n && n.register && s && n.register(i),
        i.root.didUpdate(),
        i.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        i.setOptions({
          ...i.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      ($c.hasEverUpdated = true);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: n,
        drag: s,
        isPresent: i,
      } = this.props,
      o = n.projection;
    return o
      ? ((o.isPresent = i),
        s || e.layoutDependency !== t || undefined === t
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== i &&
          (i
            ? o.promote()
            : o.relegate() ||
              Wo.postRender(() => {
                const e = o.getStack();
                (e && e.members.length) || this.safeToRemove();
              })),
        null)
      : null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      renderingProcessorSchedule.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: n,
      } = this.props,
      { projection: s } = e;
    s &&
      (s.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(s),
      n && n.deregister && n.deregister(s));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
};
export function Wc(e) {
  const [t, n] = (function () {
      const e = (0, react10.useContext)(context4);
      if (null === e) return [true, null];
      const { isPresent: t, onExitComplete: n, register: s } = e,
        i = (0, react10.useId)();
      return (
        (0, react10.useEffect)(() => s(i), []),
        !t && n ? [false, () => n && n(i)] : [true]
      );
    })(),
    s = (0, react9.useContext)(layoutContext);
  return react9.default.createElement(ClassComponentWrapper, {
    ...e,
    layoutGroup: s,
    switchLayoutGroup: (0, react9.useContext)(context6),
    isPresent: t,
    safeToRemove: n,
  });
}
export var Kc = {
  borderRadius: {
    ...Qc,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: Qc,
  borderTopRightRadius: Qc,
  borderBottomLeftRadius: Qc,
  borderBottomRightRadius: Qc,
  boxShadow: Gc,
};
export var Yc = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
export var Xc = Yc.length;
export var Jc = (e) => ("string" == typeof e ? parseFloat(e) : e);
export var eu = (e) => "number" == typeof e || pixelUnit.test(e);
export function tu(e, t) {
  return undefined !== e[t] ? e[t] : e.borderRadius;
}
export var nu = iu(0, 0.5, Gr);
export var su = iu(0.5, 0.95, Zo);
export function iu(e, t, n) {
  return (s) => (s < e ? 0 : s > t ? 1 : n(Ea(e, t, s)));
}
export function ou(e, t) {
  (e.min = t.min), (e.max = t.max);
}
export function ru(e, t) {
  ou(e.x, t.x), ou(e.y, t.y);
}
export function au(e, t, n, s, i) {
  return (
    (e = _c((e -= t), 1 / n, s)), undefined !== i && (e = _c(e, 1 / i, s)), e
  );
}
export function lu(e, t, [n, s, i], o, r) {
  !(function (e, t = 0, n = 1, s = 0.5, i, o = e, r = e) {
    percentUnit.test(t) &&
      ((t = parseFloat(t)), (t = aa(r.min, r.max, t / 100) - r.min));
    if ("number" != typeof t) return;
    let a = aa(o.min, o.max, s);
    e === o && (a -= t),
      (e.min = au(e.min, t, n, a, i)),
      (e.max = au(e.max, t, n, a, i));
  })(e, t[n], t[s], t[i], t.scale, o, r);
}
export var cu = ["x", "scaleX", "originX"];
export var uu = ["y", "scaleY", "originY"];
export function du(e, t, n, s) {
  lu(e.x, t, cu, n ? n.x : undefined, s ? s.x : undefined),
    lu(e.y, t, uu, n ? n.y : undefined, s ? s.y : undefined);
}
export function pu(e) {
  return 0 === e.translate && 1 === e.scale;
}
export function fu(e) {
  return pu(e.x) && pu(e.y);
}
export function hu(e, t) {
  return (
    Math.round(e.x.min) === Math.round(t.x.min) &&
    Math.round(e.x.max) === Math.round(t.x.max) &&
    Math.round(e.y.min) === Math.round(t.y.min) &&
    Math.round(e.y.max) === Math.round(t.y.max)
  );
}
export function mu(e) {
  return oc(e.x) / oc(e.y);
}
export var gu = class {
  constructor() {
    this.members = [];
  }
  add(e) {
    _l(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (El(this.members, e),
      e === this.prevLead && (this.prevLead = undefined),
      e === this.lead)
    ) {
      const e = this.members[this.members.length - 1];
      e && this.promote(e);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((t) => e === t);
    if (0 === t) return false;
    let n;
    for (let e = t; e >= 0; e--) {
      const t = this.members[e];
      if (false !== t.isPresent) {
        n = t;
        break;
      }
    }
    return !!n && (this.promote(n), true);
  }
  promote(e, t) {
    const n = this.lead;
    if (e !== n && ((this.prevLead = n), (this.lead = e), e.show(), n)) {
      n.instance && n.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = n),
        t && (e.resumeFrom.preserveOpacity = true),
        n.snapshot &&
          ((e.snapshot = n.snapshot),
          (e.snapshot.latestValues = n.animationValues || n.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = true);
      const { crossfade: s } = e.options;
      false === s && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: n } = e;
      t.onExitComplete && t.onExitComplete(),
        n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(false);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = undefined);
  }
};
export function xu(e, t, n) {
  let s = "";
  const i = e.x.translate / t.x,
    o = e.y.translate / t.y;
  if (
    ((i || o) && (s = `translate3d(${i}px, ${o}px, 0) `),
    (1 === t.x && 1 === t.y) || (s += `scale(${1 / t.x}, ${1 / t.y}) `),
    n)
  ) {
    const { rotate: e, rotateX: t, rotateY: i } = n;
    e && (s += `rotate(${e}deg) `),
      t && (s += `rotateX(${t}deg) `),
      i && (s += `rotateY(${i}deg) `);
  }
  const r = e.x.scale * t.x,
    a = e.y.scale * t.y;
  return (1 === r && 1 === a) || (s += `scale(${r}, ${a})`), s || "none";
}
export var bu = (e, t) => e.depth - t.depth;
export var yu = class {
  constructor() {
    (this.children = []), (this.isDirty = false);
  }
  add(e) {
    _l(this.children, e), (this.isDirty = true);
  }
  remove(e) {
    El(this.children, e), (this.isDirty = true);
  }
  forEach(e) {
    this.isDirty && this.children.sort(bu),
      (this.isDirty = false),
      this.children.forEach(e);
  }
};
export function vu(e) {
  return e instanceof SVGElement && "svg" !== e.tagName;
}
export function wu(e, t, n) {
  const s = zi(e) ? e : Bl(e);
  return s.start(Cl("", s, t, n)), s.animation;
}
export var ku = ["", "X", "Y", "Z"];
export var Cu = { visibility: "hidden" };
export var ju = 0;
export var Su = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
};
export function _u({
  attachResizeListener: e,
  defaultParent: t,
  measureScroll: n,
  checkIsScrollRoot: s,
  resetTransform: i,
}) {
  return class ProjectionNode {
    constructor(e = {}, n = null == t ? undefined : t()) {
      (this.id = ju++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = false),
        (this.isAnimationBlocked = false),
        (this.isLayoutDirty = false),
        (this.isProjectionDirty = false),
        (this.isSharedProjectionDirty = false),
        (this.isTransformDirty = false),
        (this.updateManuallyBlocked = false),
        (this.updateBlockedByResize = false),
        (this.isUpdating = false),
        (this.isSVG = false),
        (this.needsReset = false),
        (this.shouldResetTransform = false),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = false),
        (this.updateScheduled = false),
        (this.projectionUpdateScheduled = false),
        (this.checkUpdateFailed = () => {
          this.isUpdating &&
            ((this.isUpdating = false), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          var e;
          (this.projectionUpdateScheduled = false),
            (Su.totalNodes =
              Su.resolvedTargetDeltas =
              Su.recalculatedProjection =
                0),
            this.nodes.forEach(Pu),
            this.nodes.forEach(Vu),
            this.nodes.forEach(Du),
            this.nodes.forEach(Au),
            (e = Su),
            window.MotionDebug && window.MotionDebug.record(e);
        }),
        (this.hasProjected = false),
        (this.isVisible = true),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = e),
        (this.root = n ? n.root || n : this),
        (this.path = n ? [...n.path, n] : []),
        (this.parent = n),
        (this.depth = n ? n.depth + 1 : 0);
      for (let e = 0; e < this.path.length; e++)
        this.path[e].shouldResetTransform = true;
      this.root === this && (this.nodes = new yu());
    }
    addEventListener(e, t) {
      return (
        this.eventHandlers.has(e) || this.eventHandlers.set(e, new Ll()),
        this.eventHandlers.get(e).add(t)
      );
    }
    notifyListeners(e, ...t) {
      const n = this.eventHandlers.get(e);
      n && n.notify(...t);
    }
    hasListeners(e) {
      return this.eventHandlers.has(e);
    }
    mount(t, n = this.root.hasTreeAnimated) {
      if (this.instance) return;
      (this.isSVG = vu(t)), (this.instance = t);
      const { layoutId: s, layout: i, visualElement: o } = this.options;
      if (
        (o && !o.current && o.mount(t),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        n && (i || s) && (this.isLayoutDirty = true),
        e)
      ) {
        let n;
        const s = () => (this.root.updateBlockedByResize = false);
        e(t, () => {
          (this.root.updateBlockedByResize = true),
            n && n(),
            (n = (function (e, t) {
              const n = Xa.now(),
                s = ({ timestamp: i }) => {
                  const o = i - n;
                  o >= t && (Ko(s), e(o - t));
                };
              return Wo.read(s, true), () => Ko(s);
            })(s, 250)),
            $c.hasAnimatedSinceResize &&
              (($c.hasAnimatedSinceResize = false), this.nodes.forEach(Ru));
        });
      }
      s && this.root.registerSharedNode(s, this),
        false !== this.options.animate &&
          o &&
          (s || i) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: e,
              hasLayoutChanged: t,
              hasRelativeTargetChanged: n,
              layout: s,
            }) => {
              if (this.isTreeAnimationBlocked())
                return (
                  (this.target = undefined),
                  void (this.relativeTarget = undefined)
                );
              const i =
                  this.options.transition || o.getDefaultTransition() || zu,
                { onLayoutAnimationStart: r, onLayoutAnimationComplete: a } =
                  o.getProps(),
                l = !this.targetLayout || !hu(this.targetLayout, s) || n,
                c = !t && n;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                c ||
                (t && (l || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = undefined)),
                  this.setAnimationOrigin(e, c);
                const t = { ...kl(i, "layout"), onPlay: r, onComplete: a };
                (o.shouldReduceMotion || this.options.layoutRoot) &&
                  ((t.delay = 0), (t.type = false)),
                  this.startAnimation(t);
              } else
                t || Ru(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = s;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const e = this.getStack();
      e && e.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = undefined),
        Ko(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        false
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = true),
        this.nodes && this.nodes.forEach(Fu),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: e } = this.options;
      return e && e.getProps().transformTemplate;
    }
    willUpdate(e = true) {
      if (((this.root.hasTreeAnimated = true), this.root.isUpdateBlocked()))
        return void (
          this.options.onExitComplete && this.options.onExitComplete()
        );
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = true;
      for (let e = 0; e < this.path.length; e++) {
        const t = this.path[e];
        (t.shouldResetTransform = true),
          t.updateScroll("snapshot"),
          t.options.layoutRoot && t.willUpdate(false);
      }
      const { layoutId: t, layout: n } = this.options;
      if (undefined === t && !n) return;
      const s = this.getTransformTemplate();
      (this.prevTransformTemplateValue = s
        ? s(this.latestValues, "")
        : undefined),
        this.updateSnapshot(),
        e && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      if (this.isUpdateBlocked())
        return (
          this.unblockUpdate(),
          this.clearAllSnapshots(),
          void this.nodes.forEach(Tu)
        );
      this.isUpdating || this.nodes.forEach(Mu),
        (this.isUpdating = false),
        this.nodes.forEach(Ou),
        this.nodes.forEach(Eu),
        this.nodes.forEach(Lu),
        this.clearAllSnapshots();
      const e = Xa.now();
      (Yo.delta = Ki(0, 1e3 / 60, e - Yo.timestamp)),
        (Yo.timestamp = e),
        (Yo.isProcessing = true),
        Xo.update.process(Yo),
        Xo.preRender.process(Yo),
        Xo.render.process(Yo),
        (Yo.isProcessing = false);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = true),
        renderingProcessorSchedule.read(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Bu), this.sharedNodes.forEach(Iu);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = true),
        Wo.preRender(this.updateProjection, false, true));
    }
    scheduleCheckAfterUnmount() {
      Wo.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      !this.snapshot && this.instance && (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance) return;
      if (
        (this.updateScroll(),
        !(
          (this.options.alwaysMeasureLayout && this.isLead()) ||
          this.isLayoutDirty
        ))
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let e = 0; e < this.path.length; e++) {
          this.path[e].updateScroll();
        }
      const e = this.layout;
      (this.layout = this.measure(false)),
        (this.layoutCorrected = bc()),
        (this.isLayoutDirty = false),
        (this.projectionDelta = undefined),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: t } = this.options;
      t &&
        t.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          e ? e.layoutBox : undefined
        );
    }
    updateScroll(e = "measure") {
      let t = Boolean(this.options.layoutScroll && this.instance);
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === e &&
        (t = false),
        t &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: e,
            isRoot: s(this.instance),
            offset: n(this.instance),
          });
    }
    resetTransform() {
      if (!i) return;
      const e = this.isLayoutDirty || this.shouldResetTransform,
        t = this.projectionDelta && !fu(this.projectionDelta),
        n = this.getTransformTemplate(),
        s = n ? n(this.latestValues, "") : undefined,
        o = s !== this.prevTransformTemplateValue;
      e &&
        (t || Cc(this.latestValues) || o) &&
        (i(this.instance, s),
        (this.shouldResetTransform = false),
        this.scheduleRender());
    }
    measure(e = true) {
      const t = this.measurePageBox();
      let n = this.removeElementScroll(t);
      var s;
      return (
        e && (n = this.removeTransform(n)),
        Qu((s = n).x),
        Qu(s.y),
        {
          animationId: this.root.animationId,
          measuredBox: t,
          layoutBox: n,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: e } = this.options;
      if (!e) return bc();
      const t = e.measureViewportBox(),
        { scroll: n } = this.root;
      return n && (Bc(t.x, n.offset.x), Bc(t.y, n.offset.y)), t;
    }
    removeElementScroll(e) {
      const t = bc();
      ru(t, e);
      for (let n = 0; n < this.path.length; n++) {
        const s = this.path[n],
          { scroll: i, options: o } = s;
        if (s !== this.root && i && o.layoutScroll) {
          if (i.isRoot) {
            ru(t, e);
            const { scroll: n } = this.root;
            n && (Bc(t.x, -n.offset.x), Bc(t.y, -n.offset.y));
          }
          Bc(t.x, i.offset.x), Bc(t.y, i.offset.y);
        }
      }
      return t;
    }
    applyTransform(e, t = false) {
      const n = bc();
      ru(n, e);
      for (let e = 0; e < this.path.length; e++) {
        const s = this.path[e];
        !t &&
          s.options.layoutScroll &&
          s.scroll &&
          s !== s.root &&
          Rc(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
          Cc(s.latestValues) && Rc(n, s.latestValues);
      }
      return Cc(this.latestValues) && Rc(n, this.latestValues), n;
    }
    removeTransform(e) {
      const t = bc();
      ru(t, e);
      for (let e = 0; e < this.path.length; e++) {
        const n = this.path[e];
        if (!n.instance) continue;
        if (!Cc(n.latestValues)) continue;
        kc(n.latestValues) && n.updateSnapshot();
        const s = bc();
        ru(s, n.measurePageBox()),
          du(
            t,
            n.latestValues,
            n.snapshot ? n.snapshot.layoutBox : undefined,
            s
          );
      }
      return Cc(this.latestValues) && du(t, this.latestValues), t;
    }
    setTargetDelta(e) {
      (this.targetDelta = e),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = true);
    }
    setOptions(e) {
      this.options = {
        ...this.options,
        ...e,
        crossfade: undefined === e.crossfade || e.crossfade,
      };
    }
    clearMeasurements() {
      (this.scroll = undefined),
        (this.layout = undefined),
        (this.snapshot = undefined),
        (this.prevTransformTemplateValue = undefined),
        (this.targetDelta = undefined),
        (this.target = undefined),
        (this.isLayoutDirty = false);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== Yo.timestamp &&
        this.relativeParent.resolveTargetDelta(true);
    }
    resolveTargetDelta(e = false) {
      var t;
      const n = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = n.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = n.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = n.isSharedProjectionDirty);
      const s = Boolean(this.resumingFrom) || this !== n;
      if (
        !(
          e ||
          (s && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (null === (t = this.parent) || undefined === t
            ? undefined
            : t.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return;
      const { layout: i, layoutId: o } = this.options;
      if (this.layout && (i || o)) {
        if (
          ((this.resolvedRelativeTargetAt = Yo.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const e = this.getClosestProjectingParent();
          e && e.layout && 1 !== this.animationProgress
            ? ((this.relativeParent = e),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = bc()),
              (this.relativeTargetOrigin = bc()),
              dc(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                e.layout.layoutBox
              ),
              ru(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = undefined);
        }
        if (this.relativeTarget || this.targetDelta) {
          var r, a, l;
          if (
            (this.target ||
              ((this.target = bc()), (this.targetWithTransforms = bc())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                (r = this.target),
                (a = this.relativeTarget),
                (l = this.relativeParent.target),
                cc(r.x, a.x, l.x),
                cc(r.y, a.y, l.y))
              : this.targetDelta
              ? (Boolean(this.resumingFrom)
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : ru(this.target, this.layout.layoutBox),
                Pc(this.target, this.targetDelta))
              : ru(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = false;
            const e = this.getClosestProjectingParent();
            e &&
            Boolean(e.resumingFrom) === Boolean(this.resumingFrom) &&
            !e.options.layoutScroll &&
            e.target &&
            1 !== this.animationProgress
              ? ((this.relativeParent = e),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = bc()),
                (this.relativeTargetOrigin = bc()),
                dc(this.relativeTargetOrigin, this.target, e.target),
                ru(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = undefined);
          }
          Su.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        this.parent &&
        !kc(this.parent.latestValues) &&
        !jc(this.parent.latestValues)
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return Boolean(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
          this.layout
      );
    }
    calcProjection() {
      var e;
      const t = this.getLead(),
        n = Boolean(this.resumingFrom) || this !== t;
      let s = true;
      if (
        ((this.isProjectionDirty ||
          (null === (e = this.parent) || undefined === e
            ? undefined
            : e.isProjectionDirty)) &&
          (s = false),
        n &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (s = false),
        this.resolvedRelativeTargetAt === Yo.timestamp && (s = false),
        s)
      )
        return;
      const { layout: i, layoutId: o } = this.options;
      if (
        ((this.isTreeAnimating = Boolean(
          (this.parent && this.parent.isTreeAnimating) ||
            this.currentAnimation ||
            this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = undefined),
        !this.layout || (!i && !o))
      )
        return;
      ru(this.layoutCorrected, this.layout.layoutBox);
      const r = this.treeScale.x,
        a = this.treeScale.y;
      !(function (e, t, n, s = false) {
        const i = n.length;
        if (!i) return;
        let o, r;
        t.x = t.y = 1;
        for (let a = 0; a < i; a++) {
          (o = n[a]), (r = o.projectionDelta);
          const i = o.instance;
          (i && i.style && "contents" === i.style.display) ||
            (s &&
              o.options.layoutScroll &&
              o.scroll &&
              o !== o.root &&
              Rc(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }),
            r && ((t.x *= r.x.scale), (t.y *= r.y.scale), Pc(e, r)),
            s && Cc(o.latestValues) && Rc(e, o.latestValues));
        }
        (t.x = Ac(t.x)), (t.y = Ac(t.y));
      })(this.layoutCorrected, this.treeScale, this.path, n),
        !t.layout ||
          t.target ||
          (1 === this.treeScale.x && 1 === this.treeScale.y) ||
          ((t.target = t.layout.layoutBox), (t.targetWithTransforms = bc()));
      const { target: l } = t;
      if (!l)
        return void (
          this.projectionTransform &&
          ((this.projectionDelta = xc()),
          (this.projectionTransform = "none"),
          this.scheduleRender())
        );
      this.projectionDelta ||
        ((this.projectionDelta = xc()),
        (this.projectionDeltaWithTransform = xc()));
      const c = this.projectionTransform;
      lc(this.projectionDelta, this.layoutCorrected, l, this.latestValues),
        (this.projectionTransform = xu(this.projectionDelta, this.treeScale)),
        (this.projectionTransform === c &&
          this.treeScale.x === r &&
          this.treeScale.y === a) ||
          ((this.hasProjected = true),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", l)),
        Su.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(e = true) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), e)) {
        const e = this.getStack();
        e && e.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = undefined);
    }
    setAnimationOrigin(e, t = false) {
      const n = this.snapshot,
        s = n ? n.latestValues : {},
        i = { ...this.latestValues },
        o = xc();
      (this.relativeParent && this.relativeParent.options.layoutRoot) ||
        (this.relativeTarget = this.relativeTargetOrigin = undefined),
        (this.attemptToResolveRelativeTarget = !t);
      const r = bc(),
        a =
          (n ? n.source : undefined) !==
          (this.layout ? this.layout.source : undefined),
        l = this.getStack(),
        c = !l || l.members.length <= 1,
        u = Boolean(
          a && !c && true === this.options.crossfade && !this.path.some(Uu)
        );
      let d;
      (this.animationProgress = 0),
        (this.mixTargetDelta = (t) => {
          const n = t / 1e3;
          var l, p, f, h, m, g;
          Hu(o.x, e.x, n),
            Hu(o.y, e.y, n),
            this.setTargetDelta(o),
            this.relativeTarget &&
              this.relativeTargetOrigin &&
              this.layout &&
              this.relativeParent &&
              this.relativeParent.layout &&
              (dc(
                r,
                this.layout.layoutBox,
                this.relativeParent.layout.layoutBox
              ),
              (f = this.relativeTarget),
              (h = this.relativeTargetOrigin),
              (m = r),
              (g = n),
              Nu(f.x, h.x, m.x, g),
              Nu(f.y, h.y, m.y, g),
              d &&
                ((l = this.relativeTarget),
                (p = d),
                l.x.min === p.x.min &&
                  l.x.max === p.x.max &&
                  l.y.min === p.y.min &&
                  l.y.max === p.y.max) &&
                (this.isProjectionDirty = false),
              d || (d = bc()),
              ru(d, this.relativeTarget)),
            a &&
              ((this.animationValues = i),
              (function (e, t, n, s, i, o) {
                i
                  ? ((e.opacity = aa(
                      0,
                      undefined !== n.opacity ? n.opacity : 1,
                      nu(s)
                    )),
                    (e.opacityExit = aa(
                      undefined !== t.opacity ? t.opacity : 1,
                      0,
                      su(s)
                    )))
                  : o &&
                    (e.opacity = aa(
                      undefined !== t.opacity ? t.opacity : 1,
                      undefined !== n.opacity ? n.opacity : 1,
                      s
                    ));
                for (let i = 0; i < Xc; i++) {
                  const o = `border${Yc[i]}Radius`;
                  let r = tu(t, o),
                    a = tu(n, o);
                  (undefined === r && undefined === a) ||
                    (r || (r = 0),
                    a || (a = 0),
                    0 === r || 0 === a || eu(r) === eu(a)
                      ? ((e[o] = Math.max(aa(Jc(r), Jc(a), s), 0)),
                        (percentUnit.test(a) || percentUnit.test(r)) &&
                          (e[o] += "%"))
                      : (e[o] = a));
                }
                (t.rotate || n.rotate) &&
                  (e.rotate = aa(t.rotate || 0, n.rotate || 0, s));
              })(i, s, this.latestValues, n, u, c)),
            this.root.scheduleUpdateProjection(),
            this.scheduleRender(),
            (this.animationProgress = n);
        }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(e) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Ko(this.pendingAnimation), (this.pendingAnimation = undefined)),
        (this.pendingAnimation = Wo.update(() => {
          ($c.hasAnimatedSinceResize = true),
            (this.currentAnimation = wu(0, 1e3, {
              ...e,
              onUpdate: (t) => {
                this.mixTargetDelta(t), e.onUpdate && e.onUpdate(t);
              },
              onComplete: () => {
                e.onComplete && e.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = undefined);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = undefined),
        (this.resumingFrom.preserveOpacity = undefined));
      const e = this.getStack();
      e && e.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            undefined),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(1e3),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const e = this.getLead();
      let {
        targetWithTransforms: t,
        target: n,
        layout: s,
        latestValues: i,
      } = e;
      if (t && n && s) {
        if (
          this !== e &&
          this.layout &&
          s &&
          Gu(this.options.animationType, this.layout.layoutBox, s.layoutBox)
        ) {
          n = this.target || bc();
          const t = oc(this.layout.layoutBox.x);
          (n.x.min = e.target.x.min), (n.x.max = n.x.min + t);
          const s = oc(this.layout.layoutBox.y);
          (n.y.min = e.target.y.min), (n.y.max = n.y.min + s);
        }
        ru(t, n),
          Rc(t, i),
          lc(this.projectionDeltaWithTransform, this.layoutCorrected, t, i);
      }
    }
    registerSharedNode(e, t) {
      this.sharedNodes.has(e) || this.sharedNodes.set(e, new gu());
      this.sharedNodes.get(e).add(t);
      const n = t.options.initialPromotionConfig;
      t.promote({
        transition: n ? n.transition : undefined,
        preserveFollowOpacity:
          n && n.shouldPreserveFollowOpacity
            ? n.shouldPreserveFollowOpacity(t)
            : undefined,
      });
    }
    isLead() {
      const e = this.getStack();
      return !e || e.lead === this;
    }
    getLead() {
      var e;
      const { layoutId: t } = this.options;
      return (
        (t &&
          (null === (e = this.getStack()) || undefined === e
            ? undefined
            : e.lead)) ||
        this
      );
    }
    getPrevLead() {
      var e;
      const { layoutId: t } = this.options;
      return t
        ? null === (e = this.getStack()) || undefined === e
          ? undefined
          : e.prevLead
        : undefined;
    }
    getStack() {
      const { layoutId: e } = this.options;
      if (e) return this.root.sharedNodes.get(e);
    }
    promote({ needsReset: e, transition: t, preserveFollowOpacity: n } = {}) {
      const s = this.getStack();
      s && s.promote(this, n),
        e && ((this.projectionDelta = undefined), (this.needsReset = true)),
        t && this.setOptions({ transition: t });
    }
    relegate() {
      const e = this.getStack();
      return !!e && e.relegate(this);
    }
    resetRotation() {
      const { visualElement: e } = this.options;
      if (!e) return;
      let t = false;
      const { latestValues: n } = e;
      if (((n.rotate || n.rotateX || n.rotateY || n.rotateZ) && (t = true), !t))
        return;
      const s = {};
      for (let t = 0; t < ku.length; t++) {
        const i = "rotate" + ku[t];
        n[i] && ((s[i] = n[i]), e.setStaticValue(i, 0));
      }
      e.render();
      for (const t in s) e.setStaticValue(t, s[t]);
      e.scheduleRender();
    }
    getProjectionStyles(e) {
      var t, n;
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) return Cu;
      const s = { visibility: "" },
        i = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = false),
          (s.opacity = ""),
          (s.pointerEvents = qo(null == e ? undefined : e.pointerEvents) || ""),
          (s.transform = i ? i(this.latestValues, "") : "none"),
          s
        );
      const o = this.getLead();
      if (!this.projectionDelta || !this.layout || !o.target) {
        const t = {};
        return (
          this.options.layoutId &&
            ((t.opacity =
              undefined !== this.latestValues.opacity
                ? this.latestValues.opacity
                : 1),
            (t.pointerEvents =
              qo(null == e ? undefined : e.pointerEvents) || "")),
          this.hasProjected &&
            !Cc(this.latestValues) &&
            ((t.transform = i ? i({}, "") : "none"),
            (this.hasProjected = false)),
          t
        );
      }
      const r = o.animationValues || o.latestValues;
      this.applyTransformsToTarget(),
        (s.transform = xu(
          this.projectionDeltaWithTransform,
          this.treeScale,
          r
        )),
        i && (s.transform = i(r, s.transform));
      const { x: a, y: l } = this.projectionDelta;
      (s.transformOrigin = `${100 * a.origin}% ${100 * l.origin}% 0`),
        o.animationValues
          ? (s.opacity =
              o === this
                ? null !==
                    (n =
                      null !== (t = r.opacity) && undefined !== t
                        ? t
                        : this.latestValues.opacity) && undefined !== n
                  ? n
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : r.opacityExit)
          : (s.opacity =
              o === this
                ? undefined !== r.opacity
                  ? r.opacity
                  : ""
                : undefined !== r.opacityExit
                ? r.opacityExit
                : 0);
      for (const e in dimentionalPropsState) {
        if (undefined === r[e]) continue;
        const { correct: t, applyTo: n } = dimentionalPropsState[e],
          i = "none" === s.transform ? r[e] : t(r[e], o);
        if (n) {
          const e = n.length;
          for (let t = 0; t < e; t++) s[n[t]] = i;
        } else s[e] = i;
      }
      return (
        this.options.layoutId &&
          (s.pointerEvents =
            o === this
              ? qo(null == e ? undefined : e.pointerEvents) || ""
              : "none"),
        s
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = undefined;
    }
    resetTree() {
      this.root.nodes.forEach((e) => {
        var t;
        return null === (t = e.currentAnimation) || undefined === t
          ? undefined
          : t.stop();
      }),
        this.root.nodes.forEach(Tu),
        this.root.sharedNodes.clear();
    }
  };
}
export function Eu(e) {
  e.updateLayout();
}
export function Lu(e) {
  var t;
  const n =
    (null === (t = e.resumeFrom) || undefined === t ? undefined : t.snapshot) ||
    e.snapshot;
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: t, measuredBox: s } = e.layout,
      { animationType: i } = e.options,
      o = n.source !== e.layout.source;
    "size" === i
      ? yc((e) => {
          const s = o ? n.measuredBox[e] : n.layoutBox[e],
            i = oc(s);
          (s.min = t[e].min), (s.max = s.min + i);
        })
      : Gu(i, n.layoutBox, t) &&
        yc((s) => {
          const i = o ? n.measuredBox[s] : n.layoutBox[s],
            r = oc(t[s]);
          (i.max = i.min + r),
            e.relativeTarget &&
              !e.currentAnimation &&
              ((e.isProjectionDirty = true),
              (e.relativeTarget[s].max = e.relativeTarget[s].min + r));
        });
    const r = xc();
    lc(r, t, n.layoutBox);
    const a = xc();
    o ? lc(a, e.applyTransform(s, true), n.measuredBox) : lc(a, t, n.layoutBox);
    const l = !fu(r);
    let c = false;
    if (!e.resumeFrom) {
      const s = e.getClosestProjectingParent();
      if (s && !s.resumeFrom) {
        const { snapshot: i, layout: o } = s;
        if (i && o) {
          const r = bc();
          dc(r, n.layoutBox, i.layoutBox);
          const a = bc();
          dc(a, t, o.layoutBox),
            hu(r, a) || (c = true),
            s.options.layoutRoot &&
              ((e.relativeTarget = a),
              (e.relativeTargetOrigin = r),
              (e.relativeParent = s));
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: t,
      snapshot: n,
      delta: a,
      layoutDelta: r,
      hasLayoutChanged: l,
      hasRelativeTargetChanged: c,
    });
  } else if (e.isLead()) {
    const { onExitComplete: t } = e.options;
    t && t();
  }
  e.options.transition = undefined;
}
export function Pu(e) {
  Su.totalNodes++,
    e.parent &&
      (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
      e.isSharedProjectionDirty ||
        (e.isSharedProjectionDirty = Boolean(
          e.isProjectionDirty ||
            e.parent.isProjectionDirty ||
            e.parent.isSharedProjectionDirty
        )),
      e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
export function Au(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = false;
}
export function Bu(e) {
  e.clearSnapshot();
}
export function Tu(e) {
  e.clearMeasurements();
}
export function Mu(e) {
  e.isLayoutDirty = false;
}
export function Ou(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
    e.resetTransform();
}
export function Ru(e) {
  e.finishAnimation(),
    (e.targetDelta = e.relativeTarget = e.target = undefined),
    (e.isProjectionDirty = true);
}
export function Vu(e) {
  e.resolveTargetDelta();
}
export function Du(e) {
  e.calcProjection();
}
export function Fu(e) {
  e.resetRotation();
}
export function Iu(e) {
  e.removeLeadSnapshot();
}
export function Hu(e, t, n) {
  (e.translate = aa(t.translate, 0, n)),
    (e.scale = aa(t.scale, 1, n)),
    (e.origin = t.origin),
    (e.originPoint = t.originPoint);
}
export function Nu(e, t, n, s) {
  (e.min = aa(t.min, n.min, s)), (e.max = aa(t.max, n.max, s));
}
export function Uu(e) {
  return e.animationValues && undefined !== e.animationValues.opacityExit;
}
export var zu = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
export var $u = (e) =>
  "undefined" != typeof navigator &&
  navigator.userAgent.toLowerCase().includes(e);
export var qu = $u("applewebkit/") && !$u("chrome/") ? Math.round : Zo;
export function Qu(e) {
  (e.min = qu(e.min)), (e.max = qu(e.max));
}
export function Gu(e, t, n) {
  return (
    "position" === e || ("preserve-aspect" === e && !rc(mu(t), mu(n), 0.2))
  );
}
export var Zu = _u({
  attachResizeListener: (e, t) => addEventListenerWithCleanup(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop,
  }),
  checkIsScrollRoot: () => true,
});
export var Wu = { current: undefined };
export var Ku = _u({
  measureScroll: (e) => ({ x: e.scrollLeft, y: e.scrollTop }),
  defaultParent: () => {
    if (!Wu.current) {
      const e = new Zu({});
      e.mount(window), e.setOptions({ layoutScroll: true }), (Wu.current = e);
    }
    return Wu.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = undefined !== t ? t : "none";
  },
  checkIsScrollRoot: (e) =>
    Boolean("fixed" === window.getComputedStyle(e).position),
});
export var Yu = {
  pan: {
    Feature: class extends FrameRenderer {
      constructor() {
        super(...arguments), (this.removePointerDownListener = Zo);
      }
      onPointerDown(e) {
        this.session = new Xl(e, this.createPanHandlers(), {
          transformPagePoint: this.node.getTransformPagePoint(),
          contextWindow: Dc(this.node),
        });
      }
      createPanHandlers() {
        const {
          onPanSessionStart: e,
          onPanStart: t,
          onPan: n,
          onPanEnd: s,
        } = this.node.getProps();
        return {
          onSessionStart: Nc(e),
          onStart: Nc(t),
          onMove: n,
          onEnd: (e, t) => {
            delete this.session, s && Wo.update(() => s(e, t));
          },
        };
      }
      mount() {
        this.removePointerDownListener = or(
          this.node.current,
          "pointerdown",
          (e) => this.onPointerDown(e)
        );
      }
      update() {
        this.session && this.session.updateHandlers(this.createPanHandlers());
      }
      unmount() {
        this.removePointerDownListener(), this.session && this.session.end();
      }
    },
  },
  drag: {
    Feature: class extends FrameRenderer {
      constructor(e) {
        super(e),
          (this.removeGroupControls = Zo),
          (this.removeListeners = Zo),
          (this.controls = new Ic(e));
      }
      mount() {
        const { dragControls: e } = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
          (this.removeListeners = this.controls.addListeners() || Zo);
      }
      unmount() {
        this.removeGroupControls(), this.removeListeners();
      }
    },
    ProjectionNode: Ku,
    MeasureLayout: Wc,
  },
};
export var Xu = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
export var Ju = 4;
export function ed(e, t, n = 1) {
  Er(
    n <= Ju,
    `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`
  );
  const [s, i] = (function (e) {
    const t = Xu.exec(e);
    if (!t) return [,];
    const [, n, s] = t;
    return [n, s];
  })(e);
  if (!s) return;
  const o = window.getComputedStyle(t).getPropertyValue(s);
  if (o) {
    const e = o.trim();
    return Sl(e) ? parseFloat(e) : e;
  }
  return Zi(i) ? ed(i, t, n + 1) : i;
}
export var td = new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY",
]);
export var nd = (e) => td.has(e);
export var sd = (e) => e === Yi || e === pixelUnit;
export var id = (e, t) => parseFloat(e.split(", ")[t]);
export var od =
  (e, t) =>
  (n, { transform: s }) => {
    if ("none" === s || !s) return 0;
    const i = s.match(/^matrix3d\((.+)\)$/);
    if (i) return id(i[1], t);
    {
      const t = s.match(/^matrix\((.+)\)$/);
      return t ? id(t[1], e) : 0;
    }
  };
export var rd = new Set(["x", "y", "z"]);
export var ad = dimensionalProperties.filter((e) => !rd.has(e));
export var ld = {
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  x: od(4, 13),
  y: od(5, 14),
};
(ld.translateX = ld.x), (ld.translateY = ld.y);
export var cd = (e, t, n = {}, s = {}) => {
  (t = { ...t }), (s = { ...s });
  const i = Object.keys(t).filter(nd);
  let o = [],
    r = false;
  const a = [];
  if (
    (i.forEach((i) => {
      const l = e.getValue(i);
      if (!e.hasValue(i)) return;
      let c = n[i],
        u = Ol(c);
      const d = t[i];
      let p;
      if (Uo(d)) {
        const e = d.length,
          t = null === d[0] ? 1 : 0;
        (c = d[t]), (u = Ol(c));
        for (let n = t; n < e && null !== d[n]; n++)
          p
            ? Er(Ol(d[n]) === p, "All keyframes must be of the same type")
            : ((p = Ol(d[n])),
              Er(
                p === u || (sd(u) && sd(p)),
                "Keyframes must be of the same dimension as the current value"
              ));
      } else p = Ol(d);
      if (u !== p)
        if (sd(u) && sd(p)) {
          const e = l.get();
          "string" == typeof e && l.set(parseFloat(e)),
            "string" == typeof d
              ? (t[i] = parseFloat(d))
              : Array.isArray(d) &&
                p === pixelUnit &&
                (t[i] = d.map(parseFloat));
        } else
          (null == u ? undefined : u.transform) &&
          (null == p ? undefined : p.transform) &&
          (0 === c || 0 === d)
            ? 0 === c
              ? l.set(p.transform(c))
              : (t[i] = u.transform(d))
            : (r ||
                ((o = (function (e) {
                  const t = [];
                  return (
                    ad.forEach((n) => {
                      const s = e.getValue(n);
                      undefined !== s &&
                        (t.push([n, s.get()]),
                        s.set(n.startsWith("scale") ? 1 : 0));
                    }),
                    t.length && e.render(),
                    t
                  );
                })(e)),
                (r = true)),
              a.push(i),
              (s[i] = undefined !== s[i] ? s[i] : t[i]),
              l.jump(d));
    }),
    a.length)
  ) {
    const n = a.indexOf("height") >= 0 ? window.pageYOffset : null,
      i = ((e, t, n) => {
        const s = t.measureViewportBox(),
          i = t.current,
          o = getComputedStyle(i),
          { display: r } = o,
          a = {};
        "none" === r && t.setStaticValue("display", e.display || "block"),
          n.forEach((e) => {
            a[e] = ld[e](s, o);
          }),
          t.render();
        const l = t.measureViewportBox();
        return (
          n.forEach((n) => {
            const s = t.getValue(n);
            s && s.jump(a[n]), (e[n] = ld[n](l, o));
          }),
          e
        );
      })(t, e, a);
    return (
      o.length &&
        o.forEach(([t, n]) => {
          e.getValue(t).set(n);
        }),
      e.render(),
      isDocumentDefined && null !== n && window.scrollTo({ top: n }),
      { target: i, transitionEnd: s }
    );
  }
  return { target: t, transitionEnd: s };
};
export function ud(e, t, n, s) {
  return ((e) => Object.keys(e).some(nd))(t)
    ? cd(e, t, n, s)
    : { target: t, transitionEnd: s };
}
export var dd = (e, t, n, s) => {
  const i = (function (e, { ...t }, n) {
    const s = e.current;
    if (!(s instanceof Element)) return { target: t, transitionEnd: n };
    n && (n = { ...n }),
      e.values.forEach((e) => {
        const t = e.get();
        if (!Zi(t)) return;
        const n = ed(t, s);
        n && e.set(n);
      });
    for (const e in t) {
      const i = t[e];
      if (!Zi(i)) continue;
      const o = ed(i, s);
      o && ((t[e] = o), n || (n = {}), undefined === n[e] && (n[e] = i));
    }
    return { target: t, transitionEnd: n };
  })(e, t, s);
  return ud(e, (t = i.target), n, (s = i.transitionEnd));
};
export var pd = { current: null };
export var fd = { current: false };
export var hd = new WeakMap();
export var md = Object.keys(Li);
export var gd = md.length;
export var xd = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
export var bd = allAnimationStates.length;
export var yd = class {
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: n,
      reducedMotionConfig: s,
      visualState: i,
    },
    o = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = false),
      (this.isControllingVariants = false),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.scheduleRender = () => Wo.render(this.render, false, true));
    const { latestValues: r, renderState: a } = i;
    (this.latestValues = r),
      (this.baseTarget = { ...r }),
      (this.initialValues = t.initial ? { ...r } : {}),
      (this.renderState = a),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = n),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = s),
      (this.options = o),
      (this.isControllingVariants = hasAnimationProperties(t)),
      (this.isVariantNode = hasVariants(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = Boolean(e && e.current));
    const { willChange: l, ...c } = this.scrapeMotionValuesFromProps(t, {});
    for (const e in c) {
      const t = c[e];
      undefined !== r[e] && zi(t) && (t.set(r[e], false), jl(l) && l.add(e));
    }
  }
  scrapeMotionValuesFromProps(e, t) {
    return {};
  }
  mount(e) {
    (this.current = e),
      hd.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((e, t) => this.bindToMotionValue(t, e)),
      fd.current ||
        (function () {
          if (((fd.current = true), isDocumentDefined))
            if (window.matchMedia) {
              const e = window.matchMedia("(prefers-reduced-motion)"),
                t = () => (pd.current = e.matches);
              e.addListener(t), t();
            } else pd.current = false;
        })(),
      (this.shouldReduceMotion =
        "never" !== this.reducedMotionConfig &&
        ("always" === this.reducedMotionConfig || pd.current)),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    hd.delete(this.current),
      this.projection && this.projection.unmount(),
      Ko(this.notifyUpdate),
      Ko(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, t) {
    const n = dimensionalPropertiesSet.has(e),
      s = t.on("change", (t) => {
        (this.latestValues[e] = t),
          this.props.onUpdate && Wo.update(this.notifyUpdate, false, true),
          n && this.projection && (this.projection.isTransformDirty = true);
      }),
      i = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      s(), i();
    });
  }
  sortNodePosition(e) {
    return this.current && this.sortInstanceNodePosition && this.type === e.type
      ? this.sortInstanceNodePosition(this.current, e.current)
      : 0;
  }
  loadFeatures({ children: e, ...t }, n, s, i) {
    let o, r;
    for (let e = 0; e < gd; e++) {
      const n = md[e],
        {
          isEnabled: s,
          Feature: i,
          ProjectionNode: a,
          MeasureLayout: l,
        } = Li[n];
      a && (o = a),
        s(t) &&
          (!this.features[n] && i && (this.features[n] = new i(this)),
          l && (r = l));
    }
    if (
      ("html" === this.type || "svg" === this.type) &&
      !this.projection &&
      o
    ) {
      this.projection = new o(
        this.latestValues,
        this.parent && this.parent.projection
      );
      const {
        layoutId: e,
        layout: n,
        drag: s,
        dragConstraints: r,
        layoutScroll: a,
        layoutRoot: l,
      } = t;
      this.projection.setOptions({
        layoutId: e,
        layout: n,
        alwaysMeasureLayout: Boolean(s) || (r && hasCurrentProperty(r)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: "string" == typeof n ? n : "both",
        initialPromotionConfig: i,
        layoutScroll: a,
        layoutRoot: l,
      });
    }
    return r;
  }
  updateFeatures() {
    for (const e in this.features) {
      const t = this.features[e];
      t.isMounted ? t.update() : (t.mount(), (t.isMounted = true));
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : bc();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  makeTargetAnimatable(e, t = true) {
    return this.makeTargetAnimatableFromInstance(e, t);
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let t = 0; t < xd.length; t++) {
      const n = xd[t];
      this.propEventSubscriptions[n] &&
        (this.propEventSubscriptions[n](),
        delete this.propEventSubscriptions[n]);
      const s = e["on" + n];
      s && (this.propEventSubscriptions[n] = this.on(n, s));
    }
    (this.prevMotionValues = (function (e, t, n) {
      const { willChange: s } = t;
      for (const i in t) {
        const o = t[i],
          r = n[i];
        if (zi(o)) e.addValue(i, o), jl(s) && s.add(i);
        else if (zi(r))
          e.addValue(i, Bl(o, { owner: e })), jl(s) && s.remove(i);
        else if (r !== o)
          if (e.hasValue(i)) {
            const t = e.getValue(i);
            !t.hasAnimated && t.set(o);
          } else {
            const t = e.getStaticValue(i);
            e.addValue(i, Bl(undefined !== t ? t : o, { owner: e }));
          }
      }
      for (const s in n) undefined === t[s] && e.removeValue(s);
      return t;
    })(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : undefined;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : undefined;
  }
  getVariantContext(e = false) {
    if (e) return this.parent ? this.parent.getVariantContext() : undefined;
    if (!this.isControllingVariants) {
      const e = (this.parent && this.parent.getVariantContext()) || {};
      return (
        undefined !== this.props.initial && (e.initial = this.props.initial), e
      );
    }
    const t = {};
    for (let e = 0; e < bd; e++) {
      const n = allAnimationStates[e],
        s = this.props[n];
      (isStringOrArray(s) || false === s) && (t[n] = s);
    }
    return t;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    t !== this.values.get(e) &&
      (this.removeValue(e), this.bindToMotionValue(e, t)),
      this.values.set(e, t),
      (this.latestValues[e] = t.get());
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let n = this.values.get(e);
    return (
      undefined === n &&
        undefined !== t &&
        ((n = Bl(t, { owner: this })), this.addValue(e, n)),
      n
    );
  }
  readValue(e) {
    var t;
    return undefined === this.latestValues[e] && this.current
      ? null !== (t = this.getBaseTargetFromProps(this.props, e)) &&
        undefined !== t
        ? t
        : this.readValueFromInstance(this.current, e, this.options)
      : this.latestValues[e];
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var t;
    const { initial: n } = this.props,
      s =
        "string" == typeof n || "object" == typeof n
          ? null === (t = Io(this.props, n)) || undefined === t
            ? undefined
            : t[e]
          : undefined;
    if (n && undefined !== s) return s;
    const i = this.getBaseTargetFromProps(this.props, e);
    return undefined === i || zi(i)
      ? undefined !== this.initialValues[e] && undefined === s
        ? undefined
        : this.baseTarget[e]
      : i;
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new Ll()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
};
export var vd = class extends yd {
  sortInstanceNodePosition(e, t) {
    return 2 & e.compareDocumentPosition(t) ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : undefined;
  }
  removeValueFromRenderState(e, { vars: t, style: n }) {
    delete t[e], delete n[e];
  }
  makeTargetAnimatableFromInstance(
    { transition: e, transitionEnd: t, ...n },
    s
  ) {
    const i = (function (e, t, n) {
      const s = {};
      for (const i in e) {
        const e = Dl(i, t);
        if (undefined !== e) s[i] = e;
        else {
          const e = n.getValue(i);
          e && (s[i] = e.get());
        }
      }
      return s;
    })(n, e || {}, this);
    if (s) {
      !(function (e, t, n) {
        var s, i;
        const o = Object.keys(t).filter((t) => !e.hasValue(t)),
          r = o.length;
        var a;
        if (r)
          for (let l = 0; l < r; l++) {
            const r = o[l],
              c = t[r];
            let u = null;
            Array.isArray(c) && (u = c[0]),
              null === u &&
                (u =
                  null !==
                    (i =
                      null !== (s = n[r]) && undefined !== s
                        ? s
                        : e.readValue(r)) && undefined !== i
                    ? i
                    : t[r]),
              null != u &&
                ("string" == typeof u && (Sl(u) || vl(u))
                  ? (u = parseFloat(u))
                  : ((a = u), !Rl.find(Tl(a)) && wa.test(c) && (u = yl(r, c))),
                e.addValue(r, Bl(u, { owner: e })),
                undefined === n[r] && (n[r] = u),
                null !== u && e.setBaseTarget(r, u));
          }
      })(this, n, i);
      const e = dd(this, n, i, t);
      (t = e.transitionEnd), (n = e.target);
    }
    return { transition: e, transitionEnd: t, ...n };
  }
};
export var wd = class extends vd {
  constructor() {
    super(...arguments), (this.type = "html");
  }
  readValueFromInstance(e, t) {
    if (dimensionalPropertiesSet.has(t)) {
      const e = bl(t);
      return (e && e.default) || 0;
    }
    {
      const s = ((n = e), window.getComputedStyle(n)),
        i = (Gi(t) ? s.getPropertyValue(t) : s[t]) || 0;
      return "string" == typeof i ? i.trim() : i;
    }
    var n;
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return Vc(e, t);
  }
  build(e, t, n, s) {
    mo(e, t, n, s.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t) {
    return Vo(e, t);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    zi(e) &&
      (this.childSubscription = e.on("change", (e) => {
        this.current && (this.current.textContent = `${e}`);
      }));
  }
  renderInstance(e, t, n, s) {
    Mo(e, t, n, s);
  }
};
export var kd = class extends vd {
  constructor() {
    super(...arguments), (this.type = "svg"), (this.isSVGTag = false);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (dimensionalPropertiesSet.has(t)) {
      const e = bl(t);
      return (e && e.default) || 0;
    }
    return (t = Oo.has(t) ? t : generateSlug(t)), e.getAttribute(t);
  }
  measureInstanceViewportBox() {
    return bc();
  }
  scrapeMotionValuesFromProps(e, t) {
    return Do(e, t);
  }
  build(e, t, n, s) {
    Lo(e, t, n, this.isSVGTag, s.transformTemplate);
  }
  renderInstance(e, t, n, s) {
    Ro(e, t, 0, s);
  }
  mount(e) {
    (this.isSVGTag = Ao(e.tagName)), super.mount(e);
  }
};
export var Cd = (e, t) =>
  isValidElementType(e)
    ? new kd(t, { enableHardwareAcceleration: false })
    : new wd(t, { enableHardwareAcceleration: true });
export var jd = {
  ...Kl,
  ...Cr,
  ...Yu,
  ...{ layout: { ProjectionNode: Ku, MeasureLayout: Wc } },
};
export const Sd = Oi((e, t) =>
  (function (e, { forwardMotionProps: t = false }, n, s) {
    return {
      ...(isValidElementType(e) ? Jo : er),
      preloadedFeatures: n,
      useRender: To(t),
      createVisualElement: s,
      Component: e,
    };
  })(e, t, jd, Cd)
);
export function Ad() {
  const e = (0, Pd.useRef)(false);
  return (
    dynamicUseEffect(
      () => (
        (e.current = true),
        () => {
          e.current = false;
        }
      ),
      []
    ),
    e
  );
}
export var Rd = class extends Md.Component {
  getSnapshotBeforeUpdate(e) {
    const t = this.props.childRef.current;
    if (t && e.isPresent && !this.props.isPresent) {
      const e = this.props.sizeRef.current;
      (e.height = t.offsetHeight || 0),
        (e.width = t.offsetWidth || 0),
        (e.top = t.offsetTop),
        (e.left = t.offsetLeft);
    }
    return null;
  }
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
};
export function Vd({ children: e, isPresent: t }) {
  const n = (0, Od.useId)(),
    s = (0, Od.useRef)(null),
    i = (0, Od.useRef)({ width: 0, height: 0, top: 0, left: 0 });
  return (
    (0, Od.useInsertionEffect)(() => {
      const { width: e, height: o, top: r, left: a } = i.current;
      if (t || !s.current || !e || !o) return;
      s.current.dataset.motionPopId = n;
      const l = document.createElement("style");
      return (
        document.head.appendChild(l),
        l.sheet &&
          l.sheet.insertRule(
            `\n          [data-motion-pop-id="${n}"] {\n            position: absolute !important;\n            width: ${e}px !important;\n            height: ${o}px !important;\n            top: ${r}px !important;\n            left: ${a}px !important;\n          }\n        `
          ),
        () => {
          document.head.removeChild(l);
        }
      );
    }, [t]),
    Md.createElement(
      Rd,
      { isPresent: t, childRef: s, sizeRef: i },
      Md.cloneElement(e, { ref: s })
    )
  );
}
export var Dd = ({
  children: e,
  initial: t,
  isPresent: n,
  onExitComplete: s,
  custom: i,
  presenceAffectsLayout: o,
  mode: r,
}) => {
  const a = No(Fd),
    l = (0, Td.useId)(),
    c = (0, Td.useMemo)(
      () => ({
        id: l,
        initial: t,
        isPresent: n,
        custom: i,
        onExitComplete: (e) => {
          a.set(e, true);
          for (const e of a.values()) if (!e) return;
          s && s();
        },
        register: (e) => (a.set(e, false), () => a.delete(e)),
      }),
      o ? undefined : [n]
    );
  return (
    (0, Td.useMemo)(() => {
      a.forEach((e, t) => a.set(t, false));
    }, [n]),
    Bd.useEffect(() => {
      !n && !a.size && s && s();
    }, [n]),
    "popLayout" === r && (e = Bd.createElement(Vd, { isPresent: n }, e)),
    Bd.createElement(context4.Provider, { value: c }, e)
  );
};
export function Fd() {
  return new Map();
}
export var Hd = (e) => e.key || "";
export var DynamicPresenceTransition = ({
  children: e,
  custom: t,
  initial: n = true,
  onExitComplete: s,
  exitBeforeEnter: i,
  presenceAffectsLayout: o = true,
  mode: r = "sync",
}) => {
  Er(!i, "Replace exitBeforeEnter with mode='wait'");
  const a =
      (0, Ed.useContext)(layoutContext).forceRender ||
      (function () {
        const e = Ad(),
          [t, n] = (0, Ld.useState)(0),
          s = (0, Ld.useCallback)(() => {
            e.current && n(t + 1);
          }, [t]);
        return [(0, Ld.useCallback)(() => Wo.postRender(s), [s]), t];
      })()[0],
    l = Ad(),
    c = (function (e) {
      const t = [];
      return (
        Ed.Children.forEach(e, (e) => {
          (0, Ed.isValidElement)(e) && t.push(e);
        }),
        t
      );
    })(e);
  let u = c;
  const d = (0, Ed.useRef)(new Map()).current,
    p = (0, Ed.useRef)(u),
    f = (0, Ed.useRef)(new Map()).current,
    h = (0, Ed.useRef)(true);
  var m;
  if (
    (dynamicUseEffect(() => {
      (h.current = false),
        (function (e, t) {
          e.forEach((e) => {
            const n = Hd(e);
            t.set(n, e);
          });
        })(c, f),
        (p.current = u);
    }),
    (m = () => {
      (h.current = true), f.clear(), d.clear();
    }),
    (0, Id.useEffect)(() => () => m(), []),
    h.current)
  )
    return _d.createElement(
      _d.Fragment,
      null,
      u.map((e) =>
        _d.createElement(
          Dd,
          {
            key: Hd(e),
            isPresent: true,
            initial: !!n && undefined,
            presenceAffectsLayout: o,
            mode: r,
          },
          e
        )
      )
    );
  u = [...u];
  const g = p.current.map(Hd),
    x = c.map(Hd),
    b = g.length;
  for (let e = 0; e < b; e++) {
    const t = g[e];
    -1 !== x.indexOf(t) || d.has(t) || d.set(t, undefined);
  }
  return (
    "wait" === r && d.size && (u = []),
    d.forEach((e, n) => {
      if (-1 !== x.indexOf(n)) return;
      const i = f.get(n);
      if (!i) return;
      const h = g.indexOf(n);
      let m = e;
      if (!m) {
        const e = () => {
          d.delete(n);
          const e = Array.from(f.keys()).filter((e) => !x.includes(e));
          if (
            (e.forEach((e) => f.delete(e)),
            (p.current = c.filter((t) => {
              const s = Hd(t);
              return s === n || e.includes(s);
            })),
            !d.size)
          ) {
            if (false === l.current) return;
            a(), s && s();
          }
        };
        (m = _d.createElement(
          Dd,
          {
            key: Hd(i),
            isPresent: false,
            onExitComplete: e,
            custom: t,
            presenceAffectsLayout: o,
            mode: r,
          },
          i
        )),
          d.set(n, m);
      }
      u.splice(h, 0, m);
    }),
    (u = u.map((e) => {
      const t = e.key;
      return d.has(t)
        ? e
        : _d.createElement(
            Dd,
            {
              key: Hd(e),
              isPresent: true,
              presenceAffectsLayout: o,
              mode: r,
            },
            e
          );
    })),
    _d.createElement(
      _d.Fragment,
      null,
      d.size ? u : u.map((e) => (0, Ed.cloneElement)(e))
    )
  );
};
export function zd(e) {
  const t = No(() => Bl(e)),
    { isStatic: n } = (0, Ud.useContext)(pagePointContext);
  if (n) {
    const [, n] = (0, Ud.useState)(e);
    (0, Ud.useEffect)(() => t.on("change", n), []);
  }
  return t;
}
export function $d(...e) {
  const t = !Array.isArray(e[0]),
    n = t ? 0 : -1,
    s = e[0 + n],
    i = e[1 + n],
    o = e[2 + n],
    r = e[3 + n],
    a = Aa(i, o, {
      mixer:
        ((l = o[0]),
        ((e) => e && "object" == typeof e && e.mix)(l) ? l.mix : undefined),
      ...r,
    });
  var l;
  return t ? a(s) : a;
}
export function qd(e, t, n) {
  var s;
  if ("string" == typeof e) {
    let i = document;
    t &&
      (Er(Boolean(t.current), "Scope provided, but no element detected."),
      (i = t.current)),
      n
        ? ((null !== (s = n[e]) && undefined !== s) ||
            (n[e] = i.querySelectorAll(e)),
          (e = n[e]))
        : (e = i.querySelectorAll(e));
  } else e instanceof Element && (e = [e]);
  return Array.from(e || []);
}
export var Qd = class extends Al {
  constructor() {
    super(...arguments), (this.members = []), (this.transforms = new Set());
  }
  add(e) {
    let t;
    dimensionalPropertiesSet.has(e)
      ? (this.transforms.add(e), (t = "transform"))
      : e.startsWith("origin") ||
        Gi(e) ||
        "willChange" === e ||
        (t = generateSlug(e)),
      t && (_l(this.members, t), this.update());
  }
  remove(e) {
    dimensionalPropertiesSet.has(e)
      ? (this.transforms.delete(e),
        this.transforms.size || El(this.members, "transform"))
      : El(this.members, generateSlug(e)),
      this.update();
  }
  update() {
    this.set(this.members.length ? this.members.join(", ") : "auto");
  }
};
export var Gd = il(() => undefined !== window.ScrollTimeline);
export var Zd = class {
  constructor(e) {
    this.animations = e.filter(Boolean);
  }
  then(e, t) {
    return Promise.all(this.animations).then(e).catch(t);
  }
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, t) {
    for (let n = 0; n < this.animations.length; n++) this.animations[n][e] = t;
  }
  attachTimeline(e) {
    const t = this.animations.map((t) => {
      if (!Gd() || !t.attachTimeline)
        return (
          t.pause(),
          (function (e, t) {
            let n;
            const s = () => {
              const { currentTime: s } = t,
                i = (null === s ? 0 : s.value) / 100;
              n !== i && e(i), (n = i);
            };
            return Wo.update(s, true), () => Ko(s);
          })((e) => {
            t.time = t.duration * e;
          }, e)
        );
      t.attachTimeline(e);
    });
    return () => {
      t.forEach((e, t) => {
        e && e(), this.animations[t].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get duration() {
    let e = 0;
    for (let t = 0; t < this.animations.length; t++)
      e = Math.max(e, this.animations[t].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((t) => t[e]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  stop() {
    this.runAll("stop");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
};
export function Wd(e) {
  const t = {
      presenceContext: null,
      props: {},
      visualState: {
        renderState: {
          transform: {},
          transformOrigin: {},
          style: {},
          vars: {},
          attrs: {},
        },
        latestValues: {},
      },
    },
    n = vu(e)
      ? new kd(t, { enableHardwareAcceleration: false })
      : new wd(t, { enableHardwareAcceleration: true });
  n.mount(e), hd.set(e, n);
}
export function Kd(e, t = 100) {
  const n = Wa({ keyframes: [0, t], ...e }),
    s = Math.min(tl(n), el);
  return {
    type: "keyframes",
    ease: (e) => n.next(s * e).value / t,
    duration: Pr(s),
  };
}
export function Yd(e, t, n, s) {
  var i;
  return "number" == typeof t
    ? t
    : t.startsWith("-") || t.startsWith("+")
    ? Math.max(0, e + parseFloat(t))
    : "<" === t
    ? n
    : null !== (i = s.get(t)) && undefined !== i
    ? i
    : e;
}
export var Xd = (e, t, n) => {
  const s = t - e;
  return ((((n - e) % s) + s) % s) + e;
};
export function Jd(e, t) {
  return zr(e) ? e[Xd(0, e.length, t)] : e;
}
export function ep(e, t, n, s, i, o) {
  !(function (e, t, n) {
    for (let s = 0; s < e.length; s++) {
      const i = e[s];
      i.at > t && i.at < n && (El(e, i), s--);
    }
  })(e, i, o);
  for (let r = 0; r < t.length; r++)
    e.push({ value: t[r], at: aa(i, o, s[r]), easing: Jd(n, r) });
}
export function tp(e, t) {
  return e.at === t.at
    ? null === e.value
      ? 1
      : null === t.value
      ? -1
      : 0
    : e.at - t.at;
}
export var np = "easeInOut";
export function sp(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
export function ip(e, t) {
  return t[e] || (t[e] = []), t[e];
}
export function op(e) {
  return Array.isArray(e) ? e : [e];
}
export function rp(e, t) {
  return e[t] ? { ...e, ...e[t] } : { ...e };
}
export var ap = (e) => "number" == typeof e;
export var lp = (e) => e.every(ap);
export function cp(e, t, n, s) {
  const i = qd(e, s),
    o = i.length;
  Er(Boolean(o), "No valid element provided.");
  const r = [];
  for (let e = 0; e < o; e++) {
    const s = i[e];
    hd.has(s) || Wd(s);
    const a = hd.get(s),
      l = { ...n };
    "function" == typeof l.delay && (l.delay = l.delay(e, o)),
      r.push(...Hl(a, { ...t, transition: l }, {}));
  }
  return new Zd(r);
}
export function up(e, t, n) {
  const s = [],
    i = (function (e, { defaultTransition: t = {}, ...n } = {}, s) {
      const i = t.duration || 0.3,
        o = new Map(),
        r = new Map(),
        a = {},
        l = new Map();
      let c = 0,
        u = 0,
        d = 0;
      for (let n = 0; n < e.length; n++) {
        const o = e[n];
        if ("string" == typeof o) {
          l.set(o, u);
          continue;
        }
        if (!Array.isArray(o)) {
          l.set(o.name, Yd(u, o.at, c, l));
          continue;
        }
        let [p, f, h = {}] = o;
        undefined !== h.at && (u = Yd(u, h.at, c, l));
        let m = 0;
        const g = (e, n, s, o = 0, r = 0) => {
          const a = op(e),
            { delay: l = 0, times: c = Ta(a), type: p = "keyframes", ...f } = n;
          let { ease: h = t.ease || "easeOut", duration: g } = n;
          const x = "function" == typeof l ? l(o, r) : l,
            b = a.length;
          if (b <= 2 && "spring" === p) {
            let e = 100;
            if (2 === b && lp(a)) {
              const t = a[1] - a[0];
              e = Math.abs(t);
            }
            const t = { ...f };
            undefined !== g && (t.duration = Lr(g));
            const n = Kd(t, e);
            (h = n.ease), (g = n.duration);
          }
          null != g || (g = i);
          const y = u + x,
            v = y + g;
          1 === c.length && 0 === c[0] && (c[1] = 1);
          const w = c.length - a.length;
          w > 0 && Ba(c, w),
            1 === a.length && a.unshift(null),
            ep(s, a, h, c, y, v),
            (m = Math.max(x + g, m)),
            (d = Math.max(v, d));
        };
        if (zi(p)) g(f, h, ip("default", sp(p, r)));
        else {
          const e = qd(p, s, a),
            t = e.length;
          for (let n = 0; n < t; n++) {
            const s = sp(e[n], r);
            for (const e in f) g(f[e], rp(h, e), ip(e, s), n, t);
          }
        }
        (c = u), (u += m);
      }
      return (
        r.forEach((e, s) => {
          for (const i in e) {
            const r = e[i];
            r.sort(tp);
            const a = [],
              l = [],
              c = [];
            for (let e = 0; e < r.length; e++) {
              const { at: t, value: n, easing: s } = r[e];
              a.push(n), l.push(Ea(0, d, t)), c.push(s || "easeOut");
            }
            0 !== l[0] && (l.unshift(0), a.unshift(a[0]), c.unshift(np)),
              1 !== l[l.length - 1] && (l.push(1), a.push(null)),
              o.has(s) || o.set(s, { keyframes: {}, transition: {} });
            const u = o.get(s);
            (u.keyframes[i] = a),
              (u.transition[i] = {
                ...t,
                duration: d,
                ease: c,
                times: l,
                ...n,
              });
          }
        }),
        o
      );
    })(e, t, n);
  return (
    i.forEach(({ keyframes: e, transition: t }, n) => {
      let i;
      (i = zi(n) ? wu(n, e.default, t.default) : cp(n, e, t)), s.push(i);
    }),
    new Zd(s)
  );
}
export var dp;
export var pp = function (e, t, n) {
  let s;
  var i;
  return (
    (i = e),
    (s =
      Array.isArray(i) && Array.isArray(i[0])
        ? up(e, t, dp)
        : (function (e) {
            return "object" == typeof e && !Array.isArray(e);
          })(t)
        ? cp(e, t, n, dp)
        : wu(e, t, n)),
    dp && dp.animations.push(s),
    s
  );
};
export var hp = { some: 0, all: 1 };
export function mp(e, { root: t, margin: n, amount: s, once: i = false } = {}) {
  const [o, r] = (0, fp.useState)(false);
  return (
    (0, fp.useEffect)(() => {
      if (!e.current || (i && o)) return;
      const a = { root: (t && t.current) || undefined, margin: n, amount: s };
      return (function (e, t, { root: n, margin: s, amount: i = "some" } = {}) {
        const o = qd(e),
          r = new WeakMap(),
          a = new IntersectionObserver(
            (e) => {
              e.forEach((e) => {
                const n = r.get(e.target);
                if (e.isIntersecting !== Boolean(n))
                  if (e.isIntersecting) {
                    const n = t(e);
                    "function" == typeof n
                      ? r.set(e.target, n)
                      : a.unobserve(e.target);
                  } else n && (n(e), r.delete(e.target));
              });
            },
            {
              root: n,
              rootMargin: s,
              threshold: "number" == typeof i ? i : hp[i],
            }
          );
        return o.forEach((e) => a.observe(e)), () => a.disconnect();
      })(e.current, () => (r(true), i ? undefined : () => r(false)), a);
    }, [t, e, n, i, s]),
    o
  );
}
export var componentContriller = () => new ComponentController();
Object.defineProperty(CompPlainToggleButton, "displayName", {
  value: "uikit/PlainToggleButton",
});
export var Up, zp, $p, qp, Qp;
export var Gp = CompPlainToggleButton;
export var Zp = Gp;
((Qp = Up || (Up = {})).HEX = "HEX"),
  (Qp.RGB = "RGB"),
  (Qp.HSL = "HSL"),
  (Qp.CIELab = "CIELab"),
  (Qp.CMYK = "CMYK"),
  (function (e) {
    (e.ANALOGOUS = "ANALOGOUS"),
      (e.COMPLEMENTARY = "COMPLEMENTARY"),
      (e.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY"),
      (e.TRIADIC = "TRIADIC"),
      (e.TETRADIC = "TETRADIC"),
      (e.SQUARE = "SQUARE");
  })(zp || (zp = {})),
  (function (e) {
    (e.ADDITIVE = "ADDITIVE"), (e.SUBTRACTIVE = "SUBTRACTIVE");
  })($p || ($p = {})),
  (function (e) {
    (e.black = "#000000"),
      (e.silver = "#C0C0C0"),
      (e.gray = "#808080"),
      (e.white = "#FFFFFF"),
      (e.maroon = "#800000"),
      (e.red = "#FF0000"),
      (e.purple = "#800080"),
      (e.fuchsia = "#FF00FF"),
      (e.green = "#008000"),
      (e.lime = "#00FF00"),
      (e.olive = "#808000"),
      (e.yellow = "#FFFF00"),
      (e.navy = "#000080"),
      (e.blue = "#0000FF"),
      (e.teal = "#008080"),
      (e.aqua = "#00FFFF"),
      (e.orange = "#FFA500"),
      (e.aliceblue = "#F0F8FF"),
      (e.antiquewhite = "#FAEBD7"),
      (e.aquamarine = "#7FFFD4"),
      (e.azure = "#F0FFFF"),
      (e.beige = "#F5F5DC"),
      (e.bisque = "#FFE4C4"),
      (e.blanchedalmond = "#FFEBCD"),
      (e.blueviolet = "#8A2BE2"),
      (e.brown = "#A52A2A"),
      (e.burlywood = "#DEB887"),
      (e.cadetblue = "#5F9EA0"),
      (e.chartreuse = "#7FFF00"),
      (e.chocolate = "#D2691E"),
      (e.coral = "#FF7F50"),
      (e.cornflowerblue = "#6495ED"),
      (e.cornsilk = "#FFF8DC"),
      (e.crimson = "#DC143C"),
      (e.cyan = "#00FFFF"),
      (e.darkblue = "#00008B"),
      (e.darkcyan = "#008B8B"),
      (e.darkgoldenrod = "#B8860B"),
      (e.darkgray = "#A9A9A9"),
      (e.darkgreen = "#006400"),
      (e.darkgrey = "#A9A9A9"),
      (e.darkkhaki = "#BDB76B"),
      (e.darkmagenta = "#8B008B"),
      (e.darkolivegreen = "#556B2F"),
      (e.darkorange = "#FF8C00"),
      (e.darkorchid = "#9932CC"),
      (e.darkred = "#8B0000"),
      (e.darksalmon = "#E9967A"),
      (e.darkseagreen = "#8FBC8F"),
      (e.darkslateblue = "#483D8B"),
      (e.darkslategray = "#2F4F4F"),
      (e.darkslategrey = "#2F4F4F"),
      (e.darkturquoise = "#00CED1"),
      (e.darkviolet = "#9400D3"),
      (e.deeppink = "#FF1493"),
      (e.deepskyblue = "#00BFFF"),
      (e.dimgray = "#696969"),
      (e.dimgrey = "#696969"),
      (e.dodgerblue = "#1E90FF"),
      (e.firebrick = "#B22222"),
      (e.floralwhite = "#FFFAF0"),
      (e.forestgreen = "#228B22"),
      (e.gainsboro = "#DCDCDC"),
      (e.ghostwhite = "#F8F8FF"),
      (e.gold = "#FFD700"),
      (e.goldenrod = "#DAA520"),
      (e.greenyellow = "#ADFF2F"),
      (e.grey = "#808080"),
      (e.honeydew = "#F0FFF0"),
      (e.hotpink = "#FF69B4"),
      (e.indianred = "#CD5C5C"),
      (e.indigo = "#4B0082"),
      (e.ivory = "#FFFFF0"),
      (e.khaki = "#F0E68C"),
      (e.lavender = "#E6E6FA"),
      (e.lavenderblush = "#FFF0F5"),
      (e.lawngreen = "#7CFC00"),
      (e.lemonchiffon = "#FFFACD"),
      (e.lightblue = "#ADD8E6"),
      (e.lightcoral = "#F08080"),
      (e.lightcyan = "#E0FFFF"),
      (e.lightgoldenrodyellow = "#FAFAD2"),
      (e.lightgray = "#D3D3D3"),
      (e.lightgreen = "#90EE90"),
      (e.lightgrey = "#D3D3D3"),
      (e.lightpink = "#FFB6C1"),
      (e.lightsalmon = "#FFA07A"),
      (e.lightseagreen = "#20B2AA"),
      (e.lightskyblue = "#87CEFA"),
      (e.lightslategray = "#778899"),
      (e.lightslategrey = "#778899"),
      (e.lightsteelblue = "#B0C4DE"),
      (e.lightyellow = "#FFFFE0"),
      (e.limegreen = "#32CD32"),
      (e.linen = "#FAF0E6"),
      (e.magenta = "#FF00FF"),
      (e.mediumaquamarine = "#66CDAA"),
      (e.mediumblue = "#0000CD"),
      (e.mediumorchid = "#BA55D3"),
      (e.mediumpurple = "#9370DB"),
      (e.mediumseagreen = "#3CB371"),
      (e.mediumslateblue = "#7B68EE"),
      (e.mediumspringgreen = "#00FA9A"),
      (e.mediumturquoise = "#48D1CC"),
      (e.mediumvioletred = "#C71585"),
      (e.midnightblue = "#191970"),
      (e.mintcream = "#F5FFFA"),
      (e.mistyrose = "#FFE4E1"),
      (e.moccasin = "#FFE4B5"),
      (e.navajowhite = "#FFDEAD"),
      (e.oldlace = "#FDF5E6"),
      (e.olivedrab = "#6B8E23"),
      (e.orangered = "#FF4500"),
      (e.orchid = "#DA70D6"),
      (e.palegoldenrod = "#EEE8AA"),
      (e.palegreen = "#98FB98"),
      (e.paleturquoise = "#AFEEEE"),
      (e.palevioletred = "#DB7093"),
      (e.papayawhip = "#FFEFD5"),
      (e.peachpuff = "#FFDAB9"),
      (e.peru = "#CD853F"),
      (e.pink = "#FFC0CB"),
      (e.plum = "#DDA0DD"),
      (e.powderblue = "#B0E0E6"),
      (e.rosybrown = "#BC8F8F"),
      (e.royalblue = "#4169E1"),
      (e.saddlebrown = "#8B4513"),
      (e.salmon = "#FA8072"),
      (e.sandybrown = "#F4A460"),
      (e.seagreen = "#2E8B57"),
      (e.seashell = "#FFF5EE"),
      (e.sienna = "#A0522D"),
      (e.skyblue = "#87CEEB"),
      (e.slateblue = "#6A5ACD"),
      (e.slategray = "#708090"),
      (e.slategrey = "#708090"),
      (e.snow = "#FFFAFA"),
      (e.springgreen = "#00FF7F"),
      (e.steelblue = "#4682B4"),
      (e.tan = "#D2B48C"),
      (e.thistle = "#D8BFD8"),
      (e.tomato = "#FF6347"),
      (e.turquoise = "#40E0D0"),
      (e.violet = "#EE82EE"),
      (e.wheat = "#F5DEB3"),
      (e.whitesmoke = "#F5F5F5"),
      (e.yellowgreen = "#9ACD32"),
      (e.rebeccapurple = "#663399");
  })(qp || (qp = {}));
export var Yp;
export var Xp = Object.keys(qp);
export var Jp = {
  HEX: ["R", "G", "B", "A"],
  RGB: ["R", "G", "B", "A"],
  HSL: ["H", "S", "L", "A"],
  CIELab: ["L", "a", "b", "A"],
  CMYK: ["C", "M", "Y", "K", "A"],
};
export var ef = {
  BGR: Up.RGB,
  ABGR: Up.RGB,
  HLS: Up.HSL,
  AHLS: Up.HSL,
  LAB: Up.CIELab,
  ALAB: Up.CIELab,
  CKMY: Up.CMYK,
  ACKMY: Up.CMYK,
};
!(function (e) {
  (e.NUMBER = "number"), (e.BOOLEAN = "boolean");
})(Yp || (Yp = {}));
export var tf, nf, sf;
export var of = {
  [Up.HEX]:
    /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i,
  [Up.RGB]:
    /^rgba?\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/,
  [Up.HSL]:
    /^hsla?\s*\(\s*(?:(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*,\s*((?:\d*\.)?\d+)%\s*,\s*((?:\d*\.)?\d+)%(?:\s*,\s*((?:\d*\.)?\d+))?|(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*((?:\d*\.)?\d+)%\s*((?:\d*\.)?\d+)%(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/,
  [Up.CIELab]:
    /^lab\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*(-?(?:\d*\.)?\d+%?)\s*(-?(?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/,
  [Up.CMYK]:
    /^(?:device-cmyk|cmyk)\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/,
};
export var rf = /^(-?(?:\d*\.)?\d+)((?:deg|grad|rad|turn)?)$/;
export var af = /^(-?\d+(?:\.\d+)?|-?\.\d+)%$/;
export var lf = /^0x([a-f\d]{1,2})$/i;
export var cf = /\{(\d+)\}/g;
export var uf = /,( +|\d+)/g;
export var df = / +/;
!(function (e) {
  (e.NONE = "none"),
    (e.DEGREES = "deg"),
    (e.GRADIANS = "grad"),
    (e.RADIANS = "rad"),
    (e.TURNS = "turn");
})(tf || (tf = {})),
  (function (e) {
    (e.NONE = "none"), (e.PERCENT = "percent");
  })(nf || (nf = {})),
  (function (e) {
    (e.DEVICE_CMYK = "device-cmyk"), (e.CMYK = "cmyk");
  })(sf || (sf = {}));
export var pf = {
  decimals: 6,
  legacyCSS: false,
  spacesAfterCommas: false,
  anglesUnit: tf.NONE,
  rgbUnit: nf.NONE,
  labUnit: nf.NONE,
  cmykUnit: nf.PERCENT,
  alphaUnit: nf.NONE,
  cmykFunction: sf.DEVICE_CMYK,
};
export var ff = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
export var hf = (e) => +`${e}`.replace(af, "$1");
export var mf = (e) => (af.test(`${e}`) ? hf(e) : Math.min(+e, 100));
export var gf = (e) => (1 === e.length && (e += e), parseInt(e, 16));
export var xf = (e) => {
  const t = kf(e, 0).toString(16).toUpperCase();
  return 1 === t.length ? `0x0${t}` : `0x${t}`;
};
export var bf = (e, t = false) =>
  !t && af.test(e)
    ? Math.min((255 * hf(e)) / 100, 255)
    : lf.test(e)
    ? (3 === e.length && (e += e.slice(-1)), t ? kf(e) / 255 : kf(e))
    : Math.min(+e, t ? 1 : 255);
export var yf = (e) =>
  af.test(e) ? Cf((125 * hf(e)) / 100, -125, 125) : Cf(+e, -125, 125);
export var vf = (e) => Math.min(af.test(e) ? hf(e) / 100 : +e, 1);
export var wf = (e) => [...e].sort().join("").toUpperCase();
export var kf = (e, t = 6) => {
  const n = Math.pow(10, t);
  return Math.round(+e * n) / n;
};
export var Cf = (e, t, n) => Math.max(t, Math.min(e, n));
export var jf = (e) => {
  if ("string" == typeof e) {
    const t = e.match(rf),
      n = +t[1];
    switch (t[2]) {
      case tf.RADIANS:
        e = kf((180 * n) / Math.PI);
        break;
      case tf.TURNS:
        e = kf(360 * n);
        break;
      case tf.GRADIANS:
        e = kf(0.9 * n);
        break;
      case tf.DEGREES:
      default:
        e = n;
    }
  }
  return (e > 360 || e < 0) && (e -= 360 * Math.floor(e / 360)), e;
};
export var Sf = (e, ...t) => {
  const n = [],
    s = [],
    i = [],
    o = [],
    r = [],
    a = [],
    l = Object.values(tf),
    c = Object.values(nf),
    u = Object.values(sf),
    d = { legacyCSS: 0, spacesAfterCommas: 0, cmykFunction: 0 };
  for (const e of t)
    if ("string" == typeof e) {
      if ((n.push(e), e.includes(","))) {
        d.legacyCSS++;
        const t = e.match(uf);
        1 === new Set(t).size &&
          df.test(t[0].slice(1)) &&
          d.spacesAfterCommas++;
      }
      if (e.match(of.HSL)) {
        const t = e.match(of.HSL),
          n = t[1] || t[5],
          i = t[8],
          o = n.match(rf)[2];
        s.push("" === o ? tf.NONE : o), a.push(af.test(i));
        continue;
      }
      if (of.RGB.test(e)) {
        const t = e.match(of.RGB),
          n = t[1] || t[5],
          s = t[2] || t[6],
          o = t[3] || t[7],
          r = t[8];
        i.push(af.test(n) && af.test(s) && af.test(o)), a.push(af.test(r));
        continue;
      }
      if (of.CIELab.test(e)) {
        const t = e.match(of.CIELab),
          n = t[1],
          s = t[2],
          i = t[3],
          r = t[4];
        o.push(af.test(n) && af.test(s) && af.test(i)), a.push(af.test(r));
        continue;
      }
      if (e.match(of.CMYK)) {
        const t = e.match(of.CMYK),
          n = t[1] || t[6],
          s = t[2] || t[7],
          i = t[3] || t[8],
          o = t[4] || t[9],
          l = t[10];
        r.push(af.test(n) && af.test(s) && af.test(i) && af.test(o)),
          e.startsWith("cmyk") && d.cmykFunction++,
          a.push(af.test(l));
      }
    }
  return {
    decimals: typeof e.decimals === Yp.NUMBER ? e.decimals : pf.decimals,
    legacyCSS:
      typeof e.legacyCSS === Yp.BOOLEAN
        ? e.legacyCSS
        : Boolean(n.length && d.legacyCSS === n.length) || pf.legacyCSS,
    spacesAfterCommas:
      typeof e.spacesAfterCommas === Yp.BOOLEAN
        ? e.spacesAfterCommas
        : Boolean(n.length && d.spacesAfterCommas === n.length) ||
          pf.spacesAfterCommas,
    anglesUnit:
      e.anglesUnit && l.includes(e.anglesUnit)
        ? e.anglesUnit
        : 1 === new Set(s).size
        ? s[0]
        : pf.anglesUnit,
    rgbUnit:
      e.rgbUnit && c.includes(e.rgbUnit)
        ? e.rgbUnit
        : 1 === new Set(i).size && i[0]
        ? nf.PERCENT
        : pf.rgbUnit,
    labUnit:
      e.labUnit && c.includes(e.labUnit)
        ? e.labUnit
        : 1 === new Set(o).size && o[0]
        ? nf.PERCENT
        : pf.labUnit,
    cmykUnit:
      e.cmykUnit && c.includes(e.cmykUnit)
        ? e.cmykUnit
        : 1 !== new Set(r).size || r[0]
        ? pf.cmykUnit
        : nf.NONE,
    alphaUnit:
      e.alphaUnit && c.includes(e.alphaUnit)
        ? e.alphaUnit
        : 1 === new Set(a).size && a[0]
        ? nf.PERCENT
        : pf.alphaUnit,
    cmykFunction:
      e.cmykFunction && u.includes(e.cmykFunction)
        ? e.cmykFunction
        : r.length && r.length === d.cmykFunction
        ? sf.CMYK
        : pf.cmykFunction,
  };
};
export var _f = (e) => `${e}` in $p;
export var Ef = [
  [0.4360747, 0.3850649, 0.1430804],
  [0.2225045, 0.7168786, 0.0606169],
  [0.0139322, 0.0971045, 0.7141733],
];
export var Lf = [
  [3.1338561, -1.6168667, -0.4906146],
  [-0.9787684, 1.9161415, 0.033454],
  [0.0719453, -0.2289914, 1.4052427],
];
export var Pf = Ef.map((e) => e.reduce((e, t) => e + t, 0));
export var Af = (e, t, n) => (
  n < 0 && (n += 6),
  n >= 6 && (n -= 6),
  kf(
    n < 1
      ? 255 * ((t - e) * n + e)
      : n < 3
      ? 255 * t
      : n < 4
      ? 255 * ((t - e) * (4 - n) + e)
      : 255 * e
  )
);
export var Bf = (e) =>
  e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
export var Tf = (e) =>
  e <= 0.0031308 ? 12.92 * e : 1.055 * e ** (1 / 2.4) - 0.055;
export var Mf = (e, t, n, s) => {
  const i = [0, 0, 0],
    o = [e, t, n];
  return (
    s.forEach((e, t) => {
      e.forEach((e, n) => {
        i[t] += e * o[n];
      });
    }),
    i
  );
};
export var Of = (e, t, n) => {
  t /= 100;
  const s = (n /= 100) <= 0.5 ? n * (t + 1) : n + t - n * t,
    i = 2 * n - s;
  return { R: Af(i, s, 2 + (e /= 60)), G: Af(i, s, e), B: Af(i, s, e - 2) };
};
export var Rf = (e, t, n, s = 1) => {
  (e /= 255), (t /= 255), (n /= 255), (s = Math.min(s, 1));
  const i = Math.max(e, t, n),
    o = Math.min(e, t, n),
    r = i - o;
  let a = 0,
    l = 0;
  const c = (i + o) / 2;
  if (0 !== r) {
    switch (i) {
      case e:
        a = ((t - n) / r) % 6;
        break;
      case t:
        a = (n - e) / r + 2;
        break;
      case n:
        a = (e - t) / r + 4;
    }
    (a = kf(60 * a)), a < 0 && (a += 360), (l = r / (1 - Math.abs(2 * c - 1)));
  }
  return { H: a, S: kf(100 * l), L: kf(100 * c), A: s };
};
export var Vf = (e, t, n) => {
  const s = [e / 255, t / 255, n / 255].map(Bf),
    i = Mf(s[0], s[1], s[2], Ef),
    o = ((e, t, n) => {
      const s = (e) =>
          e > (6 / 29) ** 3 ? Math.cbrt(e) : e / (3 * (6 / 29) ** 2) + 4 / 29,
        i = s(e / Pf[0]),
        o = s(t / Pf[1]);
      return [116 * o - 16, 500 * (i - o), 200 * (o - s(n / Pf[2]))];
    })(i[0], i[1], i[2]);
  return { L: o[0], a: o[1], b: o[2] };
};
export var Df = (e, t, n) => {
  const s = ((e, t, n) => {
      const s = (e) => (e > 6 / 29 ? e ** 3 : 3 * (6 / 29) ** 2 * (e - 4 / 29)),
        i = (e + 16) / 116,
        o = t / 500,
        r = n / 200;
      return [Pf[0] * s(i + o), Pf[1] * s(i), Pf[2] * s(i - r)];
    })(e, t, n),
    i = Mf(s[0], s[1], s[2], Lf).map(Tf);
  return {
    R: Cf(255 * i[0], 0, 255),
    G: Cf(255 * i[1], 0, 255),
    B: Cf(255 * i[2], 0, 255),
  };
};
export var Ff = (e, t, n, s) => ({
  R: kf(255 * (1 - e) * (s = 1 - s)),
  G: kf(255 * (1 - t) * s),
  B: kf(255 * (1 - n) * s),
});
export var If = (e, t, n) => {
  (e /= 255), (t /= 255), (n /= 255);
  const s = 1 - Math.max(e, t, n),
    i = 1 - s,
    o = i && (i - t) / i,
    r = i && (i - n) / i;
  return {
    C: kf(100 * (i && (i - e) / i)),
    M: kf(100 * o),
    Y: kf(100 * r),
    K: kf(100 * s),
  };
};
export var Hf = (e, t) => {
  if ((e < 0 && (e += 360), e > 360 && (e -= 360), 360 === e || 0 === e))
    return e;
  const n = [
      [0, 120],
      [120, 180],
      [180, 240],
      [240, 360],
    ],
    s = [
      [0, 60],
      [60, 120],
      [120, 240],
      [240, 360],
    ],
    i = t ? s : n;
  let o = 0,
    r = 0,
    a = 0,
    l = 0;
  return (
    (t ? n : s).find(
      (t, n) =>
        e >= t[0] &&
        e < t[1] &&
        ((o = t[0]), (r = t[1]), (a = i[n][0]), (l = i[n][1]), true)
    ),
    a + ((l - a) / (r - o)) * (e - o)
  );
};
export var Nf = (e) => (e ? ", " : ",");
export var Uf = (e, t) => {
  const n = wf(Object.keys(e));
  return Jp[ef[n]].reduce((n, s, i) => {
    const o = e[s];
    return undefined !== o && n.push(t(o, i)), n;
  }, []);
};
export var zf = (e, t) => e.replace(cf, (e, n) => `${t[+n - 1]}`);
export var $f = (e, t, n = false) => {
  const { alphaUnit: s, legacyCSS: i, decimals: o } = t;
  return s !== nf.PERCENT || (i && !n) ? kf(e, o) : `${kf(100 * e, o)}%`;
};
export var qf = {
  [Up.HEX]: (e) => {
    const t = Uf(e, (e) =>
        ((e) => {
          let t = kf(e, 0).toString(16).toUpperCase();
          return 1 === t.length && (t = `0${t}`), t;
        })(kf(e))
      ),
      n = 4 === t.length ? "#{1}{2}{3}{4}" : "#{1}{2}{3}";
    return zf(n, t);
  },
  [Up.RGB]: (e, t) => {
    const { decimals: n, legacyCSS: s, spacesAfterCommas: i, rgbUnit: o } = t,
      r = Nf(i),
      a = Uf(e, (e, s) => {
        return o === nf.PERCENT && s < 3
          ? `${((i = e), (r = n), kf((i / 255) * 100, r))}%`
          : 3 === s
          ? $f(e, t)
          : kf(e, n);
        var i, r;
      }),
      l = s
        ? 4 === a.length
          ? `rgba({1}${r}{2}${r}{3}${r}{4})`
          : `rgb({1}${r}{2}${r}{3})`
        : 4 === a.length
        ? "rgb({1} {2} {3} / {4})"
        : "rgb({1} {2} {3})";
    return zf(l, a);
  },
  [Up.HSL]: (e, t) => {
    const {
        decimals: n,
        legacyCSS: s,
        spacesAfterCommas: i,
        anglesUnit: o,
      } = t,
      r = Nf(i),
      a = Uf(e, (e, s) =>
        0 === s && o !== tf.NONE
          ? `${kf(
              ((e, t) => {
                let n;
                switch (t) {
                  case tf.RADIANS:
                    n = kf((e * Math.PI) / 180);
                    break;
                  case tf.TURNS:
                    n = kf(e / 360);
                    break;
                  case tf.GRADIANS:
                    n = kf((10 / 9) * e);
                    break;
                  case tf.DEGREES:
                  case tf.NONE:
                  default:
                    n = e;
                }
                return n;
              })(e, o),
              n
            )}${o}`
          : 3 === s
          ? $f(e, t)
          : kf(e, n)
      ),
      l = s
        ? 4 === a.length
          ? `hsla({1}${r}{2}%${r}{3}%${r}{4})`
          : `hsl({1}${r}{2}%${r}{3}%)`
        : 4 === a.length
        ? "hsl({1} {2}% {3}% / {4})"
        : "hsl({1} {2}% {3}%)";
    return zf(l, a);
  },
  [Up.CIELab]: (e, t) => {
    const { decimals: n, labUnit: s } = t,
      i = Uf(e, (e, i) => {
        if (0 === i) {
          const t = kf(mf(e), n);
          return s === nf.PERCENT ? `${t}%` : `${t}`;
        }
        return i < 3
          ? s === nf.PERCENT
            ? `${((o = e), (r = n), kf((o / 125) * 100, r))}%`
            : kf(e, n)
          : $f(e, t, true);
        var o, r;
      }),
      o = 4 === i.length ? "lab({1} {2} {3} / {4})" : "lab({1} {2} {3})";
    return zf(o, i);
  },
  [Up.CMYK]: (e, t) => {
    const {
        decimals: n,
        legacyCSS: s,
        spacesAfterCommas: i,
        cmykUnit: o,
        cmykFunction: r,
      } = t,
      a = Nf(i),
      l = Uf(e, (e, s) =>
        o === nf.PERCENT && s < 4
          ? `${kf(e, n)}%`
          : 4 === s
          ? $f(e, t)
          : kf(e / 100, n)
      ),
      c = s
        ? 5 === l.length
          ? `${r}({1}${a}{2}${a}{3}${a}{4}${a}{5})`
          : `${r}({1}${a}{2}${a}{3}${a}{4})`
        : 5 === l.length
        ? `${r}({1} {2} {3} {4} / {5})`
        : `${r}({1} {2} {3} {4})`;
    return zf(c, l);
  },
};
export var Qf = (e) => (
  "string" == typeof e && (e = af.test(e) ? hf(e) / 100 : +e),
  isNaN(+e) || e > 1 ? 1 : kf(e)
);
export var Gf = (e, t, n) =>
  t.reduce(
    (t, s) => [
      ...t,
      {
        ...e,
        H: n === $p.ADDITIVE ? jf(e.H + s) : jf(Hf(Hf(e.H, false) + s, true)),
      },
    ],
    [{ ...e }]
  );
export var Zf = (e, t) => Gf(e, [30, -30], t);
export var Wf = (e, t) => Gf(e, [180], t);
export var Kf = (e, t) => Gf(e, [150, -150], t);
export var Yf = (e, t) => Gf(e, [120, -120], t);
export var Xf = (e, t) => Gf(e, [60, -120, 180], t);
export var Jf = (e, t) => Gf(e, [90, -90, 180], t);
export var eh = (e) =>
  "string" == typeof e
    ? ((e) => {
        let t;
        if (
          (Object.keys(Up).some((n) => {
            if (of[n].test(e)) return (t = n), true;
          }),
          !t && ~Xp.indexOf(e) && (t = Up.HEX),
          !t)
        )
          throw new Error(
            "The provided string color doesn't have a correct format"
          );
        return t;
      })(e)
    : ((e) => {
        let t,
          n = false;
        const s = wf(Object.keys(e));
        if ((ef[s] && (t = ef[s]), t && t === Up.RGB)) {
          const s = Object.entries(e).some((e) => !lf.test(`${e[1]}`)),
            i = Object.entries(e).some(
              (e) =>
                !(
                  af.test(`${e[1]}`) ||
                  (!lf.test(`${e[1]}`) && !isNaN(+e[1]) && +e[1] <= 255)
                )
            );
          s && i && (n = true), s || (t = Up.HEX);
        }
        if (!t || n)
          throw new Error(
            "The provided color object doesn't have the proper keys or format"
          );
        return t;
      })(e);
export var th = {
  [Up.HEX](e) {
    const t = (~Xp.indexOf(e) ? qp[e] : e).match(of.HEX),
      n = { R: gf(t[1] || t[5]), G: gf(t[2] || t[6]), B: gf(t[3] || t[7]) },
      s = t[4] || t[8];
    return undefined !== s && (n.A = gf(s) / 255), n;
  },
  [Up.RGB](e) {
    const t = e.match(of.RGB),
      n = bf(t[1] || t[5]),
      s = bf(t[2] || t[6]),
      i = bf(t[3] || t[7]),
      o = t[4] || t[8],
      r = { R: Math.min(n, 255), G: Math.min(s, 255), B: Math.min(i, 255) };
    return undefined !== o && (r.A = Qf(o)), r;
  },
  [Up.HSL](e) {
    const t = e.match(of.HSL),
      n = jf(t[1] || t[5]),
      s = mf(t[2] || t[6]),
      i = mf(t[3] || t[7]),
      o = t[4] || t[8],
      r = Of(n, s, i);
    return undefined !== o && (r.A = Qf(o)), r;
  },
  [Up.CIELab](e) {
    const t = e.match(of.CIELab),
      n = mf(t[1]),
      s = yf(t[2]),
      i = yf(t[3]),
      o = t[4],
      r = Df(n, s, i);
    return undefined !== o && (r.A = Qf(o)), r;
  },
  [Up.CMYK](e) {
    const t = e.match(of.CMYK),
      n = vf(t[1] || t[6]),
      s = vf(t[2] || t[7]),
      i = vf(t[3] || t[8]),
      o = vf(t[4] || t[9]),
      r = t[5] || t[10],
      a = Ff(n, s, i, o);
    return undefined !== r && (a.A = Qf(r)), a;
  },
};
export var nh = {
  [Up.HEX](e) {
    const t = { R: bf(`${e.R}`), G: bf(`${e.G}`), B: bf(`${e.B}`) };
    return ff(e, "A") && (t.A = Math.min(bf(`${e.A}`, true), 1)), t;
  },
  [Up.RGB](e) {
    return this.HEX(e);
  },
  [Up.HSL](e) {
    const t = mf(`${e.S}`),
      n = mf(`${e.L}`),
      s = Of(jf(e.H), t, n);
    return ff(e, "A") && (s.A = Qf(e.A)), s;
  },
  [Up.CIELab](e) {
    const t = mf(`${e.L}`),
      n = yf(`${e.a}`),
      s = yf(`${e.b}`),
      i = Df(t, n, s);
    return ff(e, "A") && (i.A = Qf(e.A)), i;
  },
  [Up.CMYK](e) {
    const t = vf(`${e.C}`),
      n = vf(`${e.M}`),
      s = vf(`${e.Y}`),
      i = vf(`${e.K}`),
      o = Ff(t, n, s, i);
    return ff(e, "A") && (o.A = Qf(e.A)), o;
  },
};
export var sh = (e, t = eh(e)) => ("string" == typeof e ? th[t](e) : nh[t](e));
export var ih = {
  [Up.HEX]: (e) => ({ R: xf(e.R), G: xf(e.G), B: xf(e.B) }),
  HEXA(e) {
    const t = ih.HEX(e);
    return (t.A = ff(e, "A") ? xf(255 * e.A) : "0xFF"), t;
  },
  [Up.RGB](e, t) {
    const n = lh(e, t);
    return ff(n, "A") && delete n.A, n;
  },
  RGBA(e, t) {
    const n = ih.RGB(e, t);
    return (n.A = ff(e, "A") ? kf(e.A) : 1), n;
  },
  [Up.HSL](e, t) {
    const n = Rf(e.R, e.G, e.B);
    return delete n.A, ch(n, t);
  },
  HSLA(e, t) {
    const n = ih.HSL(e, t);
    return (n.A = ff(e, "A") ? kf(e.A, t) : 1), n;
  },
  [Up.CIELab](e, t) {
    const n = Vf(e.R, e.G, e.B);
    return uh(n, t);
  },
  CIELabA(e, t) {
    const n = ih.CIELab(e, t);
    return (n.A = ff(e, "A") ? kf(e.A, t) : 1), n;
  },
  [Up.CMYK]: (e, t) => dh(If(e.R, e.G, e.B), t),
  CMYKA(e, t) {
    const n = ih.CMYK(e, t);
    return (n.A = ff(e, "A") ? kf(e.A, t) : 1), n;
  },
};
export var oh = (e, t, n, s) => {
  const i = eh(e),
    o = "string" == typeof e,
    r = sh(e, i),
    a =
      ("string" == typeof e && ff(r, "A")) ||
      ("string" != typeof e && ff(e, "A")),
    l = Rf(r.R, r.G, r.B, r.A);
  a || delete l.A;
  const c = n ? l.L / (t + 1) : (100 - l.L) / (t + 1),
    u = Array(t)
      .fill(null)
      .map((e, t) => ({ ...l, L: l.L + c * (t + 1) * (1 - 2 * +n) }));
  switch (i) {
    case Up.HEX:
    default:
      return u.map((e) => {
        const t = Of(e.H, e.S, e.L);
        return (
          a && (t.A = e.A),
          o
            ? a
              ? qf.HEX({ ...t, A: kf(255 * t.A) })
              : qf.HEX(t)
            : a
            ? ih.HEXA(t)
            : ih.HEX(t)
        );
      });
    case Up.RGB:
      return u.map((e) => {
        const t = Of(e.H, e.S, e.L);
        return (
          a && (t.A = e.A),
          o ? qf.RGB(t, s) : a ? ih.RGBA(t, s.decimals) : ih.RGB(t, s.decimals)
        );
      });
    case Up.HSL:
      return u.map((e) =>
        o
          ? qf.HSL(e, s)
          : a
          ? ih.HSLA({ ...Of(e.H, e.S, e.L), A: e.A }, s.decimals)
          : ih.HSL(Of(e.H, e.S, e.L), s.decimals)
      );
    case Up.CIELab:
      return u.map((e) => {
        const t = Of(e.H, e.S, e.L);
        return o
          ? qf.CIELab(
              a ? ih.CIELabA(t, s.decimals) : ih.CIELab(t, s.decimals),
              s
            )
          : a
          ? ih.CIELabA({ ...t, A: e.A }, s.decimals)
          : ih.CIELab(t, s.decimals);
      });
  }
};
export var rh = {
  buildHarmony(e, t, n, s) {
    const i = eh(e),
      o = sh(e, i),
      r = Rf(o.R, o.G, o.B, o.A),
      a =
        ("string" == typeof e && ff(o, "A")) ||
        ("string" != typeof e && ff(e, "A")),
      l = "string" == typeof e;
    switch (i) {
      case Up.HEX:
      default:
        return a ? this.HEXA(ch(r, 0), t, n, l) : this.HEX(ch(r, 0), t, n, l);
      case Up.HSL:
        return a ? this.HSLA(r, t, n, l, s) : this.HSL(r, t, n, l, s);
      case Up.RGB:
        return a ? this.RGBA(r, t, n, l, s) : this.RGB(r, t, n, l, s);
      case Up.CIELab:
        return a ? this.CIELabA(r, t, n, l, s) : this.CIELab(r, t, n, l, s);
    }
  },
  [Up.HEX]: (e, t, n, s) =>
    t(e, n).map((e) =>
      s ? qf.HEX(Of(e.H, e.S, e.L)) : ih.HEX(Of(e.H, e.S, e.L))
    ),
  HEXA: (e, t, n, s) =>
    t(e, n).map((e) =>
      s
        ? qf.HEX({ ...Of(e.H, e.S, e.L), A: 255 * Qf(e.A) })
        : ih.HEXA({ ...Of(e.H, e.S, e.L), A: Qf(e.A) })
    ),
  [Up.RGB]: (e, t, n, s, i) =>
    t(e, n).map((e) =>
      s ? qf.RGB(Of(e.H, e.S, e.L), i) : ih.RGB(Of(e.H, e.S, e.L), i.decimals)
    ),
  RGBA: (e, t, n, s, i) =>
    t(e, n).map((e) =>
      s
        ? qf.RGB({ ...Of(e.H, e.S, e.L), A: Qf(e.A) }, i)
        : ih.RGBA({ ...Of(e.H, e.S, e.L), A: Qf(e.A) }, i.decimals)
    ),
  [Up.HSL]: (e, t, n, s, i) =>
    t(e, n).map((e) =>
      s
        ? qf.HSL({ H: e.H, S: e.S, L: e.L }, i)
        : ih.HSL(Of(e.H, e.S, e.L), i.decimals)
    ),
  HSLA: (e, t, n, s, i) =>
    t(e, n).map((e) =>
      s
        ? qf.HSL({ ...e, A: Qf(e.A) }, i)
        : ih.HSLA({ ...Of(e.H, e.S, e.L), A: Qf(e.A) }, i.decimals)
    ),
  [Up.CIELab]: (e, t, n, s, i) =>
    t(e, n).map((e) => {
      const t = Of(e.H, e.S, e.L);
      return s ? qf.CIELab(Vf(t.R, t.G, t.B), i) : ih.CIELab(t, i.decimals);
    }),
  CIELabA: (e, t, n, s, i) =>
    t(e, n).map((e) => {
      const t = Of(e.H, e.S, e.L);
      return s
        ? qf.CIELab({ ...Vf(t.R, t.G, t.B), A: Qf(e.A) }, i)
        : ih.CIELabA({ ...t, A: Qf(e.A) }, i.decimals);
    }),
};
export var ah = {
  mix(e, t) {
    const n = e.map((e) => {
        const t = eh(e);
        return sh(e, t);
      }),
      s =
        t === $p.SUBTRACTIVE
          ? n.map((e) => {
              const t = ((e, t, n) => {
                const s = Math.min(e, t, n),
                  i = Math.min(255 - e, 255 - t, 255 - n),
                  o = e - s,
                  r = t - s,
                  a = n - s,
                  l = Math.min(o, r),
                  c = o - l,
                  u = (r + l) / 2,
                  d = (a + r - l) / 2,
                  p = Math.max(c, u, d) / Math.max(o, r, a),
                  f = isNaN(p) || p === 1 / 0 || p <= 0 ? 1 : p;
                return { R: c / f + i, Y: u / f + i, B: d / f + i };
              })(e.R, e.G, e.B);
              return ff(e, "A") && (t.A = e.A), t;
            })
          : null;
    function i(e) {
      const n =
        t === $p.ADDITIVE
          ? { R: 0, G: 0, B: 0, A: 0 }
          : { R: 0, Y: 0, B: 0, A: 0 };
      return e.reduce((e, n) => {
        const s = ff(n, "A") ? n.A : 1,
          i = {
            R: Math.min(e.R + n.R * s, 255),
            B: Math.min(e.B + n.B * s, 255),
            A: 1 - (1 - s) * (1 - e.A),
          },
          o = "G" in e ? e.G : e.Y,
          r = "G" in n ? n.G : n.Y;
        return {
          ...i,
          ...(t === $p.ADDITIVE
            ? { G: Math.min(o + r * s, 255) }
            : { Y: Math.min(o + r * s, 255) }),
        };
      }, n);
    }
    let o;
    if (t === $p.ADDITIVE) o = i(n);
    else {
      const e = i(s);
      (o = ((e, t, n) => {
        const s = Math.min(e, t, n),
          i = Math.min(255 - e, 255 - t, 255 - n),
          o = e - s,
          r = t - s,
          a = n - s,
          l = Math.min(r, a),
          c = o + r - l,
          u = r + l,
          d = 2 * (a - l),
          p = Math.max(c, u, d) / Math.max(o, r, a),
          f = isNaN(p) || p === 1 / 0 || p <= 0 ? 1 : p;
        return { R: c / f + i, G: u / f + i, B: d / f + i };
      })(e.R, e.Y, e.B)),
        (o.A = e.A);
    }
    return { R: kf(o.R), G: kf(o.G), B: kf(o.B), A: Cf(o.A, 0, 1) };
  },
  [Up.HEX](e, t, n) {
    const s = this.mix(e, t);
    return delete s.A, n ? qf.HEX(s) : ih.HEX(s);
  },
  HEXA(e, t, n) {
    const s = this.mix(e, t);
    return (s.A = n ? 255 * Qf(s.A) : Qf(s.A)), n ? qf.HEX(s) : ih.HEXA(s);
  },
  [Up.RGB](e, t, n, s) {
    const i = this.mix(e, t);
    return delete i.A, n ? qf.RGB(i, s) : ih.RGB(i, s.decimals);
  },
  RGBA(e, t, n, s) {
    const i = this.mix(e, t);
    return n ? qf.RGB(i, s) : ih.RGBA(i, s.decimals);
  },
  [Up.HSL](e, t, n, s) {
    const i = this.mix(e, t),
      o = Rf(i.R, i.G, i.B);
    return delete i.A, delete o.A, n ? qf.HSL(o, s) : ih.HSL(i, s.decimals);
  },
  HSLA(e, t, n, s) {
    const i = this.mix(e, t),
      o = Rf(i.R, i.G, i.B, i.A);
    return n ? qf.HSL(o, s) : ih.HSLA(i, s.decimals);
  },
  [Up.CIELab](e, t, n, s) {
    const i = this.mix(e, t),
      o = Vf(i.R, i.G, i.B);
    return delete i.A, n ? qf.CIELab(o, s) : ih.CIELabA(i, s.decimals);
  },
  CIELabA(e, t, n, s) {
    const i = this.mix(e, t),
      o = Vf(i.R, i.G, i.B);
    return (
      ff(i, "A") && (o.A = i.A), n ? qf.CIELab(o, s) : ih.CIELabA(i, s.decimals)
    );
  },
};
export var lh = (e, t) => ({
  R: kf(e.R, t),
  G: kf(e.G, t),
  B: kf(e.B, t),
  ...(ff(e, "A") ? { A: kf(e.A, t) } : {}),
});
export var ch = (e, t) => ({
  H: kf(e.H, t),
  S: kf(e.S, t),
  L: kf(e.L, t),
  ...(ff(e, "A") ? { A: kf(e.A, t) } : {}),
});
export var uh = (e, t) => ({ L: kf(e.L, t), a: kf(e.a, t), b: kf(e.b, t) });
export var dh = (e, t) => ({
  C: kf(e.C, t),
  M: kf(e.M, t),
  Y: kf(e.Y, t),
  K: kf(e.K, t),
});
export var ph = (e, t, n, s) => s(sh(e, t), n);
export var fh = (e, t, n, s, i) => {
  n < 1 && (n = 5);
  return ((e, t, n) => {
    const s = n - 1,
      i = (t.R - e.R) / s,
      o = (t.G - e.G) / s,
      r = (t.B - e.B) / s,
      a = Qf(e.A),
      l = (Qf(t.A) - a) / s;
    return Array(n)
      .fill(null)
      .map((n, c) =>
        0 === c
          ? e
          : c === s
          ? t
          : {
              R: kf(e.R + i * c),
              G: kf(e.G + o * c),
              B: kf(e.B + r * c),
              A: kf(a + l * c),
            }
      );
  })(sh(e), sh(t), n).map((e) => i(e, s));
};
export var hh = (e, t, n, s) =>
  ({
    [zp.ANALOGOUS]: rh.buildHarmony(t, Zf, n, s),
    [zp.COMPLEMENTARY]: rh.buildHarmony(t, Wf, n, s),
    [zp.SPLIT_COMPLEMENTARY]: rh.buildHarmony(t, Kf, n, s),
    [zp.TRIADIC]: rh.buildHarmony(t, Yf, n, s),
    [zp.TETRADIC]: rh.buildHarmony(t, Xf, n, s),
    [zp.SQUARE]: rh.buildHarmony(t, Jf, n, s),
  }[e]);
export const gh = "ubq-public";
export function bh(e, t) {
  try {
    const t = xh(e),
      n = new ColorRelatedSomething(t).RGBAObject,
      { R: s, G: i, B: o, A: r } = n;
    if (null == n || [s, i, o, r].some(Number.isNaN))
      throw Error(
        `Error: ${e} could not be parsed. This might happen if the passed color is not a valid CSS color string.`
      );
    return { r: s / 255, g: i / 255, b: o / 255, a: r ?? 1 };
  } catch (e) {
    if (null != t) return t;
    throw e;
  }
}
export var jh;
export var Sh = ContextWrapper8;

export function Dh({ children: e, className: t, style: n }) {
  return (0, Vh.jsx)("div", {
    className: (0, _h.default)(Eh, t),
    style: n,
    children: e,
  });
}
((jh = Dh || (Dh = {})).TopLeft = function ({ children: e, className: t }) {
  return (0, Vh.jsx)("div", { className: (0, _h.default)(Lh, t), children: e });
}),
  (jh.MiddleLeft = function ({ children: e, className: t }) {
    return (0, Vh.jsx)("div", {
      className: (0, _h.default)(Ph, t),
      children: e,
    });
  }),
  (jh.BottomLeft = function ({ children: e, className: t }) {
    return (0, Vh.jsx)("div", {
      className: (0, _h.default)(Ah, t),
      children: e,
    });
  }),
  (jh.TopCenter = function ({ children: e, className: t }) {
    return (0, Vh.jsx)("div", {
      className: (0, _h.default)(Bh, t),
      children: e,
    });
  }),
  (jh.BottomCenter = function ({ children: e, className: t }) {
    return (0, Vh.jsx)("div", {
      className: (0, _h.default)(Th, t),
      children: e,
    });
  }),
  (jh.TopRight = function ({ children: e, className: t }) {
    return (0, Vh.jsx)("div", {
      className: (0, _h.default)(Mh, t),
      children: e,
    });
  }),
  (jh.MiddleRight = function ({ children: e, className: t }) {
    return (0, Vh.jsx)("div", {
      className: (0, _h.default)(Oh, t),
      children: e,
    });
  }),
  (jh.BottomRight = function ({ children: e, className: t }) {
    return (0, Vh.jsx)("div", {
      className: (0, _h.default)(Rh, t),
      children: e,
    });
  });
export var Fh = { Edge: Dh };
export var Ih = Fh;
export var Hh = CompCustomShapes;

export var zh = function ({
  children: e,
  asyncState: t,
  showCircularSpinner: n,
}) {
  switch (t) {
    case "waiting":
      return n
        ? (0, Uh.jsx)("div", { className: Nh, children: (0, Uh.jsx)(Hh, {}) })
        : null;
    case "success":
      return (0, Uh.jsx)(Uh.Fragment, {
        children: "function" == typeof e ? e() : e,
      });
    default:
      return null;
  }
};

export var Jh = function ({ children: e, className: t }) {
  return (0, Xh.jsx)("div", {
    className: (0, Kh.default)(Yh, t),
    children: e,
  });
};

export var sm = function ({ children: e, className: t }) {
  return (0, nm.jsx)("div", {
    className: (0, em.default)(tm, t),
    children: e,
  });
};
export var rm = isDOMAvailable && !!document.body.attachShadow;
export function lm(e) {
  const { focusTrapOptions: t = {} } = e,
    n = document.querySelector(`.${gh}`);
  return (0, am.jsx)(im.default, {
    ...e,
    focusTrapOptions: {
      trapStack: cm,
      ...t,
      document: rm ? n?.shadowRoot : window.document,
      onActivate: () => {
        document.dispatchEvent(new Event("ubq-focustrap-activate")),
          t?.onActivate && t?.onActivate();
      },
      onDeactivate: () => {
        document.dispatchEvent(new Event("ubq-focustrap-deactivate")),
          t?.onDeactivate && t?.onDeactivate();
      },
    },
  });
}
export var cm = [];
(lm || (lm = {})).isActive = function () {
  return cm.some((e) => e.active && false === e.paused);
};
export var um = lm;
export var dm = um;
export var xm = function (e) {
  return e.reduce(function (e, t) {
    var n = t[0],
      s = t[1];
    return (e[n] = s), e;
  }, {});
};
export var bm =
  "undefined" != typeof window &&
  window.document &&
  window.document.createElement
    ? gm.useLayoutEffect
    : gm.useEffect;
export var Tm = Sm.reduce(function (e, t) {
  return e.concat([t + "-" + _m, t + "-" + Em]);
}, []);
export var Mm = [].concat(Sm, [jm]).reduce(function (e, t) {
  return e.concat([t, t + "-" + _m, t + "-" + Em]);
}, []);
export function Rm(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
export function Vm(e) {
  if (null == e) return window;
  if ("[object Window]" !== e.toString()) {
    var t = e.ownerDocument;
    return (t && t.defaultView) || window;
  }
  return e;
}
export function Dm(e) {
  return e instanceof Vm(e).Element || e instanceof Element;
}
export function Fm(e) {
  return e instanceof Vm(e).HTMLElement || e instanceof HTMLElement;
}
export function Im(e) {
  return (
    "undefined" != typeof ShadowRoot &&
    (e instanceof Vm(e).ShadowRoot || e instanceof ShadowRoot)
  );
}
export var Hm = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: function (e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function (e) {
      var n = t.styles[e] || {},
        s = t.attributes[e] || {},
        i = t.elements[e];
      Fm(i) &&
        Rm(i) &&
        (Object.assign(i.style, n),
        Object.keys(s).forEach(function (e) {
          var t = s[e];
          false === t
            ? i.removeAttribute(e)
            : i.setAttribute(e, true === t ? "" : t);
        }));
    });
  },
  effect: function (e) {
    var t = e.state,
      n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      };
    return (
      Object.assign(t.elements.popper.style, n.popper),
      (t.styles = n),
      t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
      function () {
        Object.keys(t.elements).forEach(function (e) {
          var s = t.elements[e],
            i = t.attributes[e] || {},
            o = Object.keys(
              t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]
            ).reduce(function (e, t) {
              return (e[t] = ""), e;
            }, {});
          Fm(s) &&
            Rm(s) &&
            (Object.assign(s.style, o),
            Object.keys(i).forEach(function (e) {
              s.removeAttribute(e);
            }));
        });
      }
    );
  },
  requires: ["computeStyles"],
};
export function Nm(e) {
  return e.split("-")[0];
}
export var Um = Math.max;
export var zm = Math.min;
export var $m = Math.round;
export function qm() {
  var e = navigator.userAgentData;
  return null != e && e.brands && Array.isArray(e.brands)
    ? e.brands
        .map(function (e) {
          return e.brand + "/" + e.version;
        })
        .join(" ")
    : navigator.userAgent;
}
export function Qm() {
  return !/^((?!chrome|android).)*safari/i.test(qm());
}
export function Gm(e, t, n) {
  undefined === t && (t = false), undefined === n && (n = false);
  var s = e.getBoundingClientRect(),
    i = 1,
    o = 1;
  t &&
    Fm(e) &&
    ((i = (e.offsetWidth > 0 && $m(s.width) / e.offsetWidth) || 1),
    (o = (e.offsetHeight > 0 && $m(s.height) / e.offsetHeight) || 1));
  var r = (Dm(e) ? Vm(e) : window).visualViewport,
    a = !Qm() && n,
    l = (s.left + (a && r ? r.offsetLeft : 0)) / i,
    c = (s.top + (a && r ? r.offsetTop : 0)) / o,
    u = s.width / i,
    d = s.height / o;
  return {
    width: u,
    height: d,
    top: c,
    right: l + u,
    bottom: c + d,
    left: l,
    x: l,
    y: c,
  };
}
export function Zm(e) {
  var t = Gm(e),
    n = e.offsetWidth,
    s = e.offsetHeight;
  return (
    Math.abs(t.width - n) <= 1 && (n = t.width),
    Math.abs(t.height - s) <= 1 && (s = t.height),
    { x: e.offsetLeft, y: e.offsetTop, width: n, height: s }
  );
}
export function Wm(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t)) return true;
  if (n && Im(n)) {
    var s = t;
    do {
      if (s && e.isSameNode(s)) return true;
      s = s.parentNode || s.host;
    } while (s);
  }
  return false;
}
export function Km(e) {
  return Vm(e).getComputedStyle(e);
}
export function Ym(e) {
  return ["table", "td", "th"].indexOf(Rm(e)) >= 0;
}
export function Xm(e) {
  return ((Dm(e) ? e.ownerDocument : e.document) || window.document)
    .documentElement;
}
export function Jm(e) {
  return "html" === Rm(e)
    ? e
    : e.assignedSlot || e.parentNode || (Im(e) ? e.host : null) || Xm(e);
}
export function eg(e) {
  return Fm(e) && "fixed" !== Km(e).position ? e.offsetParent : null;
}
export function tg(e) {
  for (var t = Vm(e), n = eg(e); n && Ym(n) && "static" === Km(n).position; )
    n = eg(n);
  return n &&
    ("html" === Rm(n) || ("body" === Rm(n) && "static" === Km(n).position))
    ? t
    : n ||
        (function (e) {
          var t = /firefox/i.test(qm());
          if (/Trident/i.test(qm()) && Fm(e) && "fixed" === Km(e).position)
            return null;
          var n = Jm(e);
          for (
            Im(n) && (n = n.host);
            Fm(n) && ["html", "body"].indexOf(Rm(n)) < 0;

          ) {
            var s = Km(n);
            if (
              "none" !== s.transform ||
              "none" !== s.perspective ||
              "paint" === s.contain ||
              -1 !== ["transform", "perspective"].indexOf(s.willChange) ||
              (t && "filter" === s.willChange) ||
              (t && s.filter && "none" !== s.filter)
            )
              return n;
            n = n.parentNode;
          }
          return null;
        })(e) ||
        t;
}
export function ng(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
export function sg(e, t, n) {
  return Um(e, zm(t, n));
}
export function ig(e) {
  return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e);
}
export function og(e, t) {
  return t.reduce(function (t, n) {
    return (t[n] = e), t;
  }, {});
}
export var rg = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: function (e) {
    var t,
      n = e.state,
      s = e.name,
      i = e.options,
      o = n.elements.arrow,
      r = n.modifiersData.popperOffsets,
      a = Nm(n.placement),
      l = ng(a),
      c = [Cm, km].indexOf(a) >= 0 ? "height" : "width";
    if (o && r) {
      var u = (function (e, t) {
          return ig(
            "number" !=
              typeof (e =
                "function" == typeof e
                  ? e(Object.assign({}, t.rects, { placement: t.placement }))
                  : e)
              ? e
              : og(e, Sm)
          );
        })(i.padding, n),
        d = Zm(o),
        p = "y" === l ? vm : Cm,
        f = "y" === l ? wm : km,
        h =
          n.rects.reference[c] +
          n.rects.reference[l] -
          r[l] -
          n.rects.popper[c],
        m = r[l] - n.rects.reference[l],
        g = tg(o),
        x = g ? ("y" === l ? g.clientHeight || 0 : g.clientWidth || 0) : 0,
        b = h / 2 - m / 2,
        y = u[p],
        v = x - d[c] - u[f],
        w = x / 2 - d[c] / 2 + b,
        k = sg(y, w, v),
        C = l;
      n.modifiersData[s] = (((t = {})[C] = k), (t.centerOffset = k - w), t);
    }
  },
  effect: function (e) {
    var t = e.state,
      n = e.options.element,
      s = undefined === n ? "[data-popper-arrow]" : n;
    null != s &&
      ("string" != typeof s || (s = t.elements.popper.querySelector(s))) &&
      Wm(t.elements.popper, s) &&
      (t.elements.arrow = s);
  },
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
export function ag(e) {
  return e.split("-")[1];
}
export var lg = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
export function cg(e) {
  var t,
    n = e.popper,
    s = e.popperRect,
    i = e.placement,
    o = e.variation,
    r = e.offsets,
    a = e.position,
    l = e.gpuAcceleration,
    c = e.adaptive,
    u = e.roundOffsets,
    d = e.isFixed,
    p = r.x,
    f = undefined === p ? 0 : p,
    h = r.y,
    m = undefined === h ? 0 : h,
    g = "function" == typeof u ? u({ x: f, y: m }) : { x: f, y: m };
  (f = g.x), (m = g.y);
  var x = r.hasOwnProperty("x"),
    b = r.hasOwnProperty("y"),
    y = Cm,
    v = vm,
    w = window;
  if (c) {
    var k = tg(n),
      C = "clientHeight",
      j = "clientWidth";
    if (
      (k === Vm(n) &&
        "static" !== Km((k = Xm(n))).position &&
        "absolute" === a &&
        ((C = "scrollHeight"), (j = "scrollWidth")),
      i === vm || ((i === Cm || i === km) && o === Em))
    )
      (v = wm),
        (m -=
          (d && k === w && w.visualViewport ? w.visualViewport.height : k[C]) -
          s.height),
        (m *= l ? 1 : -1);
    if (i === Cm || ((i === vm || i === wm) && o === Em))
      (y = km),
        (f -=
          (d && k === w && w.visualViewport ? w.visualViewport.width : k[j]) -
          s.width),
        (f *= l ? 1 : -1);
  }
  var S,
    _ = Object.assign({ position: a }, c && lg),
    E =
      true === u
        ? (function (e, t) {
            var n = e.x,
              s = e.y,
              i = t.devicePixelRatio || 1;
            return { x: $m(n * i) / i || 0, y: $m(s * i) / i || 0 };
          })({ x: f, y: m }, Vm(n))
        : { x: f, y: m };
  return (
    (f = E.x),
    (m = E.y),
    l
      ? Object.assign(
          {},
          _,
          (((S = {})[v] = b ? "0" : ""),
          (S[y] = x ? "0" : ""),
          (S.transform =
            (w.devicePixelRatio || 1) <= 1
              ? "translate(" + f + "px, " + m + "px)"
              : "translate3d(" + f + "px, " + m + "px, 0)"),
          S)
        )
      : Object.assign(
          {},
          _,
          (((t = {})[v] = b ? m + "px" : ""),
          (t[y] = x ? f + "px" : ""),
          (t.transform = ""),
          t)
        )
  );
}
export var ug = { passive: true };
export var dg = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function () {},
  effect: function (e) {
    var t = e.state,
      n = e.instance,
      s = e.options,
      i = s.scroll,
      o = undefined === i || i,
      r = s.resize,
      a = undefined === r || r,
      l = Vm(t.elements.popper),
      c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return (
      o &&
        c.forEach(function (e) {
          e.addEventListener("scroll", n.update, ug);
        }),
      a && l.addEventListener("resize", n.update, ug),
      function () {
        o &&
          c.forEach(function (e) {
            e.removeEventListener("scroll", n.update, ug);
          }),
          a && l.removeEventListener("resize", n.update, ug);
      }
    );
  },
  data: {},
};
export var pg = { left: "right", right: "left", bottom: "top", top: "bottom" };
export function fg(e) {
  return e.replace(/left|right|bottom|top/g, function (e) {
    return pg[e];
  });
}
export var hg = { start: "end", end: "start" };
export function mg(e) {
  return e.replace(/start|end/g, function (e) {
    return hg[e];
  });
}
export function gg(e) {
  var t = Vm(e);
  return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
export function xg(e) {
  return Gm(Xm(e)).left + gg(e).scrollLeft;
}
export function bg(e) {
  var t = Km(e),
    n = t.overflow,
    s = t.overflowX,
    i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + s);
}
export function yg(e) {
  return ["html", "body", "#document"].indexOf(Rm(e)) >= 0
    ? e.ownerDocument.body
    : Fm(e) && bg(e)
    ? e
    : yg(Jm(e));
}
export function vg(e, t) {
  var n;
  undefined === t && (t = []);
  var s = yg(e),
    i = s === (null == (n = e.ownerDocument) ? undefined : n.body),
    o = Vm(s),
    r = i ? [o].concat(o.visualViewport || [], bg(s) ? s : []) : s,
    a = t.concat(r);
  return i ? a : a.concat(vg(Jm(r)));
}
export function wg(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height,
  });
}
export function kg(e, t, n) {
  return t === Pm
    ? wg(
        (function (e, t) {
          var n = Vm(e),
            s = Xm(e),
            i = n.visualViewport,
            o = s.clientWidth,
            r = s.clientHeight,
            a = 0,
            l = 0;
          if (i) {
            (o = i.width), (r = i.height);
            var c = Qm();
            (c || (!c && "fixed" === t)) &&
              ((a = i.offsetLeft), (l = i.offsetTop));
          }
          return { width: o, height: r, x: a + xg(e), y: l };
        })(e, n)
      )
    : Dm(t)
    ? (function (e, t) {
        var n = Gm(e, false, "fixed" === t);
        return (
          (n.top = n.top + e.clientTop),
          (n.left = n.left + e.clientLeft),
          (n.bottom = n.top + e.clientHeight),
          (n.right = n.left + e.clientWidth),
          (n.width = e.clientWidth),
          (n.height = e.clientHeight),
          (n.x = n.left),
          (n.y = n.top),
          n
        );
      })(t, n)
    : wg(
        (function (e) {
          var t,
            n = Xm(e),
            s = gg(e),
            i = null == (t = e.ownerDocument) ? undefined : t.body,
            o = Um(
              n.scrollWidth,
              n.clientWidth,
              i ? i.scrollWidth : 0,
              i ? i.clientWidth : 0
            ),
            r = Um(
              n.scrollHeight,
              n.clientHeight,
              i ? i.scrollHeight : 0,
              i ? i.clientHeight : 0
            ),
            a = -s.scrollLeft + xg(e),
            l = -s.scrollTop;
          return (
            "rtl" === Km(i || n).direction &&
              (a += Um(n.clientWidth, i ? i.clientWidth : 0) - o),
            { width: o, height: r, x: a, y: l }
          );
        })(Xm(e))
      );
}
export function Cg(e, t, n, s) {
  var i =
      "clippingParents" === t
        ? (function (e) {
            var t = vg(Jm(e)),
              n =
                ["absolute", "fixed"].indexOf(Km(e).position) >= 0 && Fm(e)
                  ? tg(e)
                  : e;
            return Dm(n)
              ? t.filter(function (e) {
                  return Dm(e) && Wm(e, n) && "body" !== Rm(e);
                })
              : [];
          })(e)
        : [].concat(t),
    o = [].concat(i, [n]),
    r = o[0],
    a = o.reduce(function (t, n) {
      var i = kg(e, n, s);
      return (
        (t.top = Um(i.top, t.top)),
        (t.right = zm(i.right, t.right)),
        (t.bottom = zm(i.bottom, t.bottom)),
        (t.left = Um(i.left, t.left)),
        t
      );
    }, kg(e, r, s));
  return (
    (a.width = a.right - a.left),
    (a.height = a.bottom - a.top),
    (a.x = a.left),
    (a.y = a.top),
    a
  );
}
export function jg(e) {
  var t,
    n = e.reference,
    s = e.element,
    i = e.placement,
    o = i ? Nm(i) : null,
    r = i ? ag(i) : null,
    a = n.x + n.width / 2 - s.width / 2,
    l = n.y + n.height / 2 - s.height / 2;
  switch (o) {
    case vm:
      t = { x: a, y: n.y - s.height };
      break;
    case wm:
      t = { x: a, y: n.y + n.height };
      break;
    case km:
      t = { x: n.x + n.width, y: l };
      break;
    case Cm:
      t = { x: n.x - s.width, y: l };
      break;
    default:
      t = { x: n.x, y: n.y };
  }
  var c = o ? ng(o) : null;
  if (null != c) {
    var u = "y" === c ? "height" : "width";
    switch (r) {
      case _m:
        t[c] = t[c] - (n[u] / 2 - s[u] / 2);
        break;
      case Em:
        t[c] = t[c] + (n[u] / 2 - s[u] / 2);
    }
  }
  return t;
}
export function Sg(e, t) {
  undefined === t && (t = {});
  var n = t,
    s = n.placement,
    i = undefined === s ? e.placement : s,
    o = n.strategy,
    r = undefined === o ? e.strategy : o,
    a = n.boundary,
    l = undefined === a ? Lm : a,
    c = n.rootBoundary,
    u = undefined === c ? Pm : c,
    d = n.elementContext,
    p = undefined === d ? Am : d,
    f = n.altBoundary,
    h = undefined !== f && f,
    m = n.padding,
    g = undefined === m ? 0 : m,
    x = ig("number" != typeof g ? g : og(g, Sm)),
    b = p === Am ? Bm : Am,
    y = e.rects.popper,
    v = e.elements[h ? b : p],
    w = Cg(Dm(v) ? v : v.contextElement || Xm(e.elements.popper), l, u, r),
    k = Gm(e.elements.reference),
    C = jg({ reference: k, element: y, strategy: "absolute", placement: i }),
    j = wg(Object.assign({}, y, C)),
    S = p === Am ? j : k,
    _ = {
      top: w.top - S.top + x.top,
      bottom: S.bottom - w.bottom + x.bottom,
      left: w.left - S.left + x.left,
      right: S.right - w.right + x.right,
    },
    E = e.modifiersData.offset;
  if (p === Am && E) {
    var L = E[i];
    Object.keys(_).forEach(function (e) {
      var t = [km, wm].indexOf(e) >= 0 ? 1 : -1,
        n = [vm, wm].indexOf(e) >= 0 ? "y" : "x";
      _[e] += L[n] * t;
    });
  }
  return _;
}
export var _g = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: function (e) {
    var t = e.state,
      n = e.options,
      s = e.name;
    if (!t.modifiersData[s]._skip) {
      for (
        var i = n.mainAxis,
          o = undefined === i || i,
          r = n.altAxis,
          a = undefined === r || r,
          l = n.fallbackPlacements,
          c = n.padding,
          u = n.boundary,
          d = n.rootBoundary,
          p = n.altBoundary,
          f = n.flipVariations,
          h = undefined === f || f,
          m = n.allowedAutoPlacements,
          g = t.options.placement,
          x = Nm(g),
          b =
            l ||
            (x === g || !h
              ? [fg(g)]
              : (function (e) {
                  if (Nm(e) === jm) return [];
                  var t = fg(e);
                  return [mg(e), t, mg(t)];
                })(g)),
          y = [g].concat(b).reduce(function (e, n) {
            return e.concat(
              Nm(n) === jm
                ? (function (e, t) {
                    undefined === t && (t = {});
                    var n = t,
                      s = n.placement,
                      i = n.boundary,
                      o = n.rootBoundary,
                      r = n.padding,
                      a = n.flipVariations,
                      l = n.allowedAutoPlacements,
                      c = undefined === l ? Mm : l,
                      u = ag(s),
                      d = u
                        ? a
                          ? Tm
                          : Tm.filter(function (e) {
                              return ag(e) === u;
                            })
                        : Sm,
                      p = d.filter(function (e) {
                        return c.indexOf(e) >= 0;
                      });
                    0 === p.length && (p = d);
                    var f = p.reduce(function (t, n) {
                      return (
                        (t[n] = Sg(e, {
                          placement: n,
                          boundary: i,
                          rootBoundary: o,
                          padding: r,
                        })[Nm(n)]),
                        t
                      );
                    }, {});
                    return Object.keys(f).sort(function (e, t) {
                      return f[e] - f[t];
                    });
                  })(t, {
                    placement: n,
                    boundary: u,
                    rootBoundary: d,
                    padding: c,
                    flipVariations: h,
                    allowedAutoPlacements: m,
                  })
                : n
            );
          }, []),
          v = t.rects.reference,
          w = t.rects.popper,
          k = new Map(),
          C = true,
          j = y[0],
          S = 0;
        S < y.length;
        S++
      ) {
        var _ = y[S],
          E = Nm(_),
          L = ag(_) === _m,
          P = [vm, wm].indexOf(E) >= 0,
          A = P ? "width" : "height",
          B = Sg(t, {
            placement: _,
            boundary: u,
            rootBoundary: d,
            altBoundary: p,
            padding: c,
          }),
          T = P ? (L ? km : Cm) : L ? wm : vm;
        v[A] > w[A] && (T = fg(T));
        var M = fg(T),
          O = [];
        if (
          (o && O.push(B[E] <= 0),
          a && O.push(B[T] <= 0, B[M] <= 0),
          O.every(function (e) {
            return e;
          }))
        ) {
          (j = _), (C = false);
          break;
        }
        k.set(_, O);
      }
      if (C)
        for (
          var R = function (e) {
              var t = y.find(function (t) {
                var n = k.get(t);
                if (n)
                  return n.slice(0, e).every(function (e) {
                    return e;
                  });
              });
              if (t) return (j = t), "break";
            },
            V = h ? 3 : 1;
          V > 0;
          V--
        ) {
          if ("break" === R(V)) break;
        }
      t.placement !== j &&
        ((t.modifiersData[s]._skip = true),
        (t.placement = j),
        (t.reset = true));
    }
  },
  requiresIfExists: ["offset"],
  data: { _skip: false },
};
export function Eg(e, t, n) {
  return (
    undefined === n && (n = { x: 0, y: 0 }),
    {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x,
    }
  );
}
export function Lg(e) {
  return [vm, km, wm, Cm].some(function (t) {
    return e[t] >= 0;
  });
}
export var Pg = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: function (e) {
    var t = e.state,
      n = e.name,
      s = t.rects.reference,
      i = t.rects.popper,
      o = t.modifiersData.preventOverflow,
      r = Sg(t, { elementContext: "reference" }),
      a = Sg(t, { altBoundary: true }),
      l = Eg(r, s),
      c = Eg(a, i, o),
      u = Lg(l),
      d = Lg(c);
    (t.modifiersData[n] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: c,
      isReferenceHidden: u,
      hasPopperEscaped: d,
    }),
      (t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": d,
      }));
  },
};
export var Ag = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: function (e) {
    var t = e.state,
      n = e.options,
      s = e.name,
      i = n.offset,
      o = undefined === i ? [0, 0] : i,
      r = Mm.reduce(function (e, n) {
        return (
          (e[n] = (function (e, t, n) {
            var s = Nm(e),
              i = [Cm, vm].indexOf(s) >= 0 ? -1 : 1,
              o =
                "function" == typeof n
                  ? n(Object.assign({}, t, { placement: e }))
                  : n,
              r = o[0],
              a = o[1];
            return (
              (r = r || 0),
              (a = (a || 0) * i),
              [Cm, km].indexOf(s) >= 0 ? { x: a, y: r } : { x: r, y: a }
            );
          })(n, t.rects, o)),
          e
        );
      }, {}),
      a = r[t.placement],
      l = a.x,
      c = a.y;
    null != t.modifiersData.popperOffsets &&
      ((t.modifiersData.popperOffsets.x += l),
      (t.modifiersData.popperOffsets.y += c)),
      (t.modifiersData[s] = r);
  },
};
export var Bg = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: function (e) {
    var t = e.state,
      n = e.name;
    t.modifiersData[n] = jg({
      reference: t.rects.reference,
      element: t.rects.popper,
      strategy: "absolute",
      placement: t.placement,
    });
  },
  data: {},
};
export var Tg = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: function (e) {
    var t = e.state,
      n = e.options,
      s = e.name,
      i = n.mainAxis,
      o = undefined === i || i,
      r = n.altAxis,
      a = undefined !== r && r,
      l = n.boundary,
      c = n.rootBoundary,
      u = n.altBoundary,
      d = n.padding,
      p = n.tether,
      f = undefined === p || p,
      h = n.tetherOffset,
      m = undefined === h ? 0 : h,
      g = Sg(t, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }),
      x = Nm(t.placement),
      b = ag(t.placement),
      y = !b,
      v = ng(x),
      w = "x" === v ? "y" : "x",
      k = t.modifiersData.popperOffsets,
      C = t.rects.reference,
      j = t.rects.popper,
      S =
        "function" == typeof m
          ? m(Object.assign({}, t.rects, { placement: t.placement }))
          : m,
      _ =
        "number" == typeof S
          ? { mainAxis: S, altAxis: S }
          : Object.assign({ mainAxis: 0, altAxis: 0 }, S),
      E = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
      L = { x: 0, y: 0 };
    if (k) {
      if (o) {
        var P,
          A = "y" === v ? vm : Cm,
          B = "y" === v ? wm : km,
          T = "y" === v ? "height" : "width",
          M = k[v],
          O = M + g[A],
          R = M - g[B],
          V = f ? -j[T] / 2 : 0,
          D = b === _m ? C[T] : j[T],
          F = b === _m ? -j[T] : -C[T],
          I = t.elements.arrow,
          H = f && I ? Zm(I) : { width: 0, height: 0 },
          N = t.modifiersData["arrow#persistent"]
            ? t.modifiersData["arrow#persistent"].padding
            : { top: 0, right: 0, bottom: 0, left: 0 },
          U = N[A],
          z = N[B],
          $ = sg(0, C[T], H[T]),
          q = y ? C[T] / 2 - V - $ - U - _.mainAxis : D - $ - U - _.mainAxis,
          Q = y ? -C[T] / 2 + V + $ + z + _.mainAxis : F + $ + z + _.mainAxis,
          G = t.elements.arrow && tg(t.elements.arrow),
          Z = G ? ("y" === v ? G.clientTop || 0 : G.clientLeft || 0) : 0,
          W = null != (P = null == E ? undefined : E[v]) ? P : 0,
          K = M + Q - W,
          Y = sg(f ? zm(O, M + q - W - Z) : O, M, f ? Um(R, K) : R);
        (k[v] = Y), (L[v] = Y - M);
      }
      if (a) {
        var X,
          J = "x" === v ? vm : Cm,
          ee = "x" === v ? wm : km,
          te = k[w],
          ne = "y" === w ? "height" : "width",
          se = te + g[J],
          ie = te - g[ee],
          oe = -1 !== [vm, Cm].indexOf(x),
          re = null != (X = null == E ? undefined : E[w]) ? X : 0,
          ae = oe ? se : te - C[ne] - j[ne] - re + _.altAxis,
          le = oe ? te + C[ne] + j[ne] - re - _.altAxis : ie,
          ce =
            f && oe
              ? (function (e, t, n) {
                  var s = sg(e, t, n);
                  return s > n ? n : s;
                })(ae, te, le)
              : sg(f ? ae : se, te, f ? le : ie);
        (k[w] = ce), (L[w] = ce - te);
      }
      t.modifiersData[s] = L;
    }
  },
  requiresIfExists: ["offset"],
};
export function Mg(e, t, n) {
  undefined === n && (n = false);
  var s,
    i,
    o = Fm(t),
    r =
      Fm(t) &&
      (function (e) {
        var t = e.getBoundingClientRect(),
          n = $m(t.width) / e.offsetWidth || 1,
          s = $m(t.height) / e.offsetHeight || 1;
        return 1 !== n || 1 !== s;
      })(t),
    a = Xm(t),
    l = Gm(e, r, n),
    c = { scrollLeft: 0, scrollTop: 0 },
    u = { x: 0, y: 0 };
  return (
    (o || (!o && !n)) &&
      (("body" !== Rm(t) || bg(a)) &&
        (c =
          (s = t) !== Vm(s) && Fm(s)
            ? { scrollLeft: (i = s).scrollLeft, scrollTop: i.scrollTop }
            : gg(s)),
      Fm(t)
        ? (((u = Gm(t, true)).x += t.clientLeft), (u.y += t.clientTop))
        : a && (u.x = xg(a))),
    {
      x: l.left + c.scrollLeft - u.x,
      y: l.top + c.scrollTop - u.y,
      width: l.width,
      height: l.height,
    }
  );
}
export function Og(e) {
  var t = new Map(),
    n = new Set(),
    s = [];
  function i(e) {
    n.add(e.name),
      []
        .concat(e.requires || [], e.requiresIfExists || [])
        .forEach(function (e) {
          if (!n.has(e)) {
            var s = t.get(e);
            s && i(s);
          }
        }),
      s.push(e);
  }
  return (
    e.forEach(function (e) {
      t.set(e.name, e);
    }),
    e.forEach(function (e) {
      n.has(e.name) || i(e);
    }),
    s
  );
}
export var Rg = { placement: "bottom", modifiers: [], strategy: "absolute" };
export function Vg() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function (e) {
    return !(e && "function" == typeof e.getBoundingClientRect);
  });
}
export function Dg(e) {
  undefined === e && (e = {});
  var t = e,
    n = t.defaultModifiers,
    s = undefined === n ? [] : n,
    i = t.defaultOptions,
    o = undefined === i ? Rg : i;
  return function (e, t, n) {
    undefined === n && (n = o);
    var i,
      r,
      a = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Rg, o),
        modifiersData: {},
        elements: { reference: e, popper: t },
        attributes: {},
        styles: {},
      },
      l = [],
      c = false,
      u = {
        state: a,
        setOptions: function (n) {
          var i = "function" == typeof n ? n(a.options) : n;
          d(),
            (a.options = Object.assign({}, o, a.options, i)),
            (a.scrollParents = {
              reference: Dm(e)
                ? vg(e)
                : e.contextElement
                ? vg(e.contextElement)
                : [],
              popper: vg(t),
            });
          var r,
            c,
            p = (function (e) {
              var t = Og(e);
              return Om.reduce(function (e, n) {
                return e.concat(
                  t.filter(function (e) {
                    return e.phase === n;
                  })
                );
              }, []);
            })(
              ((r = [].concat(s, a.options.modifiers)),
              (c = r.reduce(function (e, t) {
                var n = e[t.name];
                return (
                  (e[t.name] = n
                    ? Object.assign({}, n, t, {
                        options: Object.assign({}, n.options, t.options),
                        data: Object.assign({}, n.data, t.data),
                      })
                    : t),
                  e
                );
              }, {})),
              Object.keys(c).map(function (e) {
                return c[e];
              }))
            );
          return (
            (a.orderedModifiers = p.filter(function (e) {
              return e.enabled;
            })),
            a.orderedModifiers.forEach(function (e) {
              var t = e.name,
                n = e.options,
                s = undefined === n ? {} : n,
                i = e.effect;
              if ("function" == typeof i) {
                var o = i({ state: a, name: t, instance: u, options: s }),
                  r = function () {};
                l.push(o || r);
              }
            }),
            u.update()
          );
        },
        forceUpdate: function () {
          if (!c) {
            var e = a.elements,
              t = e.reference,
              n = e.popper;
            if (Vg(t, n)) {
              (a.rects = {
                reference: Mg(t, tg(n), "fixed" === a.options.strategy),
                popper: Zm(n),
              }),
                (a.reset = false),
                (a.placement = a.options.placement),
                a.orderedModifiers.forEach(function (e) {
                  return (a.modifiersData[e.name] = Object.assign({}, e.data));
                });
              for (var s = 0; s < a.orderedModifiers.length; s++)
                if (true !== a.reset) {
                  var i = a.orderedModifiers[s],
                    o = i.fn,
                    r = i.options,
                    l = undefined === r ? {} : r,
                    d = i.name;
                  "function" == typeof o &&
                    (a =
                      o({ state: a, options: l, name: d, instance: u }) || a);
                } else (a.reset = false), (s = -1);
            }
          }
        },
        update:
          ((i = function () {
            return new Promise(function (e) {
              u.forceUpdate(), e(a);
            });
          }),
          function () {
            return (
              r ||
                (r = new Promise(function (e) {
                  Promise.resolve().then(function () {
                    (r = undefined), e(i());
                  });
                })),
              r
            );
          }),
        destroy: function () {
          d(), (c = true);
        },
      };
    if (!Vg(e, t)) return u;
    function d() {
      l.forEach(function (e) {
        return e();
      }),
        (l = []);
    }
    return (
      u.setOptions(n).then(function (e) {
        !c && n.onFirstUpdate && n.onFirstUpdate(e);
      }),
      u
    );
  };
}
export var Fg = Dg({
  defaultModifiers: [
    dg,
    Bg,
    {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: function (e) {
        var t = e.state,
          n = e.options,
          s = n.gpuAcceleration,
          i = undefined === s || s,
          o = n.adaptive,
          r = undefined === o || o,
          a = n.roundOffsets,
          l = undefined === a || a,
          c = {
            placement: Nm(t.placement),
            variation: ag(t.placement),
            popper: t.elements.popper,
            popperRect: t.rects.popper,
            gpuAcceleration: i,
            isFixed: "fixed" === t.options.strategy,
          };
        null != t.modifiersData.popperOffsets &&
          (t.styles.popper = Object.assign(
            {},
            t.styles.popper,
            cg(
              Object.assign({}, c, {
                offsets: t.modifiersData.popperOffsets,
                position: t.options.strategy,
                adaptive: r,
                roundOffsets: l,
              })
            )
          )),
          null != t.modifiersData.arrow &&
            (t.styles.arrow = Object.assign(
              {},
              t.styles.arrow,
              cg(
                Object.assign({}, c, {
                  offsets: t.modifiersData.arrow,
                  position: "absolute",
                  adaptive: false,
                  roundOffsets: l,
                })
              )
            )),
          (t.attributes.popper = Object.assign({}, t.attributes.popper, {
            "data-popper-placement": t.placement,
          }));
      },
      data: {},
    },
    Hm,
    Ag,
    _g,
    Tg,
    rg,
    Pg,
  ],
});
export var Hg = [];
export var Ng = function (e, t, n) {
  undefined === n && (n = {});
  var s = ym.useRef(null),
    i = {
      onFirstUpdate: n.onFirstUpdate,
      placement: n.placement || "bottom",
      strategy: n.strategy || "absolute",
      modifiers: n.modifiers || Hg,
    },
    o = ym.useState({
      styles: {
        popper: { position: i.strategy, left: "0", top: "0" },
        arrow: { position: "absolute" },
      },
      attributes: {},
    }),
    r = o[0],
    a = o[1],
    l = ym.useMemo(function () {
      return {
        name: "updateState",
        enabled: true,
        phase: "write",
        fn: function (e) {
          var t = e.state,
            n = Object.keys(t.elements);
          a({
            styles: xm(
              n.map(function (e) {
                return [e, t.styles[e] || {}];
              })
            ),
            attributes: xm(
              n.map(function (e) {
                return [e, t.attributes[e]];
              })
            ),
          });
        },
        requires: ["computeStyles"],
      };
    }, []),
    c = ym.useMemo(
      function () {
        var e = {
          onFirstUpdate: i.onFirstUpdate,
          placement: i.placement,
          strategy: i.strategy,
          modifiers: [].concat(i.modifiers, [
            l,
            { name: "applyStyles", enabled: false },
          ]),
        };
        return (0, Ig.default)(s.current, e)
          ? s.current || e
          : ((s.current = e), e);
      },
      [i.onFirstUpdate, i.placement, i.strategy, i.modifiers, l]
    ),
    u = ym.useRef();
  return (
    bm(
      function () {
        u.current && u.current.setOptions(c);
      },
      [c]
    ),
    bm(
      function () {
        if (null != e && null != t) {
          var s = (n.createPopper || Fg)(e, t, c);
          return (
            (u.current = s),
            function () {
              s.destroy(), (u.current = null);
            }
          );
        }
      },
      [e, t, n.createPopper]
    ),
    {
      state: u.current ? u.current.state : null,
      styles: r.styles,
      attributes: r.attributes,
      update: u.current ? u.current.update : null,
      forceUpdate: u.current ? u.current.forceUpdate : null,
    }
  );
};
!(function (e) {
  if (e) {
    var t = {},
      n = e.prototype.stopCallback;
    (e.prototype.stopCallback = function (e, s, i, o) {
      return !!this.paused || (!t[i] && !t[o] && n.call(this, e, s, i));
    }),
      (e.prototype.bindGlobal = function (e, n, s) {
        if ((this.bind(e, n, s), e instanceof Array))
          for (var i = 0; i < e.length; i++) t[e[i]] = true;
        else t[e] = true;
      }),
      e.init();
  }
})("undefined" != typeof Mousetrap ? Mousetrap : undefined);
export var $g = (e) => (null != e ? e : () => {});
export var mostlyHook1 = (e, t, n = {}) => {
  const s = (0, zg.useRef)($g(t));
  (0, zg.useEffect)(() => {
    s.current = $g(t);
  }, [t]),
    (0, zg.useEffect)(() => {
      const { elementRef: t, action: i } = n,
        o = null != t?.current ? (0, Ug.default)(t.current) : Ug.default;
      return (
        e &&
          (n.global && "bindGlobal" in o
            ? o.bindGlobal(e, s.current, i)
            : o.bind(e, s.current, i)),
        () => {
          e && o.unbind(e);
        }
      );
    }, [e]);
};
export var sx;
export var ax = () => {
  const e = (0, react13.useRef)(true);
  return (
    (0, react13.useEffect)(
      () => (
        (e.current = true),
        () => {
          e.current = false;
        }
      ),
      []
    ),
    e
  );
};
export function px({ layer: e = "default", children: t }) {
  const { portals: n } = (0, react14.useContext)(context9),
    s = n[e];
  return s ? (0, ox.createPortal)(t, s) : null;
}
export function hx({ children: e }) {
  return (0, lx.jsx)(px, { children: e });
}
((hx || (hx = {})).Container = ContextWrapper4),
  ((sx = px || (px = {})).Provider = ContextPortalContextProvider),
  (sx.Container = ContextWrapper5);
export var mx = px;

export var wx = (0, hm.createContext)({
  closePopover: () => {
    throw new Error("No Context for Popover provided");
  },
  isOpen: false,
});
export var Cx = PopoverWrapper;
export var _x = {
  heading: "UBQ_Heading-module__heading--DTBrP",
  singleline: "UBQ_Heading-module__singleline--2WkDS",
  multiline: "UBQ_Heading-module__multiline--3XdoA",
  largeTypography: "UBQ_Heading-module__largeTypography--fDsf7",
};
export function Ex({
  children: e,
  start: t = 1,
  level: n,
  typographySize: s = "medium",
  className: i,
  multiline: o,
  ...r
}) {
  const a = `h${Math.min(t + n - 1, 6)}`;
  return (0, Sx.createElement)(
    a,
    {
      className: (0, jx.default)(_x.heading, i, {
        [_x.largeTypography]: "large" === s,
        [_x.singleline]: !o,
        [_x.multiline]: o,
      }),
      ...r,
    },
    e
  );
}

(eb || (eb = {})).Item = Jx;
export var tb = eb;
export var nb = Wx;

export var ob = { block: "UBQ_ColorField-module__block--Du2AZ" };

export var mb = new RegExp(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "i");
export var gb = new RegExp(/[A-Fa-f0-9]{1}/, "g");
export var xb = new RegExp(/[A-Fa-f0-9]{2}/, "g");
export var bb = (e) => {
  const t = e.match(/\((.+)\)/);
  if (!t) return { r: 0, g: 0, b: 0, a: 0 };
  const [, n] = t,
    [s, i, o, r] = n.split(",");
  return {
    r: parseInt(s, 10) / 255,
    g: parseInt(i, 10) / 255,
    b: parseInt(o, 10) / 255,
    a: parseInt(r, 10) / 255,
  };
};
export var yb = (e) => {
  const { r: t, g: n, b: s, a: i } = e;
  return `rgba(${255 * t}, ${255 * n}, ${255 * s}, ${i})`;
};
export var vb = (e) =>
  `linear-gradient(to right, ${e
    .map(
      ({ r: e, g: t, b: n, a: s }) =>
        `rgb(${255 * e}, ${255 * t}, ${255 * n}, ${s})`
    )
    .join(", ")})`;
export var wb = (e, t = false) => {
  const { r: n, g: s, b: i, a: o } = e,
    r = Math.round(255 * n),
    a = Math.round(255 * s),
    l = Math.round(255 * i),
    c = Math.round(255 * o),
    u = (e) => e.toString(16).padStart(2, "0");
  return `#${u(r)}${u(a)}${u(l)}${t ? u(c) : ""}`;
};
export var kb = (e) => {
  const t = (e, t, n, s, i) => ({
    r: parseInt(e, 16) / i,
    g: parseInt(t, 16) / i,
    b: parseInt(n, 16) / i,
    a: undefined === s ? 1 : parseInt(s, 16) / i,
  });
  if (e.startsWith("#")) {
    if (4 === e.length || 5 === e.length) {
      const n = e.match(gb);
      if (n) {
        const [e, s, i, o] = n;
        return t(e, s, i, o, 15);
      }
    }
    if (7 === e.length || 8 === e.length) {
      const n = e.match(xb);
      if (n) {
        const [e, s, i, o] = n;
        return t(e, s, i, o, 255);
      }
    }
  }
  throw new Error(
    'Invalid hex string! Allowed RGB formats are "#FFF" and "#FFFFFF". Allowed RGBA formats are "#FFFF" and "#FFFFFFFF'
  );
};
export var Cb = (e) =>
  ((e) => {
    const { r: t, g: n, b: s } = e;
    return 255 * t * 0.2126 + 255 * n * 0.7152 + 255 * s * 0.0722 > 128;
  })(e)
    ? "rgba(0,0,0,0.9)"
    : "rgba(255,255,255,0.9)";

export var Pb = function ({
  previewColor: e,
  hidePreviewLabel: t,
  customPreviewLabel: n,
  invertedLabel: s,
}) {
  const i = undefined === e || Array.isArray(e) ? e : [e],
    o = i && i.length > 1;
  return (0, Lb.jsx)("div", {
    className: jb,
    children: i?.map((e) => {
      const i = "string" != typeof e,
        r = i ? e : bb(e),
        a = n ?? wb(r).toUpperCase(),
        l = t ? "transparent" : Cb(i ? e : bb(e)),
        c = i ? yb(e) : e;
      return (0, Lb.jsx)(
        "div",
        {
          className: (0, hb.default)(Sb),
          style: { background: c },
          children:
            !o &&
            (0, Lb.jsx)("span", {
              className: (0, hb.default)(_b, { [Eb]: s && !t }),
              style: { color: s && !t ? undefined : l },
              children: a,
            }),
        },
        c
      );
    }),
  });
};

export var Ib = (0, Ab.forwardRef)(function (
  {
    previewColor: e,
    hidePreviewLabel: t,
    customPreviewLabel: n,
    invertedLabel: s,
    hideChevron: i,
    renderChevronIcon: o,
    isOpen: r,
    className: a,
    ...l
  },
  c
) {
  const u =
    o ||
    (() =>
      r ? (0, Fb.jsx)(IconChevronDown, {}) : (0, Fb.jsx)(IconChevronUp, {}));
  return (0, Fb.jsx)(CompCustomButton, {
    ref: c,
    ...l,
    className: (0, fb.default)(Bb, a, Tb),
    children: (0, Fb.jsxs)("div", {
      className: (0, fb.default)(Mb),
      children: [
        (0, Fb.jsx)("div", {
          className: (0, fb.default)({ [Ob]: e, [Rb]: !e }),
          children: "",
        }),
        (0, Fb.jsx)(Pb, {
          previewColor: e,
          hidePreviewLabel: t,
          customPreviewLabel: n,
          invertedLabel: s,
        }),
        (0, Fb.jsx)("div", { className: Db }),
        !i &&
          (0, Fb.jsx)("div", { className: Vb, children: u({ isOpen: !!r }) }),
      ],
    }),
  });
});

export var qb = (0, Nb.forwardRef)(function (
  { children: e, className: t, revealLastOnHover: n },
  s
) {
  return (0, $b.jsx)("div", {
    ref: s,
    className: (0, Hb.default)(Ub, t, { [zb]: n }),
    children: e,
  });
});
qb.displayName = "uikit/ElementStack";
export var Qb = qb;
export var Gb = Qb;

export var iy =
  "UBQ_ColorPreviewField-module__mappedPreviewColorsContainer--qugKf";

export var py = (0, Wb.forwardRef)(function (
  {
    previewColor: e,
    hidePreviewLabel: t,
    customPreviewLabel: n,
    invertedLabel: s,
    isDisabled: i,
    strikeThrough: o,
    donutHole: r,
  },
  a
) {
  const l = undefined === e || Array.isArray(e) ? e : [e],
    c = "string" == typeof l?.[0] ? bb(l[0]) : l?.[0];
  return (0, dy.jsxs)(Gb, {
    ref: a,
    children: [
      (0, dy.jsx)(lb, {
        className: (0, Zb.default)(Xb, { [Jb]: i }),
        children: (0, dy.jsxs)("span", {
          className: ey,
          style: { color: c && Cb(c) },
          children: [
            (0, dy.jsxs)("div", {
              className: (0, Zb.default)(ay, ly),
              children: [
                (0, dy.jsx)("div", {
                  className: (0, Zb.default)(uy, { [cy]: e, [ry]: !e }),
                  children: "",
                }),
                (0, dy.jsx)("div", {
                  className: iy,
                  children: (0, dy.jsx)(Pb, {
                    previewColor: e,
                    hidePreviewLabel: t,
                    customPreviewLabel: n,
                    invertedLabel: s,
                  }),
                }),
                (0, dy.jsx)("div", { className: oy }),
              ],
            }),
            (0, dy.jsx)("div", {
              className: (0, Zb.default)(ty, { [ny]: r }),
            }),
          ],
        }),
      }),
      o && (0, dy.jsx)(Yb, { className: sy }),
    ],
  });
});

export var xy = (0, hy.forwardRef)(function (
  {
    previewColor: e,
    hidePreviewLabel: t,
    customPreviewLabel: n,
    invertedLabel: s,
    isDisabled: i,
    strikeThrough: o,
    donutHole: r,
    children: a,
    ...l
  },
  c
) {
  return (0, gy.jsxs)(CompCustomButton, {
    ref: c,
    variant: "plain",
    className: (0, fy.default)(my, l.className),
    ...l,
    children: [
      (0, gy.jsx)(py, {
        previewColor: e,
        hidePreviewLabel: t,
        customPreviewLabel: n,
        invertedLabel: s,
        isDisabled: i,
        strikeThrough: o,
        donutHole: r,
      }),
      (0, gy.jsx)("span", { children: a }),
    ],
  });
});

export var ky = !!("ontouchstart" in window || navigator.maxTouchPoints > 0);
export var Cy = {
  block: "UBQ_Tooltip-module__block--Y4hJv",
  warning: "UBQ_Tooltip-module__warning--3PMmf",
  error: "UBQ_Tooltip-module__error---gu4D",
};
export var _y = [
  { name: "preventOverflow", options: { padding: 8 } },
  {
    name: "offset",
    options: {
      offset: () => [
        0,
        parseInt(xh("--ubq-scale-base", { fallback: "4px" }), 10),
      ],
    },
  },
  {
    name: "flip",
    options: {
      fallbackPlacements: [
        "bottom-end",
        "bottom-start",
        "top",
        "top-end",
        "top-start",
        "left",
        "left-end",
        "left-start",
        "right",
        "right-end",
        "right-start",
      ],
    },
  },
];
export var Ey = (0, wy.forwardRef)(function (
  { children: e, label: t, placement: n, variant: s = "regular", "data-cy": i },
  o
) {
  const [r] = (0, wy.useState)(yx),
    [a, l] = (0, wy.useState)(null),
    [c, u] = (0, wy.useState)(null),
    [d, p] = (0, wy.useState)(false),
    { styles: f, attributes: h } = Ng(a, c, { placement: n, modifiers: _y });
  (0, wy.useEffect)(() => {
    if (a) {
      const e = (0, vy.default)(() => p(true), 1200, { leading: false }),
        t = () => {
          e.cancel(), p(false);
        },
        n = (t) => {
          t.target.matches(":focus-visible") && e();
        };
      return (
        a.addEventListener("pointerenter", e),
        a.addEventListener("pointerleave", t),
        ky ||
          (a.addEventListener("focusin", n), a.addEventListener("focusout", t)),
        () => {
          e.cancel(),
            a.removeEventListener("pointerenter", e),
            a.removeEventListener("pointerleave", t),
            ky ||
              (a.removeEventListener("focusin", n),
              a.removeEventListener("focusout", t));
        }
      );
    }
    return yy.default;
  }, [a]);
  const m = (0, wy.useMemo)(() => Qg(e.ref, l, o), [e.ref, o]);
  return (0, reactJsx1.jsxs)(reactJsx1.Fragment, {
    children: [
      (0, wy.cloneElement)(e, { ref: m, "aria-describedby": r }),
      (0, reactJsx1.jsx)(DynamicPresenceTransition, {
        children:
          d &&
          (0, reactJsx1.jsx)(hx, {
            children: (0, reactJsx1.jsx)(Sd.div, {
              id: r,
              ref: u,
              style: f.popper,
              ...h.popper,
              transition: { ease: "easeInOut", duration: 0.2 },
              initial: { opacity: 0 },
              animate: { opacity: 1 },
              exit: { opacity: 0 },
              className: (0, by.default)(Cy.block, Cy[s]),
              role: "tooltip",
              "aria-hidden": !d,
              "data-cy": i,
              children: t,
            }),
          }),
      }),
    ],
  });
});
export var Ly = Ey;

export var Ay = function ({
  name: e,
  children: t,
  renderReference: n,
  previewColor: s,
  label: i,
  "aria-label": o,
  onClose: r,
  isDisabled: a,
  isPropertyEnabled: l,
  popoverOptions: c = {},
  closeOnWheel: u,
  hidePreviewLabel: d = false,
  customPreviewLabel: p,
  invertedLabel: f,
  hideChevron: h = false,
  mode: m = "default",
  donutHole: g = false,
}) {
  return "none" === m
    ? (0, Py.jsx)(Py.Fragment, { children: t })
    : (0, Py.jsxs)(PopoverWrapper, {
        ...c,
        onClose: r,
        closeOnWheel: u,
        children: [
          (t, { isOpen: r }) =>
            n
              ? n(t)
              : "minimal" === m
              ? (0, Py.jsx)(Ly, {
                  label: o,
                  children: (0, Py.jsx)(xy, {
                    name: e,
                    "aria-label": o,
                    previewColor: s,
                    hidePreviewLabel: d,
                    customPreviewLabel: p,
                    invertedLabel: f,
                    isDisabled: a || !l,
                    strikeThrough: !l,
                    donutHole: g,
                    ...t,
                    children: i,
                  }),
                })
              : (0, Py.jsx)(Ly, {
                  label: o,
                  children: (0, Py.jsx)(Ib, {
                    name: e,
                    "aria-label": o,
                    previewColor: s,
                    hidePreviewLabel: d,
                    customPreviewLabel: p,
                    invertedLabel: f,
                    isOpen: r,
                    ...t,
                    hideChevron: h,
                    isDisabled: a || !l,
                  }),
                }),
          () => (0, Py.jsx)("div", { children: t }),
        ],
      });
};
export var By = Ay;
export var Ty = Ib;
export var My = xy;

export var Hy = (0, Dy.forwardRef)(({ className: e, ...t }, n) =>
  (0, Iy.jsx)("input", { ...t, className: (0, Vy.default)(Fy, e), ref: n })
);
Hy.displayName = "uikit/BaseInput";
export var Ny = Hy;

export var Gy = (0, Ry.forwardRef)(
  (
    {
      value: e,
      onChange: t,
      onRelease: n,
      isDisabled: s,
      className: i,
      innerLabel: o,
      ...r
    },
    a
  ) => {
    const l = (0, Ry.useRef)(e);
    return (0, Qy.jsxs)("div", {
      className: (0, Oy.default)(Uy, { [zy]: !!o }),
      children: [
        (0, Qy.jsx)(Ny, {
          ref: a,
          type: "text",
          value: e,
          onChange: (e) => {
            t && t(e.currentTarget.value);
          },
          onBlur: (e) => {
            const t = e.currentTarget.value;
            n && t !== l.current && (n(t), (l.current = t));
          },
          disabled: s,
          className: (0, Oy.default)($y, i),
          ...r,
        }),
        o && (0, Qy.jsx)("span", { className: qy, children: o }),
      ],
    });
  }
);
Gy.displayName = "uikit/TextInput";
export var Zy = Gy;

export var Yy = function ({
  value: e,
  onChange: t,
  onRelease: n,
  "aria-label": s,
  innerLabel: i,
  ...o
}) {
  const [r, a] = (0, Wy.useState)(wb(e).replace("#", "")),
    l = (0, Wy.useRef)(r);
  return (
    (0, Wy.useEffect)(() => {
      if (!r.match(/^([A-Fa-f0-9]{3})$/i)) {
        const t = wb(e).replace("#", "");
        a(t);
      }
    }, [e]),
    (0, Ky.jsx)(Zy, {
      value: r.toUpperCase(),
      onChange: (e) => {
        if (e.match(/^[A-Fa-f0-9]{0,6}$/i)) {
          a(e);
          const s = `#${e}`;
          if (((n = s), mb.test(n))) {
            const e = kb(s);
            t(e);
          }
        }
        var n;
      },
      onBlur: function () {
        let e = r;
        r.match(/^([A-Fa-f0-9]{3})$/i) || r.match(/^([A-Fa-f0-9]{6})$/i)
          ? r.match(/^([A-Fa-f0-9]{3})$/i) && ((e = `${r}${r}`), a(e))
          : ((e = l.current), a(e));
        const t = `#${e}`;
        if (n && e !== l.current) {
          const s = kb(t);
          n(s), (l.current = e);
        }
      },
      "aria-label":
        "function" == typeof s
          ? s(
              ((c = r),
              c
                .replace("#", "")
                .split("")
                .map((e) => `${e}.`)
                .join(""))
            )
          : s,
      ...o,
      innerLabel: i,
    })
  );
  var c;
};
export var Xy = mostlyHook1;

export function ov(e) {
  const t = (0, iv.useRef)(e);
  t.current = e;
  const n = (0, iv.useCallback)((...e) => t.current(...e), []);
  return t.current ? n : t.current;
}
export function rv(e, t) {
  const [n, s] = (0, sv.useState)(() => e?.getBoundingClientRect()),
    i = ov(t);
  return (
    (0, sv.useLayoutEffect)(
      () =>
        e
          ? (function (e, t) {
              const n = new Set();
              if (window.ResizeObserver) {
                const s = new ResizeObserver(([e]) => {
                  const s = setTimeout(function () {
                    n.delete(s);
                    const i = e.target.getBoundingClientRect();
                    t(i);
                  }, 0);
                  n.add(s);
                });
                return (
                  s.observe(e),
                  () => {
                    s.disconnect();
                    for (const e of n) clearTimeout(e);
                    n.clear();
                  }
                );
              }
              {
                const n = () => {
                  const n = e.getBoundingClientRect();
                  t(n);
                };
                return (
                  window.addEventListener("resize", n),
                  t(e.getBoundingClientRect()),
                  () => {
                    window.removeEventListener("resize", n);
                  }
                );
              }
            })(e, (e) => {
              s(e), i?.(e);
            })
          : () => {},
      [e, i]
    ),
    n
  );
}
export var av = "UBQ_SaturationBrightnessSelector-module__block--RHwQ8";

export var pv = (e, t, n) => ({
  width: e.width - t,
  height: e.height - t,
  widthPlus: e.width - t + 2 * n,
  heightPlus: e.height - t + 2 * n,
});
export var fv = function ({
  value: e,
  onChange: t,
  className: n,
  onRelease: s,
  "aria-label": i,
  isDisabled: o = false,
}) {
  const [r, a] = (0, tv.useState)(null),
    [l, c] = (0, tv.useState)(),
    [u, d] = (0, tv.useState)(12);
  (0, tv.useLayoutEffect)(() => {
    l && d(l.getBoundingClientRect().width);
  }, [l]);
  const p = u / 2,
    f = u / 2,
    { h: h, s: m, v: g } = e,
    [x, b] = (0, tv.useState)({ x: 0, y: 0 }),
    y = rv(r, (e) => {
      if (r) {
        const { widthPlus: t, heightPlus: n } = pv(e, u, p);
        b({ x: m * t - p, y: n - g * n - p });
      }
    }) ?? { width: 0, height: 0 },
    v = (n, s) => {
      if (!r) return;
      const { width: i, height: o, widthPlus: a, heightPlus: l } = pv(y, u, p),
        c = Math.max(Math.min(n, i + p), -p),
        d = Math.max(Math.min(s, o + p), -p);
      b({ x: c, y: d });
      const f = (c + p) / a,
        h = (l - (d + p)) / l;
      t({ h: e.h, s: f, v: h });
    },
    w = (0, tv.useMemo)(() => ({ current: r }), [r]);
  Xy(["up"], () => (v(x.x, x.y - 5), false), { elementRef: w }),
    Xy(["down"], () => (v(x.x, x.y + 5), false), { elementRef: w }),
    Xy(["left"], () => (v(x.x - 5, x.y), false), { elementRef: w }),
    Xy(["right"], () => (v(x.x + 5, x.y), false), { elementRef: w });
  const k = {
    "--ubq_internal-SaturationBrightnessSelector-current-hue": 360 * h,
  };
  return (0, dv.jsx)("div", {
    className: (0, ev.default)(av, n, { [lv]: o }),
    "aria-live": "assertive",
    "aria-label": i,
    children: (0, dv.jsx)(nv.DraggableCore, {
      "aria-live": "off",
      onStart: (e, t) => {
        const n = t.x - f,
          s = t.y - f;
        v(n, s);
      },
      onDrag: (e, t) => {
        const n = t.x - f,
          s = t.y - f;
        v(n, s);
      },
      onStop: s,
      children: (0, dv.jsx)("div", {
        ref: a,
        className: cv,
        style: k,
        tabIndex: o ? -1 : 0,
        "data-cy": "saturationBrightnessSelector",
        children: (0, dv.jsx)("div", {
          "data-cy": "saturationBrightnessSelectorThumb",
          ref: c,
          className: uv,
          style: {
            transform: `translate(${x.x}px, ${x.y}px)`,
            backgroundColor: Jy.default.hsv(360 * h, m, g).hex(),
          },
        }),
      }),
    }),
  });
};
export function yv(e, t) {
  const n = ov(e),
    s = (0, bv.useRef)(),
    i = (0, bv.useRef)(false),
    o = (0, bv.useRef)(t),
    r = (0, bv.useRef)(0),
    a = (0, bv.useCallback)(() => {
      i.current &&
        null != o.current &&
        (clearTimeout(s.current),
        (i.current = false),
        (o.current -= Date.now() - r.current),
        (r.current = 0));
    }, []),
    l = (0, bv.useCallback)(() => {
      i.current ||
        null == o.current ||
        ((i.current = true),
        (r.current = Date.now()),
        (s.current = setTimeout(() => {
          n?.();
        }, o.current)));
    }, [n]);
  return (
    (0, bv.useEffect)(
      () =>
        null != t && null != n
          ? ((s.current = setTimeout(() => {
              n();
            }, t)),
            (i.current = true),
            (o.current = t),
            (r.current = Date.now()),
            () => {
              clearTimeout(s.current);
            })
          : xv.default,
      [t, n]
    ),
    { pause: a, resume: l }
  );
}
export var vv = {
  block: "UBQ_Notification-module__block--4Z2nM",
  wrapper: "UBQ_Notification-module__wrapper--TKM4E",
  info: "UBQ_Notification-module__info--0vbWO",
  warning: "UBQ_Notification-module__warning--L3tCn",
  success: "UBQ_Notification-module__success--nA06c",
  error: "UBQ_Notification-module__error--9aKAb",
  icon: "UBQ_Notification-module__icon--B9gKp",
  spinner: "UBQ_Notification-module__spinner--VdgnF",
  content: "UBQ_Notification-module__content--1fjU2",
  dismissButton: "UBQ_Notification-module__dismissButton--MdgFs",
  actionButton: "UBQ_Notification-module__actionButton--pmf8l",
  notificationContainer:
    "UBQ_Notification-module__notificationContainer--NKdiI",
};

export var kv = {
  initial: { opacity: 0, transform: "translate3d(-30%, 0px, 0px)" },
  enter: { opacity: 1, transform: "translate3d(0%, 0px, 0px)" },
  exit: { opacity: 0 },
};
export var Cv = {
  Container: function ({ children: e }) {
    return (0, wv.jsx)("div", {
      "aria-live": "polite",
      role: "region",
      className: vv.notificationContainer,
      children: (0, wv.jsx)(DynamicPresenceTransition, { children: e }),
    });
  },
  Item: function ({
    children: e,
    onClick: t,
    "data-cy": n,
    type: s = "info",
    loading: i = false,
    action: o,
    name: r,
    ariaLabelCloseButton: a,
    timeoutAction: l,
    timeoutDelay: c,
  }) {
    const { pause: u, resume: d } = yv(l, c);
    return (0, wv.jsx)(Sd.div, {
      layout: true,
      layoutId: r,
      transition: { ease: [0.2, 0, 0, 1], duration: 0.3 },
      variants: kv,
      initial: "initial",
      animate: "enter",
      exit: "exit",
      children: (0, wv.jsxs)("div", {
        className: (0, gv.default)(vv.block, vv[s]),
        "data-cy": n || r,
        onMouseEnter: u,
        onMouseLeave: d,
        children: [
          i &&
            (0, wv.jsx)("div", {
              className: vv.icon,
              children: (0, wv.jsx)(Hh, {
                className: vv.spinner,
                strokeWidth: 2,
              }),
            }),
          (0, wv.jsxs)("div", {
            className: vv.wrapper,
            children: [
              (0, wv.jsx)("div", { className: vv.content, children: e }),
              (0, wv.jsx)(CompCustomButton, {
                className: vv.dismissButton,
                onClick: t,
                variant: "plain",
                name: "closeNotificationItem",
                "aria-label": a,
                children: (0, wv.jsx)(mv, {}),
              }),
              o &&
                (0, wv.jsx)(CompCustomButton, {
                  className: vv.actionButton,
                  onClick: o.onClick,
                  name: "closeNotificationItem",
                  "aria-label": a,
                  children: o.label,
                }),
            ],
          }),
        ],
      }),
    });
  },
};
export var jv = Cv;
export var Sv = Ux;

export var Lv = function ({
  className: e,
  name: t,
  label: n,
  children: s,
  isDisabled: i = false,
}) {
  const o = (0, _v.default)(`UBQ_input-${t.replace(" ", "-")}-`);
  return (0, Ev.jsxs)(Ev.Fragment, {
    children: [
      (0, Ev.jsx)(Ux, {
        className: e,
        labelFor: o,
        isDisabled: i,
        children: n,
      }),
      (0, Ev.jsx)(Ev.Fragment, { children: s({ id: o, name: t }) }),
    ],
  });
};
export var Pv = Lv;

export var Ov = (0, Bv.forwardRef)(
  (
    { value: e, onChange: t, onRelease: n, isDisabled: s, className: i, ...o },
    r
  ) => {
    const a = (0, Bv.useRef)(e);
    return (0, Mv.jsx)("textarea", {
      ref: r,
      value: e,
      onChange: (e) => {
        t && t(e.currentTarget.value);
      },
      onBlur: (e) => {
        const t = e.currentTarget.value;
        n && t !== a.current && (n(t), (a.current = t));
      },
      disabled: s,
      className: (0, Av.default)(Tv),
      ...o,
    });
  }
);
Ov.displayName = "uikit/TextArea";
export var Rv = Ov;

export var Fv = (e, t) => (null == e ? "" : (+e.toFixed(t)).toString());
export function Iv(e, t) {
  return undefined === e || undefined === t
    ? e
    : (function (e, t) {
        if (0 === t) return e;
        const n = Math.abs(e % t),
          s = Math.abs(t) - n,
          i = s < n ? s : -n;
        return e + Math.sign(e) * i;
      })(parseFloat(e.toString()), parseFloat(t.toString()));
}
export var Hv = {
  block: "UBQ_NumberInput-module__block--y1ECY",
  input: "UBQ_NumberInput-module__input--6EI9x",
  overlay: "UBQ_NumberInput-module__overlay--6SA7a",
  inputUnit: "UBQ_NumberInput-module__inputUnit--ZZ19t",
  withButtonSpace: "UBQ_NumberInput-module__withButtonSpace--7gj--",
  minimumWidth: "UBQ_NumberInput-module__minimumWidth--OHmtt",
  overlayUnit: "UBQ_NumberInput-module__overlayUnit--z5CDz",
  overlayValue: "UBQ_NumberInput-module__overlayValue--1B-lc",
  disabled: "UBQ_NumberInput-module__disabled--aPTGR",
};

export var Uv = (0, Dv.forwardRef)(function (
  {
    value: e,
    onChange: t,
    onRelease: n,
    step: s = 1,
    maxFractionDigits: i = 2,
    stepFromZero: o = true,
    isDisabled: r,
    className: a,
    tooltipLabel: l,
    unitLabel: c,
    unitLabelWithButtonSpace: u = false,
    formatLabel: d,
    min: p,
    max: f,
    inlineIcon: h,
    dynamicWidth: m = false,
    ...g
  },
  x
) {
  const b = (0, Dv.useRef)(false),
    y = (0, Dv.useRef)(parseFloat(Fv(e, i))),
    v = (0, Dv.useRef)(null),
    [w, k] = (0, Dv.useState)(Fv(e, i)),
    C = (0, Dv.useCallback)(
      (e) => {
        const t = Fv(e, i);
        k((e) => (e !== t ? t : e));
      },
      [i, k]
    );
  (0, Dv.useEffect)(() => {
    b.current || C(e);
  }, [e, C]),
    (0, Dv.useEffect)(() => {
      w && (y.current = parseFloat(w));
    }, [w]);
  const j = (t) => {
      if (t) {
        const s = ((e, t) => {
          const n = "string" == typeof t.min ? parseInt(t.min, 10) : t.min,
            s = "string" == typeof t.max ? parseInt(t.max, 10) : t.max;
          let i = e;
          return (
            undefined !== n && (i = Math.max(n, i)),
            undefined !== s && (i = Math.min(s, i)),
            i
          );
        })(parseFloat(t), { min: p, max: f });
        n && v.current !== s && (n(s), (v.current = s)), C(e);
      } else
        k(`${y.current}`),
          n &&
            v.current !== y.current &&
            (n(y.current), (v.current = y.current));
      v.current = null;
    },
    S = (0, Dv.useRef)(undefined);
  (0, Dv.useEffect)(() => {
    if (m && f) {
      const e = parseFloat(f.toString());
      S.current = `${Fv(e, i).length}ch`;
    } else S.current = undefined;
  }, []);
  const _ = {
      ref: x,
      type: "number",
      step: s,
      value: w,
      onChange: (e) => {
        ((e) => {
          if (t)
            if (e) {
              k(e);
              const n = parseFloat(e);
              t(n);
            } else k(""), t(y.current);
        })(e.currentTarget.value);
      },
      disabled: r,
      min: o ? Iv(p, "any" === s ? 1 : s) : p,
      max: f,
      ...g,
      style: {
        ...g?.style,
        "--ubq_internal-numberInput-valueCharacterCount": S.current,
      },
      onFocus: (t) => {
        (v.current = e), (b.current = true), g.onFocus && g.onFocus(t);
      },
      onBlur: (e) => {
        (b.current = false), g.onBlur && g.onBlur(e), j(e.currentTarget.value);
      },
    },
    E = {
      "--ubq_internal-NumberInput-unitLabel-length": `${c?.length}ch` ?? 0,
    },
    L = (0, Nv.jsxs)("div", {
      className: (0, Vv.default)(Hv.block, {
        [Hv.disabled]: r,
        [Hv.withInnerLabel]: !!c,
        [Hv.withInnerLabelIncludingButton]: u,
      }),
      style: E,
      children: [
        (0, Nv.jsx)(Ny, {
          ..._,
          className: (0, Vv.default)(Hv.input, a, {
            [Hv.withButtonSpace]: u,
            [Hv.minimumWidth]: m,
          }),
        }),
        c &&
          (0, Nv.jsx)("span", {
            className: (0, Vv.default)(Hv.inputUnit, {
              [Hv.withButtonSpace]: u,
            }),
            children: c,
          }),
        (0, Nv.jsxs)("span", {
          className: (0, Vv.default)(Hv.overlay),
          "aria-hidden": true,
          children: [
            (0, Nv.jsx)("span", { className: Hv.overlayValue, children: w }),
            (0, Nv.jsx)("span", {
              className: (0, Vv.default)(Hv.overlayUnit, {
                [Hv.withButtonSpace]: u,
              }),
              children: c,
            }),
          ],
        }),
      ],
    });
  return l ? (0, Nv.jsx)(Ly, { label: l, children: L }) : L;
});
export var zv = Uv;

"undefined" != typeof window && window.Math == Math
  ? window
  : "undefined" != typeof self && self.Math == Math && self;
export function Yv() {
  return !(
    "undefined" == typeof window ||
    !window.document ||
    !window.document.createElement
  );
}
export function Xv() {}
export function Jv() {
  return (
    (Jv =
      Object.assign ||
      function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    Jv.apply(this, arguments)
  );
}
export function ew(e, t, n) {
  var s,
    i,
    o,
    r =
      ((s = (0, Wv.useState)(Object.create(null))[1]),
      (0, Wv.useCallback)(function () {
        s(Object.create(null));
      }, [])),
    a = (0, Zv.useContext)(t),
    l = a.registerDescendant,
    c = a.unregisterDescendant,
    u = a.descendants,
    d =
      null != n
        ? n
        : u.findIndex(function (t) {
            return t.element === e.element;
          }),
    p =
      ((i = u),
      (o = (0, Wv.useRef)(null)),
      (0, Wv.useEffect)(
        function () {
          o.current = i;
        },
        [i]
      ),
      o.current),
    f = u.some(function (e, t) {
      var n;
      return (
        e.element !==
        (null == p || null === (n = p[t]) || undefined === n
          ? undefined
          : n.element)
      );
    });
  return (
    Kv(function () {
      return (
        e.element || r(),
        l(Jv({}, e, { index: d })),
        function () {
          return c(e.element);
        }
      );
    }, [r, d, l, f, c].concat(Object.values(e))),
    d
  );
}
export function tw(e) {
  var t = e.context,
    n = e.children,
    s = e.items,
    i = e.set,
    o = (0, Zv.useCallback)(function (e) {
      var t = e.element,
        n = e.index,
        s = (function (e, t) {
          if (null == e) return {};
          var n,
            s,
            i = {},
            o = Object.keys(e);
          for (s = 0; s < o.length; s++)
            (n = o[s]), t.indexOf(n) >= 0 || (i[n] = e[n]);
          return i;
        })(e, ["element", "index"]);
      t &&
        i(function (e) {
          var i;
          if (null != n)
            i = [].concat(e, [Jv({}, s, { element: t, index: n })]);
          else if (0 === e.length)
            i = [].concat(e, [Jv({}, s, { element: t, index: 0 })]);
          else if (
            e.find(function (e) {
              return e.element === t;
            })
          )
            i = e;
          else {
            var o = e.findIndex(function (e) {
                return (
                  !(!e.element || !t) &&
                  Boolean(
                    e.element.compareDocumentPosition(t) &
                      Node.DOCUMENT_POSITION_PRECEDING
                  )
                );
              }),
              r = Jv({}, s, { element: t, index: o });
            i =
              -1 === o
                ? [].concat(e, [r])
                : [].concat(e.slice(0, o), [r], e.slice(o));
          }
          return i.map(function (e, t) {
            return Jv({}, e, { index: t });
          });
        });
    }, []),
    r = (0, Zv.useCallback)(function (e) {
      e &&
        i(function (t) {
          return t.filter(function (t) {
            return e !== t.element;
          });
        });
    }, []);
  return (0, Zv.createElement)(
    t.Provider,
    {
      value: (0, Zv.useMemo)(
        function () {
          return {
            descendants: s,
            registerDescendant: o,
            unregisterDescendant: r,
          };
        },
        [s, o, r]
      ),
    },
    n
  );
}
export var nw;

export var rw = {
  options: "UBQ_ListBox-module__options--QXJ8g",
  option: "UBQ_ListBox-module__option--eAH8y",
  loading: "UBQ_ListBox-module__loading--9tdIb",
  loadingAnimation: "UBQ_ListBox-module__loadingAnimation--hrq-v",
};
export var aw = 0;
export var lw = () => `UBQ__select-option-${(aw += 1)}`;
export var cw = (e, t) => `${t}-${e}`;

export var dw =
  (undefined === nw && (nw = {}),
  (function (e, t) {
    var n = (0, Wv.createContext)(t);
    return (n.displayName = e), n;
  })(
    "DescendantContext",
    Jv(
      { descendants: [], registerDescendant: Xv, unregisterDescendant: Xv },
      nw
    )
  ));
export var pw = (0, ow.createContext)({
  value: "",
  select: () => {
    throw new Error("No Context for ListBox provided");
  },
  activeIndex: -1,
  setActiveIndex: () => {
    throw new Error("No Context for ListBox provided");
  },
  idPrefix: "",
  scrollTo: () => {
    throw new Error("No Context for scrollTo provided");
  },
});
export var fw;
export var hw = {
  Container: function (e) {
    const {
        value: t,
        onClose: n,
        onChange: s,
        children: i,
        className: o,
        "data-ubq-id": r,
        ...a
      } = e,
      [l, c] = (0, Zv.useState)([]),
      [u, d] = (0, ow.useState)(-1),
      p = (0, ow.useRef)(null),
      f = (0, ow.useCallback)(
        (e, t) => {
          s(e), d(t), n && n();
        },
        [s, n]
      );
    (0, ow.useEffect)(() => {
      const e = l.findIndex((e) =>
        "object" == typeof t ? (0, iw.default)(e.value, t) : e.value === t
      );
      e !== u && d(e);
    }, [t]);
    const h = (0, ow.useCallback)(
      (e, t = false) => {
        if (p.current) {
          const n = p.current,
            s = l[e]?.element;
          if (s && p.current) {
            const e =
              ("static" !== getComputedStyle(n).position
                ? s.offsetTop
                : s.offsetTop - n.offsetTop) -
              n.clientHeight / 2 +
              s.offsetHeight;
            p.current.scrollTo
              ? p.current.scrollTo({
                  behavior: t ? "smooth" : "auto",
                  top: Math.max(e, 0),
                })
              : p.current.scrollIntoView();
          }
        }
      },
      [l]
    );
    mostlyHook1(
      ["down"],
      () => (
        d((e) => {
          const t = Math.min(e + 1, l.length - 1);
          return e !== t && h(t, true), t;
        }),
        false
      ),
      { elementRef: p }
    ),
      mostlyHook1(
        ["up"],
        () => (
          d((e) => {
            const t = Math.max(e - 1, 0);
            return e !== t && h(t, true), t;
          }),
          false
        ),
        { elementRef: p }
      ),
      mostlyHook1(
        ["tab", "shift+tab"],
        () => {
          n && n();
        },
        { elementRef: p }
      ),
      mostlyHook1(["space", "enter"], () => (f(l[u].value, u), false), {
        elementRef: p,
      });
    const m = (0, ow.useMemo)(lw, []),
      g = (0, ow.useMemo)(
        () => ({
          value: t,
          select: f,
          activeIndex: u,
          setActiveIndex: d,
          idPrefix: m,
          scrollTo: h,
        }),
        [u, m, h, f, t]
      );
    return (0, uw.jsx)(tw, {
      context: dw,
      items: l,
      set: c,
      children: (0, uw.jsx)(pw.Provider, {
        value: g,
        children: (0, uw.jsx)("ul", {
          ref: p,
          role: "listbox",
          tabIndex: 0,
          className: (0, sw.default)(rw.options, o),
          "data-ubq-id": r,
          "aria-activedescendant": u > -1 ? cw(u, m) : undefined,
          ...a,
          children: i,
        }),
      }),
    });
  },
  Option: function ({
    children: e,
    className: t,
    value: n,
    "data-value": s,
    isLoading: i,
    icon: o,
    ...r
  }) {
    const a = (0, ow.useRef)(null),
      {
        activeIndex: l,
        setActiveIndex: c,
        value: u,
        select: d,
        idPrefix: p,
        scrollTo: f,
      } = (0, ow.useContext)(pw),
      h = ew({ element: a.current, value: n }, dw),
      m = cw(h, p),
      g = l === h,
      x = (0, iw.default)(u, n);
    return (
      (0, ow.useEffect)(() => {
        x && c((e) => (-1 === e ? (f(h), h) : e));
      }, [h]),
      (0, uw.jsxs)("li", {
        id: m,
        ref: a,
        role: "option",
        "aria-selected": x,
        "data-selected": x,
        "data-active": g,
        "data-value": s,
        onClick: () => {
          d(n, h);
        },
        className: (0, sw.default)(rw.option, t, {
          [rw.loading]: i,
          [rw.selected]: x,
          [rw.active]: g,
        }),
        ...r,
        children: [
          o,
          (0, uw.jsx)("span", {
            children:
              "function" == typeof e ? e({ isActive: g, isSelected: x }) : e,
          }),
        ],
      })
    );
  },
};
export var mw = {
  block: "UBQ_Select-module__block--jJ2Mf",
  optionsContainer: "UBQ_Select-module__optionsContainer--ofxOA",
  empty: "UBQ_Select-module__empty--N2A4N",
};

export function xw({ children: e, ...t }) {
  return (0, gw.jsx)(Cx, { ...t, children: e });
}
((fw = xw || (xw = {})).Options = function ({
  children: e,
  className: t,
  ...n
}) {
  const { closePopover: s } = (0, Gv.useContext)(wx);
  return (0, gw.jsx)(hw.Container, {
    ...n,
    onClose: s,
    className: (0, Qv.default)(mw.block, t),
    children: e,
  });
}),
  (fw.Option = function ({ children: e, className: t, ...n }) {
    return (0, gw.jsx)(hw.Option, {
      ...n,
      className: (0, Qv.default)(mw.selectOption, t),
      children: e,
    });
  }),
  (fw.Async = function ({ children: e, fetchValues: t, ...n }) {
    const [s, i] = (0, Gv.useState)([]),
      [o, r] = (0, Gv.useState)("waiting"),
      [a, l] = e;
    return (0, gw.jsxs)(Cx, {
      ...n,
      disableFocusTrap: "success" !== o || 0 === s.length,
      onOpen: ({ forceUpdate: e }) => {
        r("waiting"),
          t()
            .then((t) => {
              i(t), r("success"), e?.();
            })
            .catch(() => {
              r("error");
            });
      },
      children: [
        a,
        () =>
          (0, gw.jsx)(
            "div",
            {
              className: mw.optionsContainer,
              children: (0, gw.jsx)(zh, {
                asyncState: o,
                showCircularSpinner: true,
                children:
                  s.length > 0
                    ? l({ values: s })
                    : (0, gw.jsx)("div", {
                        className: mw.empty,
                        children: (0, gw.jsx)(qv, {}),
                      }),
              }),
            },
            "async-select"
          ),
      ],
    });
  });
export var bw = xw;

export var jw = function ({ className: e, orientation: t = "horizontal" }) {
  return (0, Cw.jsx)("hr", {
    className: (0, ww.default)(kw, e),
    "aria-orientation": t,
  });
};
export var Sw = jw;
export var _w = {
  block: "UBQ_NumberSelectInput-module__block--W6-1L",
  numberInput: "UBQ_NumberSelectInput-module__numberInput--hazaB",
  numberSelectInputReference:
    "UBQ_NumberSelectInput-module__numberSelectInputReference--Yy6Ao",
  numberSelectOption: "UBQ_NumberSelectInput-module__numberSelectOption--dN6Rv",
};

export function Lw({ children: e, tooltip: t }) {
  return t
    ? (0, Ew.jsx)(Ly, { label: t, children: e })
    : (0, Ew.jsx)(Ew.Fragment, { children: e });
}
export function Pw({
  value: e,
  onChange: t,
  onRelease: n,
  className: s,
  options: i,
  selectedOption: o,
  isDisabled: r,
  children: a,
  ...l
}) {
  const c = (0, vw.useRef)(e);
  return (0, Ew.jsxs)("div", {
    className: (0, yw.default)(_w.block, s),
    children: [
      "number" != typeof e || a
        ? a
          ? (0, Ew.jsx)(Lw, { tooltip: l["aria-label"], children: a })
          : null
        : (0, Ew.jsx)(Lw, {
            tooltip: l["aria-label"],
            children: (0, Ew.jsx)(zv, {
              value: e,
              onChange: t,
              onRelease: n,
              className: (0, yw.default)(_w.numberInput),
              isDisabled: r,
              unitLabelWithButtonSpace: true,
              ...l,
            }),
          }),
      (0, Ew.jsxs)(bw, {
        placement: "bottom",
        doubleOffset: true,
        children: [
          (e, { isOpen: t }) =>
            (0, Ew.jsx)(CompCustomButton, {
              name: "numberSelectInputReference",
              className: _w.numberSelectInputReference,
              isDisabled: r,
              "aria-label": l["aria-label"],
              "aria-labelledby": l["aria-labelledby"],
              ...e,
              children: t
                ? (0, Ew.jsx)(IconChevronDown, {})
                : (0, Ew.jsx)(IconChevronUp, {}),
            }),
          () =>
            (0, Ew.jsx)(bw.Options, {
              value: o,
              onChange: (e) => {
                null != e &&
                  (t(e.value),
                  n &&
                    e.value !== c.current &&
                    (n(e.value), (c.current = e.value)));
              },
              children: i.reduce((e, t) => {
                const { value: n, label: s, separate: i } = t,
                  o = e.concat(
                    (0, Ew.jsx)(
                      bw.Option,
                      {
                        value: t,
                        children: (0, Ew.jsx)("div", {
                          className: _w.numberSelectOption,
                          children: s || n,
                        }),
                      },
                      n
                    )
                  );
                return (
                  i &&
                    o.push(
                      (0, Ew.jsx)(
                        Sw,
                        { className: _w.separator },
                        `separator-${n}`
                      )
                    ),
                  o
                );
              }, []),
            }),
        ],
      }),
    ],
  });
}
export var Aw = function ({
  value: e,
  onChange: t,
  onRelease: n,
  className: s,
  options: i,
  selectedOption: o,
  isDisabled: r,
  ...a
}) {
  const l = (0, vw.useRef)(e);
  return (0, Ew.jsxs)("div", {
    className: (0, yw.default)(_w.block, s),
    children: [
      (0, Ew.jsx)(Lw, {
        tooltip: a["aria-label"],
        children: (0, Ew.jsx)(zv, {
          value: e,
          onChange: t,
          onRelease: n,
          className: (0, yw.default)(_w.numberInput),
          isDisabled: r,
          unitLabelWithButtonSpace: true,
          ...a,
        }),
      }),
      (0, Ew.jsxs)(bw, {
        placement: "bottom",
        doubleOffset: true,
        children: [
          (e, { isOpen: t }) =>
            (0, Ew.jsx)(CompCustomButton, {
              name: "numberSelectInputReference",
              className: _w.numberSelectInputReference,
              isDisabled: r,
              "aria-label": a["aria-label"],
              "aria-labelledby": a["aria-labelledby"],
              ...e,
              children: t
                ? (0, Ew.jsx)(IconChevronDown, {})
                : (0, Ew.jsx)(IconChevronUp, {}),
            }),
          () =>
            (0, Ew.jsx)(bw.Options, {
              value: o,
              onChange: (e) => {
                null != e &&
                  (t(e.value),
                  n &&
                    e.value !== l.current &&
                    (n(e.value), (l.current = e.value)));
              },
              children: i.map((e) => {
                const { value: t, label: n } = e;
                return (0, Ew.jsx)(
                  bw.Option,
                  {
                    value: e,
                    children: (0, Ew.jsx)("div", {
                      className: _w.numberSelectOption,
                      children: n || t,
                    }),
                  },
                  t
                );
              }),
            }),
        ],
      }),
    ],
  });
};
export var Bw = {
  block: "UBQ_Progress-module__block--wCo-k",
  indeterminateProgress: "UBQ_Progress-module__indeterminateProgress--jzouT",
  indeterminateProgressFill:
    "UBQ_Progress-module__indeterminateProgressFill---QtbY",
  indeterminate: "UBQ_Progress-module__indeterminate--wtGuM",
};

export function Mw({
  variant: e = Mw.Variant.Determinate,
  max: t = 100,
  value: n,
}) {
  return (0, Tw.jsx)("div", {
    className: Bw.block,
    children:
      e === Mw.Variant.Indeterminate
        ? (0, Tw.jsx)("div", {
            className: Bw.indeterminateProgress,
            children: (0, Tw.jsx)("div", {
              className: Bw.indeterminateProgressFill,
            }),
          })
        : (0, Tw.jsx)("progress", {
            className: Bw.determinate,
            max: t,
            value: n,
          }),
  });
}
((e) => {
  let t;
  var n;
  ((n = t = e.Variant || (e.Variant = {})).Indeterminate = "indeterminate"),
    (n.Determinate = "determinate");
})(Mw || (Mw = {}));

export function $w(e, t = 100) {
  return `${Math.round((e / t) * 100)}%`;
}
export var qw = {
  block: "UBQ_Dialog-module__block--8gEdi",
  dialog: "UBQ_Dialog-module__dialog--WDrz1",
  body: "UBQ_Dialog-module__body--22mCq",
  icon: "UBQ_Dialog-module__icon--YAfsD",
  info: "UBQ_Dialog-module__info--caS5k",
  success: "UBQ_Dialog-module__success--atH2l",
  warning: "UBQ_Dialog-module__warning--Ney-j",
  error: "UBQ_Dialog-module__error--vCixT",
  content: "UBQ_Dialog-module__content--AKXLs",
  footer: "UBQ_Dialog-module__footer--0RwTK",
};

export function Gw({ children: e }) {
  return (0, Qw.jsx)("div", {
    className: (0, Uw.default)(qw.content),
    children: e,
  });
}
export function Zw({ type: e, progress: t }) {
  let n;
  switch (e) {
    case "info":
      n = (0, Qw.jsx)(Dw, {});
      break;
    case "success":
      n = (0, Qw.jsx)(Iw, {});
      break;
    case "warning":
      n = (0, Qw.jsx)(Nw, {});
      break;
    case "error":
      n = (0, Qw.jsx)(Rw, {});
      break;
    case "loading":
      n = (0, Qw.jsx)(Hh, { ...Kw(t) });
      break;
    default:
      return null;
  }
  return (0, Qw.jsx)("div", { className: qw.icon, children: n });
}
export function Ww({
  children: e,
  show: t,
  "data-cy": n,
  onClose: s,
  type: i = "regular",
  size: o = "regular",
  "aria-label": r,
  clickOutsideToClose: a = true,
  footer: l,
  className: c,
  progress: u = 0,
}) {
  const d = (0, zw.useRef)(null);
  mostlyHook1(["esc"], s ?? null, { elementRef: d });
  return (0, Qw.jsx)(DynamicPresenceTransition, {
    children:
      t &&
      (0, Qw.jsx)(ClickOutsideContextProvider, {
        onClickOutside: (e) => {
          e.isOutside(d.current) && a ? s?.() : e.stopPropagation();
        },
        children: (0, Qw.jsx)(Sd.div, {
          transition: { type: "spring", duration: 0.3 },
          variants: { exit: { opacity: 0 }, enter: { opacity: 1 } },
          initial: "exit",
          animate: "enter",
          exit: "exit",
          className: (0, Uw.default)(qw.block),
          "data-cy": n,
          onClick: (e) => {
            e.stopPropagation();
          },
          children: (0, Qw.jsx)(um, {
            focusTrapOptions: {
              escapeDeactivates: false,
              fallbackFocus: `.${qw.dialog}`,
              allowOutsideClick: true,
            },
            children: (0, Qw.jsxs)("div", {
              ref: d,
              className: (0, Uw.default)(qw.dialog, qw[i], c),
              role: "regular" !== i ? "alertdialog" : "dialog",
              "aria-modal": "true",
              "aria-label": r,
              "data-size": o,
              children: [
                (0, Qw.jsxs)("div", {
                  className: qw.body,
                  children: [
                    (0, Qw.jsx)(Zw, { type: i, progress: u }),
                    (0, Qw.jsx)(Gw, { children: e }),
                  ],
                }),
                l
                  ? (0, Qw.jsxs)(Qw.Fragment, {
                      children: [(0, Qw.jsx)(jw, {}), l],
                    })
                  : null,
              ],
            }),
          }),
        }),
      }),
  });
}
export function Kw(e) {
  return null == e || "indeterminate" === e
    ? { variant: "indeterminate" }
    : "number" == typeof e
    ? { variant: "determinate", value: e, max: 100, label: $w(e) }
    : {
        variant: "determinate",
        value: e.value,
        max: e.max,
        label: $w(e.value, e.max),
      };
}
(Ww || (Ww = {})).Footer = function ({ children: e }) {
  return (0, Qw.jsx)("footer", { className: qw.footer, children: e });
};
export var Yw = Ww;

export var ek = function () {
  return (0, Jw.jsx)("x-spacer", { class: Xw });
};
export var tk = mx;

export var ok = {
  block: "UBQ_Card-module__block--Zs4rt",
  shortHeight: "UBQ_Card-module__shortHeight--0Hr9R",
  extraShortHeight: "UBQ_Card-module__extraShortHeight--xZVB-",
  stateRepresentation: "UBQ_Card-module__stateRepresentation--HIjTB",
  autoHeight: "UBQ_Card-module__autoHeight--yuOcz",
  backgroundImage: "UBQ_Card-module__backgroundImage--fXz-k",
  cover: "UBQ_Card-module__cover--I9azZ",
  contain: "UBQ_Card-module__contain--ToAWK",
  content: "UBQ_Card-module__content--9sQsw",
};

export var ak = ((e) => (
  (e.Default = "defaultHeight"),
  (e.Short = "shortHeight"),
  (e.ExtraShort = "extraShortHeight"),
  (e.Auto = "autoHeight"),
  e
))(ak || {});
export function lk({
  children: e,
  isActive: t = false,
  isDisabled: n = false,
  backgroundImage: s,
  backgroundType: i = "cover",
  "aria-label": o,
  height: r = "defaultHeight",
  className: a,
  "data-cy": l,
  style: c,
  ...u
}) {
  return (0, rk.jsx)(CompTooltip, {
    showTooltip: !!o,
    label: o ?? "",
    children: (0, rk.jsxs)("button", {
      type: "button",
      className: (0, ik.default)(ok.block, ok[r], a, {
        [ok.contain]: "contain" === i,
        [ok.cover]: "cover" === i,
      }),
      style: c || {},
      disabled: n,
      "data-active": t,
      "aria-label": o,
      "data-cy": l || u.name,
      ...u,
      children: [
        s &&
          (0, rk.jsx)("img", {
            className: (0, ik.default)(ok.backgroundImage),
            src: s,
            alt: o,
          }),
        (0, rk.jsx)("div", { className: ok.stateRepresentation }),
        e,
      ],
    }),
  });
}
(lk || (lk = {})).Height = ak;
export var ck = lk;

export function dk({ children: e }) {
  return (0, uk.jsx)("span", { className: sk, children: e });
}
export function pk({ children: e, ...t }) {
  return (0, uk.jsx)(ck, { ...t, className: nk, children: e });
}
(pk || (pk = {})).Label = dk;
export var fk = pk;
export var hk = ck;
export const vk = (e) => {
  const t = (+e).toString();
  return -1 === t.lastIndexOf(".") ? 0 : t.slice(t.lastIndexOf(".") + 1).length;
};
export var wk = (e, t, n) => Math.min(Math.max(e, t), n);

export var Ek =
  "UBQ_Slider-module__centeredValueHigherThanSelectedValue--4cMIW";

export var Vk = function ({
  name: e,
  min: t = 0,
  max: n = 100,
  step: s = 1,
  value: i = 0,
  defaultValue: o,
  centeredZeroPosition: r = false,
  hideTrackBackground: a = false,
  className: l,
  style: c,
  onNumberInputChange: u,
  toggleNumberInputAriaLabel: d,
  disabled: p,
  onRelease: f,
  maxFractionDigits: h = 2,
  ...m
}) {
  const g = (0, bk.useRef)(null),
    x = (0, bk.useRef)(null),
    b = (0, bk.useRef)(null),
    y = (0, bk.useRef)(null),
    v = (t + n) / 2,
    w = o === i,
    k = PercentageHelper.isPercentageSlider(t, n),
    [C, j] = (0, bk.useState)(false);
  (0, bk.useEffect)(() => {
    C && x?.current?.focus();
  }, [C]),
    mostlyHook1(
      ["enter"],
      () => {
        j(true), x?.current?.focus();
      },
      { elementRef: g }
    ),
    mostlyHook1(
      ["enter"],
      () => {
        j(false), g?.current?.focus();
      },
      { elementRef: x }
    );
  const S = (e, i) =>
      i
        ? parseFloat(Fv(PercentageHelper.valueToPercentage(e, t, n), 0))
        : parseFloat(e.toFixed(Math.min(h, vk(s)))),
    _ = () => {
      y.current = i;
    },
    E = () => {
      y.current !== i && (f?.(), (y.current = i)), (y.current = null);
    };
  function L(e, t) {
    return (n) => {
      e(), t?.(n);
    };
  }
  const P = {
    ...c,
    "--ubq_internal-Slider-min": t,
    "--ubq_internal-Slider-max": n,
    "--ubq_internal-Slider-value": 0 === vk(s) ? S(i, false) : i,
  };
  return (0, Rk.jsxs)("div", {
    className: kk,
    children: [
      (0, Rk.jsxs)("div", {
        className: (0, xk.default)(jk, { [Sk]: p, [Mk]: C }),
        children: [
          (0, Rk.jsx)("input", {
            ref: g,
            ...m,
            className: (0, xk.default)(_k, l, {
              [Ak]: !w,
              [Ek]: r && v >= i,
              [Lk]: r && v < i,
              [Pk]: a,
            }),
            name: e,
            type: "range",
            min: t,
            max: n,
            value: i,
            step: s,
            onMouseDown: L(_, m.onMouseDown),
            onTouchStart: L(_, m.onTouchStart),
            onKeyDown: L(_, m.onKeyDown),
            onMouseUp: L(E, m.onMouseUp),
            onTouchEnd: L(E, m.onTouchEnd),
            onKeyUp: L(E, m.onKeyUp),
            style: P,
            disabled: p,
          }),
          (0, Rk.jsx)("div", {
            className: Bk,
            children: (0, Rk.jsx)("span", {
              className: Tk,
              "data-cy": "slider-number-value",
              children: S(i, k),
            }),
          }),
        ],
      }),
      (0, Rk.jsx)("div", {
        className: (0, xk.default)({ [Mk]: !C }),
        children: (0, Rk.jsx)(Uv, {
          ref: x,
          className: l,
          name: "slider-number-input",
          min: S(t, k),
          max: S(n, k),
          value: S(i, k),
          onFocus: (e) => {
            e.target.select(), _();
          },
          onChange: (e) => {
            var s;
            u &&
              u(
                wk(
                  ((s = e ?? 0),
                  k ? PercentageHelper.percentageToValue(s, t, n) : s),
                  t,
                  n
                )
              );
          },
          onBlur: (e) => {
            b.current !== e.relatedTarget && j(false);
          },
          onRelease: f,
          disabled: p,
        }),
      }),
      !p &&
        (0, Rk.jsx)("div", {
          className: (0, xk.default)(Ck, { [Mk]: C }),
          children: (0, Rk.jsx)("div", {
            className: Ok,
            children: (0, Rk.jsx)(Ly, {
              label: d,
              children: (0, Rk.jsx)(Gp, {
                ref: b,
                name: "toggle-number_input",
                "aria-label": d,
                onClick: () => {
                  j(!C);
                },
                isActive: C,
                isDisabled: p,
                children: (0, Rk.jsx)(gk, {}),
              }),
            }),
          }),
        }),
    ],
  });
};
export var Dk = Vk;

export var Qk = function ({
  title: e,
  headingLevel: t,
  headingStart: n,
  headingAreaRight: s,
  className: i,
  classNameContent: o,
  children: r,
}) {
  return (0, qk.jsxs)("section", {
    className: (0, Fk.default)(Ik, i),
    children: [
      (0, qk.jsx)(jw, {}),
      e &&
        (0, qk.jsxs)(Ex, {
          className: Hk,
          level: t || 1,
          start: n,
          children: [
            (0, qk.jsx)("span", { className: Nk, children: e }),
            s && (0, qk.jsx)("span", { className: Uk, children: s }),
          ],
        }),
      (0, qk.jsx)("div", {
        className: (0, Fk.default)(zk, o, { [$k]: !e }),
        children: r,
      }),
    ],
  });
};

export var Yk = Kk;
export var iC = {
  block: "UBQ_Panel-module__block--EaNC7",
  floating: "UBQ_Panel-module__floating--XYymS",
  left: "UBQ_Panel-module__left--dN7Uw",
  right: "UBQ_Panel-module__right--p4cWi",
  verticalLayout: "UBQ_Panel-module__verticalLayout--NmiHx",
  fixed: "UBQ_Panel-module__fixed--btzoD",
  fullHeight: "UBQ_Panel-module__fullHeight--QGYo4",
  borderLeft: "UBQ_Panel-module__borderLeft--53yW6",
  borderRight: "UBQ_Panel-module__borderRight---MlC9",
};

export var rC = function ({
  children: e,
  show: t = true,
  delayRenderAfterAnimation: n,
  floating: s,
  position: i = "left",
  "data-cy": o,
  className: r,
  borderLeft: a,
  borderRight: l,
  animationDirection: c = "horizontal",
  style: u,
  fullHeight: d,
}) {
  const [p, f] = (0, sC.useState)(!n),
    h = (0, sC.useRef)(t);
  let m;
  if (
    ((0, sC.useEffect)(() => {
      h.current = t;
    }, [t, s]),
    "vertical" === c)
  )
    m = {
      open: { x: 0, y: (s ? -100 : 0) + "%" },
      closed: { x: 0, y: (s ? 0 : 100) + "%" },
    };
  else
    switch (i) {
      case "left":
        m = { open: { x: "0%", y: 0 }, closed: { x: "-100%", y: 0 } };
        break;
      case "right":
        m = { open: { x: "0%", y: 0 }, closed: { x: "100%", y: 0 } };
        break;
      default:
        m = { open: { x: "0%", y: "0%" }, closed: { x: "0%", y: "0%" } };
    }
  return (0, oC.jsx)(DynamicPresenceTransition, {
    children:
      t &&
      (0, oC.jsx)(Sd.div, {
        className: (0, nC.default)(iC.block, r, iC[i], {
          [iC.floating]: s,
          [iC.fixed]: !s,
          [iC.borderLeft]: a,
          [iC.borderRight]: l,
          [iC.verticalLayout]: "vertical" === c,
          [iC.fullHeight]: d,
        }),
        transition: { type: "spring", bounce: 0, duration: 0.3 },
        variants: m,
        onAnimationComplete: () => {
          n && f(h.current);
        },
        initial: "closed",
        animate: "open",
        exit: "closed",
        "data-cy": o,
        style: u,
        children: "function" == typeof e ? e({ animationComplete: p }) : p && e,
      }),
  });
};

export var bC = {
  Container: function ({ children: e, className: t }) {
    const n = (0, dC.useRef)(null),
      s = null !== n.current ? (0, pC.tabbable)(n.current) : [];
    return (
      mostlyHook1(
        ["down"],
        ({ target: e }) => {
          if (s.length > 0) {
            const t = s.findIndex((t) => t === e);
            return (
              -1 === t ||
              (s.length === t + 1 ? s[0].focus() : s[t + 1].focus(), false)
            );
          }
          return true;
        },
        { elementRef: n }
      ),
      mostlyHook1(
        ["up"],
        ({ target: e }) => {
          if (s.length > 0) {
            const t = s.findIndex((t) => t === e);
            return (
              -1 === t ||
              (0 === t
                ? s[s.length - 1].focus()
                : t > 0 && t < s.length && s[t - 1].focus(),
              false)
            );
          }
          return true;
        },
        { elementRef: n }
      ),
      (0, mC.jsx)("ul", {
        className: (0, uC.default)(fC, t),
        ref: n,
        role: "menu",
        children: e,
      })
    );
  },
  Item: gC,
  ItemCheckbox: function ({ children: e, checked: t, ...n }) {
    return (0, mC.jsx)(gC, {
      role: "menuitemcheckbox",
      "aria-checked": t,
      ...n,
      children: e,
    });
  },
  Heading: function ({ children: e, level: t }) {
    return (0, mC.jsx)(Ex, { level: t || 2, className: hC, children: e });
  },
};
export var yC = bC;

export function ej(e) {
  const t = e
      .split("")
      .map((e) => e.charCodeAt(0))
      .join(""),
    n = parseInt(t, 10) % JC.length;
  return JC[n];
}
export function tj({
  url: e,
  alt: t,
  variant: n = tj.Variant.Circle,
  children: s,
  className: i,
}) {
  const [o, r] = (0, QC.useState)(false),
    a = o || (!e && !s),
    l = {
      className: (0, qC.default)(GC, i, {
        [KC]: a,
        [WC]: !!s,
        [ZC]: n === tj.Variant.Circle,
      }),
    };
  if (a) {
    let e = "";
    if (t) {
      const n = t.split(" ").filter(Boolean);
      n.length > 1
        ? (e = n[0][0] + n[1][0])
        : 1 === n.length && (e = n[0].slice(0, 2));
    }
    return (0, XC.jsx)("div", {
      ...l,
      style: { backgroundColor: ej(e) },
      children: e,
    });
  }
  return s
    ? (0, XC.jsx)("div", { ...l, children: s })
    : (0, XC.jsx)("img", {
        alt: t,
        src: e,
        ...l,
        className: (0, qC.default)(l.className, YC),
        onError: () => {
          r(true);
        },
      });
}
((e) => {
  let t;
  var n;
  ((n = t = e.Variant || (e.Variant = {})).Rounded = "rounded"),
    (n.Circle = "circle");
})(tj || (tj = {}));

export var sj = (0, nj.createContext)(null);
export var ij = { didCatch: false, error: null };
export var oj = class extends nj.Component {
  constructor(e) {
    super(e),
      (this.state = ij),
      (this.resetBoundary = this.resetBoundary.bind(this)),
      (this.showBoundary = this.showBoundary.bind(this));
  }
  static getDerivedStateFromError(e) {
    return { didCatch: true, error: e };
  }
  componentDidCatch(e, t) {
    this.props.onError?.(e, t);
  }
  resetBoundary = () => {
    const { error: e } = this.state;
    null !== e && (this.props.onReset?.(), this.setState(ij));
  };
  showBoundary = (e) => {
    this.setState({ didCatch: true, error: e });
  };
  render() {
    const { children: e, fallback: t } = this.props,
      { didCatch: n, error: s } = this.state;
    let i = e;
    return (
      n && (i = t ? t(s) : null),
      (0, nj.createElement)(
        sj.Provider,
        {
          value: {
            showBoundary: this.showBoundary,
            resetBoundary: this.resetBoundary,
          },
        },
        i
      )
    );
  }
};

export function cj(e, t) {
  if (!t || (!t.source && !t.medium)) return e;
  const n = e.split("?"),
    s = n[0],
    i = [];
  if (
    (t?.source && i.push(`utm_source=${encodeURIComponent(t.source)}`),
    t?.medium && i.push(`utm_medium=${encodeURIComponent(t.medium)}`),
    0 === i.length)
  )
    return e;
  const o = n[1] ? `&${n[1]}` : "";
  return `${s}?${i.join("&")}${o}`;
}
export var uj;
export var dj = function ({ url: e, children: t, utm: n, className: s }) {
  return (0, lj.jsx)("a", {
    href: cj(e, n),
    target: "_blank",
    rel: "noreferrer noopener",
    className: (0, rj.default)(aj, s),
    children: t ?? e,
  });
};

export var hj = {
  block: "UBQ_Dock-module__block--yQhta",
  horizontal: "UBQ_Dock-module__horizontal--xFft-",
  hasSelected: "UBQ_Dock-module__hasSelected--qyxUE",
  button: "UBQ_Dock-module__button--zD3e8",
  small: "UBQ_Dock-module__small--sONUA",
  big: "UBQ_Dock-module__big--oyiIY",
  buttonLabel: "UBQ_Dock-module__buttonLabel--2qIS0",
  hideLabels: "UBQ_Dock-module__hideLabels--LxGYb",
};

export function CompSidebar({
  children: e,
  hasSelected: t,
  size: n = "big",
  "data-cy": s,
  horizontal: i = false,
  hideLabels: o = false,
  className: r,
}) {
  return (0, mj.jsx)("div", {
    "data-cy": s,
    className: (0, pj.default)(hj.block, r, hj[n], {
      [hj.hasSelected]: t,
      [hj.horizontal]: i,
      [hj.hideLabels]: o,
    }),
    children: e,
  });
}
export function xj({ children: e }) {
  return (0, mj.jsx)("div", { children: e });
}
export function bj(
  { children: e, name: t, icon: n, variant: s = "plain", ...i },
  o
) {
  return (0, mj.jsx)(CompCustomButton, {
    ref: o,
    name: t,
    className: hj.button,
    variant: s,
    ...i,
    children: (0, mj.jsxs)("div", {
      className: hj.buttonLabel,
      children: [n, (0, mj.jsx)("span", { children: e })],
    }),
  });
}
((uj = CompSidebar || (CompSidebar = {})).Panel = xj),
  (uj.Button = (0, fj.forwardRef)(bj));
export var yj = CompSidebar;

export function Cj({ children: e, height: t, width: n, gap: s, style: i }) {
  const o = ((r = t), (a = s), Math.ceil(r / a) * a);
  var r, a;
  return (0, kj.jsx)("div", {
    className: wj.item,
    style: {
      ...i,
      height: o,
      width: n,
      gridRowEnd: `span ${Math.round(o / s) + 1}`,
    },
    children: e,
  });
}
export function jj({ children: e, width: t, columnCount: n, className: s }) {
  const i = parseInt(xh("--ubq-margin-s", { fallback: "4px" }), 10),
    o = (t - i * (n - 1)) / n,
    r = `repeat(${n}, ${o}px)`;
  return (0, kj.jsx)("div", {
    className: (0, vj.default)(wj.block, s),
    style: { gridTemplateColumns: r },
    children: e({ columnWidth: o, gap: i }),
  });
}
(jj || (jj = {})).Item = Cj;
export var Sj;
export var _j = jj;

export var Ij = 16384;
export function Hj({
  children: e,
  renderBackground: t,
  className: n,
  style: s,
  isSelected: i,
  ...o
}) {
  return (0, Fj.jsxs)("div", {
    className: (0, Ej.default)(Pj, n),
    style: s,
    ...o,
    children: [
      t && (0, Fj.jsx)("div", { className: Tj, children: t() }),
      i && (0, Fj.jsx)("div", { className: Dj }),
      (0, Fj.jsx)("div", { className: Aj, children: e }),
    ],
  });
}
export function Nj({ children: e }) {
  return (0, Fj.jsx)("div", { className: Bj, children: e });
}
export function Uj({ frame: e, className: t }) {
  return (0, Fj.jsx)("div", {
    className: (0, Ej.default)(Mj, t),
    style: { backgroundImage: `url(${e})` },
  });
}
export function zj({ frame: e, className: t }) {
  return (0, Fj.jsx)("div", {
    className: (0, Ej.default)(Rj, t),
    style: { maskImage: `url(${e})`, WebkitMaskImage: `url(${e})` },
  });
}
export function $j({ color: e }) {
  return (0, Fj.jsx)("div", { className: Oj, style: { backgroundColor: e } });
}
export function qj({ atlas: e, atlasColumns: t, atlasRows: n }) {
  const s = (0, Lj.useRef)(null),
    i = (0, Lj.useRef)(document.createElement("img")),
    [o, r] = (0, Lj.useState)("");
  return (
    (0, Lj.useEffect)(() => {
      let e,
        o = 0,
        r = 0;
      const a = () => {
        if (s.current) {
          const e = s.current.getBoundingClientRect();
          (e.width === o && r === window.devicePixelRatio) ||
            ((o = e.width),
            (r = window.devicePixelRatio),
            (function (e, s, o) {
              const r = Math.min(s.width * o, Ij),
                a = s.height * o,
                l = i.current.naturalWidth,
                c = i.current.naturalHeight,
                u = e.getContext("2d");
              if (u && a && r) {
                (e.width === r && e.height === a) ||
                  ((e.width = r), (e.height = a));
                const s = l / t,
                  o = c / n,
                  d = a * (s / o),
                  p = a,
                  f = Math.ceil(r / d);
                let h = 0;
                for (let e = 0; e < r; e += d) {
                  const r = Math.floor(h),
                    a = (r % t) * s,
                    l = Math.floor(r / t) * o;
                  u.drawImage(i.current, a, l, s, o, e, 0, d, p),
                    (h += (t * n) / f);
                }
              }
            })(s.current, e, r));
        }
        e = requestAnimationFrame(a);
      };
      return (
        a(),
        () => {
          cancelAnimationFrame(e);
        }
      );
    }, [o, t, n]),
    (0, Lj.useEffect)(() => {
      let t = true;
      return (
        (i.current.src = e),
        (i.current.onload = () => {
          t && r(e);
        }),
        () => {
          t = false;
        }
      );
    }, [e]),
    (0, Fj.jsx)("canvas", {
      className: Vj,
      ref: s,
      style: { maxWidth: "16384px" },
    })
  );
}
((Sj = Hj || (Hj = {})).Content = Nj),
  (Sj.Background = {
    SingleFrame: Uj,
    SolidColor: $j,
    MaskedSvg: zj,
    Atlas: qj,
  });
export var Qj = Hj;
export var Gj = Qj;

export var Jj = (0, Wj.forwardRef)(
  (
    {
      orientation: e = "horizontal",
      className: t,
      currentValue: n,
      minValue: s,
      maxValue: i,
      ...o
    },
    r
  ) =>
    (0, Xj.jsx)("div", {
      ref: r,
      role: "separator",
      tabIndex: 0,
      "aria-valuenow": n,
      "aria-valuemin": s,
      "aria-valuemax": i,
      className: (0, Zj.default)(Kj, t, { [Yj]: "vertical" === e }),
      ...o,
    })
);
Jj.displayName = "uikit/ResizeHandle";
export var eS = Jj;

export var iS = function ({ children: e, className: t }) {
  return (0, sS.jsx)("div", {
    className: (0, tS.default)(nS, t),
    children: e,
  });
};

export function lS(e, t) {
  return e / t;
}
export function cS(e, t) {
  return t * e;
}
export var uS = {
  block: "UBQ_MediaTrim-module__block--9efb5",
  containedWrapper: "UBQ_MediaTrim-module__containedWrapper--Z5q7z",
  contained: "UBQ_MediaTrim-module__contained--ccHap",
  containedChildren: "UBQ_MediaTrim-module__containedChildren--dJ9ui",
  outerMediaStrip: "UBQ_MediaTrim-module__outerMediaStrip--DJEIU",
  innerMediaStrip: "UBQ_MediaTrim-module__innerMediaStrip--zELqb",
  grabbing: "UBQ_MediaTrim-module__grabbing--hIiS5",
  handle: "UBQ_MediaTrim-module__handle--nvxx8",
};

export function pS({ children: e, overlayWidth: t, style: n }) {
  const s = { ...n, "--ubq_internal-MediaTrim-overlay-width": t };
  return (0, dS.jsxs)("div", {
    className: uS.containedWrapper,
    children: [
      (0, dS.jsx)("div", { className: uS.contained, style: s }),
      (0, dS.jsx)("div", { className: uS.containedChildren, children: e }),
    ],
  });
}
export var fS = function ({
  mediaDuration: e,
  trimOffset: t,
  setTrimOffset: n,
  trimLength: s,
  setTrimLength: i,
  onUpdateTrimProperties: o,
  postContainedDuration: r = 0,
  renderBackground: a,
}) {
  const [l, c] = (0, rS.useState)(null),
    u = (0, rS.useRef)(),
    d = (0, rS.useRef)(),
    p = (0, rS.useRef)(),
    f = (0, rS.useRef)(),
    h = (0, rS.useRef)(),
    [m, g] = (0, rS.useState)(false),
    [x, b] = (0, rS.useState)(0),
    [y, v] = (0, rS.useState)(0),
    w = cS(s, y),
    k = cS(t, y);
  rv(l, (t) => {
    b(t.width);
    const n = t.width / e;
    v(n);
  });
  const C = (0, rS.useCallback)(
    (e) => {
      null !== e && null === l && c(e);
    },
    [l]
  );
  return (0, dS.jsx)("div", {
    className: uS.block,
    ref: C,
    children: (0, dS.jsx)(Qj, {
      className: uS.outerMediaStrip,
      renderBackground: a,
      children: (0, dS.jsx)(aS.DraggableCore, {
        offsetParent: l,
        cancel: `.${uS.handle}`,
        onStart: (e, n) => {
          const { x: s } = n;
          (u.current = s), (d.current = cS(t, y)), g(true);
        },
        onDrag: (e, { x: t }) => {
          n(() => {
            const e = t - (u.current ?? 0),
              n = (d.current ?? 0) + e;
            if (n < 0) return 0;
            const s = x - w;
            return lS(n >= s ? s : n, y);
          });
        },
        onStop: () => {
          (u.current = undefined), (d.current = undefined), g(false), o && o();
        },
        children: (0, dS.jsx)(Qj, {
          "data-cy": "mediaTrimStrip",
          className: (0, oS.default)(uS.innerMediaStrip, {
            [uS.grabbing]: m,
          }),
          style: {
            minWidth: "32px",
            width: (100 / x) * w + "%",
            maxWidth: x - k + "px",
            transform: `translateX(${k}px)`,
          },
          children: (0, dS.jsx)(Qj.Content, {
            children: (0, dS.jsx)(pS, {
              overlayWidth: cS(r, y),
              children: (0, dS.jsxs)(Fh.Edge, {
                children: [
                  (0, dS.jsx)(Fh.Edge.MiddleLeft, {
                    children: (0, dS.jsx)(aS.DraggableCore, {
                      offsetParent: l,
                      onStart: (e, n) => {
                        const { x: i } = n;
                        (u.current = i),
                          (d.current = cS(t, y)),
                          (p.current = cS(s, y));
                      },
                      onDrag: (e, { x: t }) => {
                        const s = t - (u.current ?? 0);
                        let o = (d.current ?? 0) + s,
                          r = (p.current ?? 0) - s;
                        const a = (d.current ?? 0) + (p.current ?? 0) - 32;
                        o < 0 ? (o = 0) : o >= a && (o = a);
                        const l = (d.current ?? 0) + (p.current ?? 0);
                        r < 32 ? (r = 32) : r > l && (r = l),
                          i(lS(r, y)),
                          n(lS(o, y));
                      },
                      onStop: () => {
                        (u.current = undefined),
                          (d.current = undefined),
                          (p.current = undefined),
                          o && o();
                      },
                      children: (0, dS.jsx)("div", {
                        className: uS.handle,
                        children: (0, dS.jsx)(eS, {
                          "data-cy": "mediaTrimHandleLeft",
                          currentValue: k,
                        }),
                      }),
                    }),
                  }),
                  (0, dS.jsx)(Fh.Edge.MiddleRight, {
                    children: (0, dS.jsx)(aS.DraggableCore, {
                      offsetParent: l,
                      onStart: (n, { x: i }) => {
                        (u.current = i), (p.current = cS(s, y));
                        const o = e - t,
                          r = lS(32, y);
                        (f.current = cS(o, y)), (h.current = cS(r, y));
                      },
                      onDrag: (e, { x: t }) => {
                        i(() => {
                          const e = t - (u.current ?? 0),
                            n = (p.current ?? 0) + e,
                            s = f.current,
                            i = h.current;
                          return lS(
                            null != s && n > s ? s : null != i && n < i ? i : n,
                            y
                          );
                        });
                      },
                      onStop: () => {
                        (f.current = undefined),
                          (h.current = undefined),
                          (u.current = undefined),
                          o && o();
                      },
                      children: (0, dS.jsx)("div", {
                        className: uS.handle,
                        children: (0, dS.jsx)(eS, {
                          "data-cy": "mediaTrimHandleRight",
                          currentValue: w - k,
                        }),
                      }),
                    }),
                  }),
                ],
              }),
            }),
          }),
        }),
      }),
    }),
  });
};

export function xS(e, t = false) {
  const n = Math.floor(e);
  let s = Math.round(n % 60);
  const i = Math.round(((n - s) / 60) % 60),
    o = Math.round(n >= 3600 ? (n / 60 - i) / 60 : 0);
  let r = "";
  if (t)
    switch (((r = Fv(e - n, 1)), r)) {
      case "1":
        (s += 1), (r = ".0");
        break;
      case "0":
        r = ".0";
        break;
      default:
        r = r.slice(1);
    }
  return {
    periodString: `PT${o}H${i}M${s}S`,
    timeString: `${o > 0 ? `${o}:` : ""}${`${i}:`}${s
      .toString()
      .padStart(2, "0")}${r}`,
  };
}

export var ES = (0, wS.forwardRef)(
  (
    {
      className: e,
      isGrabbing: t = false,
      id: n,
      ariaLabeledBy: s,
      ariaValueNow: i = 0,
      ariaValueMin: o,
      ariaValueMax: r,
    },
    a
  ) =>
    (0, _S.jsxs)("div", {
      className: (0, vS.default)(kS, e),
      ref: a,
      id: n,
      role: "slider",
      tabIndex: 0,
      "aria-valuenow": i,
      "aria-labelledby": s,
      "aria-valuemin": o,
      "aria-valuemax": r,
      children: [
        (0, _S.jsx)("div", { className: SS }),
        (0, _S.jsx)("div", {
          className: (0, vS.default)(CS, { [jS]: t }),
          children: (0, _S.jsx)(yS, {}),
        }),
      ],
    })
);
ES.displayName = "uikit/Seeker";
export var LS = ES;
export var PS = {
  block: "UBQ_MediaSeeker-module__block--pLKtg",
  big: "UBQ_MediaSeeker-module__big--sjSWW",
  overlay: "UBQ_MediaSeeker-module__overlay--P2qaZ",
  flipLabel: "UBQ_MediaSeeker-module__flipLabel--Un1Zm",
};

export var BS = function ({
  mediaDuration: e,
  offset: t,
  setOffset: n,
  min: s,
  max: i,
  showTime: o = false,
  bigMode: r = false,
  children: a,
  className: l,
  pixelTimeRatio: c,
  onStart: u,
  onStop: d,
}) {
  const [p, f] = (0, mS.useState)(null),
    [h, m] = (0, mS.useState)(0),
    [g, x] = (0, mS.useState)(null),
    [b, y] = (0, mS.useState)(0),
    [v, w] = (0, mS.useState)(0),
    [k, C] = (0, mS.useState)(false);
  rv(p, (t) => {
    if ((m(t.width), c)) w(c);
    else {
      const n = t.width / e;
      w(n);
    }
  }),
    rv(g, (e) => {
      y(lS(e.width, v)),
        g && g.style.setProperty("--ubq_internal-seeker-width", `${e.width}px`);
    });
  const j = (0, mS.useCallback)(
      (e) => {
        null !== e && null === p && f(e);
      },
      [p]
    ),
    S = (0, mS.useCallback)(
      (e) => {
        null !== e && null === g && x(e);
      },
      [g]
    ),
    _ = o && e - t < b,
    E = s ? cS(s, c ?? v) : 0,
    L = i ? cS(i, c ?? v) : h;
  return (0, AS.jsxs)("div", {
    className: (0, hS.default)(PS.block, l, { [PS.big]: r }),
    children: [
      (0, AS.jsx)("div", { ref: j, children: a }),
      (0, AS.jsx)(gS.default, {
        offsetParent: p ?? undefined,
        axis: "x",
        bounds: { left: E, right: L, top: 0, bottom: 0 },
        position: { x: Math.round(cS(t, c ?? v)), y: 0 },
        onDrag: (e, t) => {
          const s = Math.max(0, Math.min(h, t.x));
          n(lS(s, c ?? v));
        },
        onStart: (e) => {
          C(true), u && u(e);
        },
        onStop: (e) => {
          C(false), d && d(e);
        },
        children: (0, AS.jsxs)("div", {
          className: (0, hS.default)(PS.overlay, { [PS.flipLabel]: _ }),
          ref: S,
          children: [
            (0, AS.jsx)(LS, {
              className: PS.seeker,
              isGrabbing: k,
              id: "mediaseeker-element",
              ariaValueNow: t,
              ariaLabeledBy: "mediaseeker-time",
              ariaValueMin: 0,
              ariaValueMax: e,
            }),
            o &&
              (0, AS.jsx)("label", {
                id: "mediaseeker-time",
                htmlFor: "mediaseeker-element",
                children: (0, AS.jsx)("time", {
                  children: xS(t, true).timeString,
                }),
              }),
          ],
        }),
      }),
    ],
  });
};

export var OS = {
  block: "UBQ_FloatingActionButton-module__block--b1Wco",
  button: "UBQ_FloatingActionButton-module__button--Gg7ZH",
  "ubq-size_small": "UBQ_FloatingActionButton-module__ubq-size_small--dm2uu",
};

export var VS = (0, MS.forwardRef)(function (
  { children: e, "aria-label": t, size: n = "normal", ...s },
  i
) {
  return (0, RS.jsx)("div", {
    className: (0, TS.default)(OS.block, OS[`ubq-size_${n}`]),
    children: (0, RS.jsx)("button", {
      type: "button",
      className: OS.button,
      "aria-label": t,
      ...s,
      ref: i,
      children: (0, RS.jsx)("span", { children: MS.Children.only(e) }),
    }),
  });
});

export var WS = 48;
(0, FS.forwardRef)(
  (
    {
      isSelected: e,
      isResizable: t = true,
      duration: n,
      startTime: s,
      setDuration: i,
      label: o,
      width: r,
      onClick: a,
      pixelSecondRatio: l,
      offsetParent: c,
      setOverscrollOffset: u,
      children: d,
      onDurationUpdate: p,
      onLeftHandleDrag: f,
      onRightHandleDrag: h,
      className: m,
      renderBackground: g,
    },
    x
  ) => {
    const b = (0, FS.useRef)(),
      y = (0, FS.useRef)(),
      v = (0, FS.useRef)(),
      w = (0, FS.useRef)(null),
      k = (0, FS.useRef)(null);
    function C(e = false) {
      const t = e ? 10 : 1,
        s = lS(WS, l),
        o = 0.1 * t;
      i(s <= n - o ? n - o : s);
    }
    function j(e = false) {
      i(n + 0.1 * (e ? 10 : 1));
    }
    return (
      mostlyHook1(
        "left",
        () => {
          j();
        },
        { elementRef: w }
      ),
      mostlyHook1(
        "right",
        () => {
          C();
        },
        { elementRef: w }
      ),
      mostlyHook1(
        "left",
        () => {
          C();
        },
        { elementRef: k }
      ),
      mostlyHook1(
        "right",
        () => {
          j();
        },
        { elementRef: k }
      ),
      mostlyHook1(
        "shift+left",
        () => {
          j(true);
        },
        { elementRef: w }
      ),
      mostlyHook1(
        "shift+right",
        () => {
          C(true);
        },
        { elementRef: w }
      ),
      mostlyHook1(
        "shift+left",
        () => {
          C(true);
        },
        { elementRef: k }
      ),
      mostlyHook1(
        "shift+right",
        () => {
          j(true);
        },
        { elementRef: k }
      ),
      (0, ZS.jsxs)("div", {
        ref: x,
        className: HS,
        "data-cy": "timelineVideoStrip",
        style: { width: r },
        children: [
          (0, ZS.jsx)(Qj, {
            className: (0, DS.default)(NS, m, { [$S]: e }),
            style: { minWidth: "48" },
            renderBackground: g,
            onClick: a,
            onKeyPress: (e) => {
              const { code: t } = e;
              ("Space" !== t && "Enter" !== t) || a?.();
            },
            isSelected: e,
            tabIndex: 0,
            children: (0, ZS.jsx)(Qj.Content, {
              children: (0, ZS.jsxs)(Fh.Edge, {
                children: [
                  (0, ZS.jsx)(Fh.Edge.MiddleLeft, {
                    children: (0, ZS.jsx)(IS.DraggableCore, {
                      disabled: !t,
                      offsetParent: c,
                      onStart: (e, { x: t }) => {
                        (b.current = t),
                          (y.current = cS(n, l)),
                          (v.current = WS);
                      },
                      onDrag: (e, { x: t }) => {
                        const n = t - (b.current ?? 0);
                        let s = (y.current ?? 0) - n;
                        s < WS && (s = WS), i(lS(s, l)), u && u(n), f && f();
                      },
                      onStop: (e) => {
                        (v.current = undefined),
                          (b.current = undefined),
                          u && u(0),
                          p && p(),
                          e.stopPropagation();
                      },
                      children: (0, ZS.jsx)("div", {
                        className: (0, DS.default)(QS, { [GS]: !t }),
                        children: (0, ZS.jsx)(eS, {
                          "data-cy": "timelineVideoStripHandleLeft",
                          ref: w,
                          className: zS,
                          currentValue: parseFloat(s.toFixed(1)),
                        }),
                      }),
                    }),
                  }),
                  (0, ZS.jsx)(Fh.Edge.BottomLeft, {
                    children: (0, ZS.jsxs)(iS, {
                      className: US,
                      children: [n.toFixed(1), "s"],
                    }),
                  }),
                  (0, ZS.jsx)(Fh.Edge.MiddleRight, {
                    children: (0, ZS.jsx)(IS.DraggableCore, {
                      disabled: !t,
                      offsetParent: c,
                      onStart: (e, { x: t }) => {
                        (b.current = t),
                          (y.current = cS(n, l)),
                          (v.current = WS);
                      },
                      onDrag: (e, { x: t }) => {
                        const n = t - (b.current ?? 0),
                          s = (y.current ?? 0) + n,
                          o = v.current,
                          r = lS(null != o && s < o ? o : s, l);
                        i(r), h && h();
                      },
                      onStop: (e) => {
                        (v.current = undefined),
                          (b.current = undefined),
                          p && p(),
                          e.stopPropagation();
                      },
                      children: (0, ZS.jsx)("div", {
                        className: (0, DS.default)(QS, { [GS]: !t }),
                        children: (0, ZS.jsx)(eS, {
                          "data-cy": "timelineVideoStripHandleRight",
                          ref: k,
                          className: zS,
                          currentValue: parseFloat((s + n).toFixed(1)),
                        }),
                      }),
                    }),
                  }),
                  d,
                ],
              }),
            }),
          }),
          (0, ZS.jsx)("div", { className: qS, children: o }),
        ],
      })
    );
  }
).displayName = "uikit/TimelineVideoStrip";

export var YS;
export var XS =
  'data:image/svg+xml,<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" opacity="0.1">%0A<rect width="16" height="16" fill="white"/>%0A<rect width="4" height="4" fill="black"/>%0A<rect x="8" width="4" height="4" fill="black"/>%0A<rect x="4" y="4" width="4" height="4" fill="black"/>%0A<rect x="12" y="4" width="4" height="4" fill="black"/>%0A<rect y="8" width="4" height="4" fill="black"/>%0A<rect x="8" y="8" width="4" height="4" fill="black"/>%0A<rect x="4" y="12" width="4" height="4" fill="black"/>%0A<rect x="12" y="12" width="4" height="4" fill="black"/>%0A</svg>%0A';

export var e_ = {
  block: "UBQ_ContentBox-module__block--lEbIe",
  small: "UBQ_ContentBox-module__small--vZjGs",
  medium: "UBQ_ContentBox-module__medium--ruRrj",
  blockState: "UBQ_ContentBox-module__blockState--Ce-K-",
  solid: "UBQ_ContentBox-module__solid--X-HrJ",
  interactionElement: "UBQ_ContentBox-module__interactionElement--NedyS",
  background: "UBQ_ContentBox-module__background--rpCBH",
  checkered: "UBQ_ContentBox-module__checkered--t5zjt",
};

export function n_({ color: e, className: t, checkered: n, style: s }) {
  return (0, t_.jsx)("span", {
    className: (0, JS.default)(e_.background, t, { [e_.checkered]: n }),
    style: { backgroundColor: e, ...s },
  });
}
export function s_({ className: e, style: t }) {
  return (0, t_.jsx)("span", {
    className: (0, JS.default)(e_.background, e_.checkered, e),
    style: t,
  });
}
export function i_({
  url: e,
  size: t,
  repeat: n,
  position: s,
  checkered: i,
  className: o,
}) {
  return (0, t_.jsx)("span", {
    className: (0, JS.default)(e_.background, o),
    style: {
      backgroundImage: `url('${e}')${i ? `, url('${XS}')` : ""}`,
      backgroundSize: `${t}${i ? ", auto" : ""}`,
      backgroundRepeat: `${n ? "repeat" : "no-repeat"}${i ? ", repeat" : ""}}`,
      backgroundPosition: `${s}${i ? ", center center" : ""}`,
    },
  });
}
export function o_({ gradient: e }) {
  return (0, t_.jsx)("span", {
    className: e_.background,
    style: { backgroundImage: e },
  });
}
export function r_({ children: e, ...t }) {
  return (0, t_.jsx)("div", {
    className: e_.solid,
    children: (0, t_.jsx)(CompCustomButton, {
      className: e_.interactionElement,
      ...t,
      children: e,
    }),
  });
}
export function a_({ size: e = "medium", children: t, className: n, ...s }) {
  return (0, t_.jsx)("div", {
    className: (0, JS.default)(e_.block, n, e_[e]),
    ...s,
    children: t,
  });
}
((YS = a_ || (a_ = {})).InteractionElement = r_),
  (YS.Background = { Color: n_, Gradient: o_, Image: i_, Checkered: s_ });
export var l_;
export var c_ = a_;

export function m_({ className: e, ...t }) {
  return (0, h_.jsx)("div", { className: (0, u_.default)(d_, e), ...t });
}
((l_ = m_ || (m_ = {})).Overlay = function ({ children: e }) {
  return (0, h_.jsx)("span", { className: p_, children: e });
}),
  (l_.InteractiveElement = function ({ children: e }) {
    return (0, h_.jsx)("span", { className: f_, children: e });
  });
export var g_ = m_;

export var context7 = (0, x_.createContext)({
  default: { width: 0, height: 0 },
});

export var E_ = function ({
  isDisabled: e,
  onClick: t,
  children: n,
  className: s,
  label: i,
}) {
  return e
    ? (0, __.jsxs)("div", {
        className: (0, w_.default)(k_, s),
        children: [
          (0, __.jsx)("div", { className: C_, children: n }),
          (0, __.jsx)("div", {
            className: (0, w_.default)(j_, { [S_]: null != t }),
            role: "button",
            "aria-disabled": "true",
            "aria-hidden": "false",
            onClick: t,
            onKeyDown: (e) => {
              ("Enter" !== e.key && " " !== e.key) || t?.();
            },
            "aria-label": i,
          }),
        ],
      })
    : (0, __.jsx)(__.Fragment, { children: n });
};

export var A_ = {
  timeline: "UBQ_NewTimeline-module__timeline--elSOw",
  dragBounds: "UBQ_NewTimeline-module__dragBounds--jo9gX",
  droppableTrack: "UBQ_NewTimeline-module__droppableTrack--jMmwY",
  dropping: "UBQ_NewTimeline-module__dropping--yZe8u",
  timelineElement: "UBQ_NewTimeline-module__timelineElement--NJWfZ",
  fixed: "UBQ_NewTimeline-module__fixed--V0Mmk",
  blueGhost: "UBQ_NewTimeline-module__blueGhost--A9Fc1",
  timelineContent: "UBQ_NewTimeline-module__timelineContent--gCAaS",
  elementInsertBefore: "UBQ_NewTimeline-module__elementInsertBefore--fv0B8",
  timelineScale: "UBQ_NewTimeline-module__timelineScale--u0Yjr",
  timelineScaleStep: "UBQ_NewTimeline-module__timelineScaleStep--UG8xF",
  shadedBackground: "UBQ_NewTimeline-module__shadedBackground--rlXyd",
  handle: "UBQ_NewTimeline-module__handle--B4gWZ",
  handleLeft:
    "UBQ_NewTimeline-module__handleLeft--ylpXE UBQ_NewTimeline-module__handle--B4gWZ",
  handleRight:
    "UBQ_NewTimeline-module__handleRight--BuGUI UBQ_NewTimeline-module__handle--B4gWZ",
  ghost: "UBQ_NewTimeline-module__ghost--ZZlQ9",
};

export function O_({
  index: e,
  element: t,
  originalElement: n,
  trackIndex: s,
  context: {
    elementHeight: i,
    dragState: o,
    updateState: r,
    renderContent: a,
    renderGhost: l,
    pxPerSec: c,
    packed: u,
  },
}) {
  const d = (0, T_.useRef)(null),
    p = t.duration * c,
    f = t.start * c;
  let h;
  if ("trimming" === o.state && o.elementId === t.id) {
    const e = t.start + t.duration / 2;
    if ("start" === o.trimPosition && o.deltaT > 0) {
      const t = n.start;
      h = {
        left: t * c,
        width: (e - t) * c,
        content: l?.({
          element: n,
          position: "start",
          timeBegin: t,
          timeEnd: e,
          pxPerSec: c,
          height: i,
        }),
      };
    } else if ("end" === o.trimPosition && o.deltaT < 0) {
      const s = n.start + n.duration;
      h = {
        left: e * c,
        width: (s - e) * c,
        content: l?.({
          element: t,
          position: "end",
          timeBegin: e,
          timeEnd: s,
          pxPerSec: c,
          height: i,
        }),
      };
    }
  }
  if ("moving" === o.state && o.elementId === t.id) {
    const e = t.start,
      n = e + t.duration;
    h = {
      left: f,
      width: p,
      content: l?.({
        element: t,
        position: "both",
        timeBegin: e,
        timeEnd: n,
        pxPerSec: c,
        height: i,
      }),
    };
  }
  const m = (0, T_.useMemo)(() => {
      const n = (n) =>
        function (i) {
          if (2 === i.button) return;
          const o = i.currentTarget;
          o.hasPointerCapture(i.pointerId) &&
            o.releasePointerCapture(i.pointerId);
          const { x: a, y: l } = d.current.getBoundingClientRect();
          r({
            type: "pointerDown",
            initiator: n,
            trackIndex: s,
            elementId: t.id,
            elementIndex: e,
            clientX: i.clientX,
            clientY: i.clientY,
            elementX: a,
            elementY: l,
          });
        };
      function i(e) {
        let t;
        return (n) => {
          n
            ? (n.addEventListener("pointerdown", e),
              (t = () => n.removeEventListener("pointerdown", e)))
            : t?.();
        };
      }
      return {
        trimLeftRef: i(n("trimStart")),
        trimRightRef: i(n("trimEnd")),
        moveRef: i(n("move")),
      };
    }, [t.id, e, s, r]),
    g = a
      ? a({
          element: t,
          timeBegin: t.start,
          timeEnd: t.start + t.duration,
          pxPerSec: c,
          height: i,
          action: "idle" !== o.state && o.elementId === t.id ? o.state : "idle",
          ...m,
        })
      : `Element ${t.id}`,
    x =
      "moving" === o.state &&
      o.toTrackIndex === s &&
      o.dropOverElementIndex === e &&
      o.toElementIndex !== o.elementIndex;
  return (0, M_.jsx)(
    R_,
    {
      ref: d,
      left: f,
      width: p,
      height: i,
      content: g,
      hideClip:
        "moving" === o.state &&
        o.elementId === t.id &&
        (s !== o.toTrackIndex || u),
      clipGhost: h,
      insertBefore: x,
    },
    t.id
  );
}
export var R_ = (0, T_.forwardRef)(function (
  {
    fixed: e,
    width: t,
    height: n,
    left: s,
    top: i = 0,
    insertBefore: o = false,
    clipGhost: r,
    content: a,
    hideClip: l,
  },
  c
) {
  const u = r
    ? {
        width: `${r.width}px`,
        height: `${n}px`,
        transform: `translate(${r.left}px,0)`,
      }
    : { display: "none" };
  return (0, M_.jsxs)(M_.Fragment, {
    children: [
      (0, M_.jsx)("div", {
        className: A_.ghost,
        style: u,
        children: r?.content,
      }),
      !l &&
        (0, M_.jsx)("div", {
          ref: c,
          className: (0, B_.default)(A_.timelineElement, { [A_.fixed]: e }),
          style: {
            width: `${t}px`,
            height: `${n}px`,
            transform: `translate(${s}px,${i}px)`,
          },
          children: a,
        }),
      o &&
        (0, M_.jsx)("div", {
          className: A_.elementInsertBefore,
          style: {
            height: `${n}px`,
            transform: `translate(${s - 1}px,${i}px)`,
          },
        }),
    ],
  });
});
export function V_({
  context: {
    dragState: e,
    pxPerSec: t,
    elementHeight: n,
    renderContent: s,
    packed: i,
  },
  tracks: o,
}) {
  if ("moving" !== e.state) return null;
  const {
    elementId: r,
    trackIndex: a,
    toTrackIndex: l,
    initialMouseY: c,
    currentMouseY: u,
    initialElementX: d,
    initialElementY: p,
    deltaT: f,
  } = e;
  if (a === l && !i) return null;
  const h = o[a],
    m = h.elements.findIndex((e) => e.id === r),
    g = h.elements[m],
    x = g.duration * t,
    b = d + f * t,
    y = p + u - c,
    v = s
      ? s({
          element: g,
          timeBegin: g.start,
          timeEnd: g.start + g.duration,
          pxPerSec: t,
          height: n,
          action: "moving",
        })
      : `Element ${g.id}`;
  return (0, M_.jsx)(
    R_,
    { fixed: true, width: x, height: n, left: b, top: y, content: v },
    g.id
  );
}
export function D_({
  context: { elementHeight: e, dragState: t, pxPerSec: n },
  track: s,
  trackIndex: i,
}) {
  const o = s.elements[s.elements.length - 1],
    r = o.start + o.duration;
  return "moving" === t.state &&
    t.dropOverTrackIndex === i &&
    t.dropOverElementIndex === s.elements.length
    ? (0, M_.jsx)("div", {
        className: A_.elementInsertBefore,
        style: { transform: `translate(${r * n - 1}px,0px)`, height: `${e}px` },
      })
    : null;
}
export function I_(e, t) {
  if (e === t) return true;
  for (const n in e) if (e[n] !== t[n]) return false;
  return true;
}
export function H_(e, t) {
  if (e === t) return true;
  if (e.elements === t.elements) return true;
  if (e.elements.length !== t.elements.length) return false;
  for (let n = 0; n < e.elements.length; n++)
    if (!I_(e.elements[n], t.elements[n])) return false;
  return true;
}
export function N_(e, t = [], n = []) {
  return Math.min(Math.max(e, ...t), ...n);
}
export function U_(e, t, n, s, i = []) {
  const { start: o, duration: r } = e,
    a = o + r,
    l = 5 / n,
    c = t / n,
    u = [0];
  return (
    i.forEach(function (e) {
      ("start" !== s && "both" !== s) || u.push(e - o);
      ("end" !== s && "both" !== s) || u.push(e - a);
    }),
    (function (e, t, n = 0.5) {
      for (const o of t) if (((s = e), (i = o), Math.abs(s - i) < n)) return o;
      var s, i;
      return e;
    })(c, u, l)
  );
}
export function z_(e, t, n, s = 0, i = 1 / 0, o) {
  if ("trimming" !== t.state && "moving" !== t.state) return e;
  const { elementIndex: r, deltaT: a, elementId: l } = t;
  if (e.elements[r].id !== l) return e;
  const c = e.elements[r],
    u = c.start + c.duration;
  if ("trimming" === t.state) {
    const { trimPosition: l } = t,
      f = e.elements.reduce((e, t) => e - t.duration, i);
    if ("end" === l) {
      const t = i - u,
        l = N_(
          a,
          [s - c.duration],
          [t, f, (c.maxDuration ?? 1 / 0) - c.duration - (c.trimOffset ?? 0)]
        ),
        d = (function (e, t) {
          if (null != t.trimOffset && null != t.maxDuration) {
            const n = t.maxDuration - t.trimOffset - t.duration - e,
              s = Math.min(t.trimOffset, t.trimOffset + n);
            return { ...t, trimOffset: s, duration: t.duration + e };
          }
          return { ...t, duration: t.duration + e };
        })(l, c),
        p = q_(e.elements, r, d);
      return "dragging" === n && l < 0
        ? { ...e, elements: p }
        : { ...e, elements: $_(p, o) };
    }
    if ("start" === l) {
      const t = o ? -1 / 0 : -c.start,
        i = c.duration - s,
        l = N_(a, [t, -f, -(c.trimOffset ?? 1 / 0)], [i]),
        u =
          ((d = l),
          null == (p = c).trimOffset
            ? { ...p, start: p.start + d, duration: p.duration - d }
            : {
                ...p,
                start: p.start + d,
                trimOffset: Math.max(0, p.trimOffset + d),
                duration: p.duration - d,
              }),
        h = q_(e.elements, r, u);
      return "dragging" === n
        ? { ...e, elements: h }
        : { ...e, elements: $_(h, o) };
    }
  } else if ("moving" === t.state) {
    const { trackIndex: s, toTrackIndex: l, toElementIndex: d } = t;
    if ("dragging" === n && (l !== s || o)) return e;
    if (o) {
      const t = [...e.elements];
      return t.splice(d, 0, t.splice(r, 1)[0]), { ...e, elements: $_(t, o) };
    }
    {
      const t = i - u,
        n = N_(a, [-c.start], [t]),
        s = q_(
          e.elements,
          r,
          (function (e, t) {
            return { ...t, start: t.start + e };
          })(n, c)
        );
      return { ...e, elements: s };
    }
  }
  var d, p;
  return e;
}
export function $_(e, t, n = 0) {
  return e.map(
    (e) => (
      (e = e.start < n || t ? { ...e, start: n } : e),
      (n = e.start + e.duration),
      e
    )
  );
}
export function q_(e, t, n) {
  return I_(e[t], n) || ((e = [...e])[t] = n), e;
}
export function G_({
  track: e,
  index: t,
  context: {
    dragState: n,
    updateState: s,
    packed: i,
    maxTotalDuration: o,
    minElementDuration: r,
    elementHeight: a,
  },
  context: l,
}) {
  const c = z_(e, n, "dragging", r, o, i);
  return (0, Q_.jsxs)("div", {
    style: { height: `${a}px` },
    className: (0, F_.default)(
      A_.videotrack,
      A_.droppableTrack,
      "moving" === n.state && {
        [A_.dropping]:
          n.trackIndex !== n.toTrackIndex && t === n.dropOverTrackIndex,
      }
    ),
    onPointerMove: (e) => {
      const [, n] = (function ({ clientX: e, clientY: t }, n) {
          do {
            (e -= n.offsetLeft), (t -= n.offsetTop);
          } while ((n = n.offsetParent));
          return [e, t];
        })(e, e.currentTarget),
        i = e.currentTarget.clientHeight;
      s({
        type: "videoTrackPointerMove",
        trackIndex: t,
        position: n < i / 2 ? "top" : "bottom",
      });
    },
    children: [
      c.elements.map((n, s) =>
        (0, Q_.jsx)(
          O_,
          {
            element: n,
            originalElement: e.elements[s],
            context: l,
            index: s,
            trackIndex: t,
          },
          n.id
        )
      ),
      (0, Q_.jsx)(D_, { trackIndex: t, track: e, context: l }),
    ],
  });
}
export function Z_({ index: e, context: { dragState: t } }) {
  return (0, Q_.jsx)("div", {
    className: (0, F_.default)(A_.droppableTrack, {
      [A_.dropping]: "moving" === t.state && e === t.dropOverTrackIndex,
    }),
  });
}
export var W_ = { state: "idle" };
export var K_ = (e) => {
  return function (e, i) {
    return "pointerDown" === i.type && "idle" === e.state
      ? (function (e) {
          return "move" === e.initiator
            ? (function (e) {
                return {
                  state: "start-moving",
                  trackIndex: e.trackIndex,
                  toTrackIndex: e.trackIndex,
                  deltaT: 0,
                  currentMouseX: e.clientX,
                  currentMouseY: e.clientY,
                  initialMouseX: e.clientX,
                  initialMouseY: e.clientY,
                  elementId: e.elementId,
                  elementIndex: e.elementIndex,
                  toElementIndex: e.elementIndex,
                  initialElementX: e.elementX,
                  initialElementY: e.elementY,
                };
              })(e)
            : (function (e) {
                return {
                  state: "start-trimming",
                  trimPosition: "trimStart" === e.initiator ? "start" : "end",
                  trackIndex: e.trackIndex,
                  deltaT: 0,
                  initialMouseX: e.clientX,
                  elementId: e.elementId,
                  elementIndex: e.elementIndex,
                };
              })(e);
        })(i)
      : ("pointerMove" === i.type && "start-trimming" === e.state) ||
        ("pointerMove" === i.type && "trimming" === e.state)
      ? n(e, i)
      : ("pointerMove" === i.type && "start-moving" === e.state) ||
        ("pointerMove" === i.type && "moving" === e.state)
      ? t(e, i)
      : ("videoTrackPointerMove" === i.type && "start-moving" === e.state) ||
        ("videoTrackPointerMove" === i.type && "moving" === e.state)
      ? s(e, i)
      : "tracksChanged" === i.type
      ? (function () {
          0;
          return { state: "idle" };
        })()
      : "pointerCancel" === i.type || "pointerUp" === i.type
      ? { state: "idle" }
      : e;
  };
  function t(t, n) {
    const s = n.clientX - t.initialMouseX,
      i = U_(
        e.tracks[t.trackIndex].elements[t.elementIndex],
        s,
        e.pxPerSec,
        "both",
        e.snapTimes
      );
    if (i === t.deltaT) return t;
    const o = e.tracks[t.trackIndex],
      r = e.tracks[t.toTrackIndex],
      a = t.elementIndex,
      l = o.elements[a],
      c = l.start + l.duration / 2 + i;
    let u,
      d = a;
    for (let e = 0; e < r.elements.length; e++) {
      const t = r.elements[e],
        n = c < t.start + t.duration / 2;
      if (e < a && n) {
        (d = e), (u = e);
        break;
      }
      e > a && !n && ((d = e), (u = e + 1));
    }
    return {
      ...t,
      state: "moving",
      deltaT: i,
      currentMouseX: n.clientX,
      currentMouseY: n.clientY,
      toElementIndex: d,
      dropOverElementIndex: u,
    };
  }
  function n(t, n) {
    const s = n.clientX - t.initialMouseX,
      i = U_(
        e.tracks[t.trackIndex].elements[t.elementIndex],
        s,
        e.pxPerSec,
        t.trimPosition,
        e.snapTimes
      );
    return i === t.deltaT ? t : { ...t, state: "trimming", deltaT: i };
  }
  function s(e, t) {
    const n = "top" === t.position,
      s = "bottom" === t.position,
      i = e.trackIndex,
      o = t.trackIndex,
      r =
        o === i + 1 && n
          ? o
          : o > i && n
          ? o - 1
          : o === i - 1 && s
          ? o
          : o < i && s
          ? o + 1
          : o,
      a = r > e.trackIndex ? r + 1 : r;
    return r !== e.toTrackIndex || a !== e.dropOverTrackIndex
      ? { ...e, toTrackIndex: r, dropOverTrackIndex: a }
      : { ...e };
  }
};

export function X_({
  packed: e = false,
  maxTotalDuration: t,
  minElementDuration: n = 0,
  tracks: s,
  pxPerSec: i,
  elementHeight: o,
  onChange: r,
  renderContent: a,
  renderGhost: l,
  snapTimes: c = t ? [0, t] : [0],
  onActionChange: u,
}) {
  const [d, p] = (0, P_.useReducer)(
      K_({ pxPerSec: i, tracks: s, snapTimes: c }),
      W_
    ),
    f = {
      packed: e,
      maxTotalDuration: t,
      minElementDuration: n,
      pxPerSec: i,
      elementHeight: o,
      dragState: d,
      updateState: p,
      renderContent: a,
      renderGhost: l,
    },
    h = ov(function (e) {
      if ("pointermove" === e.type)
        p({ type: "pointerMove", clientX: e.clientX, clientY: e.clientY });
      else if ("pointerup" === e.type) {
        if ("moving" === d.state || "trimming" === d.state) {
          const e = (function (
            e,
            t,
            { minElementDuration: n, maxTotalDuration: s, packed: i }
          ) {
            const { trackIndex: o } = t,
              r = "moving" === t.state ? t.toTrackIndex : o,
              a = [...e],
              l = a.splice(o, 1)[0];
            return a.splice(r, 0, z_(l, t, "submitting", n, s, i)), a;
          })(s, d, f);
          (function (e, t) {
            if (e === t) return true;
            if (e.length !== t.length) return false;
            for (let n = 0; n < e.length; n++)
              if (!H_(e[n], t[n])) return false;
            return true;
          })(e, s) || r?.(e);
        }
        p({ type: "pointerUp", clientX: e.clientX, clientY: e.clientY });
      }
    }),
    m = "idle" === d.state;
  return (
    (0, P_.useEffect)(
      () =>
        m
          ? L_.default
          : (window.addEventListener("pointermove", h),
            window.addEventListener("pointerup", h),
            () => {
              window.removeEventListener("pointerup", h),
                window.removeEventListener("pointermove", h);
            }),
      [h, m]
    ),
    (0, P_.useEffect)(() => {
      p({ type: "tracksChanged", tracks: s });
    }, [s]),
    (0, P_.useEffect)(() => {
      u?.(d.state);
    }, [d.state, u]),
    (0, Y_.jsxs)("div", {
      className: A_.dragBounds,
      onPointerOut: (e) => {
        e.currentTarget === e.target &&
          f.updateState({ type: "pointerCancel" });
      },
      onPointerCancel: () => {
        f.updateState({ type: "pointerCancel" });
      },
      onPointerUp: (e) => {
        if ("moving" === d.state || "trimming" === d.state) {
          e.stopPropagation();
          const t = new PointerEvent("pointerup", {
            clientX: e.clientX,
            clientY: e.clientY,
          });
          window.dispatchEvent(t);
        }
      },
      children: [
        s.map((e, t) =>
          (0, Y_.jsx)(G_, { index: t, track: e, context: f }, e.id)
        ),
        (0, Y_.jsx)(Z_, { context: f, index: s.length }),
        (0, Y_.jsx)(V_, { context: f, tracks: s }),
      ],
    })
  );
}

export var aE = [
  { interval: 40, tickIntervals: [40, 20, 10, 5, 2] },
  { interval: 20, tickIntervals: [20, 10, 5, 2] },
  { interval: 15, tickIntervals: [15, 5, 10] },
  { interval: 10, tickIntervals: [10, 5, 2] },
  { interval: 4, tickIntervals: [8, 4, 2] },
  { interval: 2, tickIntervals: [10, 4, 2] },
  { interval: 1, tickIntervals: [10, 5, 2] },
];
export function lE(e) {
  if (e < 60) return `${e}s`;
  const t = e % 60;
  return `${Math.floor(e / 60)}:${t < 10 ? `0${t}` : t}`;
}
export var cE = function ({
  className: e,
  pixelRatio: t,
  minDuration: n,
  maxDuration: s,
  totalDuration: i = s,
  zeroPointOffset: o = 0,
  baseTickSpacing: r = 30,
  baseSecondSpacing: a = 200,
}) {
  const l = (0, J_.useRef)(null),
    [c, u] = (0, J_.useState)(0);
  (0, J_.useLayoutEffect)(() => {
    const e = l.current;
    if (!e) return;
    u(e.clientWidth);
    const t = new ResizeObserver(([e]) => {
      u(e.contentRect.width);
    });
    return (
      t.observe(e),
      () => {
        t.disconnect();
      }
    );
  }, []);
  const {
      interval: d,
      tickIntervals: p,
      totalSeconds: f,
    } = (0, J_.useMemo)(() => {
      const e = Math.max(1, Math.floor(a / t));
      return {
        ...(aE.find((t) => t.interval <= e) ?? aE[0]),
        totalSeconds: Math.ceil(c / t),
      };
    }, [a, t, c]),
    h = (0, J_.useMemo)(() => {
      const e = Math.ceil(f / d),
        n = p.find((e) => e <= Math.floor((d * t) / r)),
        s = n
          ? Array(n)
              .fill(null)
              .map((e, t) => t)
          : [];
      return new Array(e).fill(null).map((e, n) => {
        const i = n * d;
        return { value: i, width: d * t, offset: i * t + o, ticks: s };
      });
    }, [r, d, t, p, f, o]),
    m = s ?? i;
  return (0, rE.jsxs)("div", {
    className: (0, eE.default)(tE, e),
    ref: l,
    children: [
      h.map((e) =>
        (0, rE.jsx)(
          "span",
          {
            className: nE,
            "data-second": lE(e.value),
            style: { width: e.width, left: e.offset },
            children: e.ticks.map((e) =>
              (0, rE.jsx)("span", { className: sE }, e)
            ),
          },
          e.value
        )
      ),
      null != n &&
        (0, rE.jsx)("span", { className: oE, style: { left: n * t + o } }),
      (0, rE.jsx)("span", { className: iE, style: { left: 0, width: o } }),
      null != m &&
        (0, rE.jsx)("span", {
          className: iE,
          style: { left: m * t + o, right: 0 },
        }),
    ],
  });
};

export var hE = function ({
  className: e,
  pixelRatio: t,
  maxDuration: n,
  totalDuration: s = n,
  zeroPointOffset: i = 0,
}) {
  const o = n ?? s;
  return (0, fE.jsxs)("div", {
    className: (0, uE.default)(dE, e),
    children: [
      (0, fE.jsx)("span", { className: pE, style: { left: 0, width: i } }),
      null != o &&
        (0, fE.jsx)("span", {
          className: pE,
          style: { left: o * t + i, right: 0 },
        }),
    ],
  });
};

export var vE;
export var wE = {
  block: "UBQ_TimelineClip-module__block--8UprU",
  trimHandle: "UBQ_TimelineClip-module__trimHandle--hLClY",
  trimHandleLeft: "UBQ_TimelineClip-module__trimHandleLeft--CNiD0",
  trimHandleRight: "UBQ_TimelineClip-module__trimHandleRight--rvNtR",
  meta: "UBQ_TimelineClip-module__meta--ORIQi",
  metaLabel: "UBQ_TimelineClip-module__metaLabel--7d-oM",
  metaIcon: "UBQ_TimelineClip-module__metaIcon--UkWBV",
  description: "UBQ_TimelineClip-module__description--Wo1Cb",
  atlas: "UBQ_TimelineClip-module__atlas--lgDR4",
  contextMenu: "UBQ_TimelineClip-module__contextMenu--CODYE",
};

export function CE({
  className: e,
  children: t,
  isSelected: n = false,
  moveRef: s,
  onPointerDown: i,
  onPointerUp: o,
  ...r
}) {
  return (0, kE.jsx)("div", {
    onPointerDown: i,
    onPointerUp: o,
    "aria-selected": n,
    ref: s,
    className: (0, mE.default)(wE.block, e, { [wE.selected]: n }),
    ...r,
    children: t,
  });
}
export function jE({
  show: e = "always",
  trimLeftRef: t,
  trimRightRef: n,
  limitReachedLeft: s,
  limitReachedRight: i,
}) {
  return (0, kE.jsxs)(kE.Fragment, {
    children: [
      (0, kE.jsx)("span", {
        ref: t,
        className: (0, mE.default)(wE.trimHandle, wE.trimHandleLeft),
        "data-show": e,
        children: s ? (0, kE.jsx)(yE, {}) : (0, kE.jsx)(xE, {}),
      }),
      (0, kE.jsx)("span", {
        ref: n,
        className: (0, mE.default)(wE.trimHandle, wE.trimHandleRight),
        "data-show": e,
        children: i ? (0, kE.jsx)(yE, {}) : (0, kE.jsx)(bE, {}),
      }),
    ],
  });
}
export function SE({ className: e, children: t, show: n = "always" }) {
  return (0, kE.jsx)("span", {
    className: (0, mE.default)(wE.meta, e),
    "data-show": n,
    children: t,
  });
}
export function _E({ className: e, children: t, show: n = "always" }) {
  return (0, kE.jsx)("span", {
    className: (0, mE.default)(wE.metaLabel, e),
    "data-show": n,
    children: t,
  });
}
export function EE({ className: e, children: t, show: n = "always" }) {
  return (0, kE.jsx)("span", {
    className: (0, mE.default)(wE.metaIcon, e),
    "data-show": n,
    children: t,
  });
}
export function LE({ className: e, children: t, show: n = "always" }) {
  return (0, kE.jsx)("span", {
    className: (0, mE.default)(wE.description, e),
    "data-show": n,
    children: t,
  });
}
export function PE({ className: e, children: t }) {
  return (0, kE.jsx)("div", {
    className: (0, mE.default)(wE.atlas, e),
    children: t,
  });
}
export function AE({
  "aria-label": e,
  show: t,
  children: n,
  closeOnWheel: s,
  returnFocus: i,
  ...o
}) {
  return (0, kE.jsxs)(Cx, {
    returnFocus: i,
    closeOnWheel: s,
    children: [
      (n) => {
        const s = (0, kE.jsx)(CompCustomButton, {
          className: wE.contextMenu,
          "aria-label": e,
          variant: "regular",
          "data-show": t,
          ...o,
          ...n,
          children: (0, kE.jsx)(CC, {}),
        });
        return e ? (0, kE.jsx)(Ly, { label: e, children: s }) : s;
      },
      (e) => (0, kE.jsx)(yC.Container, { children: n(e) }),
    ],
  });
}
export function BE(e) {
  return (0, kE.jsx)(yC.Item, { ...e });
}
((vE = CE || (CE = {})).TrimHandles = jE),
  (vE.Meta = SE),
  (vE.MetaLabel = _E),
  (vE.MetaIcon = EE),
  (vE.Description = LE),
  (vE.Atlas = PE),
  (vE.ContextMenu = AE),
  (vE.ContextMenuItem = BE);
export var TE = CE;

export var IE = function ({
  className: e,
  ariaLabeledBy: t,
  pixelRatio: n,
  zeroPointOffset: s = 0,
  totalDuration: i,
  playbackTime: o,
  onDragEnd: r,
  onDragStart: a,
  onDrag: l,
}) {
  const c = (0, OE.useRef)(null),
    u = zd(o * n);
  (0, OE.useEffect)(() => {
    u.set(o * n);
  }, [n, o, u]);
  const d = (e) => {
    const t = c.current?.getBoundingClientRect(),
      s = e instanceof TouchEvent ? e.touches[0].clientX : e.clientX,
      o = wk(0, s - t.left, i * n);
    return u.set(o), o / n;
  };
  return (0, FE.jsx)("div", {
    className: (0, ME.default)(RE, e),
    role: "slider",
    tabIndex: -1,
    "aria-valuenow": o,
    "aria-labelledby": t,
    "aria-valuemin": 0,
    "aria-valuemax": i,
    style: { left: s, width: i ? i * n : 0 },
    ref: c,
    children: (0, FE.jsx)(Sd.div, {
      className: VE,
      initial: { cursor: "grab" },
      whileTap: { cursor: "grabbing" },
      tabIndex: -1,
      drag: "x",
      _dragX: u,
      dragConstraints: c,
      dragElastic: false,
      dragMomentum: false,
      onDragStart: a,
      onDrag: (e) => {
        const t = d(e);
        l?.(t);
      },
      onDragEnd: (e) => {
        const t = d(e);
        r?.(t);
      },
      style: { x: u },
      children: (0, FE.jsx)("div", {
        className: (0, ME.default)(DE),
        children: (0, FE.jsx)("svg", {
          width: "8",
          height: "12",
          viewBox: "0 0 8 12",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          children: (0, FE.jsx)("path", {
            d: "M0.5 1C0.5 0.723858 0.723858 0.5 1 0.5H7C7.27614 0.5 7.5 0.723858 7.5 1V8.25339C7.5 8.40336 7.43269 8.54541 7.31662 8.64037L4.31662 11.0949C4.13244 11.2456 3.86756 11.2456 3.68338 11.0949L0.683381 8.64037C0.567313 8.54541 0.5 8.40336 0.5 8.25339V1Z",
          }),
        }),
      }),
    }),
  });
};
export var HE = function ({ elementRef: e, copy: t, paste: n }) {
  const s = { elementRef: e, action: "keydown", global: false };
  mostlyHook1(["ctrl+c", "command+c"], t, s),
    mostlyHook1(["ctrl+v", "command+v"], n, s);
};

export var UE = (
  e,
  { isEnabled: t = true, onIntersecting: n, rootMargin: s } = {}
) => {
  const [i, o] = (0, NE.useState)(false),
    r = (0, NE.useRef)(n);
  return (
    (0, NE.useEffect)(() => {
      r.current = n;
    }, [n]),
    (0, NE.useEffect)(() => {
      if (!t) return () => {};
      if (!window.IntersectionObserver)
        return o(true), r.current && r.current(), () => {};
      const n = new IntersectionObserver(
        ([e]) => {
          o(e.isIntersecting), r.current && e.isIntersecting && r.current();
        },
        { rootMargin: s ?? "0px" }
      );
      return (
        e.current && n.observe(e.current),
        () => {
          n.disconnect();
        }
      );
    }, [e.current, t]),
    i
  );
};

export var $E = (e, t) => {
  const n = (0, zE.useRef)(null),
    [s, i] = (0, zE.useState)(t);
  return (
    (0, zE.useEffect)(() => {
      if (null != n.current) {
        const t = getComputedStyle(n.current);
        i(e(t, n.current));
      }
    }, []),
    [n, s]
  );
};
export var QE = ["down", "shift+down"];
export var GE = ["left", "shift+left"];
export var ZE = ["right", "shift+right"];
export var WE = ["enter", "shift+enter"];
export var KE = ["escape"];
export var YE = function ({
  elementRef: e,
  up: t,
  down: n,
  left: s,
  right: i,
  enter: o,
  escape: r,
}) {
  const a = { elementRef: e, action: "keydown", global: false };
  Xy(qE, t, a),
    Xy(QE, n, a),
    Xy(GE, s, a),
    Xy(ZE, i, a),
    Xy(WE, o, a),
    Xy(KE, r, a);
};
export var JE = () => (0, XE.useReducer)(() => ({}), {})[1];

export function nL({
  minDelay: e = 300,
  maxDelay: t = 1e3,
  acceleration: n = 0.5,
} = {}) {
  const s = (0, tL.useRef)(null),
    {
      isReady: i,
      clear: o,
      debounce: r,
    } = (function (e = 0) {
      const t = (0, eL.useRef)(false),
        n = (0, eL.useRef)(),
        s = (0, eL.useCallback)(() => t.current, []),
        i = (0, eL.useCallback)(
          (s, i = e) => {
            (t.current = false),
              n.current && window.clearTimeout(n.current),
              (n.current = window.setTimeout(() => {
                (t.current = true), s();
              }, i));
          },
          [e]
        ),
        o = (0, eL.useCallback)(() => {
          (t.current = null), n.current && window.clearTimeout(n.current);
        }, []);
      return (
        (0, eL.useEffect)(() => o, [o, e]),
        { isReady: s, clear: o, debounce: i }
      );
    })(),
    a = (0, tL.useCallback)(
      (i) => {
        const a = Date.now() - (s.current || Date.now()),
          l = Math.min(e + n * a, t);
        o(), r(i, l), (s.current = Date.now());
      },
      [n, t, e, r, o]
    );
  return { isReady: i, clear: o, debounce: a };
}
export function iL(e) {
  const t = (0, sL.useContext)(context7),
    n = Object.keys(t);
  if (e && n.includes(e)) {
    const { width: n, height: s } = t[e];
    return { width: n, height: s };
  }
  {
    const { width: e, height: n } = t.default;
    return { width: e, height: n };
  }
}

export function aL({
  onFileChanged: e,
  name: t,
  className: n,
  children: s,
  ...i
}) {
  const o = (0, oL.useRef)(null),
    r = () => o.current?.click();
  return (0, rL.jsxs)(rL.Fragment, {
    children: [
      "function" == typeof s
        ? s({ onClick: r, id: t })
        : (0, rL.jsx)(CompCustomButton, {
            className: n,
            name: t,
            id: t,
            onClick: r,
            children: s,
          }),
      (0, rL.jsx)("input", {
        type: "file",
        name: t,
        "aria-labelledby": t,
        onChange: (t) => {
          const n = Array.from(t.target.files || []);
          n.length > 0 && e && e(n);
        },
        style: { display: "none" },
        ...i,
        ref: o,
      }),
    ],
  });
}
Object.defineProperty(aL, "displayName", { value: "FileUpload" });
export var lL = aL;
export var fL = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
export function hL(e) {
  var t = {
      type: "tag",
      name: "",
      voidElement: false,
      attrs: {},
      children: [],
    },
    n = e.match(/<\/?([^\s]+?)[/\s>]/);
  if (
    n &&
    ((t.name = n[1]),
    (pL.default[n[1]] || "/" === e.charAt(e.length - 2)) &&
      (t.voidElement = true),
    t.name.startsWith("!--"))
  ) {
    var s = e.indexOf("--\x3e");
    return { type: "comment", comment: -1 !== s ? e.slice(4, s) : "" };
  }
  for (var i = new RegExp(fL), o = null; null !== (o = i.exec(e)); )
    if (o[0].trim())
      if (o[1]) {
        var r = o[1].trim(),
          a = [r, ""];
        r.indexOf("=") > -1 && (a = r.split("=")),
          (t.attrs[a[0]] = a[1]),
          i.lastIndex--;
      } else
        o[2] && (t.attrs[o[2]] = o[3].trim().substring(1, o[3].length - 1));
  return t;
}
export var mL = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g;
export var gL = /^\s*$/;
export var xL = Object.create(null);
export function bL(e, t) {
  switch (t.type) {
    case "text":
      return e + t.content;
    case "tag":
      return (
        (e +=
          "<" +
          t.name +
          (t.attrs
            ? (function (e) {
                var t = [];
                for (var n in e) t.push(n + '="' + e[n] + '"');
                return t.length ? " " + t.join(" ") : "";
              })(t.attrs)
            : "") +
          (t.voidElement ? "/>" : ">")),
        t.voidElement ? e : e + t.children.reduce(bL, "") + "</" + t.name + ">"
      );
    case "comment":
      return e + "\x3c!--" + t.comment + "--\x3e";
  }
}
export var yL;
export var vL = {
  parse: function (e, t) {
    t || (t = {}), t.components || (t.components = xL);
    var n,
      s = [],
      i = [],
      o = -1,
      r = false;
    if (0 !== e.indexOf("<")) {
      var a = e.indexOf("<");
      s.push({ type: "text", content: -1 === a ? e : e.substring(0, a) });
    }
    return (
      e.replace(mL, function (a, l) {
        if (r) {
          if (a !== "</" + n.name + ">") return;
          r = false;
        }
        var c,
          u = "/" !== a.charAt(1),
          d = a.startsWith("\x3c!--"),
          p = l + a.length,
          f = e.charAt(p);
        if (d) {
          var h = hL(a);
          return o < 0 ? (s.push(h), s) : ((c = i[o]).children.push(h), s);
        }
        if (
          (u &&
            (o++,
            "tag" === (n = hL(a)).type &&
              t.components[n.name] &&
              ((n.type = "component"), (r = true)),
            n.voidElement ||
              r ||
              !f ||
              "<" === f ||
              n.children.push({
                type: "text",
                content: e.slice(p, e.indexOf("<", p)),
              }),
            0 === o && s.push(n),
            (c = i[o - 1]) && c.children.push(n),
            (i[o] = n)),
          (!u || n.voidElement) &&
            (o > -1 &&
              (n.voidElement || n.name === a.slice(2, -1)) &&
              (o--, (n = -1 === o ? s : i[o])),
            !r && "<" !== f && f))
        ) {
          c = -1 === o ? s : i[o].children;
          var m = e.indexOf("<", p),
            g = e.slice(p, -1 === m ? undefined : m);
          gL.test(g) && (g = " "),
            ((m > -1 && o + c.length >= 0) || " " !== g) &&
              c.push({ type: "text", content: g });
        }
      }),
      s
    );
  },
  stringify: function (e) {
    return e.reduce(function (e, t) {
      return e + bL("", t);
    }, "");
  },
};
export var wL = vL;
export var kL = (...e) => {
  console?.warn &&
    (LL(e[0]) && (e[0] = `react-i18next:: ${e[0]}`), console.warn(...e));
};
export var CL = {};
export var jL = (...e) => {
  (LL(e[0]) && CL[e[0]]) || (LL(e[0]) && (CL[e[0]] = new Date()), kL(...e));
};
export var SL = (e, t) => () => {
  if (e.isInitialized) t();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n);
      }, 0),
        t();
    };
    e.on("initialized", n);
  }
};
export var _L = (e, t, n) => {
  e.loadNamespaces(t, SL(e, n));
};
export var EL = (e, t, n, s) => {
  LL(n) && (n = [n]),
    n.forEach((t) => {
      e.options.ns.indexOf(t) < 0 && e.options.ns.push(t);
    }),
    e.loadLanguages(t, SL(e, s));
};
export var LL = (e) => "string" == typeof e;
export var PL = (e) => "object" == typeof e && null !== e;
export var AL =
  /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
export var BL = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/",
};
export var TL = (e) => BL[e];
export var ML = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape: (e) => e.replace(AL, TL),
};
export var OL = () => ML;
export var RL = () => yL;
export var VL = (e, t) => {
  if (!e) return false;
  const n = e.props?.children ?? e.children;
  return t ? n.length > 0 : !!n;
};
export var DL = (e) => {
  if (!e) return [];
  const t = e.props?.children ?? e.children;
  return e.props?.i18nIsDynamicList ? FL(t) : t;
};
export var FL = (e) => (Array.isArray(e) ? e : [e]);
export var IL = (e, t) => {
  if (!e) return "";
  let n = "";
  const s = FL(e),
    i = t?.transSupportBasicHtmlNodes ? t.transKeepBasicHtmlNodesFor ?? [] : [];
  return (
    s.forEach((e, s) => {
      if (LL(e)) n += `${e}`;
      else if ((0, dL.isValidElement)(e)) {
        const { props: o, type: r } = e,
          a = Object.keys(o).length,
          l = i.indexOf(r) > -1,
          c = o.children;
        if (c || !l || a)
          if ((!c && (!l || a)) || o.i18nIsDynamicList) n += `<${s}></${s}>`;
          else if (l && 1 === a && LL(c)) n += `<${r}>${c}</${r}>`;
          else {
            const e = IL(c, t);
            n += `<${s}>${e}</${s}>`;
          }
        else n += `<${r}/>`;
      } else if (null === e)
        kL(
          "Trans: the passed in value is invalid - seems you passed in a null child."
        );
      else if (PL(e)) {
        const { format: t, ...s } = e,
          i = Object.keys(s);
        if (1 === i.length) {
          const e = t ? `${i[0]}, ${t}` : i[0];
          n += `{{${e}}}`;
        } else
          kL(
            "react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.",
            e
          );
      } else
        kL(
          "Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.",
          e
        );
    }),
    n
  );
};
export var HL = (e, t, n, s, i, o) => {
  if ("" === t) return [];
  const r = s.transKeepBasicHtmlNodesFor || [],
    a = t && new RegExp(r.map((e) => `<${e}`).join("|")).test(t);
  if (!e && !a && !o) return [t];
  const l = {},
    c = (e) => {
      FL(e).forEach((e) => {
        LL(e) ||
          (VL(e)
            ? c(DL(e))
            : PL(e) && !(0, dL.isValidElement)(e) && Object.assign(l, e));
      });
    };
  c(e);
  const u = wL.parse(`<0>${t}</0>`),
    d = { ...l, ...i },
    p = (e, t, n) => {
      const s = DL(e),
        i = h(s, t.children, n);
      return (((e) => Array.isArray(e) && e.every(dL.isValidElement))(s) &&
        0 === i.length) ||
        e.props?.i18nIsDynamicList
        ? s
        : i;
    },
    f = (e, t, n, s, i) => {
      e.dummy
        ? ((e.children = t),
          n.push((0, dL.cloneElement)(e, { key: s }, i ? undefined : t)))
        : n.push(
            ...dL.Children.map([e], (e) => {
              const n = { ...e.props };
              return (
                delete n.i18nIsDynamicList,
                (0, dL.createElement)(
                  e.type,
                  { ...n, key: s, ref: e.ref },
                  i ? null : t
                )
              );
            })
          );
    },
    h = (t, i, l) => {
      const c = FL(t);
      return FL(i).reduce((t, i, u) => {
        const m =
          i.children?.[0]?.content &&
          n.services.interpolator.interpolate(
            i.children[0].content,
            d,
            n.language
          );
        if ("tag" === i.type) {
          let o = c[parseInt(i.name, 10)];
          1 !== l.length || o || (o = l[0][i.name]), o || (o = {});
          const g =
              0 !== Object.keys(i.attrs).length
                ? ((e, t) => {
                    const n = { ...t };
                    return (n.props = Object.assign(e.props, t.props)), n;
                  })({ props: i.attrs }, o)
                : o,
            x = (0, dL.isValidElement)(g),
            b = x && VL(i, true) && !i.voidElement,
            y = a && PL(g) && g.dummy && !x,
            v = PL(e) && Object.hasOwnProperty.call(e, i.name);
          if (LL(g)) {
            const e = n.services.interpolator.interpolate(g, d, n.language);
            t.push(e);
          } else if (VL(g) || b) {
            const e = p(g, i, l);
            f(g, e, t, u);
          } else if (y) {
            const e = h(c, i.children, l);
            f(g, e, t, u);
          } else if (Number.isNaN(parseFloat(i.name)))
            if (v) {
              const e = p(g, i, l);
              f(g, e, t, u, i.voidElement);
            } else if (s.transSupportBasicHtmlNodes && r.indexOf(i.name) > -1)
              if (i.voidElement)
                t.push(
                  (0, dL.createElement)(i.name, { key: `${i.name}-${u}` })
                );
              else {
                const e = h(c, i.children, l);
                t.push(
                  (0, dL.createElement)(i.name, { key: `${i.name}-${u}` }, e)
                );
              }
            else if (i.voidElement) t.push(`<${i.name} />`);
            else {
              const e = h(c, i.children, l);
              t.push(`<${i.name}>${e}</${i.name}>`);
            }
          else if (PL(g) && !x) {
            const e = i.children[0] ? m : null;
            e && t.push(e);
          } else f(g, m, t, u, 1 !== i.children.length || !m);
        } else if ("text" === i.type) {
          const e = s.transWrapTextNodes,
            r = o
              ? s.unescape(
                  n.services.interpolator.interpolate(i.content, d, n.language)
                )
              : n.services.interpolator.interpolate(i.content, d, n.language);
          e
            ? t.push((0, dL.createElement)(e, { key: `${i.name}-${u}` }, r))
            : t.push(r);
        }
        return t;
      }, []);
    },
    m = h([{ dummy: true, children: e || [] }], u, FL(e || []));
  return DL(m[0]);
};
export var UL = {
  type: "3rdParty",
  init(e) {
    ((e = {}) => {
      ML = { ...ML, ...e };
    })(e.options.react),
      ((e) => {
        yL = e;
      })(e);
  },
};
export var zL = (0, NL.createContext)();

export function qL({
  children: e,
  count: t,
  parent: n,
  i18nKey: s,
  context: i,
  tOptions: o = {},
  values: r,
  defaults: a,
  components: l,
  ns: c,
  i18n: u,
  t: d,
  shouldUnescape: p,
  ...f
}) {
  const { i18n: h, defaultNS: m } = (0, uL.useContext)(zL) || {},
    g = u || h || RL(),
    x = d || g?.t.bind(g);
  return (function ({
    children: e,
    count: t,
    parent: n,
    i18nKey: s,
    context: i,
    tOptions: o = {},
    values: r,
    defaults: a,
    components: l,
    ns: c,
    i18n: u,
    t: d,
    shouldUnescape: p,
    ...f
  }) {
    const h = u || RL();
    if (!h)
      return (
        jL(
          "You will need to pass in an i18next instance by using i18nextReactModule"
        ),
        e
      );
    const m = d || h.t.bind(h) || ((e) => e),
      g = { ...OL(), ...h.options?.react };
    let x = c || m.ns || h.options?.defaultNS;
    x = LL(x) ? [x] : x || ["translation"];
    const b = IL(e, g),
      y = a || b || g.transEmptyNodeValue || s,
      { hashTransKey: v } = g,
      w = s || (v ? v(b || y) : b || y);
    h.options?.interpolation?.defaultVariables &&
      (r =
        r && Object.keys(r).length > 0
          ? { ...r, ...h.options.interpolation.defaultVariables }
          : { ...h.options.interpolation.defaultVariables });
    const k =
        r || undefined !== t || !e
          ? o.interpolation
          : {
              interpolation: {
                ...o.interpolation,
                prefix: "#$?",
                suffix: "?$#",
              },
            },
      C = {
        ...o,
        context: i || o.context,
        count: t,
        ...r,
        ...k,
        defaultValue: y,
        ns: x,
      },
      j = w ? m(w, C) : y;
    l &&
      Object.keys(l).forEach((e) => {
        const t = l[e];
        "function" == typeof t.type ||
          !t.props ||
          !t.props.children ||
          (j.indexOf(`${e}/>`) < 0 && j.indexOf(`${e} />`) < 0) ||
          (l[e] = (0, dL.createElement)(function () {
            return (0, dL.createElement)(dL.Fragment, null, t);
          }));
      });
    const S = HL(l || e, j, h, g, C, p),
      _ = n ?? g.defaultTransParent;
    return _ ? (0, dL.createElement)(_, f, S) : S;
  })({
    children: e,
    count: t,
    parent: n,
    i18nKey: s,
    context: i,
    tOptions: o,
    values: r,
    defaults: a,
    components: l,
    ns: c || x?.ns || m || g?.options?.defaultNS,
    i18n: g,
    t: d,
    shouldUnescape: p,
    ...f,
  });
}
export var GL = (e, t, n, s) => e.getFixedT(t, n, s);
export var ZL = (e, t = {}) => {
  const { i18n: n } = t,
    { i18n: s, defaultNS: i } = (0, QL.useContext)(zL) || {},
    o = n || s || RL();
  if (
    (o && !o.reportNamespaces && (o.reportNamespaces = new NamespaceHelper()),
    !o)
  ) {
    jL(
      "You will need to pass in an i18next instance by using initReactI18next"
    );
    const e = (e, t) =>
        LL(t)
          ? t
          : PL(t) && LL(t.defaultValue)
          ? t.defaultValue
          : Array.isArray(e)
          ? e[e.length - 1]
          : e,
      t = [e, {}, false];
    return (t.t = e), (t.i18n = {}), (t.ready = false), t;
  }
  o.options.react?.wait &&
    jL(
      "It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour."
    );
  const r = { ...OL(), ...o.options.react, ...t },
    { useSuspense: a, keyPrefix: l } = r;
  let c = e || i || o.options?.defaultNS;
  (c = LL(c) ? [c] : c || ["translation"]),
    o.reportNamespaces.addUsedNamespaces?.(c);
  const u =
      (o.isInitialized || o.initializedStoreOnce) &&
      c.every((e) =>
        ((e, t, n = {}) =>
          t.languages && t.languages.length
            ? t.hasLoadedNamespace(e, {
                lng: n.lng,
                precheck: (t, s) => {
                  if (
                    n.bindI18n?.indexOf("languageChanging") > -1 &&
                    t.services.backendConnector.backend &&
                    t.isLanguageChangingTo &&
                    !s(t.isLanguageChangingTo, e)
                  )
                    return false;
                },
              })
            : (jL("i18n.languages were undefined or empty", t.languages),
              true))(e, o, r)
      ),
    d = ((e, t, n, s) => (0, QL.useCallback)(GL(e, t, n, s), [e, t, n, s]))(
      o,
      t.lng || null,
      "fallback" === r.nsMode ? c : c[0],
      l
    ),
    p = () => d,
    f = () => GL(o, t.lng || null, "fallback" === r.nsMode ? c : c[0], l),
    [h, m] = (0, QL.useState)(p);
  let g = c.join();
  t.lng && (g = `${t.lng}${g}`);
  const x = ((e, t) => {
      const n = (0, QL.useRef)();
      return (
        (0, QL.useEffect)(() => {
          n.current = t ? n.current : e;
        }, [e, t]),
        n.current
      );
    })(g),
    b = (0, QL.useRef)(true);
  (0, QL.useEffect)(() => {
    const { bindI18n: e, bindI18nStore: n } = r;
    (b.current = true),
      u ||
        a ||
        (t.lng
          ? EL(o, t.lng, c, () => {
              b.current && m(f);
            })
          : _L(o, c, () => {
              b.current && m(f);
            })),
      u && x && x !== g && b.current && m(f);
    const s = () => {
      b.current && m(f);
    };
    return (
      e && o?.on(e, s),
      n && o?.store.on(n, s),
      () => {
        (b.current = false),
          o && e?.split(" ").forEach((e) => o.off(e, s)),
          n && o && n.split(" ").forEach((e) => o.store.off(e, s));
      }
    );
  }, [o, g]),
    (0, QL.useEffect)(() => {
      b.current && u && m(p);
    }, [o, l, u]);
  const y = [h, o, u];
  if (((y.t = h), (y.i18n = o), (y.ready = u), u)) return y;
  if (!u && !a) return y;
  throw new Promise((e) => {
    t.lng ? EL(o, t.lng, c, () => e()) : _L(o, c, () => e());
  });
};
export function YL(e) {
  for (
    var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1;
    s < t;
    s++
  )
    n[s - 1] = arguments[s];
  throw new Error(
    "number" == typeof e
      ? "[MobX] minified error nr: " +
        e +
        (n.length ? " " + n.map(String).join(",") : "") +
        ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts"
      : "[MobX] " + e
  );
}
export var XL = {};
export function JL() {
  return "undefined" != typeof globalThis
    ? globalThis
    : "undefined" != typeof window
    ? window
    : "undefined" != typeof global
    ? global
    : "undefined" != typeof self
    ? self
    : XL;
}
export var eP = Object.assign;
export var tP = Object.getOwnPropertyDescriptor;
export var nP = Object.defineProperty;
export var sP = Object.prototype;
export var iP = [];
Object.freeze(iP);
export var oP = {};
Object.freeze(oP);
export var rP = "undefined" != typeof Proxy;
export var aP = Object.toString();
export function lP() {
  rP || YL("Proxy not available");
}
export function cP(e) {
  var t = false;
  return function () {
    if (!t) return (t = true), e.apply(this, arguments);
  };
}
export var uP = function () {};
export function dP(e) {
  return "function" == typeof e;
}
export function pP(e) {
  switch (typeof e) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
export function fP(e) {
  return null !== e && "object" == typeof e;
}
export function hP(e) {
  var t;
  if (!fP(e)) return false;
  var n = Object.getPrototypeOf(e);
  return (
    null == n || (null == (t = n.constructor) ? undefined : t.toString()) === aP
  );
}
export function mP(e) {
  var t = null == e ? undefined : e.constructor;
  return (
    !!t &&
    ("GeneratorFunction" === t.name || "GeneratorFunction" === t.displayName)
  );
}
export function gP(e, t, n) {
  nP(e, t, { enumerable: false, writable: true, configurable: true, value: n });
}
export function xP(e, t, n) {
  nP(e, t, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: n,
  });
}
export function bP(e, t) {
  var n = "isMobX" + e;
  return (
    (t.prototype[n] = true),
    function (e) {
      return fP(e) && true === e[n];
    }
  );
}
export function yP(e) {
  return e instanceof Map;
}
export function vP(e) {
  return e instanceof Set;
}
export var wP = undefined !== Object.getOwnPropertySymbols;
export var kP =
  "undefined" != typeof Reflect && Reflect.ownKeys
    ? Reflect.ownKeys
    : wP
    ? function (e) {
        return Object.getOwnPropertyNames(e).concat(
          Object.getOwnPropertySymbols(e)
        );
      }
    : Object.getOwnPropertyNames;
export function CP(e) {
  return null === e ? null : "object" == typeof e ? "" + e : e;
}
export function jP(e, t) {
  return sP.hasOwnProperty.call(e, t);
}
export var SP =
  Object.getOwnPropertyDescriptors ||
  function (e) {
    var t = {};
    return (
      kP(e).forEach(function (n) {
        t[n] = tP(e, n);
      }),
      t
    );
  };
export function _P(e, t) {
  for (var n = 0; n < t.length; n++) {
    var s = t[n];
    (s.enumerable = s.enumerable || false),
      (s.configurable = true),
      "value" in s && (s.writable = true),
      Object.defineProperty(e, s.key, s);
  }
}
export function EP(e, t, n) {
  return t && _P(e.prototype, t), n && _P(e, n), e;
}
export function LP() {
  return (
    (LP =
      Object.assign ||
      function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    LP.apply(this, arguments)
  );
}
export function PP(e, t) {
  (e.prototype = Object.create(t.prototype)),
    (e.prototype.constructor = e),
    (e.__proto__ = t);
}
export function AP(e) {
  if (undefined === e)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e;
}
export function BP(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var n = 0, s = new Array(t); n < t; n++) s[n] = e[n];
  return s;
}
export function TP(e, t) {
  var n;
  if ("undefined" == typeof Symbol || null == e[Symbol.iterator]) {
    if (
      Array.isArray(e) ||
      (n = (function (e, t) {
        if (e) {
          if ("string" == typeof e) return BP(e, t);
          var n = Object.prototype.toString.call(e).slice(8, -1);
          return (
            "Object" === n && e.constructor && (n = e.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(e)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? BP(e, t)
              : undefined
          );
        }
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      n && (e = n);
      var s = 0;
      return function () {
        return s >= e.length ? { done: true } : { done: false, value: e[s++] };
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  return (n = e[Symbol.iterator]()).next.bind(n);
}
export var MP = Symbol("mobx-stored-annotations");
export function OP(e) {
  return Object.assign(function (t, n) {
    RP(t, n, e);
  }, e);
}
export function RP(e, t, n) {
  jP(e, MP) || gP(e, MP, LP({}, e[MP])),
    (function (e) {
      return e.annotationType_ === zP;
    })(n) || (e[MP][t] = n);
}
export var VP = Symbol("mobx administration");
export var DP = (function () {
  function e(e) {
    undefined === e && (e = "Atom"),
      (this.name_ = undefined),
      (this.isPendingUnobservation_ = false),
      (this.isBeingObserved_ = false),
      (this.observers_ = new Set()),
      (this.diffValue_ = 0),
      (this.lastAccessedBy_ = 0),
      (this.lowestObserverState_ = DA.NOT_TRACKING_),
      (this.onBOL = undefined),
      (this.onBUOL = undefined),
      (this.name_ = e);
  }
  var t = e.prototype;
  return (
    (t.onBO = function () {
      this.onBOL &&
        this.onBOL.forEach(function (e) {
          return e();
        });
    }),
    (t.onBUO = function () {
      this.onBUOL &&
        this.onBUOL.forEach(function (e) {
          return e();
        });
    }),
    (t.reportObserved = function () {
      return uB(this);
    }),
    (t.reportChanged = function () {
      lB(), dB(this), cB();
    }),
    (t.toString = function () {
      return this.name_;
    }),
    e
  );
})();
export var FP = bP("Atom", DP);
export function IP(e, t, n) {
  undefined === t && (t = uP), undefined === n && (n = uP);
  var s,
    i = new DP(e);
  return t !== uP && DB(OB, i, t, s), n !== uP && VB(i, n), i;
}
export var HP = {
  identity: function (e, t) {
    return e === t;
  },
  structural: function (e, t) {
    return sM(e, t);
  },
  default: function (e, t) {
    return Object.is(e, t);
  },
  shallow: function (e, t) {
    return sM(e, t, 1);
  },
};
export function NP(e, t, n) {
  return YB(e)
    ? e
    : Array.isArray(e)
    ? vA.array(e, { name: n })
    : hP(e)
    ? vA.object(e, undefined, { name: n })
    : yP(e)
    ? vA.map(e, { name: n })
    : vP(e)
    ? vA.set(e, { name: n })
    : "function" != typeof e || PB(e) || KB(e)
    ? e
    : mP(e)
    ? ZB(e)
    : EB(n, e);
}
export function UP(e) {
  return e;
}
export var zP = "override";
export function $P(e, t) {
  return { annotationType_: e, options_: t, make_: qP, extend_: QP };
}
export function qP(e, t, n, s) {
  var i;
  if (null == (i = this.options_) ? undefined : i.bound)
    return null === this.extend_(e, t, n, false) ? 0 : 1;
  if (s === e.target_) return null === this.extend_(e, t, n, false) ? 0 : 2;
  if (PB(n.value)) return 1;
  var o = GP(e, this, t, n, false);
  return nP(s, t, o), 2;
}
export function QP(e, t, n, s) {
  var i = GP(e, this, t, n);
  return e.defineProperty_(t, i, s);
}
export function GP(e, t, n, s, i) {
  var o, r, a, l, c;
  undefined === i && (i = iB.safeDescriptors),
    (function (e, t, n, s) {
      t.annotationType_, s.value;
    })(0, t, 0, s);
  var u,
    d = s.value;
  (null == (o = t.options_) ? undefined : o.bound) &&
    (d = d.bind(null != (u = e.proxy_) ? u : e.target_));
  return {
    value: AA(
      null != (r = null == (a = t.options_) ? undefined : a.name)
        ? r
        : n.toString(),
      d,
      null != (l = null == (c = t.options_) ? undefined : c.autoAction) && l
    ),
    configurable: !i || e.isPlainObject_,
    enumerable: false,
    writable: !i,
  };
}
export function ZP(e, t) {
  return { annotationType_: e, options_: t, make_: WP, extend_: KP };
}
export function WP(e, t, n, s) {
  var i;
  if (s === e.target_) return null === this.extend_(e, t, n, false) ? 0 : 2;
  if (
    (null == (i = this.options_) ? undefined : i.bound) &&
    !KB(e.target_[t]) &&
    null === this.extend_(e, t, n, false)
  )
    return 0;
  if (KB(n.value)) return 1;
  var o = YP(e, this, t, n, false, false);
  return nP(s, t, o), 2;
}
export function KP(e, t, n, s) {
  var i,
    o = YP(e, this, t, n, null == (i = this.options_) ? undefined : i.bound);
  return e.defineProperty_(t, o, s);
}
export function YP(e, t, n, s, i, o) {
  undefined === o && (o = iB.safeDescriptors),
    (function (e, t, n, s) {
      t.annotationType_, s.value;
    })(0, t, 0, s);
  var r,
    a = s.value;
  i && (a = a.bind(null != (r = e.proxy_) ? r : e.target_));
  return {
    value: ZB(a),
    configurable: !o || e.isPlainObject_,
    enumerable: false,
    writable: !o,
  };
}
export function XP(e, t) {
  return { annotationType_: e, options_: t, make_: JP, extend_: eA };
}
export function JP(e, t, n) {
  return null === this.extend_(e, t, n, false) ? 0 : 1;
}
export function eA(e, t, n, s) {
  return (
    (function (e, t, n, s) {
      t.annotationType_, s.get;
      0;
    })(0, this, 0, n),
    e.defineComputedProperty_(
      t,
      LP({}, this.options_, { get: n.get, set: n.set }),
      s
    )
  );
}
export function tA(e, t) {
  return { annotationType_: e, options_: t, make_: nA, extend_: sA };
}
export function nA(e, t, n) {
  return null === this.extend_(e, t, n, false) ? 0 : 1;
}
export function sA(e, t, n, s) {
  var i, o;
  return (
    (function (e, t, n, s) {
      t.annotationType_;
      0;
    })(0, this),
    e.defineObservableProperty_(
      t,
      n.value,
      null != (i = null == (o = this.options_) ? undefined : o.enhancer)
        ? i
        : NP,
      s
    )
  );
}
export var iA = "true";
export var oA = rA();
export function rA(e) {
  return { annotationType_: iA, options_: e, make_: aA, extend_: lA };
}
export function aA(e, t, n, s) {
  var i, o, r, a;
  if (n.get) return jA.make_(e, t, n, s);
  if (n.set) {
    var l = AA(t.toString(), n.set);
    return s === e.target_
      ? null ===
        e.defineProperty_(t, {
          configurable: !iB.safeDescriptors || e.isPlainObject_,
          set: l,
        })
        ? 0
        : 2
      : (nP(s, t, { configurable: true, set: l }), 2);
  }
  if (s !== e.target_ && "function" == typeof n.value)
    return mP(n.value)
      ? ((null == (a = this.options_) ? undefined : a.autoBind)
          ? ZB.bound
          : ZB
        ).make_(e, t, n, s)
      : ((null == (r = this.options_) ? undefined : r.autoBind)
          ? EB.bound
          : EB
        ).make_(e, t, n, s);
  var c,
    u =
      false === (null == (i = this.options_) ? undefined : i.deep)
        ? vA.ref
        : vA;
  "function" == typeof n.value &&
    (null == (o = this.options_) ? undefined : o.autoBind) &&
    (n.value = n.value.bind(null != (c = e.proxy_) ? c : e.target_));
  return u.make_(e, t, n, s);
}
export function lA(e, t, n, s) {
  var i, o, r;
  if (n.get) return jA.extend_(e, t, n, s);
  if (n.set)
    return e.defineProperty_(
      t,
      {
        configurable: !iB.safeDescriptors || e.isPlainObject_,
        set: AA(t.toString(), n.set),
      },
      s
    );
  "function" == typeof n.value &&
    (null == (i = this.options_) ? undefined : i.autoBind) &&
    (n.value = n.value.bind(null != (r = e.proxy_) ? r : e.target_));
  return (
    false === (null == (o = this.options_) ? undefined : o.deep) ? vA.ref : vA
  ).extend_(e, t, n, s);
}
export var cA = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined,
  proxy: true,
};
export function uA(e) {
  return e || cA;
}
Object.freeze(cA);
export var dA = tA("observable");
export var pA = tA("observable.ref", { enhancer: UP });
export var fA = tA("observable.shallow", {
  enhancer: function (e, t, n) {
    return null == e || UT(e) || ST(e) || TT(e) || RT(e)
      ? e
      : Array.isArray(e)
      ? vA.array(e, { name: n, deep: false })
      : hP(e)
      ? vA.object(e, undefined, { name: n, deep: false })
      : yP(e)
      ? vA.map(e, { name: n, deep: false })
      : vP(e)
      ? vA.set(e, { name: n, deep: false })
      : undefined;
  },
});
export var hA = tA("observable.struct", {
  enhancer: function (e, t) {
    return sM(e, t) ? t : e;
  },
});
export var mA = OP(dA);
export function gA(e) {
  return true === e.deep
    ? NP
    : false === e.deep
    ? UP
    : (t = e.defaultDecorator) &&
      null != (n = null == (s = t.options_) ? undefined : s.enhancer)
    ? n
    : NP;
  var t, n, s;
}
export function xA(e, t, n) {
  if (!pP(t))
    return YB(e)
      ? e
      : hP(e)
      ? vA.object(e, t, n)
      : Array.isArray(e)
      ? vA.array(e, t)
      : yP(e)
      ? vA.map(e, t)
      : vP(e)
      ? vA.set(e, t)
      : "object" == typeof e && null !== e
      ? e
      : vA.box(e, t);
  RP(e, t, dA);
}
Object.assign(xA, mA);
export var bA, yA;
export var vA = eP(xA, {
  box: function (e, t) {
    var n = uA(t);
    return new RA(e, gA(n), n.name, true, n.equals);
  },
  array: function (e, t) {
    var n = uA(t);
    return (false === iB.useProxies || false === n.proxy ? XT : gT)(
      e,
      gA(n),
      n.name
    );
  },
  map: function (e, t) {
    var n = uA(t);
    return new BT(e, gA(n), n.name);
  },
  set: function (e, t) {
    var n = uA(t);
    return new OT(e, gA(n), n.name);
  },
  object: function (e, t, n) {
    return UB(
      false === iB.useProxies || false === (null == n ? undefined : n.proxy)
        ? IT({}, n)
        : (function (e, t) {
            var n, s;
            return (
              lP(),
              (e = IT(e, t)),
              null != (s = (n = e[VP]).proxy_)
                ? s
                : (n.proxy_ = new Proxy(e, sT))
            );
          })({}, n),
      e,
      t
    );
  },
  ref: OP(pA),
  shallow: OP(fA),
  deep: mA,
  struct: OP(hA),
});
export var wA = "computed";
export var kA = XP(wA);
export var CA = XP("computed.struct", { equals: HP.structural });
export var jA = function (e, t) {
  if (pP(t)) return RP(e, t, kA);
  if (hP(e)) return OP(XP(wA, e));
  var n = hP(t) ? t : {};
  return (n.get = e), n.name || (n.name = e.name || ""), new NA(n);
};
Object.assign(jA, kA), (jA.struct = OP(CA));
export var SA;
export var _A = 0;
export var EA = 1;
export var LA =
  null !=
    (bA =
      null == (yA = tP(function () {}, "name"))
        ? undefined
        : yA.configurable) && bA;
export var PA = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false,
};
export function AA(e, t, n, s) {
  function i() {
    return BA(e, n, t, s || this, arguments);
  }
  return (
    undefined === n && (n = false),
    (i.isMobxAction = true),
    LA && ((PA.value = e), Object.defineProperty(i, "name", PA)),
    i
  );
}
export function BA(e, t, n, s, i) {
  var o = (function (e, t, n, s) {
    var i = false,
      o = 0;
    var r = iB.trackingDerivation,
      a = !t || !r;
    lB();
    var l = iB.allowStateChanges;
    a && (KA(), (l = TA(true)));
    var c = XA(true),
      u = {
        runAsAction_: a,
        prevDerivation_: r,
        prevAllowStateChanges_: l,
        prevAllowStateReads_: c,
        notifySpy_: i,
        startTime_: o,
        actionId_: EA++,
        parentActionId_: _A,
      };
    return (_A = u.actionId_), u;
  })(0, t);
  try {
    return n.apply(s, i);
  } catch (e) {
    throw ((o.error_ = e), e);
  } finally {
    !(function (e) {
      _A !== e.actionId_ && YL(30);
      (_A = e.parentActionId_),
        undefined !== e.error_ && (iB.suppressReactionErrors = true);
      MA(e.prevAllowStateChanges_),
        JA(e.prevAllowStateReads_),
        cB(),
        e.runAsAction_ && YA(e.prevDerivation_);
      0;
      iB.suppressReactionErrors = false;
    })(o);
  }
}
export function TA(e) {
  var t = iB.allowStateChanges;
  return (iB.allowStateChanges = e), t;
}
export function MA(e) {
  iB.allowStateChanges = e;
}
SA = Symbol.toPrimitive;
export var OA;
export var RA = (function (e) {
  function t(t, n, s, i, o) {
    var r;
    return (
      undefined === s && (s = "ObservableValue"),
      undefined === i && (i = true),
      undefined === o && (o = HP.default),
      ((r = e.call(this, s) || this).enhancer = undefined),
      (r.name_ = undefined),
      (r.equals = undefined),
      (r.hasUnreportedChange_ = false),
      (r.interceptors_ = undefined),
      (r.changeListeners_ = undefined),
      (r.value_ = undefined),
      (r.dehancer = undefined),
      (r.enhancer = n),
      (r.name_ = s),
      (r.equals = o),
      (r.value_ = n(t, undefined, s)),
      r
    );
  }
  PP(t, e);
  var n = t.prototype;
  return (
    (n.dehanceValue = function (e) {
      return undefined !== this.dehancer ? this.dehancer(e) : e;
    }),
    (n.set = function (e) {
      this.value_;
      if ((e = this.prepareNewValue_(e)) !== iB.UNCHANGED) {
        0, this.setNewValue_(e);
      }
    }),
    (n.prepareNewValue_ = function (e) {
      if ((QA(this), iT(this))) {
        var t = rT(this, { object: this, type: fT, newValue: e });
        if (!t) return iB.UNCHANGED;
        e = t.newValue;
      }
      return (
        (e = this.enhancer(e, this.value_, this.name_)),
        this.equals(this.value_, e) ? iB.UNCHANGED : e
      );
    }),
    (n.setNewValue_ = function (e) {
      var t = this.value_;
      (this.value_ = e),
        this.reportChanged(),
        aT(this) &&
          cT(this, { type: fT, object: this, newValue: e, oldValue: t });
    }),
    (n.get = function () {
      return this.reportObserved(), this.dehanceValue(this.value_);
    }),
    (n.intercept_ = function (e) {
      return oT(this, e);
    }),
    (n.observe_ = function (e, t) {
      return (
        t &&
          e({
            observableKind: "value",
            debugObjectName: this.name_,
            object: this,
            type: fT,
            newValue: this.value_,
            oldValue: undefined,
          }),
        lT(this, e)
      );
    }),
    (n.raw = function () {
      return this.value_;
    }),
    (n.toJSON = function () {
      return this.get();
    }),
    (n.toString = function () {
      return this.name_ + "[" + this.value_ + "]";
    }),
    (n.valueOf = function () {
      return CP(this.get());
    }),
    (n[SA] = function () {
      return this.valueOf();
    }),
    t
  );
})(DP);
export var VA = bP("ObservableValue", RA);
OA = Symbol.toPrimitive;
export var DA, FA, IA, HA;
export var NA = (function () {
  function e(e) {
    (this.dependenciesState_ = DA.NOT_TRACKING_),
      (this.observing_ = []),
      (this.newObserving_ = null),
      (this.isBeingObserved_ = false),
      (this.isPendingUnobservation_ = false),
      (this.observers_ = new Set()),
      (this.diffValue_ = 0),
      (this.runId_ = 0),
      (this.lastAccessedBy_ = 0),
      (this.lowestObserverState_ = DA.UP_TO_DATE_),
      (this.unboundDepsCount_ = 0),
      (this.value_ = new zA(null)),
      (this.name_ = undefined),
      (this.triggeredBy_ = undefined),
      (this.isComputing_ = false),
      (this.isRunningSetter_ = false),
      (this.derivation = undefined),
      (this.setter_ = undefined),
      (this.isTracing_ = IA.NONE),
      (this.scope_ = undefined),
      (this.equals_ = undefined),
      (this.requiresReaction_ = undefined),
      (this.keepAlive_ = undefined),
      (this.onBOL = undefined),
      (this.onBUOL = undefined),
      e.get || YL(31),
      (this.derivation = e.get),
      (this.name_ = e.name || "ComputedValue"),
      e.set && (this.setter_ = AA("ComputedValue-setter", e.set)),
      (this.equals_ =
        e.equals ||
        (e.compareStructural || e.struct ? HP.structural : HP.default)),
      (this.scope_ = e.context),
      (this.requiresReaction_ = !!e.requiresReaction),
      (this.keepAlive_ = !!e.keepAlive);
  }
  var t = e.prototype;
  return (
    (t.onBecomeStale_ = function () {
      !(function (e) {
        if (e.lowestObserverState_ !== DA.UP_TO_DATE_) return;
        (e.lowestObserverState_ = DA.POSSIBLY_STALE_),
          e.observers_.forEach(function (e) {
            e.dependenciesState_ === DA.UP_TO_DATE_ &&
              ((e.dependenciesState_ = DA.POSSIBLY_STALE_), e.onBecomeStale_());
          });
      })(this);
    }),
    (t.onBO = function () {
      this.onBOL &&
        this.onBOL.forEach(function (e) {
          return e();
        });
    }),
    (t.onBUO = function () {
      this.onBUOL &&
        this.onBUOL.forEach(function (e) {
          return e();
        });
    }),
    (t.get = function () {
      if (
        (this.isComputing_ && YL(32, this.name_, this.derivation),
        0 !== iB.inBatch || 0 !== this.observers_.size || this.keepAlive_)
      ) {
        if ((uB(this), qA(this))) {
          var e = iB.trackingContext;
          this.keepAlive_ && !e && (iB.trackingContext = this),
            this.trackAndCompute() &&
              (function (e) {
                if (e.lowestObserverState_ === DA.STALE_) return;
                (e.lowestObserverState_ = DA.STALE_),
                  e.observers_.forEach(function (t) {
                    t.dependenciesState_ === DA.POSSIBLY_STALE_
                      ? (t.dependenciesState_ = DA.STALE_)
                      : t.dependenciesState_ === DA.UP_TO_DATE_ &&
                        (e.lowestObserverState_ = DA.UP_TO_DATE_);
                  });
              })(this),
            (iB.trackingContext = e);
        }
      } else
        qA(this) &&
          (this.warnAboutUntrackedRead_(),
          lB(),
          (this.value_ = this.computeValue_(false)),
          cB());
      var t = this.value_;
      if ($A(t)) throw t.cause;
      return t;
    }),
    (t.set = function (e) {
      if (this.setter_) {
        this.isRunningSetter_ && YL(33, this.name_),
          (this.isRunningSetter_ = true);
        try {
          this.setter_.call(this.scope_, e);
        } finally {
          this.isRunningSetter_ = false;
        }
      } else YL(34, this.name_);
    }),
    (t.trackAndCompute = function () {
      var e = this.value_,
        t = this.dependenciesState_ === DA.NOT_TRACKING_,
        n = this.computeValue_(true);
      var s = t || $A(e) || $A(n) || !this.equals_(e, n);
      return s && (this.value_ = n), s;
    }),
    (t.computeValue_ = function (e) {
      this.isComputing_ = true;
      var t,
        n = TA(false);
      if (e) t = GA(this, this.derivation, this.scope_);
      else if (true === iB.disableErrorBoundaries)
        t = this.derivation.call(this.scope_);
      else
        try {
          t = this.derivation.call(this.scope_);
        } catch (e) {
          t = new zA(e);
        }
      return MA(n), (this.isComputing_ = false), t;
    }),
    (t.suspend_ = function () {
      this.keepAlive_ || (ZA(this), (this.value_ = undefined));
    }),
    (t.observe_ = function (e, t) {
      var n = this,
        s = true,
        i = undefined;
      return AB(function () {
        var o = n.get();
        if (!s || t) {
          var r = KA();
          e({
            observableKind: "computed",
            debugObjectName: n.name_,
            type: fT,
            object: n,
            newValue: o,
            oldValue: i,
          }),
            YA(r);
        }
        (s = false), (i = o);
      });
    }),
    (t.warnAboutUntrackedRead_ = function () {}),
    (t.toString = function () {
      return this.name_ + "[" + this.derivation.toString() + "]";
    }),
    (t.valueOf = function () {
      return CP(this.get());
    }),
    (t[OA] = function () {
      return this.valueOf();
    }),
    e
  );
})();
export var UA = bP("ComputedValue", NA);
((FA = DA || (DA = {}))[(FA.NOT_TRACKING_ = -1)] = "NOT_TRACKING_"),
  (FA[(FA.UP_TO_DATE_ = 0)] = "UP_TO_DATE_"),
  (FA[(FA.POSSIBLY_STALE_ = 1)] = "POSSIBLY_STALE_"),
  (FA[(FA.STALE_ = 2)] = "STALE_"),
  ((HA = IA || (IA = {}))[(HA.NONE = 0)] = "NONE"),
  (HA[(HA.LOG = 1)] = "LOG"),
  (HA[(HA.BREAK = 2)] = "BREAK");
export var zA = function (e) {
  (this.cause = undefined), (this.cause = e);
};
export function $A(e) {
  return e instanceof zA;
}
export function qA(e) {
  switch (e.dependenciesState_) {
    case DA.UP_TO_DATE_:
      return false;
    case DA.NOT_TRACKING_:
    case DA.STALE_:
      return true;
    case DA.POSSIBLY_STALE_:
      for (
        var t = XA(true), n = KA(), s = e.observing_, i = s.length, o = 0;
        o < i;
        o++
      ) {
        var r = s[o];
        if (UA(r)) {
          if (iB.disableErrorBoundaries) r.get();
          else
            try {
              r.get();
            } catch (e) {
              return YA(n), JA(t), true;
            }
          if (e.dependenciesState_ === DA.STALE_) return YA(n), JA(t), true;
        }
      }
      return eB(e), YA(n), JA(t), false;
  }
}
export function QA(e) {}
export function GA(e, t, n) {
  var s = XA(true);
  eB(e),
    (e.newObserving_ = new Array(e.observing_.length + 100)),
    (e.unboundDepsCount_ = 0),
    (e.runId_ = ++iB.runId);
  var i,
    o = iB.trackingDerivation;
  if (
    ((iB.trackingDerivation = e),
    iB.inBatch++,
    true === iB.disableErrorBoundaries)
  )
    i = t.call(n);
  else
    try {
      i = t.call(n);
    } catch (e) {
      i = new zA(e);
    }
  return (
    iB.inBatch--,
    (iB.trackingDerivation = o),
    (function (e) {
      for (
        var t = e.observing_,
          n = (e.observing_ = e.newObserving_),
          s = DA.UP_TO_DATE_,
          i = 0,
          o = e.unboundDepsCount_,
          r = 0;
        r < o;
        r++
      ) {
        var a = n[r];
        0 === a.diffValue_ && ((a.diffValue_ = 1), i !== r && (n[i] = a), i++),
          a.dependenciesState_ > s && (s = a.dependenciesState_);
      }
      (n.length = i), (e.newObserving_ = null), (o = t.length);
      for (; o--; ) {
        var l = t[o];
        0 === l.diffValue_ && rB(l, e), (l.diffValue_ = 0);
      }
      for (; i--; ) {
        var c = n[i];
        1 === c.diffValue_ && ((c.diffValue_ = 0), oB(c, e));
      }
      s !== DA.UP_TO_DATE_ && ((e.dependenciesState_ = s), e.onBecomeStale_());
    })(e),
    JA(s),
    i
  );
}
export function ZA(e) {
  var t = e.observing_;
  e.observing_ = [];
  for (var n = t.length; n--; ) rB(t[n], e);
  e.dependenciesState_ = DA.NOT_TRACKING_;
}
export function WA(e) {
  var t = KA();
  try {
    return e();
  } finally {
    YA(t);
  }
}
export function KA() {
  var e = iB.trackingDerivation;
  return (iB.trackingDerivation = null), e;
}
export function YA(e) {
  iB.trackingDerivation = e;
}
export function XA(e) {
  var t = iB.allowStateReads;
  return (iB.allowStateReads = e), t;
}
export function JA(e) {
  iB.allowStateReads = e;
}
export function eB(e) {
  if (e.dependenciesState_ !== DA.UP_TO_DATE_) {
    e.dependenciesState_ = DA.UP_TO_DATE_;
    for (var t = e.observing_, n = t.length; n--; )
      t[n].lowestObserverState_ = DA.UP_TO_DATE_;
  }
}
export var tB = function () {
  (this.version = 6),
    (this.UNCHANGED = {}),
    (this.trackingDerivation = null),
    (this.trackingContext = null),
    (this.runId = 0),
    (this.mobxGuid = 0),
    (this.inBatch = 0),
    (this.pendingUnobservations = []),
    (this.pendingReactions = []),
    (this.isRunningReactions = false),
    (this.allowStateChanges = false),
    (this.allowStateReads = true),
    (this.enforceActions = true),
    (this.spyListeners = []),
    (this.globalReactionErrorHandlers = []),
    (this.computedRequiresReaction = false),
    (this.reactionRequiresObservable = false),
    (this.observableRequiresReaction = false),
    (this.disableErrorBoundaries = false),
    (this.suppressReactionErrors = false),
    (this.useProxies = true),
    (this.verifyProxies = false),
    (this.safeDescriptors = true);
};
export var nB = true;
export var sB = false;
export var iB = (function () {
  var e = JL();
  return (
    e.__mobxInstanceCount > 0 && !e.__mobxGlobals && (nB = false),
    e.__mobxGlobals &&
      e.__mobxGlobals.version !== new tB().version &&
      (nB = false),
    nB
      ? e.__mobxGlobals
        ? ((e.__mobxInstanceCount += 1),
          e.__mobxGlobals.UNCHANGED || (e.__mobxGlobals.UNCHANGED = {}),
          e.__mobxGlobals)
        : ((e.__mobxInstanceCount = 1), (e.__mobxGlobals = new tB()))
      : (setTimeout(function () {
          sB || YL(35);
        }, 1),
        new tB())
  );
})();
export function oB(e, t) {
  e.observers_.add(t),
    e.lowestObserverState_ > t.dependenciesState_ &&
      (e.lowestObserverState_ = t.dependenciesState_);
}
export function rB(e, t) {
  e.observers_.delete(t), 0 === e.observers_.size && aB(e);
}
export function aB(e) {
  false === e.isPendingUnobservation_ &&
    ((e.isPendingUnobservation_ = true), iB.pendingUnobservations.push(e));
}
export function lB() {
  iB.inBatch++;
}
export function cB() {
  if (0 == --iB.inBatch) {
    mB();
    for (var e = iB.pendingUnobservations, t = 0; t < e.length; t++) {
      var n = e[t];
      (n.isPendingUnobservation_ = false),
        0 === n.observers_.size &&
          (n.isBeingObserved_ && ((n.isBeingObserved_ = false), n.onBUO()),
          n instanceof NA && n.suspend_());
    }
    iB.pendingUnobservations = [];
  }
}
export function uB(e) {
  var t = iB.trackingDerivation;
  return null !== t
    ? (t.runId_ !== e.lastAccessedBy_ &&
        ((e.lastAccessedBy_ = t.runId_),
        (t.newObserving_[t.unboundDepsCount_++] = e),
        !e.isBeingObserved_ &&
          iB.trackingContext &&
          ((e.isBeingObserved_ = true), e.onBO())),
      true)
    : (0 === e.observers_.size && iB.inBatch > 0 && aB(e), false);
}
export function dB(e) {
  e.lowestObserverState_ !== DA.STALE_ &&
    ((e.lowestObserverState_ = DA.STALE_),
    e.observers_.forEach(function (e) {
      e.dependenciesState_ === DA.UP_TO_DATE_ && e.onBecomeStale_(),
        (e.dependenciesState_ = DA.STALE_);
    }));
}
export var pB = (function () {
  function e(e, t, n, s) {
    undefined === e && (e = "Reaction"),
      undefined === s && (s = false),
      (this.name_ = undefined),
      (this.onInvalidate_ = undefined),
      (this.errorHandler_ = undefined),
      (this.requiresObservable_ = undefined),
      (this.observing_ = []),
      (this.newObserving_ = []),
      (this.dependenciesState_ = DA.NOT_TRACKING_),
      (this.diffValue_ = 0),
      (this.runId_ = 0),
      (this.unboundDepsCount_ = 0),
      (this.isDisposed_ = false),
      (this.isScheduled_ = false),
      (this.isTrackPending_ = false),
      (this.isRunning_ = false),
      (this.isTracing_ = IA.NONE),
      (this.name_ = e),
      (this.onInvalidate_ = t),
      (this.errorHandler_ = n),
      (this.requiresObservable_ = s);
  }
  var t = e.prototype;
  return (
    (t.onBecomeStale_ = function () {
      this.schedule_();
    }),
    (t.schedule_ = function () {
      this.isScheduled_ ||
        ((this.isScheduled_ = true), iB.pendingReactions.push(this), mB());
    }),
    (t.isScheduled = function () {
      return this.isScheduled_;
    }),
    (t.runReaction_ = function () {
      if (!this.isDisposed_) {
        lB(), (this.isScheduled_ = false);
        var e = iB.trackingContext;
        if (((iB.trackingContext = this), qA(this))) {
          this.isTrackPending_ = true;
          try {
            this.onInvalidate_();
          } catch (e) {
            this.reportExceptionInDerivation_(e);
          }
        }
        (iB.trackingContext = e), cB();
      }
    }),
    (t.track = function (e) {
      if (!this.isDisposed_) {
        lB();
        0, (this.isRunning_ = true);
        var t = iB.trackingContext;
        iB.trackingContext = this;
        var n = GA(this, e, undefined);
        (iB.trackingContext = t),
          (this.isRunning_ = false),
          (this.isTrackPending_ = false),
          this.isDisposed_ && ZA(this),
          $A(n) && this.reportExceptionInDerivation_(n.cause),
          cB();
      }
    }),
    (t.reportExceptionInDerivation_ = function (e) {
      var t = this;
      if (this.errorHandler_) this.errorHandler_(e, this);
      else {
        if (iB.disableErrorBoundaries) throw e;
        var n = "[mobx] uncaught error in '" + this + "'";
        iB.suppressReactionErrors || console.error(n, e),
          iB.globalReactionErrorHandlers.forEach(function (n) {
            return n(e, t);
          });
      }
    }),
    (t.dispose = function () {
      this.isDisposed_ ||
        ((this.isDisposed_ = true), this.isRunning_ || (lB(), ZA(this), cB()));
    }),
    (t.getDisposer_ = function () {
      var e = this.dispose.bind(this);
      return (e[VP] = this), e;
    }),
    (t.toString = function () {
      return "Reaction[" + this.name_ + "]";
    }),
    (t.trace = function (e) {
      undefined === e && (e = false),
        (function () {
          YL("trace() is not available in production builds");
          for (
            var e = false, t = arguments.length, n = new Array(t), s = 0;
            s < t;
            s++
          )
            n[s] = arguments[s];
          "boolean" == typeof n[n.length - 1] && (e = n.pop());
          var i = (function (e) {
            switch (e.length) {
              case 0:
                return iB.trackingDerivation;
              case 1:
                return JT(e[0]);
              case 2:
                return JT(e[0], e[1]);
            }
          })(n);
          if (!i)
            return YL(
              "'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly"
            );
          i.isTracing_ === IA.NONE &&
            console.log("[mobx.trace] '" + i.name_ + "' tracing enabled");
          i.isTracing_ = e ? IA.BREAK : IA.LOG;
        })(this, e);
    }),
    e
  );
})();
export var fB = 100;
export var hB = function (e) {
  return e();
};
export function mB() {
  iB.inBatch > 0 || iB.isRunningReactions || hB(gB);
}
export function gB() {
  iB.isRunningReactions = true;
  for (var e = iB.pendingReactions, t = 0; e.length > 0; ) {
    ++t === fB &&
      (console.error("[mobx] cycle in reaction: " + e[0]), e.splice(0));
    for (var n = e.splice(0), s = 0, i = n.length; s < i; s++)
      n[s].runReaction_();
  }
  iB.isRunningReactions = false;
}
export var xB = bP("Reaction", pB);
export var bB = "action";
export var yB = "autoAction";
export var vB = "<unnamed action>";
export var wB = $P(bB);
export var kB = $P("action.bound", { bound: true });
export var CB = $P(yB, { autoAction: true });
export var jB = $P("autoAction.bound", { autoAction: true, bound: true });
export function SB(e) {
  return function (t, n) {
    return dP(t)
      ? AA(t.name || vB, t, e)
      : dP(n)
      ? AA(t, n, e)
      : pP(n)
      ? RP(t, n, e ? CB : wB)
      : pP(t)
      ? OP($P(e ? yB : bB, { name: t, autoAction: e }))
      : undefined;
  };
}
export var _B = SB(false);
Object.assign(_B, wB);
export var EB = SB(true);
export function LB(e) {
  return BA(e.name, false, e, this, undefined);
}
export function PB(e) {
  return dP(e) && true === e.isMobxAction;
}
export function AB(e, t) {
  var n, s;
  undefined === t && (t = oP);
  var i,
    o = null != (n = null == (s = t) ? undefined : s.name) ? n : "Autorun";
  if (!t.scheduler && !t.delay)
    i = new pB(
      o,
      function () {
        this.track(l);
      },
      t.onError,
      t.requiresObservable
    );
  else {
    var r = TB(t),
      a = false;
    i = new pB(
      o,
      function () {
        a ||
          ((a = true),
          r(function () {
            (a = false), i.isDisposed_ || i.track(l);
          }));
      },
      t.onError,
      t.requiresObservable
    );
  }
  function l() {
    e(i);
  }
  return i.schedule_(), i.getDisposer_();
}
Object.assign(EB, CB), (_B.bound = OP(kB)), (EB.bound = OP(jB));
export var BB = function (e) {
  return e();
};
export function TB(e) {
  return e.scheduler
    ? e.scheduler
    : e.delay
    ? function (t) {
        return setTimeout(t, e.delay);
      }
    : BB;
}
export function MB(e, t, n) {
  var s;
  undefined === n && (n = oP);
  var i,
    o,
    r,
    a = null != (s = n.name) ? s : "Reaction",
    l = _B(
      a,
      n.onError
        ? ((i = n.onError),
          (o = t),
          function () {
            try {
              return o.apply(this, arguments);
            } catch (e) {
              i.call(this, e);
            }
          })
        : t
    ),
    c = !n.scheduler && !n.delay,
    u = TB(n),
    d = true,
    p = false,
    f = undefined,
    h = n.compareStructural ? HP.structural : n.equals || HP.default,
    m = new pB(
      a,
      function () {
        d || c ? g() : p || ((p = true), u(g));
      },
      n.onError,
      n.requiresObservable
    );
  function g() {
    if (((p = false), !m.isDisposed_)) {
      var t = false;
      m.track(function () {
        var n = (function (e, t) {
          var n = TA(e);
          try {
            return t();
          } finally {
            MA(n);
          }
        })(false, function () {
          return e(m);
        });
        (t = d || !h(r, n)), (f = r), (r = n);
      }),
        ((d && n.fireImmediately) || (!d && t)) && l(r, f, m),
        (d = false);
    }
  }
  return m.schedule_(), m.getDisposer_();
}
export var OB = "onBO";
export var RB = "onBUO";
export function VB(e, t, n) {
  return DB(RB, e, t, n);
}
export function DB(e, t, n, s) {
  var i = "function" == typeof s ? JT(t, n) : JT(t),
    o = dP(s) ? s : n,
    r = e + "L";
  return (
    i[r] ? i[r].add(o) : (i[r] = new Set([o])),
    function () {
      var e = i[r];
      e && (e.delete(o), 0 === e.size && delete i[r]);
    }
  );
}
export var FB = "never";
export var IB = "always";
export var HB = "observed";
export function NB(e) {
  true === e.isolateGlobalState &&
    (function () {
      if (
        ((iB.pendingReactions.length || iB.inBatch || iB.isRunningReactions) &&
          YL(36),
        (sB = true),
        nB)
      ) {
        var e = JL();
        0 == --e.__mobxInstanceCount && (e.__mobxGlobals = undefined),
          (iB = new tB());
      }
    })();
  var t,
    n,
    s = e.useProxies,
    i = e.enforceActions;
  if (
    (undefined !== s &&
      (iB.useProxies = s === IB || (s !== FB && "undefined" != typeof Proxy)),
    "ifavailable" === s && (iB.verifyProxies = true),
    undefined !== i)
  ) {
    var o = i === IB ? IB : i === HB;
    (iB.enforceActions = o), (iB.allowStateChanges = true !== o && o !== IB);
  }
  [
    "computedRequiresReaction",
    "reactionRequiresObservable",
    "observableRequiresReaction",
    "disableErrorBoundaries",
    "safeDescriptors",
  ].forEach(function (t) {
    t in e && (iB[t] = !!e[t]);
  }),
    (iB.allowStateReads = !iB.observableRequiresReaction),
    e.reactionScheduler &&
      ((t = e.reactionScheduler),
      (n = hB),
      (hB = function (e) {
        return t(function () {
          return n(e);
        });
      }));
}
export function UB(e, t, n, s) {
  var i = SP(t),
    o = IT(e, s)[VP];
  lB();
  try {
    kP(i).forEach(function (e) {
      o.extend_(e, i[e], !n || !(e in n) || n[e]);
    });
  } finally {
    cB();
  }
  return e;
}
export function zB(e) {
  var t,
    n = { name: e.name_ };
  return (
    e.observing_ &&
      e.observing_.length > 0 &&
      (n.dependencies = ((t = e.observing_), Array.from(new Set(t))).map(zB)),
    n
  );
}
export var $B = 0;
export function qB() {
  this.message = "FLOW_CANCELLED";
}
qB.prototype = Object.create(Error.prototype);
export var QB = ZP("flow");
export var GB = ZP("flow.bound", { bound: true });
export var ZB = Object.assign(function (e, t) {
  if (pP(t)) return RP(e, t, QB);
  var n = e,
    s = n.name || "<unnamed flow>",
    i = function () {
      var e,
        t = arguments,
        i = ++$B,
        o = _B(s + " - runid: " + i + " - init", n).apply(this, t),
        r = undefined,
        a = new Promise(function (t, n) {
          var a = 0;
          function l(e) {
            var t;
            r = undefined;
            try {
              t = _B(s + " - runid: " + i + " - yield " + a++, o.next).call(
                o,
                e
              );
            } catch (e) {
              return n(e);
            }
            u(t);
          }
          function c(e) {
            var t;
            r = undefined;
            try {
              t = _B(s + " - runid: " + i + " - yield " + a++, o.throw).call(
                o,
                e
              );
            } catch (e) {
              return n(e);
            }
            u(t);
          }
          function u(e) {
            if (!dP(null == e ? undefined : e.then))
              return e.done
                ? t(e.value)
                : (r = Promise.resolve(e.value)).then(l, c);
            e.then(u, n);
          }
          (e = n), l(undefined);
        });
      return (
        (a.cancel = _B(s + " - runid: " + i + " - cancel", function () {
          try {
            r && WB(r);
            var t = o.return(undefined),
              n = Promise.resolve(t.value);
            n.then(uP, uP), WB(n), e(new qB());
          } catch (t) {
            e(t);
          }
        })),
        a
      );
    };
  return (i.isMobXFlow = true), i;
}, QB);
export function WB(e) {
  dP(e.cancel) && e.cancel();
}
export function KB(e) {
  return true === (null == e ? undefined : e.isMobXFlow);
}
export function YB(e) {
  return (function (e, t) {
    return (
      !!e &&
      (undefined !== t
        ? !!UT(e) && e[VP].values_.has(t)
        : UT(e) || !!e[VP] || FP(e) || xB(e) || UA(e))
    );
  })(e);
}
export function XB(e, t, n) {
  return e.set(t, n), n;
}
export function JB(e, t) {
  if (null == e || "object" != typeof e || e instanceof Date || !YB(e))
    return e;
  if (VA(e) || UA(e)) return JB(e.get(), t);
  if (t.has(e)) return t.get(e);
  if (ST(e)) {
    var n = XB(t, e, new Array(e.length));
    return (
      e.forEach(function (e, s) {
        n[s] = JB(e, t);
      }),
      n
    );
  }
  if (RT(e)) {
    var s = XB(t, e, new Set());
    return (
      e.forEach(function (e) {
        s.add(JB(e, t));
      }),
      s
    );
  }
  if (TT(e)) {
    var i = XB(t, e, new Map());
    return (
      e.forEach(function (e, n) {
        i.set(n, JB(e, t));
      }),
      i
    );
  }
  var o = XB(t, e, {});
  return (
    (function (e) {
      if (UT(e)) return e[VP].ownKeys_();
      YL(38);
    })(e).forEach(function (n) {
      sP.propertyIsEnumerable.call(e, n) && (o[n] = JB(e[n], t));
    }),
    o
  );
}
export function eT(e, t) {
  return JB(e, new Map());
}
export function tT(e, t) {
  undefined === t && (t = undefined), lB();
  try {
    return e.apply(t);
  } finally {
    cB();
  }
}
export function nT(e) {
  return e[VP];
}
ZB.bound = OP(GB);
export var sT = {
  has: function (e, t) {
    return nT(e).has_(t);
  },
  get: function (e, t) {
    return nT(e).get_(t);
  },
  set: function (e, t, n) {
    var s;
    return !!pP(t) && (null == (s = nT(e).set_(t, n, true)) || s);
  },
  deleteProperty: function (e, t) {
    var n;
    return !!pP(t) && (null == (n = nT(e).delete_(t, true)) || n);
  },
  defineProperty: function (e, t, n) {
    var s;
    return null == (s = nT(e).defineProperty_(t, n)) || s;
  },
  ownKeys: function (e) {
    return nT(e).ownKeys_();
  },
  preventExtensions: function (e) {
    YL(13);
  },
};
export function iT(e) {
  return undefined !== e.interceptors_ && e.interceptors_.length > 0;
}
export function oT(e, t) {
  var n = e.interceptors_ || (e.interceptors_ = []);
  return (
    n.push(t),
    cP(function () {
      var e = n.indexOf(t);
      -1 !== e && n.splice(e, 1);
    })
  );
}
export function rT(e, t) {
  var n = KA();
  try {
    for (
      var s = [].concat(e.interceptors_ || []), i = 0, o = s.length;
      i < o && ((t = s[i](t)) && !t.type && YL(14), t);
      i++
    );
    return t;
  } finally {
    YA(n);
  }
}
export function aT(e) {
  return undefined !== e.changeListeners_ && e.changeListeners_.length > 0;
}
export function lT(e, t) {
  var n = e.changeListeners_ || (e.changeListeners_ = []);
  return (
    n.push(t),
    cP(function () {
      var e = n.indexOf(t);
      -1 !== e && n.splice(e, 1);
    })
  );
}
export function cT(e, t) {
  var n = KA(),
    s = e.changeListeners_;
  if (s) {
    for (var i = 0, o = (s = s.slice()).length; i < o; i++) s[i](t);
    YA(n);
  }
}
export var uT = Symbol("mobx-keys");
export function dT(e, t, n) {
  if (hP(e)) return UB(e, e, t, n);
  var s = IT(e, n)[VP];
  if (!e[uT]) {
    var i = Object.getPrototypeOf(e),
      o = new Set([].concat(kP(e), kP(i)));
    o.delete("constructor"), o.delete(VP), gP(i, uT, o);
  }
  lB();
  try {
    e[uT].forEach(function (e) {
      return s.make_(e, !t || !(e in t) || t[e]);
    });
  } finally {
    cB();
  }
  return e;
}
export var pT = "splice";
export var fT = "update";
export var hT = {
  get: function (e, t) {
    var n = e[VP];
    return t === VP
      ? n
      : "length" === t
      ? n.getArrayLength_()
      : "string" != typeof t || isNaN(t)
      ? jP(xT, t)
        ? xT[t]
        : e[t]
      : n.get_(parseInt(t));
  },
  set: function (e, t, n) {
    var s = e[VP];
    return (
      "length" === t && s.setArrayLength_(n),
      "symbol" == typeof t || isNaN(t) ? (e[t] = n) : s.set_(parseInt(t), n),
      true
    );
  },
  preventExtensions: function () {
    YL(15);
  },
};
export var mT = (function () {
  function e(e, t, n, s) {
    undefined === e && (e = "ObservableArray"),
      (this.owned_ = undefined),
      (this.legacyMode_ = undefined),
      (this.atom_ = undefined),
      (this.values_ = []),
      (this.interceptors_ = undefined),
      (this.changeListeners_ = undefined),
      (this.enhancer_ = undefined),
      (this.dehancer = undefined),
      (this.proxy_ = undefined),
      (this.lastKnownLength_ = 0),
      (this.owned_ = n),
      (this.legacyMode_ = s),
      (this.atom_ = new DP(e)),
      (this.enhancer_ = function (e, n) {
        return t(e, n, "ObservableArray[..]");
      });
  }
  var t = e.prototype;
  return (
    (t.dehanceValue_ = function (e) {
      return undefined !== this.dehancer ? this.dehancer(e) : e;
    }),
    (t.dehanceValues_ = function (e) {
      return undefined !== this.dehancer && e.length > 0
        ? e.map(this.dehancer)
        : e;
    }),
    (t.intercept_ = function (e) {
      return oT(this, e);
    }),
    (t.observe_ = function (e, t) {
      return (
        undefined === t && (t = false),
        t &&
          e({
            observableKind: "array",
            object: this.proxy_,
            debugObjectName: this.atom_.name_,
            type: "splice",
            index: 0,
            added: this.values_.slice(),
            addedCount: this.values_.length,
            removed: [],
            removedCount: 0,
          }),
        lT(this, e)
      );
    }),
    (t.getArrayLength_ = function () {
      return this.atom_.reportObserved(), this.values_.length;
    }),
    (t.setArrayLength_ = function (e) {
      ("number" != typeof e || e < 0) && YL("Out of range: " + e);
      var t = this.values_.length;
      if (e !== t)
        if (e > t) {
          for (var n = new Array(e - t), s = 0; s < e - t; s++)
            n[s] = undefined;
          this.spliceWithArray_(t, 0, n);
        } else this.spliceWithArray_(e, t - e);
    }),
    (t.updateArrayLength_ = function (e, t) {
      e !== this.lastKnownLength_ && YL(16),
        (this.lastKnownLength_ += t),
        this.legacyMode_ && t > 0 && YT(e + t + 1);
    }),
    (t.spliceWithArray_ = function (e, t, n) {
      var s = this;
      this.atom_;
      var i = this.values_.length;
      if (
        (undefined === e
          ? (e = 0)
          : e > i
          ? (e = i)
          : e < 0 && (e = Math.max(0, i + e)),
        (t =
          1 === arguments.length
            ? i - e
            : null == t
            ? 0
            : Math.max(0, Math.min(t, i - e))),
        undefined === n && (n = iP),
        iT(this))
      ) {
        var o = rT(this, {
          object: this.proxy_,
          type: pT,
          index: e,
          removedCount: t,
          added: n,
        });
        if (!o) return iP;
        (t = o.removedCount), (n = o.added);
      }
      if (
        ((n =
          0 === n.length
            ? n
            : n.map(function (e) {
                return s.enhancer_(e, undefined);
              })),
        this.legacyMode_)
      ) {
        var r = n.length - t;
        this.updateArrayLength_(i, r);
      }
      var a = this.spliceItemsIntoValues_(e, t, n);
      return (
        (0 === t && 0 === n.length) || this.notifyArraySplice_(e, n, a),
        this.dehanceValues_(a)
      );
    }),
    (t.spliceItemsIntoValues_ = function (e, t, n) {
      var s;
      if (n.length < 1e4)
        return (s = this.values_).splice.apply(s, [e, t].concat(n));
      var i = this.values_.slice(e, e + t),
        o = this.values_.slice(e + t);
      this.values_.length = e + n.length - t;
      for (var r = 0; r < n.length; r++) this.values_[e + r] = n[r];
      for (var a = 0; a < o.length; a++) this.values_[e + n.length + a] = o[a];
      return i;
    }),
    (t.notifyArrayChildUpdate_ = function (e, t, n) {
      var s = !this.owned_ && false,
        i = aT(this),
        o =
          i || s
            ? {
                observableKind: "array",
                object: this.proxy_,
                type: fT,
                debugObjectName: this.atom_.name_,
                index: e,
                newValue: t,
                oldValue: n,
              }
            : null;
      this.atom_.reportChanged(), i && cT(this, o);
    }),
    (t.notifyArraySplice_ = function (e, t, n) {
      var s = !this.owned_ && false,
        i = aT(this),
        o =
          i || s
            ? {
                observableKind: "array",
                object: this.proxy_,
                debugObjectName: this.atom_.name_,
                type: pT,
                index: e,
                removed: n,
                added: t,
                removedCount: n.length,
                addedCount: t.length,
              }
            : null;
      this.atom_.reportChanged(), i && cT(this, o);
    }),
    (t.get_ = function (e) {
      if (e < this.values_.length)
        return this.atom_.reportObserved(), this.dehanceValue_(this.values_[e]);
      console.warn(
        "[mobx.array] Attempt to read an array index (" +
          e +
          ") that is out of bounds (" +
          this.values_.length +
          "). Please check length first. Out of bound indices will not be tracked by MobX"
      );
    }),
    (t.set_ = function (e, t) {
      var n = this.values_;
      if (e < n.length) {
        this.atom_;
        var s = n[e];
        if (iT(this)) {
          var i = rT(this, {
            type: fT,
            object: this.proxy_,
            index: e,
            newValue: t,
          });
          if (!i) return;
          t = i.newValue;
        }
        (t = this.enhancer_(t, s)) !== s &&
          ((n[e] = t), this.notifyArrayChildUpdate_(e, t, s));
      } else
        e === n.length ? this.spliceWithArray_(e, 0, [t]) : YL(17, e, n.length);
    }),
    e
  );
})();
export function gT(e, t, n, s) {
  undefined === n && (n = "ObservableArray"),
    undefined === s && (s = false),
    lP();
  var i = new mT(n, t, s, false);
  xP(i.values_, VP, i);
  var o = new Proxy(i.values_, hT);
  if (((i.proxy_ = o), e && e.length)) {
    var r = TA(true);
    i.spliceWithArray_(0, 0, e), MA(r);
  }
  return o;
}
export var xT = {
  clear: function () {
    return this.splice(0);
  },
  replace: function (e) {
    var t = this[VP];
    return t.spliceWithArray_(0, t.values_.length, e);
  },
  toJSON: function () {
    return this.slice();
  },
  splice: function (e, t) {
    for (
      var n = arguments.length, s = new Array(n > 2 ? n - 2 : 0), i = 2;
      i < n;
      i++
    )
      s[i - 2] = arguments[i];
    var o = this[VP];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return o.spliceWithArray_(e);
      case 2:
        return o.spliceWithArray_(e, t);
    }
    return o.spliceWithArray_(e, t, s);
  },
  spliceWithArray: function (e, t, n) {
    return this[VP].spliceWithArray_(e, t, n);
  },
  push: function () {
    for (
      var e = this[VP], t = arguments.length, n = new Array(t), s = 0;
      s < t;
      s++
    )
      n[s] = arguments[s];
    return e.spliceWithArray_(e.values_.length, 0, n), e.values_.length;
  },
  pop: function () {
    return this.splice(Math.max(this[VP].values_.length - 1, 0), 1)[0];
  },
  shift: function () {
    return this.splice(0, 1)[0];
  },
  unshift: function () {
    for (
      var e = this[VP], t = arguments.length, n = new Array(t), s = 0;
      s < t;
      s++
    )
      n[s] = arguments[s];
    return e.spliceWithArray_(0, 0, n), e.values_.length;
  },
  reverse: function () {
    return (
      iB.trackingDerivation && YL(37, "reverse"),
      this.replace(this.slice().reverse()),
      this
    );
  },
  sort: function () {
    iB.trackingDerivation && YL(37, "sort");
    var e = this.slice();
    return e.sort.apply(e, arguments), this.replace(e), this;
  },
  remove: function (e) {
    var t = this[VP],
      n = t.dehanceValues_(t.values_).indexOf(e);
    return n > -1 && (this.splice(n, 1), true);
  },
};
export function bT(e, t) {
  "function" == typeof Array.prototype[e] && (xT[e] = t(e));
}
export function yT(e) {
  return function () {
    var t = this[VP];
    t.atom_.reportObserved();
    var n = t.dehanceValues_(t.values_);
    return n[e].apply(n, arguments);
  };
}
export function vT(e) {
  return function (t, n) {
    var s = this,
      i = this[VP];
    return (
      i.atom_.reportObserved(),
      i.dehanceValues_(i.values_)[e](function (e, i) {
        return t.call(n, e, i, s);
      })
    );
  };
}
export function wT(e) {
  return function () {
    var t = this,
      n = this[VP];
    n.atom_.reportObserved();
    var s = n.dehanceValues_(n.values_),
      i = arguments[0];
    return (
      (arguments[0] = function (e, n, s) {
        return i(e, n, s, t);
      }),
      s[e].apply(s, arguments)
    );
  };
}
bT("concat", yT),
  bT("flat", yT),
  bT("includes", yT),
  bT("indexOf", yT),
  bT("join", yT),
  bT("lastIndexOf", yT),
  bT("slice", yT),
  bT("toString", yT),
  bT("toLocaleString", yT),
  bT("every", vT),
  bT("filter", vT),
  bT("find", vT),
  bT("findIndex", vT),
  bT("flatMap", vT),
  bT("forEach", vT),
  bT("map", vT),
  bT("some", vT),
  bT("reduce", wT),
  bT("reduceRight", wT);
export var kT, CT;
export var jT = bP("ObservableArrayAdministration", mT);
export function ST(e) {
  return fP(e) && jT(e[VP]);
}
export var _T = {};
export var ET = "add";
export var LT = "delete";
(kT = Symbol.iterator), (CT = Symbol.toStringTag);
export var PT, AT;
export var BT = (function () {
  function e(e, t, n) {
    undefined === t && (t = NP),
      undefined === n && (n = "ObservableMap"),
      (this.enhancer_ = undefined),
      (this.name_ = undefined),
      (this[VP] = _T),
      (this.data_ = undefined),
      (this.hasMap_ = undefined),
      (this.keysAtom_ = undefined),
      (this.interceptors_ = undefined),
      (this.changeListeners_ = undefined),
      (this.dehancer = undefined),
      (this.enhancer_ = t),
      (this.name_ = n),
      dP(Map) || YL(18),
      (this.keysAtom_ = IP("ObservableMap.keys()")),
      (this.data_ = new Map()),
      (this.hasMap_ = new Map()),
      this.merge(e);
  }
  var t = e.prototype;
  return (
    (t.has_ = function (e) {
      return this.data_.has(e);
    }),
    (t.has = function (e) {
      var t = this;
      if (!iB.trackingDerivation) return this.has_(e);
      var n = this.hasMap_.get(e);
      if (!n) {
        var s = (n = new RA(this.has_(e), UP, "ObservableMap.key?", false));
        this.hasMap_.set(e, s),
          VB(s, function () {
            return t.hasMap_.delete(e);
          });
      }
      return n.get();
    }),
    (t.set = function (e, t) {
      var n = this.has_(e);
      if (iT(this)) {
        var s = rT(this, {
          type: n ? fT : ET,
          object: this,
          newValue: t,
          name: e,
        });
        if (!s) return this;
        t = s.newValue;
      }
      return n ? this.updateValue_(e, t) : this.addValue_(e, t), this;
    }),
    (t.delete = function (e) {
      var t = this;
      if (
        (this.keysAtom_, iT(this)) &&
        !rT(this, { type: LT, object: this, name: e })
      )
        return false;
      if (this.has_(e)) {
        var n = aT(this),
          s = n
            ? {
                observableKind: "map",
                debugObjectName: this.name_,
                type: LT,
                object: this,
                oldValue: this.data_.get(e).value_,
                name: e,
              }
            : null;
        return (
          tT(function () {
            t.keysAtom_.reportChanged(),
              t.updateHasMapEntry_(e, false),
              t.data_.get(e).setNewValue_(undefined),
              t.data_.delete(e);
          }),
          n && cT(this, s),
          true
        );
      }
      return false;
    }),
    (t.updateHasMapEntry_ = function (e, t) {
      var n = this.hasMap_.get(e);
      n && n.setNewValue_(t);
    }),
    (t.updateValue_ = function (e, t) {
      var n = this.data_.get(e);
      if ((t = n.prepareNewValue_(t)) !== iB.UNCHANGED) {
        var s = aT(this),
          i = s
            ? {
                observableKind: "map",
                debugObjectName: this.name_,
                type: fT,
                object: this,
                oldValue: n.value_,
                name: e,
                newValue: t,
              }
            : null;
        0, n.setNewValue_(t), s && cT(this, i);
      }
    }),
    (t.addValue_ = function (e, t) {
      var n = this;
      this.keysAtom_,
        tT(function () {
          var s = new RA(t, n.enhancer_, "ObservableMap.key", false);
          n.data_.set(e, s),
            (t = s.value_),
            n.updateHasMapEntry_(e, true),
            n.keysAtom_.reportChanged();
        });
      var s = aT(this),
        i = s
          ? {
              observableKind: "map",
              debugObjectName: this.name_,
              type: ET,
              object: this,
              name: e,
              newValue: t,
            }
          : null;
      s && cT(this, i);
    }),
    (t.get = function (e) {
      return this.has(e)
        ? this.dehanceValue_(this.data_.get(e).get())
        : this.dehanceValue_(undefined);
    }),
    (t.dehanceValue_ = function (e) {
      return undefined !== this.dehancer ? this.dehancer(e) : e;
    }),
    (t.keys = function () {
      return this.keysAtom_.reportObserved(), this.data_.keys();
    }),
    (t.values = function () {
      var e = this,
        t = this.keys();
      return rM({
        next: function () {
          var n = t.next(),
            s = n.done,
            i = n.value;
          return { done: s, value: s ? undefined : e.get(i) };
        },
      });
    }),
    (t.entries = function () {
      var e = this,
        t = this.keys();
      return rM({
        next: function () {
          var n = t.next(),
            s = n.done,
            i = n.value;
          return { done: s, value: s ? undefined : [i, e.get(i)] };
        },
      });
    }),
    (t[kT] = function () {
      return this.entries();
    }),
    (t.forEach = function (e, t) {
      for (var n, s = TP(this); !(n = s()).done; ) {
        var i = n.value,
          o = i[0],
          r = i[1];
        e.call(t, r, o, this);
      }
    }),
    (t.merge = function (e) {
      var t = this;
      return (
        TT(e) && (e = new Map(e)),
        tT(function () {
          hP(e)
            ? (function (e) {
                var t = Object.keys(e);
                if (!wP) return t;
                var n = Object.getOwnPropertySymbols(e);
                return n.length
                  ? [].concat(
                      t,
                      n.filter(function (t) {
                        return sP.propertyIsEnumerable.call(e, t);
                      })
                    )
                  : t;
              })(e).forEach(function (n) {
                return t.set(n, e[n]);
              })
            : Array.isArray(e)
            ? e.forEach(function (e) {
                var n = e[0],
                  s = e[1];
                return t.set(n, s);
              })
            : yP(e)
            ? (e.constructor !== Map && YL(19, e),
              e.forEach(function (e, n) {
                return t.set(n, e);
              }))
            : null != e && YL(20, e);
        }),
        this
      );
    }),
    (t.clear = function () {
      var e = this;
      tT(function () {
        WA(function () {
          for (var t, n = TP(e.keys()); !(t = n()).done; ) {
            var s = t.value;
            e.delete(s);
          }
        });
      });
    }),
    (t.replace = function (e) {
      var t = this;
      return (
        tT(function () {
          for (
            var n,
              s = (function (e) {
                if (yP(e) || TT(e)) return e;
                if (Array.isArray(e)) return new Map(e);
                if (hP(e)) {
                  var t = new Map();
                  for (var n in e) t.set(n, e[n]);
                  return t;
                }
                return YL(21, e);
              })(e),
              i = new Map(),
              o = false,
              r = TP(t.data_.keys());
            !(n = r()).done;

          ) {
            var a = n.value;
            if (!s.has(a))
              if (t.delete(a)) o = true;
              else {
                var l = t.data_.get(a);
                i.set(a, l);
              }
          }
          for (var c, u = TP(s.entries()); !(c = u()).done; ) {
            var d = c.value,
              p = d[0],
              f = d[1],
              h = t.data_.has(p);
            if ((t.set(p, f), t.data_.has(p))) {
              var m = t.data_.get(p);
              i.set(p, m), h || (o = true);
            }
          }
          if (!o)
            if (t.data_.size !== i.size) t.keysAtom_.reportChanged();
            else
              for (
                var g = t.data_.keys(),
                  x = i.keys(),
                  b = g.next(),
                  y = x.next();
                !b.done;

              ) {
                if (b.value !== y.value) {
                  t.keysAtom_.reportChanged();
                  break;
                }
                (b = g.next()), (y = x.next());
              }
          t.data_ = i;
        }),
        this
      );
    }),
    (t.toString = function () {
      return "[object ObservableMap]";
    }),
    (t.toJSON = function () {
      return Array.from(this);
    }),
    (t.observe_ = function (e, t) {
      return lT(this, e);
    }),
    (t.intercept_ = function (e) {
      return oT(this, e);
    }),
    EP(e, [
      {
        key: "size",
        get: function () {
          return this.keysAtom_.reportObserved(), this.data_.size;
        },
      },
      {
        key: CT,
        get: function () {
          return "Map";
        },
      },
    ]),
    e
  );
})();
export var TT = bP("ObservableMap", BT);
export var MT = {};
(PT = Symbol.iterator), (AT = Symbol.toStringTag);
export var OT = (function () {
  function e(e, t, n) {
    undefined === t && (t = NP),
      undefined === n && (n = "ObservableSet"),
      (this.name_ = undefined),
      (this[VP] = MT),
      (this.data_ = new Set()),
      (this.atom_ = undefined),
      (this.changeListeners_ = undefined),
      (this.interceptors_ = undefined),
      (this.dehancer = undefined),
      (this.enhancer_ = undefined),
      (this.name_ = n),
      dP(Set) || YL(22),
      (this.atom_ = IP(this.name_)),
      (this.enhancer_ = function (e, s) {
        return t(e, s, n);
      }),
      e && this.replace(e);
  }
  var t = e.prototype;
  return (
    (t.dehanceValue_ = function (e) {
      return undefined !== this.dehancer ? this.dehancer(e) : e;
    }),
    (t.clear = function () {
      var e = this;
      tT(function () {
        WA(function () {
          for (var t, n = TP(e.data_.values()); !(t = n()).done; ) {
            var s = t.value;
            e.delete(s);
          }
        });
      });
    }),
    (t.forEach = function (e, t) {
      for (var n, s = TP(this); !(n = s()).done; ) {
        var i = n.value;
        e.call(t, i, i, this);
      }
    }),
    (t.add = function (e) {
      var t = this;
      if (
        (this.atom_, iT(this)) &&
        !rT(this, { type: ET, object: this, newValue: e })
      )
        return this;
      if (!this.has(e)) {
        tT(function () {
          t.data_.add(t.enhancer_(e, undefined)), t.atom_.reportChanged();
        });
        var n = false,
          s = aT(this),
          i = s
            ? {
                observableKind: "set",
                debugObjectName: this.name_,
                type: ET,
                object: this,
                newValue: e,
              }
            : null;
        n, s && cT(this, i);
      }
      return this;
    }),
    (t.delete = function (e) {
      var t = this;
      if (iT(this) && !rT(this, { type: LT, object: this, oldValue: e }))
        return false;
      if (this.has(e)) {
        var n = aT(this),
          s = n
            ? {
                observableKind: "set",
                debugObjectName: this.name_,
                type: LT,
                object: this,
                oldValue: e,
              }
            : null;
        return (
          tT(function () {
            t.atom_.reportChanged(), t.data_.delete(e);
          }),
          n && cT(this, s),
          true
        );
      }
      return false;
    }),
    (t.has = function (e) {
      return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(e));
    }),
    (t.entries = function () {
      var e = 0,
        t = Array.from(this.keys()),
        n = Array.from(this.values());
      return rM({
        next: function () {
          var s = e;
          return (
            (e += 1),
            s < n.length ? { value: [t[s], n[s]], done: false } : { done: true }
          );
        },
      });
    }),
    (t.keys = function () {
      return this.values();
    }),
    (t.values = function () {
      this.atom_.reportObserved();
      var e = this,
        t = 0,
        n = Array.from(this.data_.values());
      return rM({
        next: function () {
          return t < n.length
            ? { value: e.dehanceValue_(n[t++]), done: false }
            : { done: true };
        },
      });
    }),
    (t.replace = function (e) {
      var t = this;
      return (
        RT(e) && (e = new Set(e)),
        tT(function () {
          Array.isArray(e) || vP(e)
            ? (t.clear(),
              e.forEach(function (e) {
                return t.add(e);
              }))
            : null != e && YL("Cannot initialize set from " + e);
        }),
        this
      );
    }),
    (t.observe_ = function (e, t) {
      return lT(this, e);
    }),
    (t.intercept_ = function (e) {
      return oT(this, e);
    }),
    (t.toJSON = function () {
      return Array.from(this);
    }),
    (t.toString = function () {
      return "[object ObservableSet]";
    }),
    (t[PT] = function () {
      return this.values();
    }),
    EP(e, [
      {
        key: "size",
        get: function () {
          return this.atom_.reportObserved(), this.data_.size;
        },
      },
      {
        key: AT,
        get: function () {
          return "Set";
        },
      },
    ]),
    e
  );
})();
export var RT = bP("ObservableSet", OT);
export var VT = Object.create(null);
export var DT = "remove";
export var FT = (function () {
  function e(e, t, n, s) {
    undefined === t && (t = new Map()),
      undefined === s && (s = oA),
      (this.target_ = undefined),
      (this.values_ = undefined),
      (this.name_ = undefined),
      (this.defaultAnnotation_ = undefined),
      (this.keysAtom_ = undefined),
      (this.changeListeners_ = undefined),
      (this.interceptors_ = undefined),
      (this.proxy_ = undefined),
      (this.isPlainObject_ = undefined),
      (this.appliedAnnotations_ = undefined),
      (this.pendingKeys_ = undefined),
      (this.target_ = e),
      (this.values_ = t),
      (this.name_ = n),
      (this.defaultAnnotation_ = s),
      (this.keysAtom_ = new DP("ObservableObject.keys")),
      (this.isPlainObject_ = hP(this.target_));
  }
  var t = e.prototype;
  return (
    (t.getObservablePropValue_ = function (e) {
      return this.values_.get(e).get();
    }),
    (t.setObservablePropValue_ = function (e, t) {
      var n = this.values_.get(e);
      if (n instanceof NA) return n.set(t), true;
      if (iT(this)) {
        var s = rT(this, {
          type: fT,
          object: this.proxy_ || this.target_,
          name: e,
          newValue: t,
        });
        if (!s) return null;
        t = s.newValue;
      }
      if ((t = n.prepareNewValue_(t)) !== iB.UNCHANGED) {
        var i = aT(this),
          o = i
            ? {
                type: fT,
                observableKind: "object",
                debugObjectName: this.name_,
                object: this.proxy_ || this.target_,
                oldValue: n.value_,
                name: e,
                newValue: t,
              }
            : null;
        0, n.setNewValue_(t), i && cT(this, o);
      }
      return true;
    }),
    (t.get_ = function (e) {
      return (
        iB.trackingDerivation && !jP(this.target_, e) && this.has_(e),
        this.target_[e]
      );
    }),
    (t.set_ = function (e, t, n) {
      return (
        undefined === n && (n = false),
        jP(this.target_, e)
          ? this.values_.has(e)
            ? this.setObservablePropValue_(e, t)
            : n
            ? Reflect.set(this.target_, e, t)
            : ((this.target_[e] = t), true)
          : this.extend_(
              e,
              {
                value: t,
                enumerable: true,
                writable: true,
                configurable: true,
              },
              this.defaultAnnotation_,
              n
            )
      );
    }),
    (t.has_ = function (e) {
      if (!iB.trackingDerivation) return e in this.target_;
      this.pendingKeys_ || (this.pendingKeys_ = new Map());
      var t = this.pendingKeys_.get(e);
      return (
        t ||
          ((t = new RA(e in this.target_, UP, "ObservableObject.key?", false)),
          this.pendingKeys_.set(e, t)),
        t.get()
      );
    }),
    (t.make_ = function (e, t) {
      if ((true === t && (t = this.defaultAnnotation_), false !== t)) {
        if (($T(this, t, e), !(e in this.target_))) {
          var n;
          if (null == (n = this.target_[MP]) ? undefined : n[e]) return;
          YL(1, t.annotationType_, this.name_ + "." + e.toString());
        }
        for (var s = this.target_; s && s !== sP; ) {
          var i = tP(s, e);
          if (i) {
            var o = t.make_(this, e, i, s);
            if (0 === o) return;
            if (1 === o) break;
          }
          s = Object.getPrototypeOf(s);
        }
        zT(this, t, e);
      }
    }),
    (t.extend_ = function (e, t, n, s) {
      if (
        (undefined === s && (s = false),
        true === n && (n = this.defaultAnnotation_),
        false === n)
      )
        return this.defineProperty_(e, t, s);
      $T(this, n, e);
      var i = n.extend_(this, e, t, s);
      return i && zT(this, n, e), i;
    }),
    (t.defineProperty_ = function (e, t, n) {
      undefined === n && (n = false);
      try {
        lB();
        var s = this.delete_(e);
        if (!s) return s;
        if (iT(this)) {
          var i = rT(this, {
            object: this.proxy_ || this.target_,
            name: e,
            type: ET,
            newValue: t.value,
          });
          if (!i) return null;
          var o = i.newValue;
          t.value !== o && (t = LP({}, t, { value: o }));
        }
        if (n) {
          if (!Reflect.defineProperty(this.target_, e, t)) return false;
        } else nP(this.target_, e, t);
        this.notifyPropertyAddition_(e, t.value);
      } finally {
        cB();
      }
      return true;
    }),
    (t.defineObservableProperty_ = function (e, t, n, s) {
      undefined === s && (s = false);
      try {
        lB();
        var i = this.delete_(e);
        if (!i) return i;
        if (iT(this)) {
          var o = rT(this, {
            object: this.proxy_ || this.target_,
            name: e,
            type: ET,
            newValue: t,
          });
          if (!o) return null;
          t = o.newValue;
        }
        var r = NT(e),
          a = {
            configurable: !iB.safeDescriptors || this.isPlainObject_,
            enumerable: true,
            get: r.get,
            set: r.set,
          };
        if (s) {
          if (!Reflect.defineProperty(this.target_, e, a)) return false;
        } else nP(this.target_, e, a);
        var l = new RA(t, n, "ObservableObject.key", false);
        this.values_.set(e, l), this.notifyPropertyAddition_(e, l.value_);
      } finally {
        cB();
      }
      return true;
    }),
    (t.defineComputedProperty_ = function (e, t, n) {
      undefined === n && (n = false);
      try {
        lB();
        var s = this.delete_(e);
        if (!s) return s;
        if (iT(this))
          if (
            !rT(this, {
              object: this.proxy_ || this.target_,
              name: e,
              type: ET,
              newValue: undefined,
            })
          )
            return null;
        t.name || (t.name = "ObservableObject.key"),
          (t.context = this.proxy_ || this.target_);
        var i = NT(e),
          o = {
            configurable: !iB.safeDescriptors || this.isPlainObject_,
            enumerable: false,
            get: i.get,
            set: i.set,
          };
        if (n) {
          if (!Reflect.defineProperty(this.target_, e, o)) return false;
        } else nP(this.target_, e, o);
        this.values_.set(e, new NA(t)),
          this.notifyPropertyAddition_(e, undefined);
      } finally {
        cB();
      }
      return true;
    }),
    (t.delete_ = function (e, t) {
      if ((undefined === t && (t = false), !jP(this.target_, e))) return true;
      if (
        iT(this) &&
        !rT(this, { object: this.proxy_ || this.target_, name: e, type: DT })
      )
        return null;
      try {
        var n, s;
        lB();
        var i,
          o = aT(this),
          r = this.values_.get(e),
          a = undefined;
        if (!r && o)
          a = null == (i = tP(this.target_, e)) ? undefined : i.value;
        if (t) {
          if (!Reflect.deleteProperty(this.target_, e)) return false;
        } else delete this.target_[e];
        if (
          (r &&
            (this.values_.delete(e), r instanceof RA && (a = r.value_), dB(r)),
          this.keysAtom_.reportChanged(),
          null == (n = this.pendingKeys_) ||
            null == (s = n.get(e)) ||
            s.set(e in this.target_),
          o)
        ) {
          var l = {
            type: DT,
            observableKind: "object",
            object: this.proxy_ || this.target_,
            debugObjectName: this.name_,
            oldValue: a,
            name: e,
          };
          0, o && cT(this, l);
        }
      } finally {
        cB();
      }
      return true;
    }),
    (t.observe_ = function (e, t) {
      return lT(this, e);
    }),
    (t.intercept_ = function (e) {
      return oT(this, e);
    }),
    (t.notifyPropertyAddition_ = function (e, t) {
      var n,
        s,
        i = aT(this);
      if (i) {
        var o = i
          ? {
              type: ET,
              observableKind: "object",
              debugObjectName: this.name_,
              object: this.proxy_ || this.target_,
              name: e,
              newValue: t,
            }
          : null;
        0, i && cT(this, o);
      }
      null == (n = this.pendingKeys_) || null == (s = n.get(e)) || s.set(true),
        this.keysAtom_.reportChanged();
    }),
    (t.ownKeys_ = function () {
      return this.keysAtom_.reportObserved(), kP(this.target_);
    }),
    (t.keys_ = function () {
      return this.keysAtom_.reportObserved(), Object.keys(this.target_);
    }),
    e
  );
})();
export function IT(e, t) {
  var n;
  if (jP(e, VP)) return e;
  var s = null != (n = null == t ? undefined : t.name) ? n : "ObservableObject",
    i = new FT(
      e,
      new Map(),
      String(s),
      (function (e) {
        var t;
        return e ? (null != (t = e.defaultDecorator) ? t : rA(e)) : undefined;
      })(t)
    );
  return gP(e, VP, i), e;
}
export var HT = bP("ObservableObjectAdministration", FT);
export function NT(e) {
  return (
    VT[e] ||
    (VT[e] = {
      get: function () {
        return this[VP].getObservablePropValue_(e);
      },
      set: function (t) {
        return this[VP].setObservablePropValue_(e, t);
      },
    })
  );
}
export function UT(e) {
  return !!fP(e) && HT(e[VP]);
}
export function zT(e, t, n) {
  var s;
  null == (s = e.target_[MP]) || delete s[n];
}
export function $T(e, t, n) {}
export var qT, QT;
export var GT = 0;
export var ZT = function () {};
(qT = ZT),
  (QT = Array.prototype),
  Object.setPrototypeOf
    ? Object.setPrototypeOf(qT.prototype, QT)
    : undefined !== qT.prototype.__proto__
    ? (qT.prototype.__proto__ = QT)
    : (qT.prototype = QT);
export var WT = (function (e) {
  function t(t, n, s, i) {
    var o;
    undefined === s && (s = "ObservableArray"),
      undefined === i && (i = false),
      (o = e.call(this) || this);
    var r = new mT(s, n, i, true);
    if (((r.proxy_ = AP(o)), xP(AP(o), VP, r), t && t.length)) {
      var a = TA(true);
      o.spliceWithArray(0, 0, t), MA(a);
    }
    return o;
  }
  PP(t, e);
  var n = t.prototype;
  return (
    (n.concat = function () {
      this[VP].atom_.reportObserved();
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return Array.prototype.concat.apply(
        this.slice(),
        t.map(function (e) {
          return ST(e) ? e.slice() : e;
        })
      );
    }),
    (n[Symbol.iterator] = function () {
      var e = this,
        t = 0;
      return rM({
        next: function () {
          return t < e.length
            ? { value: e[t++], done: false }
            : { done: true, value: undefined };
        },
      });
    }),
    EP(t, [
      {
        key: "length",
        get: function () {
          return this[VP].getArrayLength_();
        },
        set: function (e) {
          this[VP].setArrayLength_(e);
        },
      },
      {
        key: Symbol.toStringTag,
        get: function () {
          return "Array";
        },
      },
    ]),
    t
  );
})(ZT);
export function KT(e) {
  nP(
    WT.prototype,
    "" + e,
    (function (e) {
      return {
        enumerable: false,
        configurable: true,
        get: function () {
          return this[VP].get_(e);
        },
        set: function (t) {
          this[VP].set_(e, t);
        },
      };
    })(e)
  );
}
export function YT(e) {
  if (e > GT) {
    for (var t = GT; t < e + 100; t++) KT(t);
    GT = e;
  }
}
export function XT(e, t, n) {
  return new WT(e, t, n);
}
export function JT(e, t) {
  if ("object" == typeof e && null !== e) {
    if (ST(e)) return undefined !== t && YL(23), e[VP].atom_;
    if (RT(e)) return e[VP];
    if (TT(e)) {
      if (undefined === t) return e.keysAtom_;
      var n = e.data_.get(t) || e.hasMap_.get(t);
      return n || YL(25, t, tM(e)), n;
    }
    if (UT(e)) {
      if (!t) return YL(26);
      var s = e[VP].values_.get(t);
      return s || YL(27, t, tM(e)), s;
    }
    if (FP(e) || UA(e) || xB(e)) return e;
  } else if (dP(e) && xB(e[VP])) return e[VP];
  YL(28);
}
export function eM(e, t) {
  return (
    e || YL(29),
    undefined !== t
      ? eM(JT(e, t))
      : FP(e) || UA(e) || xB(e) || TT(e) || RT(e)
      ? e
      : e[VP]
      ? e[VP]
      : void YL(24, e)
  );
}
export function tM(e, t) {
  var n;
  if (undefined !== t) n = JT(e, t);
  else {
    if (PB(e)) return e.name;
    n = UT(e) || TT(e) || RT(e) ? eM(e) : JT(e);
  }
  return n.name_;
}
Object.entries(xT).forEach(function (e) {
  var t = e[0],
    n = e[1];
  "concat" !== t && gP(WT.prototype, t, n);
}),
  YT(1e3);
export var nM = sP.toString;
export function sM(e, t, n) {
  return undefined === n && (n = -1), iM(e, t, n);
}
export function iM(e, t, n, s, i) {
  if (e === t) return 0 !== e || 1 / e == 1 / t;
  if (null == e || null == t) return false;
  if (e != e) return t != t;
  var o = typeof e;
  if (!dP(o) && "object" !== o && "object" != typeof t) return false;
  var r = nM.call(e);
  if (r !== nM.call(t)) return false;
  switch (r) {
    case "[object RegExp]":
    case "[object String]":
      return "" + e == "" + t;
    case "[object Number]":
      return +e != +e ? +t != +t : 0 == +e ? 1 / +e == 1 / t : +e == +t;
    case "[object Date]":
    case "[object Boolean]":
      return +e == +t;
    case "[object Symbol]":
      return (
        "undefined" != typeof Symbol &&
        Symbol.valueOf.call(e) === Symbol.valueOf.call(t)
      );
    case "[object Map]":
    case "[object Set]":
      n >= 0 && n++;
  }
  (e = oM(e)), (t = oM(t));
  var a = "[object Array]" === r;
  if (!a) {
    if ("object" != typeof e || "object" != typeof t) return false;
    var l = e.constructor,
      c = t.constructor;
    if (
      l !== c &&
      !(dP(l) && l instanceof l && dP(c) && c instanceof c) &&
      "constructor" in e &&
      "constructor" in t
    )
      return false;
  }
  if (0 === n) return false;
  n < 0 && (n = -1), (i = i || []);
  for (var u = (s = s || []).length; u--; ) if (s[u] === e) return i[u] === t;
  if ((s.push(e), i.push(t), a)) {
    if ((u = e.length) !== t.length) return false;
    for (; u--; ) if (!iM(e[u], t[u], n - 1, s, i)) return false;
  } else {
    var d,
      p = Object.keys(e);
    if (((u = p.length), Object.keys(t).length !== u)) return false;
    for (; u--; )
      if (!jP(t, (d = p[u])) || !iM(e[d], t[d], n - 1, s, i)) return false;
  }
  return s.pop(), i.pop(), true;
}
export function oM(e) {
  return ST(e)
    ? e.slice()
    : yP(e) || TT(e) || vP(e) || RT(e)
    ? Array.from(e.entries())
    : e;
}
export function rM(e) {
  return (e[Symbol.iterator] = aM), e;
}
export function aM() {
  return this;
}
["Symbol", "Map", "Set", "Symbol"].forEach(function (e) {
  undefined === JL()[e] &&
    YL("MobX requires global '" + e + "' to be available or polyfilled");
}),
  "object" == typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ &&
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
      spy: function (e) {
        return (
          console.warn("[mobx.spy] Is a no-op in production builds"),
          function () {}
        );
      },
      extras: { getDebugName: tM },
      $mobx: VP,
    });
export var lM = class {
  features = {};
  enable(e, t) {
    (this.features[e] ||= []), this.features[e].unshift(t);
  }
  isEnabled(e, t) {
    const n = this.features[e];
    return null != n && cM(n, t.engine);
  }
  constructor() {
    dT(this, undefined, { autoBind: true });
  }
};
export function cM(e, t) {
  if (0 === e.length) return false;
  const [n, ...s] = e;
  return "function" == typeof n
    ? n({ engine: t, isPreviousEnable: () => cM(s, t) })
    : n;
}
export var dM = [
  "ly.img.group.enter.canvasMenu",
  "ly.img.group.select.canvasMenu",
  "ly.img.page.moveUp.canvasMenu",
  "ly.img.page.moveDown.canvasMenu",
  "ly.img.separator",
  "ly.img.text.edit.canvasMenu",
  "ly.img.replace.canvasMenu",
  "ly.img.separator",
  "ly.img.placeholder.canvasMenu",
  "ly.img.separator",
  "ly.img.duplicate.canvasMenu",
  "ly.img.delete.canvasMenu",
];
export var pM = [
  "ly.img.text.color.canvasMenu",
  "ly.img.separator",
  "ly.img.text.bold.canvasMenu",
  "ly.img.text.italic.canvasMenu",
  "ly.img.separator",
  "ly.img.text.variables.canvasMenu",
];
export var fM = [
  "ly.img.back.navigationBar",
  "ly.img.undoRedo.navigationBar",
  "ly.img.spacer",
  "ly.img.title.navigationBar",
  "ly.img.spacer",
  "ly.img.zoom.navigationBar",
  "ly.img.preview.navigationBar",
  "ly.img.actions.navigationBar",
  "ly.img.close.navigationBar",
];
export var hM = [
  "ly.img.settings.canvasBar",
  "ly.img.spacer",
  "ly.img.page.add.canvasBar",
  "ly.img.spacer",
];
export var mM = [
  "ly.img.text.typeFace.inspectorBar",
  "ly.img.text.fontSize.inspectorBar",
  "ly.img.shape.options.inspectorBar",
  "ly.img.cutout.type.inspectorBar",
  "ly.img.cutout.offset.inspectorBar",
  "ly.img.cutout.smoothing.inspectorBar",
  "ly.img.group.create.inspectorBar",
  "ly.img.group.ungroup.inspectorBar",
  "ly.img.audio.replace.inspectorBar",
  "ly.img.separator",
  "ly.img.text.bold.inspectorBar",
  "ly.img.text.italic.inspectorBar",
  "ly.img.text.alignHorizontal.inspectorBar",
  "ly.img.combine.inspectorBar",
  "ly.img.separator",
  "ly.img.fill.inspectorBar",
  "ly.img.trim.inspectorBar",
  "ly.img.volume.inspectorBar",
  "ly.img.crop.inspectorBar",
  "ly.img.separator",
  "ly.img.stroke.inspectorBar",
  "ly.img.separator",
  "ly.img.animations.inspectorBar",
  "ly.img.separator",
  "ly.img.adjustment.inspectorBar",
  "ly.img.filter.inspectorBar",
  "ly.img.effect.inspectorBar",
  "ly.img.blur.inspectorBar",
  "ly.img.separator",
  "ly.img.shadow.inspectorBar",
  "ly.img.spacer",
  "ly.img.separator",
  "ly.img.position.inspectorBar",
  "ly.img.separator",
  "ly.img.options.inspectorBar",
];
export var gM = ["ly.img.trimControls.inspectorBar"];
export var xM = ["ly.img.cropControls.inspectorBar"];
export var UserInterfaceElements = {};
defineGetter(UserInterfaceElements, {
  NavigationPosition: () => vM,
  PanelPosition: () => yM,
});
export var yM = ((e) => ((e.Left = "left"), (e.Right = "right"), e))(yM || {});
export var vM = ((e) => ((e.Top = "top"), (e.Bottom = "bottom"), e))(vM || {});
export var wM = function e(t) {
  if (Array.isArray(t)) return t.reduce((t, n) => t ^ e(n), 0);
  let n = -559038737,
    s = 1103547991;
  for (let e, i = 0; i < t.length; i++)
    (e = t.charCodeAt(i)),
      (n = Math.imul(n ^ e, 2654435761)),
      (s = Math.imul(s ^ e, 1597334677));
  return (
    (n = Math.imul(n ^ (n >>> 16), 2246822507)),
    (n ^= Math.imul(s ^ (s >>> 13), 3266489909)),
    (s = Math.imul(s ^ (s >>> 16), 2246822507)),
    (s ^= Math.imul(n ^ (n >>> 13), 3266489909)),
    4294967296 * (2097151 & s) + (n >>> 0)
  );
};
export var kM = class {
  viewStyle;
  panels = {};
  panelPositions = {};
  panelPositionFunctions = {};
  panelFloatings = {};
  panelFloatingFunctions = {};
  customPanels = [];
  notifications = [];
  dialogs = new Map();
  iconSets = [];
  dockOrders = [];
  inspectorbarOrders = [];
  canvasMenuOrders = [];
  navigationBarOrders = [];
  canvasBarBottomOrders = [];
  canvasBarTopOrders = [];
  assetLibraryEntries = {};
  backgroundTrackLibraryEntries = [];
  replaceAssetLibraryEntries;
  registeredComponents = {};
  registeredPanels = {};
  getPanelPosition(e) {
    const t = this.getPanelState(e);
    return null != t?.sessionOptions?.position
      ? t.sessionOptions.position
      : this.panelPositions[e] || "left";
  }
  setPanelPosition(e, t) {
    "function" == typeof t
      ? ((this.panelPositions[e] = t()), (this.panelPositionFunctions[e] = t))
      : ((this.panelPositions[e] = t), delete this.panelPositionFunctions[e]),
      this.reevaluatePanelFunctions({ exclude: [e] });
  }
  getPanelFloating(e) {
    const t = this.getPanelState(e);
    return null != t?.sessionOptions?.floating
      ? t.sessionOptions.floating
      : null != this.panelFloatings[e] && this.panelFloatings[e];
  }
  setPanelFloating(e, t) {
    "function" == typeof t
      ? ((this.panelFloatings[e] = t()), (this.panelFloatingFunctions[e] = t))
      : ((this.panelFloatings[e] = t), delete this.panelFloatingFunctions[e]),
      this.reevaluatePanelFunctions({ exclude: [e] });
  }
  setPanelState(e, { group: t, open: n, payload: s, sessionOptions: i }) {
    const o = this.getPanelState(e) ?? {},
      r = t ?? o.group,
      a = i ?? {},
      l = {};
    n &&
      null != r &&
      Object.keys(this.panels).forEach((t) => {
        if (t === e) return;
        const n = this.panels[t];
        n?.group === r &&
          n?.open &&
          (l[t] = {
            ...n,
            payload: undefined,
            sessionOptions: undefined,
            open: false,
          });
      }),
      (this.panels = {
        ...this.panels,
        ...l,
        [e]: {
          ...o,
          open: n,
          sessionOptions: n ? a : undefined,
          payload: s,
          group: r,
        },
      });
  }
  getPanelState(e) {
    return this.panels[e];
  }
  isOpen(e) {
    return this.getPanelState(e)?.open ?? false;
  }
  registerCustomPanel(e, t) {
    this.customPanels.push({ id: e, onMount: t }), (this.panels[e] = {});
  }
  registerPanel(e, t) {
    (this.registeredPanels[e] = { id: e, type: "builder", render: t }),
      (this.panels[e] = {});
  }
  registerComponent(e, t) {
    this.registeredComponents[e] = { id: e, type: "builder", render: t };
  }
  unstable_registerReactComponent(e, t) {
    this.registeredComponents[e] = { id: e, type: "react", component: t };
  }
  setDockOrder(e, t = { editMode: "Transform" }) {
    jM(this.dockOrders, SM(e), t);
  }
  getDockOrder(e = { editMode: "Transform" }) {
    return CM(this.dockOrders, e);
  }
  setInspectorBarOrder(e, t = { editMode: "Transform" }) {
    jM(this.inspectorbarOrders, SM(e), t);
  }
  getInspectorBarOrder(e = { editMode: "Transform" }) {
    return CM(this.inspectorbarOrders, e);
  }
  setCanvasMenuOrder(e, t = { editMode: "Transform" }) {
    jM(this.canvasMenuOrders, SM(e), t);
  }
  getCanvasMenuOrder(e = { editMode: "Transform" }) {
    return CM(this.canvasMenuOrders, e);
  }
  setNavigationBarOrder(e, t = { editMode: "Transform" }) {
    jM(this.navigationBarOrders, SM(e), t);
  }
  getNavigationBarOrder(e = { editMode: "Transform" }) {
    return CM(this.navigationBarOrders, e);
  }
  setCanvasBarOrder(e, t, n = { editMode: "Transform" }) {
    if ("top" === t) jM(this.canvasBarTopOrders, SM(e), n);
    else {
      if ("bottom" !== t) throw new Error(`Invalid canvas bar position '${t}'`);
      jM(this.canvasBarBottomOrders, SM(e), n);
    }
  }
  getCanvasBarOrder(e, t = { editMode: "Transform" }) {
    if ("top" === e) return CM(this.canvasBarTopOrders, t);
    if ("bottom" === e) return CM(this.canvasBarBottomOrders, t);
    throw new Error(`Invalid canvas bar position '${e}'`);
  }
  addNotification(e) {
    this.notifications.push(e);
  }
  updateNotification(e, t) {
    const n = this.notifications.findIndex((t) => t.id === e);
    -1 !== n && (this.notifications[n] = { ...this.notifications[n], ...t });
  }
  removeNotification(e) {
    this.notifications.splice(
      this.notifications.findIndex((t) => t.id === e),
      1
    );
  }
  addDialog(e, t) {
    this.dialogs.set(e, t);
  }
  updateDialog(e, t) {
    const n = this.dialogs.get(e);
    if (null == n) return;
    const s = "function" == typeof t ? t(n) : t;
    this.dialogs.set(e, { ...n, ...s });
  }
  getCurrentDialog() {
    if (0 === this.dialogs.size) return;
    const [e, t] = this.dialogs.entries().next().value;
    return { id: e, ...t };
  }
  removeDialog(e) {
    this.dialogs.delete(e);
  }
  addIconSet(e, t) {
    this.iconSets.unshift({ id: e, svgSprite: t });
  }
  constructor(e) {
    (this.viewStyle = e.viewStyle),
      MB(
        () => e.viewStyle,
        (e) => {
          (this.viewStyle = e), this.reevaluatePanelFunctions();
        }
      ),
      dT(this, undefined, { autoBind: true }),
      this.setNavigationBarOrder([...fM]),
      this.setCanvasBarOrder([...hM], "bottom"),
      this.setCanvasMenuOrder([...dM], { editMode: "Transform" }),
      this.setCanvasMenuOrder([...pM], { editMode: "Text" });
    const t = [...mM];
    this.setInspectorBarOrder(t, { editMode: "Transform" }),
      this.setInspectorBarOrder([...gM], { editMode: "Trim" }),
      this.setInspectorBarOrder([...xM], { editMode: "Crop" });
  }
  reevaluatePanelFunctions({ exclude: e = [] } = {}) {
    Object.entries(this.panelPositionFunctions).forEach(([t, n]) => {
      e.includes(t) || (this.panelPositions[t] = n());
    }),
      Object.entries(this.panelFloatingFunctions).forEach(([t, n]) => {
        e.includes(t) || (this.panelFloatings[t] = n());
      });
  }
};
export function CM(e, t = { editMode: "Transform" }) {
  const n = e.find(({ context: e }) => e.editMode === t.editMode);
  return "Transform" === t.editMode
    ? null != n
      ? [n.components, n.hash]
      : [[], wM([])]
    : null != n
    ? [n.components, n.hash]
    : CM(e, { ...t, editMode: "Transform" });
}
export function jM(e, t, n = { editMode: "Transform" }) {
  const s = e.findIndex(({ context: e }) => e.editMode === n.editMode);
  if (-1 === s)
    return e.push({ context: n, components: t, hash: wM(t.map((e) => e.id)) });
  (e[s].components = t), (e[s].hash = wM(t.map((e) => e.id)));
}
export function SM(e) {
  return e.map((e) => ("string" == typeof e ? { id: e } : e));
}
export var _M = function () {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
    const t = (16 * Math.random()) | 0;
    return ("x" === e ? t : (3 & t) | 8).toString(16);
  });
};
export var ConfigTypes = {};
defineGetter(ConfigTypes, { ViewStyle: () => EditorModes });
export var nO = {
  width: 256,
  height: 256,
  backgroundColor: "transparent",
  waveformColor: "black",
  pixelsPerSecond: 100,
};
export var sO = async function (e, t = {}) {
  const {
      width: n,
      height: s,
      backgroundColor: i,
      waveformColor: o,
      pixelsPerSecond: r,
    } = { ...nO, ...t },
    a = new AudioContext(),
    l = await e.arrayBuffer(),
    c = await a.decodeAudioData(l),
    u = c.duration,
    d = Math.max(n, Math.ceil(u * r)),
    p = (c.sampleRate * u) / d,
    f = document.createElement("canvas");
  (f.width = n), (f.height = s);
  const h = f.getContext("2d");
  (h.fillStyle = i), h.fillRect(0, 0, n, s);
  const m = c.getChannelData(0),
    g = s / 2,
    x = c.length;
  (h.strokeStyle = o), h.beginPath(), h.moveTo(0, g);
  for (let e = 0; e < n; e++) {
    let t = 1,
      n = -1;
    for (let s = 0; s < p; s++) {
      const i = Math.floor(e * p + s);
      if (i < x) {
        const e = m[i];
        e < t && (t = e), e > n && (n = e);
      }
    }
    const s = g - t * g,
      i = g - n * g;
    h.lineTo(e, i), h.lineTo(e, s);
  }
  return (
    h.stroke(),
    new Promise((e, t) => {
      f.toBlob((n) => {
        n ? e(n) : t(new Error("Canvas to Blob conversion failed"));
      });
    })
  );
};
export var iO = async function (e) {
  const t = document.createElement("canvas"),
    n = t.getContext("2d");
  if (null === n) throw new Error("Could not create context");
  const s = new Image();
  s.src = window.URL.createObjectURL(e);
  const i = await new Promise((e, t) => {
      (s.onload = () => {
        e({ width: s.width, height: s.height });
      }),
        (s.onerror = () => {
          t(new Error("Could not measure image width/height"));
        });
    }),
    o = (function (e, t) {
      const n = e.width,
        s = e.height,
        i = t.width,
        o = t.height;
      if (n <= i && s <= o) return e;
      const r = n / i,
        a = s / o;
      return r <= a
        ? { width: n / r, height: s / r }
        : { width: n / a, height: s / a };
    })(i, { width: 250, height: 250 });
  return (
    (t.width = o.width),
    (t.height = o.height),
    n.drawImage(s, 0, 0, i.width, i.height, 0, 0, o.width, o.height),
    await new Promise((e) => {
      t.toBlob(e);
    })
  );
};
export var oO = async function (e) {
  return new Promise((t, n) => {
    const s = document.createElement("video");
    (s.src = URL.createObjectURL(e)),
      (s.onloadedmetadata = () => {
        const e = Math.min(256 / s.videoWidth, 256 / s.videoHeight);
        (s.ontimeupdate = () => {
          const i = document.createElement("canvas");
          (i.width = e * s.videoWidth), (i.height = e * s.videoHeight);
          const o = i.getContext("2d");
          null != o
            ? (o.drawImage(s, 0, 0, i.width, i.height), i.toBlob(t))
            : n(new Error("Could not create context"));
        }),
          (s.currentTime = 0.5);
      }),
      (s.onerror = () => {
        n(new Error("video measure failed"));
      });
  });
};
export var localUploadCallback = async (e, t, n) => {
  const s = window.URL.createObjectURL(e);
  let i;
  e.type.startsWith("image") && (i = await iO(e)),
    e.type.startsWith("video") && (i = await oO(e)),
    e.type.startsWith("audio") && (i = await sO(e));
  const o = i && window.URL.createObjectURL(i);
  return {
    id: (0, tO.default)(`${e.name}/`),
    label: { en: e.name, de: e.name },
    groups: n?.group ? [n.group] : undefined,
    meta: { uri: s, thumbUri: o || "", filename: e.name },
  };
};
export function fO(e, t, n = Number.EPSILON) {
  return Math.abs(e - t) < n;
}
export function hO(e) {
  const { r: t, g: n, b: s } = e,
    i = Math.max(t, n, s),
    o = Math.min(t, n, s);
  let r = 0;
  const a = i,
    l = i - o,
    c = 0 === i ? 0 : l / i;
  if (i === o) r = 0;
  else {
    switch (i) {
      case t:
        r = (n - s) / l + (n < s ? 6 : 0);
        break;
      case n:
        r = (s - t) / l + 2;
        break;
      case s:
        r = (t - n) / l + 4;
    }
    r /= 6;
  }
  return { h: r, s: c, v: a };
}
export function mO(e, t) {
  return {
    h: parseFloat(e.h.toFixed(t)),
    s: parseFloat(e.s.toFixed(t)),
    v: parseFloat(e.v.toFixed(t)),
  };
}
export function gO(e) {
  const t = Object.entries(customColorsMap),
    n = [];
  let s,
    i = 1 / 0,
    o = { name: "", hex: wb(e), rgba: e };
  return (
    t.forEach((e) => {
      const [t, s] = e;
      n.push({ name: t, hex: s, rgba: kb(s) });
    }),
    n.forEach((t) => {
      const { rgba: n } = t;
      (s = (e.r - n.r) ** 2 + (e.g - n.g) ** 2 + (e.b - n.b) ** 2),
        s < i && ((i = s), (o = t));
    }),
    o
  );
}
export var xO = (e, t = "0") => (0, dO.default)(e).set("hsl.l", t);
export var bO = (e) => {
  const t = ((e) => (0, dO.default)(e).luminance() < 0.5)(e)
    ? (0, dO.default)("white")
    : (0, dO.default)("black");
  return t;
};
export var yO = (e, t, n) =>
  (0, dO.default)(n).set(e, (0, dO.default)(t).get(e));
export var vO = (e, t) => {
  const n = yO("lch.l", e, t).toString();
  return yO("lch.c", e, n);
};
export function wO(e) {
  const t = `colorConfiguratorStyles-${e}`;
  let n = document.getElementById(t);
  return (
    n ||
      ((n = document.createElement("style")),
      (n.id = t),
      document.head.appendChild(n)),
    n
  );
}
export function kO(e, t) {
  if (undefined === t)
    return void (function (e) {
      const t = wO(e);
      t.innerHTML = "";
    })(e);
  let n;
  switch (e) {
    case "active":
      n = (function (e) {
        return {
          "--ubq-foreground-active": (0, dO.default)(e).alpha(0.9).css("hsl"),
          "--ubq-interactive-active-default": (0, dO.default)(e).css("hsl"),
          "--ubq-interactive-active-hover": xO(e, "+0.05").css("hsl"),
          "--ubq-interactive-active-pressed": xO(e, "-0.05").css("hsl"),
          "--ubq-notice-info": bO(bO(e).toString()).css("hsl"),
        };
      })(t);
      break;
    case "accent":
      n = (function (e) {
        return {
          "--ubq-foreground-accent": bO(e).alpha(1).css("hsl"),
          "--ubq-interactive-accent-default": (0, dO.default)(e).css("hsl"),
          "--ubq-interactive-accent-hover": xO(e, "+0.05").css("hsl"),
          "--ubq-interactive-accent-pressed": xO(e, "-0.05").css("hsl"),
          "--ubq-focus-default": vO(e, "#3355FF").css("hsl"),
          "--ubq-notice-warning": vO(e, "#FFBB33").css("hsl"),
          "--ubq-notice-error": vO(e, "#DC608E").css("hsl"),
          "--ubq-notice-success": vO(e, "#09B48B").css("hsl"),
        };
      })(t);
      break;
    default:
      n = (function (e) {
        return {
          "--ubq-canvas": (0, dO.default)(e).css("hsl"),
          "--ubq-elevation-1": xO(e, "+0.05").css("hsl"),
          "--ubq-elevation-2": xO(e, "+0.1").css("hsl"),
          "--ubq-elevation-3": xO(e, "+0.2").css("hsl"),
          "--ubq-foreground-default": bO(e).alpha(0.9).css("hsl"),
          "--ubq-foreground-light": bO(e).alpha(0.7).css("hsl"),
          "--ubq-foreground-info": bO(e).alpha(0.5).css("hsl"),
          "--ubq-interactive-default": xO(e, "+0.15").css("hsl"),
          "--ubq-interactive-hover": xO(e, "+0.1").css("hsl"),
          "--ubq-interactive-pressed": xO(e, "+0.025").css("hsl"),
          "--ubq-interactive-selected": xO(e, "+0.125").css("hsl"),
          "--ubq-input-default": xO(e, "-0.1").css("hsl"),
          "--ubq-input-hover": xO(e, "-0.12").css("hsl"),
          "--ubq-border-default": xO(e, "+0.5").alpha(0.1).css("hsl"),
          "--ubq-stroke-contrast-1": bO(e).alpha(0.15).css("hsl"),
          "--ubq-stroke-contrast-2": bO(e).alpha(0.3).css("hsl"),
          "--ubq-focus-outline": (0, dO.default)(e).css("hsl"),
          "--ubq-overlay-default": (0, dO.default)(e).alpha(0.8).css("hsl"),
          "--ubq-progress": bO(e).alpha(0.7).css("hsl"),
          "--ubq-foreground-notice-default": bO(e).alpha(0.9).css("hsl"),
        };
      })(t);
  }
  !(function (e, t) {
    const n = wO(t);
    let s = "";
    n &&
      n.style &&
      (Object.entries(e).forEach((e) => {
        const [t, n] = e;
        s += `  ${t}: ${n};\n`;
      }),
      (n.innerHTML = `.${gh} {\n${s}}`));
  })(n, e);
}
export var CO = (e, t) => {
  switch (t) {
    case "Red":
      return e("color.red");
    case "Orange":
      return e("color.orange");
    case "Yellow":
      return e("color.yellow");
    case "Green":
      return e("color.green");
    case "Aqua":
      return e("color.aqua");
    case "Blue":
      return e("color.blue");
    case "Purple":
      return e("color.purple");
    case "Magenta":
      return e("color.magenta");
    default:
      return "";
  }
};
export var jO = (e, t) => {
  switch (t) {
    case "c":
      return e("color.cyan");
    case "m":
      return e("color.magenta");
    case "y":
      return e("color.yellow");
    case "k":
      return e("color.black");
    default:
      return "";
  }
};
export var SO = (e, t) => {
  switch (t) {
    case "r":
      return CO(e, "Red");
    case "g":
      return CO(e, "Green");
    case "b":
      return CO(e, "Blue");
    default:
      return "";
  }
};
export function _O(e) {
  const [t, n, s, i] = e;
  return { r: t, g: n, b: s, a: i };
}
export function EO(e, t) {
  return (
    fO(e.r, t.r, 1e-4) &&
    fO(e.g, t.g, 1e-4) &&
    fO(e.b, t.b, 1e-4) &&
    fO(e.a, t.a, 1e-4)
  );
}
export function LO(e) {
  if (isRGBAColor(e)) return "sRGB";
  if (isCMYKColor(e)) return "CMYK";
  if (isSpotColor(e)) return "SpotColor";
  throw new Error("Unknown color space!");
}
export function PO(e, t) {
  return Array.isArray(e)
    ? e.map((e) => (isRGBAColor(e) ? e : t.convertColorToColorSpace(e, "sRGB")))
    : isRGBAColor(e)
    ? e
    : t.convertColorToColorSpace(e, "sRGB");
}
export function AO(e, t) {
  switch (e.colorSpace) {
    case "sRGB":
      return { ...e, a: 1 };
    case "CMYK":
      return t.editor.convertColorToColorSpace({ ...e, tint: 1 }, "sRGB");
    case "SpotColor":
      return "sRGB" === e.representation.colorSpace
        ? { ...e.representation, a: 1 }
        : t.editor.convertColorToColorSpace(
            { ...e.representation, tint: 1 },
            "sRGB"
          );
    default:
      throw new Error("Error parsing color");
  }
}
export function BO(e) {
  return `C ${Math.round(100 * e.c)}M ${Math.round(
    100 * e.m
  )}Y ${Math.round(100 * e.y)}K ${Math.round(100 * e.k)}`;
}

export var OO = (0, TO.createContext)(null);
export function VO() {
  const e = (0, TO.useContext)(OO);
  if (null == e || null == e.cesdk)
    throw new Error("Context with CE.SDK instance not initialized");
  return e.cesdk;
}
export function DO() {
  const e = (0, TO.useContext)(OO);
  if (null == e || null == e.facade)
    throw new Error("Context with engine facade not initialized");
  return e.facade;
}

export var zO = class {
  #i;
  constructor(e) {
    (this.#i = _makeEngineChannel(
      e.onRoleChanged,
      () => e.getRole(),
      (t) => e.setRole(t)
    )),
      (this.#o = this.#i.subscribe((e) => {
        null === this.previewRole.value()
          ? this.#r.update(e)
          : this.#a.value() !== e && (this.#r.update(e), this.#a.update(null));
      })),
      (this.effectiveRole = {
        subscribe: this.#i.subscribe,
        value: this.#i.value,
      });
  }
  #o;
  dispose() {
    this.#o?.(), (this.#o = undefined);
  }
  #a = _makeValueChannel(() => null);
  previewRole = {
    ...this.#a,
    update: (e) => {
      const t = this.#r.value(),
        n = e ?? t;
      this.#a.update(e), this.#i.value() !== n && this.#i.update(n);
    },
  };
  #r = _makeValueChannel(() => this.#i.value());
  regularRole = {
    ...this.#r,
    update: (e) => {
      this.#r.update(e), this.previewRole.update(null);
    },
  };
  effectiveRole;
};
export var $O = class {
  constructor(e, t, n) {
    (this.customPageFormats = _makeValueChannel(
      () => n.ui?.pageFormats ?? null
    )),
      (this.pageFormats = {
        subscribe: _streams.pipe(
          _streams.combineLatest(
            this.customPageFormats.subscribe,
            t.mode.subscribe
          ),
          _streams.map(
            ([e, t]) =>
              e ?? ("Video" === t ? StandardResolutions : CanvasSizeConfig)
          )
        ),
        value: () =>
          this.customPageFormats.value() ??
          ("Video" === t.mode.value() ? StandardResolutions : CanvasSizeConfig),
        update: this.customPageFormats.update,
      }),
      (this.roles = new zO(e));
  }
  roles;
  customPageFormats;
  pageFormats;
};
export function QO(e) {
  throw new Error(e);
}
export function GO(e, t) {
  switch (t) {
    case "Millimeter":
      return e.mm.bleedMargin;
    case "Pixel":
      return e.px.bleedMargin;
    case "Inch":
      return e.in.bleedMargin;
    default:
      return QO(t);
  }
}
export var ZO = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    console && console[e] && console[e].apply(console, t);
  },
};
export var WO = new (class _Logger {
  constructor(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    this.init(e, t);
  }
  init(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    (this.prefix = t.prefix || "i18next:"),
      (this.logger = e || ZO),
      (this.options = t),
      (this.debug = t.debug);
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "log", "", true);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "", true);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(e, t, n, s) {
    return s && !this.debug
      ? null
      : ("string" == typeof e[0] && (e[0] = `${n}${this.prefix} ${e[0]}`),
        this.logger[t](e));
  }
  create(e) {
    return new _Logger(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options,
    });
  }
  clone(e) {
    return (
      ((e = e || this.options).prefix = e.prefix || this.prefix),
      new _Logger(this.logger, e)
    );
  }
})();
export var KO = class {
  constructor() {
    this.observers = {};
  }
  on(e, t) {
    return (
      e.split(" ").forEach((e) => {
        this.observers[e] || (this.observers[e] = new Map());
        const n = this.observers[e].get(t) || 0;
        this.observers[e].set(t, n + 1);
      }),
      this
    );
  }
  off(e, t) {
    this.observers[e] &&
      (t ? this.observers[e].delete(t) : delete this.observers[e]);
  }
  emit(e) {
    for (
      var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1;
      s < t;
      s++
    )
      n[s - 1] = arguments[s];
    if (this.observers[e]) {
      Array.from(this.observers[e].entries()).forEach((e) => {
        let [t, s] = e;
        for (let e = 0; e < s; e++) t(...n);
      });
    }
    if (this.observers["*"]) {
      Array.from(this.observers["*"].entries()).forEach((t) => {
        let [s, i] = t;
        for (let t = 0; t < i; t++) s.apply(s, [e, ...n]);
      });
    }
  }
};
export var YO = () => {
  let e, t;
  const n = new Promise((n, s) => {
    (e = n), (t = s);
  });
  return (n.resolve = e), (n.reject = t), n;
};
export var XO = (e) => (null == e ? "" : "" + e);
export var JO = /###/g;
export var eR = (e) => (e && e.indexOf("###") > -1 ? e.replace(JO, ".") : e);
export var tR = (e) => !e || "string" == typeof e;
export var nR = (e, t, n) => {
  const s = "string" != typeof t ? t : t.split(".");
  let i = 0;
  for (; i < s.length - 1; ) {
    if (tR(e)) return {};
    const t = eR(s[i]);
    !e[t] && n && (e[t] = new n()),
      (e = Object.prototype.hasOwnProperty.call(e, t) ? e[t] : {}),
      ++i;
  }
  return tR(e) ? {} : { obj: e, k: eR(s[i]) };
};
export var sR = (e, t, n) => {
  const { obj: s, k: i } = nR(e, t, Object);
  if (undefined !== s || 1 === t.length) return void (s[i] = n);
  let o = t[t.length - 1],
    r = t.slice(0, t.length - 1),
    a = nR(e, r, Object);
  for (; undefined === a.obj && r.length; )
    (o = `${r[r.length - 1]}.${o}`),
      (r = r.slice(0, r.length - 1)),
      (a = nR(e, r, Object)),
      a && a.obj && undefined !== a.obj[`${a.k}.${o}`] && (a.obj = undefined);
  a.obj[`${a.k}.${o}`] = n;
};
export var iR = (e, t) => {
  const { obj: n, k: s } = nR(e, t);
  if (n) return n[s];
};
export var oR = (e, t, n) => {
  for (const s in t)
    "__proto__" !== s &&
      "constructor" !== s &&
      (s in e
        ? "string" == typeof e[s] ||
          e[s] instanceof String ||
          "string" == typeof t[s] ||
          t[s] instanceof String
          ? n && (e[s] = t[s])
          : oR(e[s], t[s], n)
        : (e[s] = t[s]));
  return e;
};
export var rR = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
export var aR = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
};
export var lR = (e) =>
  "string" == typeof e ? e.replace(/[&<>"'\/]/g, (e) => aR[e]) : e;
export var cR = [" ", ",", "?", "!", ";"];
export var uR = new (class {
  constructor(e) {
    (this.capacity = e), (this.regExpMap = new Map()), (this.regExpQueue = []);
  }
  getRegExp(e) {
    const t = this.regExpMap.get(e);
    if (undefined !== t) return t;
    const n = new RegExp(e);
    return (
      this.regExpQueue.length === this.capacity &&
        this.regExpMap.delete(this.regExpQueue.shift()),
      this.regExpMap.set(e, n),
      this.regExpQueue.push(e),
      n
    );
  }
})(20);
export var dR = function (e, t) {
  let n =
    arguments.length > 2 && undefined !== arguments[2] ? arguments[2] : ".";
  if (!e) return;
  if (e[t]) return e[t];
  const s = t.split(n);
  let i = e;
  for (let e = 0; e < s.length; ) {
    if (!i || "object" != typeof i) return;
    let t,
      o = "";
    for (let r = e; r < s.length; ++r)
      if ((r !== e && (o += n), (o += s[r]), (t = i[o]), undefined !== t)) {
        if (
          ["string", "number", "boolean"].indexOf(typeof t) > -1 &&
          r < s.length - 1
        )
          continue;
        e += r - e + 1;
        break;
      }
    i = t;
  }
  return i;
};
export var pR = (e) => (e && e.indexOf("_") > 0 ? e.replace("_", "-") : e);
export var fR = class extends KO {
  constructor(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1]
        ? arguments[1]
        : { ns: ["translation"], defaultNS: "translation" };
    super(),
      (this.data = e || {}),
      (this.options = t),
      undefined === this.options.keySeparator &&
        (this.options.keySeparator = "."),
      undefined === this.options.ignoreJSONStructure &&
        (this.options.ignoreJSONStructure = true);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const t = this.options.ns.indexOf(e);
    t > -1 && this.options.ns.splice(t, 1);
  }
  getResource(e, t, n) {
    let s =
      arguments.length > 3 && undefined !== arguments[3] ? arguments[3] : {};
    const i =
        undefined !== s.keySeparator
          ? s.keySeparator
          : this.options.keySeparator,
      o =
        undefined !== s.ignoreJSONStructure
          ? s.ignoreJSONStructure
          : this.options.ignoreJSONStructure;
    let r;
    e.indexOf(".") > -1
      ? (r = e.split("."))
      : ((r = [e, t]),
        n &&
          (Array.isArray(n)
            ? r.push(...n)
            : "string" == typeof n && i
            ? r.push(...n.split(i))
            : r.push(n)));
    const a = iR(this.data, r);
    return (
      !a &&
        !t &&
        !n &&
        e.indexOf(".") > -1 &&
        ((e = r[0]), (t = r[1]), (n = r.slice(2).join("."))),
      a || !o || "string" != typeof n
        ? a
        : dR(this.data && this.data[e] && this.data[e][t], n, i)
    );
  }
  addResource(e, t, n, s) {
    let i =
      arguments.length > 4 && undefined !== arguments[4]
        ? arguments[4]
        : { silent: false };
    const o =
      undefined !== i.keySeparator ? i.keySeparator : this.options.keySeparator;
    let r = [e, t];
    n && (r = r.concat(o ? n.split(o) : n)),
      e.indexOf(".") > -1 && ((r = e.split(".")), (s = t), (t = r[1])),
      this.addNamespaces(t),
      sR(this.data, r, s),
      i.silent || this.emit("added", e, t, n, s);
  }
  addResources(e, t, n) {
    let s =
      arguments.length > 3 && undefined !== arguments[3]
        ? arguments[3]
        : { silent: false };
    for (const s in n)
      ("string" == typeof n[s] || Array.isArray(n[s])) &&
        this.addResource(e, t, s, n[s], { silent: true });
    s.silent || this.emit("added", e, t, n);
  }
  addResourceBundle(e, t, n, s, i) {
    let o =
        arguments.length > 5 && undefined !== arguments[5]
          ? arguments[5]
          : { silent: false, skipCopy: false },
      r = [e, t];
    e.indexOf(".") > -1 && ((r = e.split(".")), (s = n), (n = t), (t = r[1])),
      this.addNamespaces(t);
    let a = iR(this.data, r) || {};
    o.skipCopy || (n = JSON.parse(JSON.stringify(n))),
      s ? oR(a, n, i) : (a = { ...a, ...n }),
      sR(this.data, r, a),
      o.silent || this.emit("added", e, t, n);
  }
  removeResourceBundle(e, t) {
    this.hasResourceBundle(e, t) && delete this.data[e][t],
      this.removeNamespaces(t),
      this.emit("removed", e, t);
  }
  hasResourceBundle(e, t) {
    return undefined !== this.getResource(e, t);
  }
  getResourceBundle(e, t) {
    return (
      t || (t = this.options.defaultNS),
      "v1" === this.options.compatibilityAPI
        ? { ...this.getResource(e, t) }
        : this.getResource(e, t)
    );
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const t = this.getDataByLanguage(e);
    return !!((t && Object.keys(t)) || []).find(
      (e) => t[e] && Object.keys(t[e]).length > 0
    );
  }
  toJSON() {
    return this.data;
  }
};
export var hR = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, n, s, i) {
    return (
      e.forEach((e) => {
        this.processors[e] && (t = this.processors[e].process(t, n, s, i));
      }),
      t
    );
  },
};
export var mR = {};
export var gR = class _Translator extends KO {
  constructor(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    super(),
      ((e, t, n) => {
        e.forEach((e) => {
          t[e] && (n[e] = t[e]);
        });
      })(
        [
          "resourceStore",
          "languageUtils",
          "pluralResolver",
          "interpolator",
          "backendConnector",
          "i18nFormat",
          "utils",
        ],
        e,
        this
      ),
      (this.options = t),
      undefined === this.options.keySeparator &&
        (this.options.keySeparator = "."),
      (this.logger = WO.create("translator"));
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1]
        ? arguments[1]
        : { interpolation: {} };
    if (null == e) return false;
    const n = this.resolve(e, t);
    return n && undefined !== n.res;
  }
  extractFromKey(e, t) {
    let n =
      undefined !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator;
    undefined === n && (n = ":");
    const s =
      undefined !== t.keySeparator ? t.keySeparator : this.options.keySeparator;
    let i = t.ns || this.options.defaultNS || [];
    const o = n && e.indexOf(n) > -1,
      r = !(
        this.options.userDefinedKeySeparator ||
        t.keySeparator ||
        this.options.userDefinedNsSeparator ||
        t.nsSeparator ||
        ((e, t, n) => {
          (t = t || ""), (n = n || "");
          const s = cR.filter((e) => t.indexOf(e) < 0 && n.indexOf(e) < 0);
          if (0 === s.length) return true;
          const i = uR.getRegExp(
            `(${s.map((e) => ("?" === e ? "\\?" : e)).join("|")})`
          );
          let o = !i.test(e);
          if (!o) {
            const t = e.indexOf(n);
            t > 0 && !i.test(e.substring(0, t)) && (o = true);
          }
          return o;
        })(e, n, s)
      );
    if (o && !r) {
      const t = e.match(this.interpolator.nestingRegexp);
      if (t && t.length > 0) return { key: e, namespaces: i };
      const o = e.split(n);
      (n !== s || (n === s && this.options.ns.indexOf(o[0]) > -1)) &&
        (i = o.shift()),
        (e = o.join(s));
    }
    return "string" == typeof i && (i = [i]), { key: e, namespaces: i };
  }
  translate(e, t, n) {
    if (
      ("object" != typeof t &&
        this.options.overloadTranslationOptionHandler &&
        (t = this.options.overloadTranslationOptionHandler(arguments)),
      "object" == typeof t && (t = { ...t }),
      t || (t = {}),
      null == e)
    )
      return "";
    Array.isArray(e) || (e = [String(e)]);
    const s =
        undefined !== t.returnDetails
          ? t.returnDetails
          : this.options.returnDetails,
      i =
        undefined !== t.keySeparator
          ? t.keySeparator
          : this.options.keySeparator,
      { key: o, namespaces: r } = this.extractFromKey(e[e.length - 1], t),
      a = r[r.length - 1],
      l = t.lng || this.language,
      c = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (l && "cimode" === l.toLowerCase()) {
      if (c) {
        const e = t.nsSeparator || this.options.nsSeparator;
        return s
          ? {
              res: `${a}${e}${o}`,
              usedKey: o,
              exactUsedKey: o,
              usedLng: l,
              usedNS: a,
              usedParams: this.getUsedParamsDetails(t),
            }
          : `${a}${e}${o}`;
      }
      return s
        ? {
            res: o,
            usedKey: o,
            exactUsedKey: o,
            usedLng: l,
            usedNS: a,
            usedParams: this.getUsedParamsDetails(t),
          }
        : o;
    }
    const u = this.resolve(e, t);
    let d = u && u.res;
    const p = (u && u.usedKey) || o,
      f = (u && u.exactUsedKey) || o,
      h = Object.prototype.toString.apply(d),
      m = undefined !== t.joinArrays ? t.joinArrays : this.options.joinArrays,
      g = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (
      g &&
      d &&
      "string" != typeof d &&
      "boolean" != typeof d &&
      "number" != typeof d &&
      ["[object Number]", "[object Function]", "[object RegExp]"].indexOf(h) <
        0 &&
      ("string" != typeof m || !Array.isArray(d))
    ) {
      if (!t.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler ||
          this.logger.warn(
            "accessing an object - but returnObjects options is not enabled!"
          );
        const e = this.options.returnedObjectHandler
          ? this.options.returnedObjectHandler(p, d, { ...t, ns: r })
          : `key '${o} (${this.language})' returned an object instead of string.`;
        return s
          ? ((u.res = e), (u.usedParams = this.getUsedParamsDetails(t)), u)
          : e;
      }
      if (i) {
        const e = Array.isArray(d),
          n = e ? [] : {},
          s = e ? f : p;
        for (const e in d)
          if (Object.prototype.hasOwnProperty.call(d, e)) {
            const o = `${s}${i}${e}`;
            (n[e] = this.translate(o, { ...t, joinArrays: false, ns: r })),
              n[e] === o && (n[e] = d[e]);
          }
        d = n;
      }
    } else if (g && "string" == typeof m && Array.isArray(d))
      (d = d.join(m)), d && (d = this.extendTranslation(d, e, t, n));
    else {
      let s = false,
        r = false;
      const c = undefined !== t.count && "string" != typeof t.count,
        p = _Translator.hasDefaultValue(t),
        f = c ? this.pluralResolver.getSuffix(l, t.count, t) : "",
        h =
          t.ordinal && c
            ? this.pluralResolver.getSuffix(l, t.count, { ordinal: false })
            : "",
        m =
          c &&
          !t.ordinal &&
          0 === t.count &&
          this.pluralResolver.shouldUseIntlApi(),
        g =
          (m && t[`defaultValue${this.options.pluralSeparator}zero`]) ||
          t[`defaultValue${f}`] ||
          t[`defaultValue${h}`] ||
          t.defaultValue;
      !this.isValidLookup(d) && p && ((s = true), (d = g)),
        this.isValidLookup(d) || ((r = true), (d = o));
      const x =
          (t.missingKeyNoValueFallbackToKey ||
            this.options.missingKeyNoValueFallbackToKey) &&
          r
            ? undefined
            : d,
        b = p && g !== d && this.options.updateMissing;
      if (r || s || b) {
        if (
          (this.logger.log(b ? "updateKey" : "missingKey", l, a, o, b ? g : d),
          i)
        ) {
          const e = this.resolve(o, { ...t, keySeparator: false });
          e &&
            e.res &&
            this.logger.warn(
              "Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format."
            );
        }
        let e = [];
        const n = this.languageUtils.getFallbackCodes(
          this.options.fallbackLng,
          t.lng || this.language
        );
        if ("fallback" === this.options.saveMissingTo && n && n[0])
          for (let t = 0; t < n.length; t++) e.push(n[t]);
        else
          "all" === this.options.saveMissingTo
            ? (e = this.languageUtils.toResolveHierarchy(
                t.lng || this.language
              ))
            : e.push(t.lng || this.language);
        const s = (e, n, s) => {
          const i = p && s !== d ? s : x;
          this.options.missingKeyHandler
            ? this.options.missingKeyHandler(e, a, n, i, b, t)
            : this.backendConnector &&
              this.backendConnector.saveMissing &&
              this.backendConnector.saveMissing(e, a, n, i, b, t),
            this.emit("missingKey", e, a, n, d);
        };
        this.options.saveMissing &&
          (this.options.saveMissingPlurals && c
            ? e.forEach((e) => {
                const n = this.pluralResolver.getSuffixes(e, t);
                m &&
                  t[`defaultValue${this.options.pluralSeparator}zero`] &&
                  n.indexOf(`${this.options.pluralSeparator}zero`) < 0 &&
                  n.push(`${this.options.pluralSeparator}zero`),
                  n.forEach((n) => {
                    s([e], o + n, t[`defaultValue${n}`] || g);
                  });
              })
            : s(e, o, g));
      }
      (d = this.extendTranslation(d, e, t, u, n)),
        r &&
          d === o &&
          this.options.appendNamespaceToMissingKey &&
          (d = `${a}:${o}`),
        (r || s) &&
          this.options.parseMissingKeyHandler &&
          (d =
            "v1" !== this.options.compatibilityAPI
              ? this.options.parseMissingKeyHandler(
                  this.options.appendNamespaceToMissingKey ? `${a}:${o}` : o,
                  s ? d : undefined
                )
              : this.options.parseMissingKeyHandler(d));
    }
    return s
      ? ((u.res = d), (u.usedParams = this.getUsedParamsDetails(t)), u)
      : d;
  }
  extendTranslation(e, t, n, s, i) {
    var o = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(
        e,
        { ...this.options.interpolation.defaultVariables, ...n },
        n.lng || this.language || s.usedLng,
        s.usedNS,
        s.usedKey,
        { resolved: s }
      );
    else if (!n.skipInterpolation) {
      n.interpolation &&
        this.interpolator.init({
          ...n,
          interpolation: {
            ...this.options.interpolation,
            ...n.interpolation,
          },
        });
      const r =
        "string" == typeof e &&
        (n && n.interpolation && undefined !== n.interpolation.skipOnVariables
          ? n.interpolation.skipOnVariables
          : this.options.interpolation.skipOnVariables);
      let a;
      if (r) {
        const t = e.match(this.interpolator.nestingRegexp);
        a = t && t.length;
      }
      let l = n.replace && "string" != typeof n.replace ? n.replace : n;
      if (
        (this.options.interpolation.defaultVariables &&
          (l = { ...this.options.interpolation.defaultVariables, ...l }),
        (e = this.interpolator.interpolate(
          e,
          l,
          n.lng || this.language || s.usedLng,
          n
        )),
        r)
      ) {
        const t = e.match(this.interpolator.nestingRegexp);
        a < (t && t.length) && (n.nest = false);
      }
      !n.lng &&
        "v1" !== this.options.compatibilityAPI &&
        s &&
        s.res &&
        (n.lng = this.language || s.usedLng),
        false !== n.nest &&
          (e = this.interpolator.nest(
            e,
            function () {
              for (
                var e = arguments.length, s = new Array(e), r = 0;
                r < e;
                r++
              )
                s[r] = arguments[r];
              return i && i[0] === s[0] && !n.context
                ? (o.logger.warn(
                    `It seems you are nesting recursively key: ${s[0]} in key: ${t[0]}`
                  ),
                  null)
                : o.translate(...s, t);
            },
            n
          )),
        n.interpolation && this.interpolator.reset();
    }
    const r = n.postProcess || this.options.postProcess,
      a = "string" == typeof r ? [r] : r;
    return (
      null != e &&
        a &&
        a.length &&
        false !== n.applyPostProcessor &&
        (e = hR.handle(
          a,
          e,
          t,
          this.options && this.options.postProcessPassResolved
            ? {
                i18nResolved: {
                  ...s,
                  usedParams: this.getUsedParamsDetails(n),
                },
                ...n,
              }
            : n,
          this
        )),
      e
    );
  }
  resolve(e) {
    let t,
      n,
      s,
      i,
      o,
      r =
        arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    return (
      "string" == typeof e && (e = [e]),
      e.forEach((e) => {
        if (this.isValidLookup(t)) return;
        const a = this.extractFromKey(e, r),
          l = a.key;
        n = l;
        let c = a.namespaces;
        this.options.fallbackNS && (c = c.concat(this.options.fallbackNS));
        const u = undefined !== r.count && "string" != typeof r.count,
          d =
            u &&
            !r.ordinal &&
            0 === r.count &&
            this.pluralResolver.shouldUseIntlApi(),
          p =
            undefined !== r.context &&
            ("string" == typeof r.context || "number" == typeof r.context) &&
            "" !== r.context,
          f = r.lngs
            ? r.lngs
            : this.languageUtils.toResolveHierarchy(
                r.lng || this.language,
                r.fallbackLng
              );
        c.forEach((e) => {
          this.isValidLookup(t) ||
            ((o = e),
            !mR[`${f[0]}-${e}`] &&
              this.utils &&
              this.utils.hasLoadedNamespace &&
              !this.utils.hasLoadedNamespace(o) &&
              ((mR[`${f[0]}-${e}`] = true),
              this.logger.warn(
                `key "${n}" for languages "${f.join(
                  ", "
                )}" won't get resolved as namespace "${o}" was not yet loaded`,
                "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"
              )),
            f.forEach((n) => {
              if (this.isValidLookup(t)) return;
              i = n;
              const o = [l];
              if (this.i18nFormat && this.i18nFormat.addLookupKeys)
                this.i18nFormat.addLookupKeys(o, l, n, e, r);
              else {
                let e;
                u && (e = this.pluralResolver.getSuffix(n, r.count, r));
                const t = `${this.options.pluralSeparator}zero`,
                  s = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                if (
                  (u &&
                    (o.push(l + e),
                    r.ordinal &&
                      0 === e.indexOf(s) &&
                      o.push(l + e.replace(s, this.options.pluralSeparator)),
                    d && o.push(l + t)),
                  p)
                ) {
                  const n = `${l}${this.options.contextSeparator}${r.context}`;
                  o.push(n),
                    u &&
                      (o.push(n + e),
                      r.ordinal &&
                        0 === e.indexOf(s) &&
                        o.push(n + e.replace(s, this.options.pluralSeparator)),
                      d && o.push(n + t));
                }
              }
              let a;
              for (; (a = o.pop()); )
                this.isValidLookup(t) ||
                  ((s = a), (t = this.getResource(n, e, a, r)));
            }));
        });
      }),
      { res: t, usedKey: n, exactUsedKey: s, usedLng: i, usedNS: o }
    );
  }
  isValidLookup(e) {
    return !(
      undefined === e ||
      (!this.options.returnNull && null === e) ||
      (!this.options.returnEmptyString && "" === e)
    );
  }
  getResource(e, t, n) {
    let s =
      arguments.length > 3 && undefined !== arguments[3] ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource
      ? this.i18nFormat.getResource(e, t, n, s)
      : this.resourceStore.getResource(e, t, n, s);
  }
  getUsedParamsDetails() {
    let e =
      arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {};
    const t = [
        "defaultValue",
        "ordinal",
        "context",
        "replace",
        "lng",
        "lngs",
        "fallbackLng",
        "ns",
        "keySeparator",
        "nsSeparator",
        "returnObjects",
        "returnDetails",
        "joinArrays",
        "postProcess",
        "interpolation",
      ],
      n = e.replace && "string" != typeof e.replace;
    let s = n ? e.replace : e;
    if (
      (n && undefined !== e.count && (s.count = e.count),
      this.options.interpolation.defaultVariables &&
        (s = { ...this.options.interpolation.defaultVariables, ...s }),
      !n)
    ) {
      s = { ...s };
      for (const e of t) delete s[e];
    }
    return s;
  }
  static hasDefaultValue(e) {
    const t = "defaultValue";
    for (const n in e)
      if (
        Object.prototype.hasOwnProperty.call(e, n) &&
        t === n.substring(0, 12) &&
        undefined !== e[n]
      )
        return true;
    return false;
  }
};
export var xR = (e) => e.charAt(0).toUpperCase() + e.slice(1);
export var bR = class {
  constructor(e) {
    (this.options = e),
      (this.supportedLngs = this.options.supportedLngs || false),
      (this.logger = WO.create("languageUtils"));
  }
  getScriptPartFromCode(e) {
    if (!(e = pR(e)) || e.indexOf("-") < 0) return null;
    const t = e.split("-");
    return 2 === t.length
      ? null
      : (t.pop(),
        "x" === t[t.length - 1].toLowerCase()
          ? null
          : this.formatLanguageCode(t.join("-")));
  }
  getLanguagePartFromCode(e) {
    if (!(e = pR(e)) || e.indexOf("-") < 0) return e;
    const t = e.split("-");
    return this.formatLanguageCode(t[0]);
  }
  formatLanguageCode(e) {
    if ("string" == typeof e && e.indexOf("-") > -1) {
      const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let n = e.split("-");
      return (
        this.options.lowerCaseLng
          ? (n = n.map((e) => e.toLowerCase()))
          : 2 === n.length
          ? ((n[0] = n[0].toLowerCase()),
            (n[1] = n[1].toUpperCase()),
            t.indexOf(n[1].toLowerCase()) > -1 &&
              (n[1] = xR(n[1].toLowerCase())))
          : 3 === n.length &&
            ((n[0] = n[0].toLowerCase()),
            2 === n[1].length && (n[1] = n[1].toUpperCase()),
            "sgn" !== n[0] && 2 === n[2].length && (n[2] = n[2].toUpperCase()),
            t.indexOf(n[1].toLowerCase()) > -1 &&
              (n[1] = xR(n[1].toLowerCase())),
            t.indexOf(n[2].toLowerCase()) > -1 &&
              (n[2] = xR(n[2].toLowerCase()))),
        n.join("-")
      );
    }
    return this.options.cleanCode || this.options.lowerCaseLng
      ? e.toLowerCase()
      : e;
  }
  isSupportedCode(e) {
    return (
      ("languageOnly" === this.options.load ||
        this.options.nonExplicitSupportedLngs) &&
        (e = this.getLanguagePartFromCode(e)),
      !this.supportedLngs ||
        !this.supportedLngs.length ||
        this.supportedLngs.indexOf(e) > -1
    );
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let t;
    return (
      e.forEach((e) => {
        if (t) return;
        const n = this.formatLanguageCode(e);
        (this.options.supportedLngs && !this.isSupportedCode(n)) || (t = n);
      }),
      !t &&
        this.options.supportedLngs &&
        e.forEach((e) => {
          if (t) return;
          const n = this.getLanguagePartFromCode(e);
          if (this.isSupportedCode(n)) return (t = n);
          t = this.options.supportedLngs.find((e) =>
            e === n
              ? e
              : e.indexOf("-") < 0 && n.indexOf("-") < 0
              ? undefined
              : (e.indexOf("-") > 0 &&
                  n.indexOf("-") < 0 &&
                  e.substring(0, e.indexOf("-")) === n) ||
                (0 === e.indexOf(n) && n.length > 1)
              ? e
              : undefined
          );
        }),
      t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]),
      t
    );
  }
  getFallbackCodes(e, t) {
    if (!e) return [];
    if (
      ("function" == typeof e && (e = e(t)),
      "string" == typeof e && (e = [e]),
      Array.isArray(e))
    )
      return e;
    if (!t) return e.default || [];
    let n = e[t];
    return (
      n || (n = e[this.getScriptPartFromCode(t)]),
      n || (n = e[this.formatLanguageCode(t)]),
      n || (n = e[this.getLanguagePartFromCode(t)]),
      n || (n = e.default),
      n || []
    );
  }
  toResolveHierarchy(e, t) {
    const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e),
      s = [],
      i = (e) => {
        e &&
          (this.isSupportedCode(e)
            ? s.push(e)
            : this.logger.warn(
                `rejecting language code not found in supportedLngs: ${e}`
              ));
      };
    return (
      "string" == typeof e && (e.indexOf("-") > -1 || e.indexOf("_") > -1)
        ? ("languageOnly" !== this.options.load &&
            i(this.formatLanguageCode(e)),
          "languageOnly" !== this.options.load &&
            "currentOnly" !== this.options.load &&
            i(this.getScriptPartFromCode(e)),
          "currentOnly" !== this.options.load &&
            i(this.getLanguagePartFromCode(e)))
        : "string" == typeof e && i(this.formatLanguageCode(e)),
      n.forEach((e) => {
        s.indexOf(e) < 0 && i(this.formatLanguageCode(e));
      }),
      s
    );
  }
};
export var yR = [
  {
    lngs: [
      "ach",
      "ak",
      "am",
      "arn",
      "br",
      "fil",
      "gun",
      "ln",
      "mfe",
      "mg",
      "mi",
      "oc",
      "pt",
      "pt-BR",
      "tg",
      "tl",
      "ti",
      "tr",
      "uz",
      "wa",
    ],
    nr: [1, 2],
    fc: 1,
  },
  {
    lngs: [
      "af",
      "an",
      "ast",
      "az",
      "bg",
      "bn",
      "ca",
      "da",
      "de",
      "dev",
      "el",
      "en",
      "eo",
      "es",
      "et",
      "eu",
      "fi",
      "fo",
      "fur",
      "fy",
      "gl",
      "gu",
      "ha",
      "hi",
      "hu",
      "hy",
      "ia",
      "it",
      "kk",
      "kn",
      "ku",
      "lb",
      "mai",
      "ml",
      "mn",
      "mr",
      "nah",
      "nap",
      "nb",
      "ne",
      "nl",
      "nn",
      "no",
      "nso",
      "pa",
      "pap",
      "pms",
      "ps",
      "pt-PT",
      "rm",
      "sco",
      "se",
      "si",
      "so",
      "son",
      "sq",
      "sv",
      "sw",
      "ta",
      "te",
      "tk",
      "ur",
      "yo",
    ],
    nr: [1, 2],
    fc: 2,
  },
  {
    lngs: [
      "ay",
      "bo",
      "cgg",
      "fa",
      "ht",
      "id",
      "ja",
      "jbo",
      "ka",
      "km",
      "ko",
      "ky",
      "lo",
      "ms",
      "sah",
      "su",
      "th",
      "tt",
      "ug",
      "vi",
      "wo",
      "zh",
    ],
    nr: [1],
    fc: 3,
  },
  {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4,
  },
  { lngs: ["ar"], nr: [0, 1, 2, 3, 11, 100], fc: 5 },
  { lngs: ["cs", "sk"], nr: [1, 2, 5], fc: 6 },
  { lngs: ["csb", "pl"], nr: [1, 2, 5], fc: 7 },
  { lngs: ["cy"], nr: [1, 2, 3, 8], fc: 8 },
  { lngs: ["fr"], nr: [1, 2], fc: 9 },
  { lngs: ["ga"], nr: [1, 2, 3, 7, 11], fc: 10 },
  { lngs: ["gd"], nr: [1, 2, 3, 20], fc: 11 },
  { lngs: ["is"], nr: [1, 2], fc: 12 },
  { lngs: ["jv"], nr: [0, 1], fc: 13 },
  { lngs: ["kw"], nr: [1, 2, 3, 4], fc: 14 },
  { lngs: ["lt"], nr: [1, 2, 10], fc: 15 },
  { lngs: ["lv"], nr: [1, 2, 0], fc: 16 },
  { lngs: ["mk"], nr: [1, 2], fc: 17 },
  { lngs: ["mnk"], nr: [0, 1, 2], fc: 18 },
  { lngs: ["mt"], nr: [1, 2, 11, 20], fc: 19 },
  { lngs: ["or"], nr: [2, 1], fc: 2 },
  { lngs: ["ro"], nr: [1, 2, 20], fc: 20 },
  { lngs: ["sl"], nr: [5, 1, 2, 3], fc: 21 },
  { lngs: ["he", "iw"], nr: [1, 2, 20, 21], fc: 22 },
];
export var vR = {
  1: (e) => Number(e > 1),
  2: (e) => Number(1 != e),
  3: (e) => 0,
  4: (e) =>
    Number(
      e % 10 == 1 && e % 100 != 11
        ? 0
        : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20)
        ? 1
        : 2
    ),
  5: (e) =>
    Number(
      0 == e
        ? 0
        : 1 == e
        ? 1
        : 2 == e
        ? 2
        : e % 100 >= 3 && e % 100 <= 10
        ? 3
        : e % 100 >= 11
        ? 4
        : 5
    ),
  6: (e) => Number(1 == e ? 0 : e >= 2 && e <= 4 ? 1 : 2),
  7: (e) =>
    Number(
      1 == e
        ? 0
        : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20)
        ? 1
        : 2
    ),
  8: (e) => Number(1 == e ? 0 : 2 == e ? 1 : 8 != e && 11 != e ? 2 : 3),
  9: (e) => Number(e >= 2),
  10: (e) => Number(1 == e ? 0 : 2 == e ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4),
  11: (e) =>
    Number(
      1 == e || 11 == e ? 0 : 2 == e || 12 == e ? 1 : e > 2 && e < 20 ? 2 : 3
    ),
  12: (e) => Number(e % 10 != 1 || e % 100 == 11),
  13: (e) => Number(0 !== e),
  14: (e) => Number(1 == e ? 0 : 2 == e ? 1 : 3 == e ? 2 : 3),
  15: (e) =>
    Number(
      e % 10 == 1 && e % 100 != 11
        ? 0
        : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20)
        ? 1
        : 2
    ),
  16: (e) => Number(e % 10 == 1 && e % 100 != 11 ? 0 : 0 !== e ? 1 : 2),
  17: (e) => Number(1 == e || (e % 10 == 1 && e % 100 != 11) ? 0 : 1),
  18: (e) => Number(0 == e ? 0 : 1 == e ? 1 : 2),
  19: (e) =>
    Number(
      1 == e
        ? 0
        : 0 == e || (e % 100 > 1 && e % 100 < 11)
        ? 1
        : e % 100 > 10 && e % 100 < 20
        ? 2
        : 3
    ),
  20: (e) =>
    Number(1 == e ? 0 : 0 == e || (e % 100 > 0 && e % 100 < 20) ? 1 : 2),
  21: (e) =>
    Number(
      e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0
    ),
  22: (e) =>
    Number(1 == e ? 0 : 2 == e ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3),
};
export var wR = ["v1", "v2", "v3"];
export var kR = ["v4"];
export var CR = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 };
export var jR = class {
  constructor(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    (this.languageUtils = e),
      (this.options = t),
      (this.logger = WO.create("pluralResolver")),
      (this.options.compatibilityJSON &&
        !kR.includes(this.options.compatibilityJSON)) ||
        ("undefined" != typeof Intl && Intl.PluralRules) ||
        ((this.options.compatibilityJSON = "v3"),
        this.logger.error(
          "Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling."
        )),
      (this.rules = (() => {
        const e = {};
        return (
          yR.forEach((t) => {
            t.lngs.forEach((n) => {
              e[n] = { numbers: t.nr, plurals: vR[t.fc] };
            });
          }),
          e
        );
      })()),
      (this.pluralRulesCache = {});
  }
  addRule(e, t) {
    this.rules[e] = t;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        const n = pR("dev" === e ? "en" : e),
          s = t.ordinal ? "ordinal" : "cardinal",
          i = JSON.stringify({ cleanedCode: n, type: s });
        if (i in this.pluralRulesCache) return this.pluralRulesCache[i];
        const o = new Intl.PluralRules(n, { type: s });
        return (this.pluralRulesCache[i] = o), o;
      } catch (e) {
        return;
      }
    return (
      this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)]
    );
  }
  needsPlural(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    const n = this.getRule(e, t);
    return this.shouldUseIntlApi()
      ? n && n.resolvedOptions().pluralCategories.length > 1
      : n && n.numbers.length > 1;
  }
  getPluralFormsOfKey(e, t) {
    let n =
      arguments.length > 2 && undefined !== arguments[2] ? arguments[2] : {};
    return this.getSuffixes(e, n).map((e) => `${t}${e}`);
  }
  getSuffixes(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    const n = this.getRule(e, t);
    return n
      ? this.shouldUseIntlApi()
        ? n
            .resolvedOptions()
            .pluralCategories.sort((e, t) => CR[e] - CR[t])
            .map(
              (e) =>
                `${this.options.prepend}${
                  t.ordinal ? `ordinal${this.options.prepend}` : ""
                }${e}`
            )
        : n.numbers.map((n) => this.getSuffix(e, n, t))
      : [];
  }
  getSuffix(e, t) {
    let n =
      arguments.length > 2 && undefined !== arguments[2] ? arguments[2] : {};
    const s = this.getRule(e, n);
    return s
      ? this.shouldUseIntlApi()
        ? `${this.options.prepend}${
            n.ordinal ? `ordinal${this.options.prepend}` : ""
          }${s.select(t)}`
        : this.getSuffixRetroCompatible(s, t)
      : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, t) {
    const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
    let s = e.numbers[n];
    this.options.simplifyPluralSuffix &&
      2 === e.numbers.length &&
      1 === e.numbers[0] &&
      (2 === s ? (s = "plural") : 1 === s && (s = ""));
    const i = () =>
      this.options.prepend && s.toString()
        ? this.options.prepend + s.toString()
        : s.toString();
    return "v1" === this.options.compatibilityJSON
      ? 1 === s
        ? ""
        : "number" == typeof s
        ? `_plural_${s.toString()}`
        : i()
      : "v2" === this.options.compatibilityJSON ||
        (this.options.simplifyPluralSuffix &&
          2 === e.numbers.length &&
          1 === e.numbers[0])
      ? i()
      : this.options.prepend && n.toString()
      ? this.options.prepend + n.toString()
      : n.toString();
  }
  shouldUseIntlApi() {
    return !wR.includes(this.options.compatibilityJSON);
  }
};
export var SR = function (e, t, n) {
  let s =
      arguments.length > 3 && undefined !== arguments[3] ? arguments[3] : ".",
    i = !(arguments.length > 4 && undefined !== arguments[4]) || arguments[4],
    o = ((e, t, n) => {
      const s = iR(e, n);
      return undefined !== s ? s : iR(t, n);
    })(e, t, n);
  return (
    !o &&
      i &&
      "string" == typeof n &&
      ((o = dR(e, n, s)), undefined === o && (o = dR(t, n, s))),
    o
  );
};
export var _R = (e) => e.replace(/\$/g, "$$$$");
export var ER = class {
  constructor() {
    let e =
      arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {};
    (this.logger = WO.create("interpolator")),
      (this.options = e),
      (this.format = (e.interpolation && e.interpolation.format) || ((e) => e)),
      this.init(e);
  }
  init() {
    let e =
      arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {};
    e.interpolation || (e.interpolation = { escapeValue: true });
    const {
      escape: t,
      escapeValue: n,
      useRawValueToEscape: s,
      prefix: i,
      prefixEscaped: o,
      suffix: r,
      suffixEscaped: a,
      formatSeparator: l,
      unescapeSuffix: c,
      unescapePrefix: u,
      nestingPrefix: d,
      nestingPrefixEscaped: p,
      nestingSuffix: f,
      nestingSuffixEscaped: h,
      nestingOptionsSeparator: m,
      maxReplaces: g,
      alwaysFormat: x,
    } = e.interpolation;
    (this.escape = undefined !== t ? t : lR),
      (this.escapeValue = undefined === n || n),
      (this.useRawValueToEscape = undefined !== s && s),
      (this.prefix = i ? rR(i) : o || "{{"),
      (this.suffix = r ? rR(r) : a || "}}"),
      (this.formatSeparator = l || ","),
      (this.unescapePrefix = c ? "" : u || "-"),
      (this.unescapeSuffix = this.unescapePrefix ? "" : c || ""),
      (this.nestingPrefix = d ? rR(d) : p || rR("$t(")),
      (this.nestingSuffix = f ? rR(f) : h || rR(")")),
      (this.nestingOptionsSeparator = m || ","),
      (this.maxReplaces = g || 1e3),
      (this.alwaysFormat = undefined !== x && x),
      this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (e, t) =>
      e && e.source === t ? ((e.lastIndex = 0), e) : new RegExp(t, "g");
    (this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`)),
      (this.regexpUnescape = e(
        this.regexpUnescape,
        `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`
      )),
      (this.nestingRegexp = e(
        this.nestingRegexp,
        `${this.nestingPrefix}(.+?)${this.nestingSuffix}`
      ));
  }
  interpolate(e, t, n, s) {
    let i, o, r;
    const a =
        (this.options &&
          this.options.interpolation &&
          this.options.interpolation.defaultVariables) ||
        {},
      l = (e) => {
        if (e.indexOf(this.formatSeparator) < 0) {
          const i = SR(
            t,
            a,
            e,
            this.options.keySeparator,
            this.options.ignoreJSONStructure
          );
          return this.alwaysFormat
            ? this.format(i, undefined, n, {
                ...s,
                ...t,
                interpolationkey: e,
              })
            : i;
        }
        const i = e.split(this.formatSeparator),
          o = i.shift().trim(),
          r = i.join(this.formatSeparator).trim();
        return this.format(
          SR(
            t,
            a,
            o,
            this.options.keySeparator,
            this.options.ignoreJSONStructure
          ),
          r,
          n,
          { ...s, ...t, interpolationkey: o }
        );
      };
    this.resetRegExp();
    const c =
        (s && s.missingInterpolationHandler) ||
        this.options.missingInterpolationHandler,
      u =
        s && s.interpolation && undefined !== s.interpolation.skipOnVariables
          ? s.interpolation.skipOnVariables
          : this.options.interpolation.skipOnVariables;
    return (
      [
        { regex: this.regexpUnescape, safeValue: (e) => _R(e) },
        {
          regex: this.regexp,
          safeValue: (e) => (this.escapeValue ? _R(this.escape(e)) : _R(e)),
        },
      ].forEach((t) => {
        for (r = 0; (i = t.regex.exec(e)); ) {
          const n = i[1].trim();
          if (((o = l(n)), undefined === o))
            if ("function" == typeof c) {
              const t = c(e, i, s);
              o = "string" == typeof t ? t : "";
            } else if (s && Object.prototype.hasOwnProperty.call(s, n)) o = "";
            else {
              if (u) {
                o = i[0];
                continue;
              }
              this.logger.warn(
                `missed to pass in variable ${n} for interpolating ${e}`
              ),
                (o = "");
            }
          else "string" == typeof o || this.useRawValueToEscape || (o = XO(o));
          const a = t.safeValue(o);
          if (
            ((e = e.replace(i[0], a)),
            u
              ? ((t.regex.lastIndex += o.length),
                (t.regex.lastIndex -= i[0].length))
              : (t.regex.lastIndex = 0),
            r++,
            r >= this.maxReplaces)
          )
            break;
        }
      }),
      e
    );
  }
  nest(e, t) {
    let n,
      s,
      i,
      o =
        arguments.length > 2 && undefined !== arguments[2] ? arguments[2] : {};
    const r = (e, t) => {
      const n = this.nestingOptionsSeparator;
      if (e.indexOf(n) < 0) return e;
      const s = e.split(new RegExp(`${n}[ ]*{`));
      let o = `{${s[1]}`;
      (e = s[0]), (o = this.interpolate(o, i));
      const r = o.match(/'/g),
        a = o.match(/"/g);
      ((r && r.length % 2 == 0 && !a) || a.length % 2 != 0) &&
        (o = o.replace(/'/g, '"'));
      try {
        (i = JSON.parse(o)), t && (i = { ...t, ...i });
      } catch (t) {
        return (
          this.logger.warn(
            `failed parsing options string in nesting for key ${e}`,
            t
          ),
          `${e}${n}${o}`
        );
      }
      return (
        i.defaultValue &&
          i.defaultValue.indexOf(this.prefix) > -1 &&
          delete i.defaultValue,
        e
      );
    };
    for (; (n = this.nestingRegexp.exec(e)); ) {
      let a = [];
      (i = { ...o }),
        (i = i.replace && "string" != typeof i.replace ? i.replace : i),
        (i.applyPostProcessor = false),
        delete i.defaultValue;
      let l = false;
      if (-1 !== n[0].indexOf(this.formatSeparator) && !/{.*}/.test(n[1])) {
        const e = n[1].split(this.formatSeparator).map((e) => e.trim());
        (n[1] = e.shift()), (a = e), (l = true);
      }
      if (
        ((s = t(r.call(this, n[1].trim(), i), i)),
        s && n[0] === e && "string" != typeof s)
      )
        return s;
      "string" != typeof s && (s = XO(s)),
        s ||
          (this.logger.warn(`missed to resolve ${n[1]} for nesting ${e}`),
          (s = "")),
        l &&
          (s = a.reduce(
            (e, t) =>
              this.format(e, t, o.lng, {
                ...o,
                interpolationkey: n[1].trim(),
              }),
            s.trim()
          )),
        (e = e.replace(n[0], s)),
        (this.regexp.lastIndex = 0);
    }
    return e;
  }
};
export var LR = (e) => {
  const t = {};
  return (n, s, i) => {
    let o = i;
    i &&
      i.interpolationkey &&
      i.formatParams &&
      i.formatParams[i.interpolationkey] &&
      i[i.interpolationkey] &&
      (o = { ...o, [i.interpolationkey]: undefined });
    const r = s + JSON.stringify(o);
    let a = t[r];
    return a || ((a = e(pR(s), i)), (t[r] = a)), a(n);
  };
};
export var PR = class {
  constructor() {
    let e =
      arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {};
    (this.logger = WO.create("formatter")),
      (this.options = e),
      (this.formats = {
        number: LR((e, t) => {
          const n = new Intl.NumberFormat(e, { ...t });
          return (e) => n.format(e);
        }),
        currency: LR((e, t) => {
          const n = new Intl.NumberFormat(e, { ...t, style: "currency" });
          return (e) => n.format(e);
        }),
        datetime: LR((e, t) => {
          const n = new Intl.DateTimeFormat(e, { ...t });
          return (e) => n.format(e);
        }),
        relativetime: LR((e, t) => {
          const n = new Intl.RelativeTimeFormat(e, { ...t });
          return (e) => n.format(e, t.range || "day");
        }),
        list: LR((e, t) => {
          const n = new Intl.ListFormat(e, { ...t });
          return (e) => n.format(e);
        }),
      }),
      this.init(e);
  }
  init(e) {
    const t = (
      arguments.length > 1 && undefined !== arguments[1]
        ? arguments[1]
        : { interpolation: {} }
    ).interpolation;
    this.formatSeparator = t.formatSeparator
      ? t.formatSeparator
      : t.formatSeparator || ",";
  }
  add(e, t) {
    this.formats[e.toLowerCase().trim()] = t;
  }
  addCached(e, t) {
    this.formats[e.toLowerCase().trim()] = LR(t);
  }
  format(e, t, n) {
    let s =
      arguments.length > 3 && undefined !== arguments[3] ? arguments[3] : {};
    const i = t.split(this.formatSeparator);
    if (
      i.length > 1 &&
      i[0].indexOf("(") > 1 &&
      i[0].indexOf(")") < 0 &&
      i.find((e) => e.indexOf(")") > -1)
    ) {
      const e = i.findIndex((e) => e.indexOf(")") > -1);
      i[0] = [i[0], ...i.splice(1, e)].join(this.formatSeparator);
    }
    return i.reduce((e, t) => {
      const { formatName: i, formatOptions: o } = ((e) => {
        let t = e.toLowerCase().trim();
        const n = {};
        if (e.indexOf("(") > -1) {
          const s = e.split("(");
          t = s[0].toLowerCase().trim();
          const i = s[1].substring(0, s[1].length - 1);
          "currency" === t && i.indexOf(":") < 0
            ? n.currency || (n.currency = i.trim())
            : "relativetime" === t && i.indexOf(":") < 0
            ? n.range || (n.range = i.trim())
            : i.split(";").forEach((e) => {
                if (e) {
                  const [t, ...s] = e.split(":"),
                    i = s
                      .join(":")
                      .trim()
                      .replace(/^'+|'+$/g, ""),
                    o = t.trim();
                  n[o] || (n[o] = i),
                    "false" === i && (n[o] = false),
                    "true" === i && (n[o] = true),
                    isNaN(i) || (n[o] = parseInt(i, 10));
                }
              });
        }
        return { formatName: t, formatOptions: n };
      })(t);
      if (this.formats[i]) {
        let t = e;
        try {
          const r =
              (s && s.formatParams && s.formatParams[s.interpolationkey]) || {},
            a = r.locale || r.lng || s.locale || s.lng || n;
          t = this.formats[i](e, a, { ...o, ...s, ...r });
        } catch (e) {
          this.logger.warn(e);
        }
        return t;
      }
      return this.logger.warn(`there was no format function for ${i}`), e;
    }, e);
  }
};
export var AR = class extends KO {
  constructor(e, t, n) {
    let s =
      arguments.length > 3 && undefined !== arguments[3] ? arguments[3] : {};
    super(),
      (this.backend = e),
      (this.store = t),
      (this.services = n),
      (this.languageUtils = n.languageUtils),
      (this.options = s),
      (this.logger = WO.create("backendConnector")),
      (this.waitingReads = []),
      (this.maxParallelReads = s.maxParallelReads || 10),
      (this.readingCalls = 0),
      (this.maxRetries = s.maxRetries >= 0 ? s.maxRetries : 5),
      (this.retryTimeout = s.retryTimeout >= 1 ? s.retryTimeout : 350),
      (this.state = {}),
      (this.queue = []),
      this.backend && this.backend.init && this.backend.init(n, s.backend, s);
  }
  queueLoad(e, t, n, s) {
    const i = {},
      o = {},
      r = {},
      a = {};
    return (
      e.forEach((e) => {
        let s = true;
        t.forEach((t) => {
          const r = `${e}|${t}`;
          !n.reload && this.store.hasResourceBundle(e, t)
            ? (this.state[r] = 2)
            : this.state[r] < 0 ||
              (1 === this.state[r]
                ? undefined === o[r] && (o[r] = true)
                : ((this.state[r] = 1),
                  (s = false),
                  undefined === o[r] && (o[r] = true),
                  undefined === i[r] && (i[r] = true),
                  undefined === a[t] && (a[t] = true)));
        }),
          s || (r[e] = true);
      }),
      (Object.keys(i).length || Object.keys(o).length) &&
        this.queue.push({
          pending: o,
          pendingCount: Object.keys(o).length,
          loaded: {},
          errors: [],
          callback: s,
        }),
      {
        toLoad: Object.keys(i),
        pending: Object.keys(o),
        toLoadLanguages: Object.keys(r),
        toLoadNamespaces: Object.keys(a),
      }
    );
  }
  loaded(e, t, n) {
    const s = e.split("|"),
      i = s[0],
      o = s[1];
    t && this.emit("failedLoading", i, o, t),
      !t &&
        n &&
        this.store.addResourceBundle(i, o, n, undefined, undefined, {
          skipCopy: true,
        }),
      (this.state[e] = t ? -1 : 2),
      t && n && (this.state[e] = 0);
    const r = {};
    this.queue.forEach((n) => {
      ((e, t, n, s) => {
        const { obj: i, k: o } = nR(e, t, Object);
        (i[o] = i[o] || []), i[o].push(n);
      })(n.loaded, [i], o),
        ((e, t) => {
          undefined !== e.pending[t] && (delete e.pending[t], e.pendingCount--);
        })(n, e),
        t && n.errors.push(t),
        0 !== n.pendingCount ||
          n.done ||
          (Object.keys(n.loaded).forEach((e) => {
            r[e] || (r[e] = {});
            const t = n.loaded[e];
            t.length &&
              t.forEach((t) => {
                undefined === r[e][t] && (r[e][t] = true);
              });
          }),
          (n.done = true),
          n.errors.length ? n.callback(n.errors) : n.callback());
    }),
      this.emit("loaded", r),
      (this.queue = this.queue.filter((e) => !e.done));
  }
  read(e, t, n) {
    let s =
        arguments.length > 3 && undefined !== arguments[3] ? arguments[3] : 0,
      i =
        arguments.length > 4 && undefined !== arguments[4]
          ? arguments[4]
          : this.retryTimeout,
      o = arguments.length > 5 ? arguments[5] : undefined;
    if (!e.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads)
      return void this.waitingReads.push({
        lng: e,
        ns: t,
        fcName: n,
        tried: s,
        wait: i,
        callback: o,
      });
    this.readingCalls++;
    const r = (r, a) => {
        if ((this.readingCalls--, this.waitingReads.length > 0)) {
          const e = this.waitingReads.shift();
          this.read(e.lng, e.ns, e.fcName, e.tried, e.wait, e.callback);
        }
        r && a && s < this.maxRetries
          ? setTimeout(() => {
              this.read.call(this, e, t, n, s + 1, 2 * i, o);
            }, i)
          : o(r, a);
      },
      a = this.backend[n].bind(this.backend);
    if (2 !== a.length) return a(e, t, r);
    try {
      const n = a(e, t);
      n && "function" == typeof n.then
        ? n.then((e) => r(null, e)).catch(r)
        : r(null, n);
    } catch (e) {
      r(e);
    }
  }
  prepareLoading(e, t) {
    let n =
        arguments.length > 2 && undefined !== arguments[2] ? arguments[2] : {},
      s = arguments.length > 3 ? arguments[3] : undefined;
    if (!this.backend)
      return (
        this.logger.warn(
          "No backend was added via i18next.use. Will not load resources."
        ),
        s && s()
      );
    "string" == typeof e && (e = this.languageUtils.toResolveHierarchy(e)),
      "string" == typeof t && (t = [t]);
    const i = this.queueLoad(e, t, n, s);
    if (!i.toLoad.length) return i.pending.length || s(), null;
    i.toLoad.forEach((e) => {
      this.loadOne(e);
    });
  }
  load(e, t, n) {
    this.prepareLoading(e, t, {}, n);
  }
  reload(e, t, n) {
    this.prepareLoading(e, t, { reload: true }, n);
  }
  loadOne(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : "";
    const n = e.split("|"),
      s = n[0],
      i = n[1];
    this.read(s, i, "read", undefined, undefined, (n, o) => {
      n &&
        this.logger.warn(
          `${t}loading namespace ${i} for language ${s} failed`,
          n
        ),
        !n &&
          o &&
          this.logger.log(`${t}loaded namespace ${i} for language ${s}`, o),
        this.loaded(e, n, o);
    });
  }
  saveMissing(e, t, n, s, i) {
    let o =
        arguments.length > 5 && undefined !== arguments[5] ? arguments[5] : {},
      r =
        arguments.length > 6 && undefined !== arguments[6]
          ? arguments[6]
          : () => {};
    if (
      this.services.utils &&
      this.services.utils.hasLoadedNamespace &&
      !this.services.utils.hasLoadedNamespace(t)
    )
      this.logger.warn(
        `did not save key "${n}" as the namespace "${t}" was not yet loaded`,
        "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"
      );
    else if (null != n && "" !== n) {
      if (this.backend && this.backend.create) {
        const a = { ...o, isUpdate: i },
          l = this.backend.create.bind(this.backend);
        if (l.length < 6)
          try {
            let i;
            (i = 5 === l.length ? l(e, t, n, s, a) : l(e, t, n, s)),
              i && "function" == typeof i.then
                ? i.then((e) => r(null, e)).catch(r)
                : r(null, i);
          } catch (e) {
            r(e);
          }
        else l(e, t, n, s, r, a);
      }
      e && e[0] && this.store.addResource(e[0], t, n, s);
    }
  }
};
export var BR = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (
      ("object" == typeof e[1] && (t = e[1]),
      "string" == typeof e[1] && (t.defaultValue = e[1]),
      "string" == typeof e[2] && (t.tDescription = e[2]),
      "object" == typeof e[2] || "object" == typeof e[3])
    ) {
      const n = e[3] || e[2];
      Object.keys(n).forEach((e) => {
        t[e] = n[e];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: true,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true,
  },
});
export var TR = (e) => (
  "string" == typeof e.ns && (e.ns = [e.ns]),
  "string" == typeof e.fallbackLng && (e.fallbackLng = [e.fallbackLng]),
  "string" == typeof e.fallbackNS && (e.fallbackNS = [e.fallbackNS]),
  e.supportedLngs &&
    e.supportedLngs.indexOf("cimode") < 0 &&
    (e.supportedLngs = e.supportedLngs.concat(["cimode"])),
  e
);
export var MR = () => {};
export var OR = class _I18n extends KO {
  constructor() {
    let e =
        arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {},
      t = arguments.length > 1 ? arguments[1] : undefined;
    var n;
    if (
      (super(),
      (this.options = TR(e)),
      (this.services = {}),
      (this.logger = WO),
      (this.modules = { external: [] }),
      (n = this),
      Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach((e) => {
        "function" == typeof n[e] && (n[e] = n[e].bind(n));
      }),
      t && !this.isInitialized && !e.isClone)
    ) {
      if (!this.options.initImmediate) return this.init(e, t), this;
      setTimeout(() => {
        this.init(e, t);
      }, 0);
    }
  }
  init() {
    var e = this;
    let t =
        arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {},
      n = arguments.length > 1 ? arguments[1] : undefined;
    (this.isInitializing = true),
      "function" == typeof t && ((n = t), (t = {})),
      !t.defaultNS &&
        false !== t.defaultNS &&
        t.ns &&
        ("string" == typeof t.ns
          ? (t.defaultNS = t.ns)
          : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const s = BR();
    (this.options = { ...s, ...this.options, ...TR(t) }),
      "v1" !== this.options.compatibilityAPI &&
        (this.options.interpolation = {
          ...s.interpolation,
          ...this.options.interpolation,
        }),
      undefined !== t.keySeparator &&
        (this.options.userDefinedKeySeparator = t.keySeparator),
      undefined !== t.nsSeparator &&
        (this.options.userDefinedNsSeparator = t.nsSeparator);
    const i = (e) => (e ? ("function" == typeof e ? new e() : e) : null);
    if (!this.options.isClone) {
      let t;
      this.modules.logger
        ? WO.init(i(this.modules.logger), this.options)
        : WO.init(null, this.options),
        this.modules.formatter
          ? (t = this.modules.formatter)
          : "undefined" != typeof Intl && (t = PR);
      const n = new bR(this.options);
      this.store = new fR(this.options.resources, this.options);
      const o = this.services;
      (o.logger = WO),
        (o.resourceStore = this.store),
        (o.languageUtils = n),
        (o.pluralResolver = new jR(n, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix,
        })),
        !t ||
          (this.options.interpolation.format &&
            this.options.interpolation.format !== s.interpolation.format) ||
          ((o.formatter = i(t)),
          o.formatter.init(o, this.options),
          (this.options.interpolation.format = o.formatter.format.bind(
            o.formatter
          ))),
        (o.interpolator = new ER(this.options)),
        (o.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this),
        }),
        (o.backendConnector = new AR(
          i(this.modules.backend),
          o.resourceStore,
          o,
          this.options
        )),
        o.backendConnector.on("*", function (t) {
          for (
            var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), i = 1;
            i < n;
            i++
          )
            s[i - 1] = arguments[i];
          e.emit(t, ...s);
        }),
        this.modules.languageDetector &&
          ((o.languageDetector = i(this.modules.languageDetector)),
          o.languageDetector.init &&
            o.languageDetector.init(o, this.options.detection, this.options)),
        this.modules.i18nFormat &&
          ((o.i18nFormat = i(this.modules.i18nFormat)),
          o.i18nFormat.init && o.i18nFormat.init(this)),
        (this.translator = new gR(this.services, this.options)),
        this.translator.on("*", function (t) {
          for (
            var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), i = 1;
            i < n;
            i++
          )
            s[i - 1] = arguments[i];
          e.emit(t, ...s);
        }),
        this.modules.external.forEach((e) => {
          e.init && e.init(this);
        });
    }
    if (
      ((this.format = this.options.interpolation.format),
      n || (n = MR),
      this.options.fallbackLng &&
        !this.services.languageDetector &&
        !this.options.lng)
    ) {
      const e = this.services.languageUtils.getFallbackCodes(
        this.options.fallbackLng
      );
      e.length > 0 && "dev" !== e[0] && (this.options.lng = e[0]);
    }
    this.services.languageDetector ||
      this.options.lng ||
      this.logger.warn(
        "init: no languageDetector is used and no lng is defined"
      );
    [
      "getResource",
      "hasResourceBundle",
      "getResourceBundle",
      "getDataByLanguage",
    ].forEach((t) => {
      this[t] = function () {
        return e.store[t](...arguments);
      };
    });
    [
      "addResource",
      "addResources",
      "addResourceBundle",
      "removeResourceBundle",
    ].forEach((t) => {
      this[t] = function () {
        return e.store[t](...arguments), e;
      };
    });
    const o = YO(),
      r = () => {
        const e = (e, t) => {
          (this.isInitializing = false),
            this.isInitialized &&
              !this.initializedStoreOnce &&
              this.logger.warn(
                "init: i18next is already initialized. You should call init just once!"
              ),
            (this.isInitialized = true),
            this.options.isClone ||
              this.logger.log("initialized", this.options),
            this.emit("initialized", this.options),
            o.resolve(t),
            n(e, t);
        };
        if (
          this.languages &&
          "v1" !== this.options.compatibilityAPI &&
          !this.isInitialized
        )
          return e(null, this.t.bind(this));
        this.changeLanguage(this.options.lng, e);
      };
    return (
      this.options.resources || !this.options.initImmediate
        ? r()
        : setTimeout(r, 0),
      o
    );
  }
  loadResources(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : MR;
    const n = "string" == typeof e ? e : this.language;
    if (
      ("function" == typeof e && (t = e),
      !this.options.resources || this.options.partialBundledLanguages)
    ) {
      if (
        n &&
        "cimode" === n.toLowerCase() &&
        (!this.options.preload || 0 === this.options.preload.length)
      )
        return t();
      const e = [],
        s = (t) => {
          if (!t) return;
          if ("cimode" === t) return;
          this.services.languageUtils.toResolveHierarchy(t).forEach((t) => {
            "cimode" !== t && e.indexOf(t) < 0 && e.push(t);
          });
        };
      if (n) s(n);
      else {
        this.services.languageUtils
          .getFallbackCodes(this.options.fallbackLng)
          .forEach((e) => s(e));
      }
      this.options.preload && this.options.preload.forEach((e) => s(e)),
        this.services.backendConnector.load(e, this.options.ns, (e) => {
          e ||
            this.resolvedLanguage ||
            !this.language ||
            this.setResolvedLanguage(this.language),
            t(e);
        });
    } else t(null);
  }
  reloadResources(e, t, n) {
    const s = YO();
    return (
      "function" == typeof e && ((n = e), (e = undefined)),
      "function" == typeof t && ((n = t), (t = undefined)),
      e || (e = this.languages),
      t || (t = this.options.ns),
      n || (n = MR),
      this.services.backendConnector.reload(e, t, (e) => {
        s.resolve(), n(e);
      }),
      s
    );
  }
  use(e) {
    if (!e)
      throw new Error(
        "You are passing an undefined module! Please check the object you are passing to i18next.use()"
      );
    if (!e.type)
      throw new Error(
        "You are passing a wrong module! Please check the object you are passing to i18next.use()"
      );
    return (
      "backend" === e.type && (this.modules.backend = e),
      ("logger" === e.type || (e.log && e.warn && e.error)) &&
        (this.modules.logger = e),
      "languageDetector" === e.type && (this.modules.languageDetector = e),
      "i18nFormat" === e.type && (this.modules.i18nFormat = e),
      "postProcessor" === e.type && hR.addPostProcessor(e),
      "formatter" === e.type && (this.modules.formatter = e),
      "3rdParty" === e.type && this.modules.external.push(e),
      this
    );
  }
  setResolvedLanguage(e) {
    if (e && this.languages && !(["cimode", "dev"].indexOf(e) > -1))
      for (let e = 0; e < this.languages.length; e++) {
        const t = this.languages[e];
        if (
          !(["cimode", "dev"].indexOf(t) > -1) &&
          this.store.hasLanguageSomeTranslations(t)
        ) {
          this.resolvedLanguage = t;
          break;
        }
      }
  }
  changeLanguage(e, t) {
    var n = this;
    this.isLanguageChangingTo = e;
    const s = YO();
    this.emit("languageChanging", e);
    const i = (e) => {
        (this.language = e),
          (this.languages = this.services.languageUtils.toResolveHierarchy(e)),
          (this.resolvedLanguage = undefined),
          this.setResolvedLanguage(e);
      },
      o = (e, o) => {
        o
          ? (i(o),
            this.translator.changeLanguage(o),
            (this.isLanguageChangingTo = undefined),
            this.emit("languageChanged", o),
            this.logger.log("languageChanged", o))
          : (this.isLanguageChangingTo = undefined),
          s.resolve(function () {
            return n.t(...arguments);
          }),
          t &&
            t(e, function () {
              return n.t(...arguments);
            });
      },
      r = (t) => {
        e || t || !this.services.languageDetector || (t = []);
        const n =
          "string" == typeof t
            ? t
            : this.services.languageUtils.getBestMatchFromCodes(t);
        n &&
          (this.language || i(n),
          this.translator.language || this.translator.changeLanguage(n),
          this.services.languageDetector &&
            this.services.languageDetector.cacheUserLanguage &&
            this.services.languageDetector.cacheUserLanguage(n)),
          this.loadResources(n, (e) => {
            o(e, n);
          });
      };
    return (
      e ||
      !this.services.languageDetector ||
      this.services.languageDetector.async
        ? !e &&
          this.services.languageDetector &&
          this.services.languageDetector.async
          ? 0 === this.services.languageDetector.detect.length
            ? this.services.languageDetector.detect().then(r)
            : this.services.languageDetector.detect(r)
          : r(e)
        : r(this.services.languageDetector.detect()),
      s
    );
  }
  getFixedT(e, t, n) {
    var s = this;
    const i = function (e, t) {
      let o;
      if ("object" != typeof t) {
        for (
          var r = arguments.length, a = new Array(r > 2 ? r - 2 : 0), l = 2;
          l < r;
          l++
        )
          a[l - 2] = arguments[l];
        o = s.options.overloadTranslationOptionHandler([e, t].concat(a));
      } else o = { ...t };
      (o.lng = o.lng || i.lng),
        (o.lngs = o.lngs || i.lngs),
        (o.ns = o.ns || i.ns),
        "" !== o.keyPrefix && (o.keyPrefix = o.keyPrefix || n || i.keyPrefix);
      const c = s.options.keySeparator || ".";
      let u;
      return (
        (u =
          o.keyPrefix && Array.isArray(e)
            ? e.map((e) => `${o.keyPrefix}${c}${e}`)
            : o.keyPrefix
            ? `${o.keyPrefix}${c}${e}`
            : e),
        s.t(u, o)
      );
    };
    return (
      "string" == typeof e ? (i.lng = e) : (i.lngs = e),
      (i.ns = t),
      (i.keyPrefix = n),
      i
    );
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let t =
      arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {};
    if (!this.isInitialized)
      return (
        this.logger.warn(
          "hasLoadedNamespace: i18next was not initialized",
          this.languages
        ),
        false
      );
    if (!this.languages || !this.languages.length)
      return (
        this.logger.warn(
          "hasLoadedNamespace: i18n.languages were undefined or empty",
          this.languages
        ),
        false
      );
    const n = t.lng || this.resolvedLanguage || this.languages[0],
      s = !!this.options && this.options.fallbackLng,
      i = this.languages[this.languages.length - 1];
    if ("cimode" === n.toLowerCase()) return true;
    const o = (e, t) => {
      const n = this.services.backendConnector.state[`${e}|${t}`];
      return -1 === n || 0 === n || 2 === n;
    };
    if (t.precheck) {
      const e = t.precheck(this, o);
      if (undefined !== e) return e;
    }
    return (
      !!this.hasResourceBundle(n, e) ||
      !(
        this.services.backendConnector.backend &&
        (!this.options.resources || this.options.partialBundledLanguages)
      ) ||
      !(!o(n, e) || (s && !o(i, e)))
    );
  }
  loadNamespaces(e, t) {
    const n = YO();
    return this.options.ns
      ? ("string" == typeof e && (e = [e]),
        e.forEach((e) => {
          this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
        }),
        this.loadResources((e) => {
          n.resolve(), t && t(e);
        }),
        n)
      : (t && t(), Promise.resolve());
  }
  loadLanguages(e, t) {
    const n = YO();
    "string" == typeof e && (e = [e]);
    const s = this.options.preload || [],
      i = e.filter(
        (e) =>
          s.indexOf(e) < 0 && this.services.languageUtils.isSupportedCode(e)
      );
    return i.length
      ? ((this.options.preload = s.concat(i)),
        this.loadResources((e) => {
          n.resolve(), t && t(e);
        }),
        n)
      : (t && t(), Promise.resolve());
  }
  dir(e) {
    if (
      (e ||
        (e =
          this.resolvedLanguage ||
          (this.languages && this.languages.length > 0
            ? this.languages[0]
            : this.language)),
      !e)
    )
      return "rtl";
    const t = (this.services && this.services.languageUtils) || new bR(BR());
    return [
      "ar",
      "shu",
      "sqr",
      "ssh",
      "xaa",
      "yhd",
      "yud",
      "aao",
      "abh",
      "abv",
      "acm",
      "acq",
      "acw",
      "acx",
      "acy",
      "adf",
      "ads",
      "aeb",
      "aec",
      "afb",
      "ajp",
      "apc",
      "apd",
      "arb",
      "arq",
      "ars",
      "ary",
      "arz",
      "auz",
      "avl",
      "ayh",
      "ayl",
      "ayn",
      "ayp",
      "bbz",
      "pga",
      "he",
      "iw",
      "ps",
      "pbt",
      "pbu",
      "pst",
      "prp",
      "prd",
      "ug",
      "ur",
      "ydd",
      "yds",
      "yih",
      "ji",
      "yi",
      "hbo",
      "men",
      "xmn",
      "fa",
      "jpr",
      "peo",
      "pes",
      "prs",
      "dv",
      "sam",
      "ckb",
    ].indexOf(t.getLanguagePartFromCode(e)) > -1 ||
      e.toLowerCase().indexOf("-arab") > 1
      ? "rtl"
      : "ltr";
  }
  static createInstance() {
    return new _I18n(
      arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {},
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
  cloneInstance() {
    let e =
        arguments.length > 0 && undefined !== arguments[0] ? arguments[0] : {},
      t =
        arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : MR;
    const n = e.forkResourceStore;
    n && delete e.forkResourceStore;
    const s = { ...this.options, ...e, isClone: true },
      i = new _I18n(s);
    (undefined === e.debug && undefined === e.prefix) ||
      (i.logger = i.logger.clone(e));
    return (
      ["store", "services", "language"].forEach((e) => {
        i[e] = this[e];
      }),
      (i.services = { ...this.services }),
      (i.services.utils = {
        hasLoadedNamespace: i.hasLoadedNamespace.bind(i),
      }),
      n &&
        ((i.store = new fR(this.store.data, s)),
        (i.services.resourceStore = i.store)),
      (i.translator = new gR(i.services, s)),
      i.translator.on("*", function (e) {
        for (
          var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1;
          s < t;
          s++
        )
          n[s - 1] = arguments[s];
        i.emit(e, ...n);
      }),
      i.init(s, t),
      (i.translator.options = s),
      (i.translator.backendConnector.services.utils = {
        hasLoadedNamespace: i.hasLoadedNamespace.bind(i),
      }),
      i
    );
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage,
    };
  }
};
export var RR = OR.createInstance();
RR.createInstance = OR.createInstance;
RR.createInstance,
  RR.dir,
  RR.init,
  RR.loadResources,
  RR.reloadResources,
  RR.use,
  RR.changeLanguage,
  RR.getFixedT,
  RR.t,
  RR.exists,
  RR.setDefaultNamespace,
  RR.hasLoadedNamespace,
  RR.loadNamespaces,
  RR.loadLanguages;
export var VR = {};
export var DR = {};

translations.forEach((e) => {
  const { key: t, de: n, en: s } = e;
  n && (VR[t] = n), s && (DR[t] = s);
});
export var FR = "en";
export var IR = ({ locale: e, custom: t = {} } = {}) => {
  const { en: n, de: s, ...i } = t,
    o = Object.keys(i),
    r = ["en", "de", ...o],
    a = o.reduce((e, t) => {
      const n = i[t] || {};
      return (e[t] = { custom: n }), e;
    }, {}),
    l = {
      en: { cesdk: DR, custom: n || {} },
      de: { cesdk: VR, custom: s || {} },
      ...a,
    },
    c = RR.createInstance();
  return (
    c.init({
      resources: l,
      supportedLngs: r,
      ns: ["custom", "cesdk"],
      defaultNS: "custom",
      fallbackNS: "cesdk",
      nsSeparator: false,
      lng: e || FR,
      fallbackLng: (e) => {
        const t =
          e
            .match(/(x-[^-]+)|([^-]+)/g)
            ?.map((e, t, n) => n.slice(0, -t).join("-"))
            .filter(Boolean) ?? [];
        return t.push(FR), t;
      },
      interpolation: { escapeValue: false },
      keySeparator: false,
      saveMissing: false,
      missingKeyHandler: (e, t, n, s) => {
        if (!window.missingKeys.has(n) && !s) {
          if ((window.missingKeys.add(n), n.match(/^assets|^presets/))) return;
          console.groupCollapsed("Missing translation key", n),
            console.trace(),
            console.groupEnd();
        }
      },
    }),
    c
  );
};

export var zR = (e) =>
  null != e && ("boolean" == typeof e ? e : null == e.show || e.show);
export var $R = class _ConfigurationStore {
  constructor(e, t = true) {
    (this.#l = e),
      this.initializeSettings(),
      t && ((this.#c = new _ConfigurationStore(this.#l, false)), dT(this));
  }
  #c;
  #l;
  theme = "light";
  customBackgroundColor = undefined;
  customAccentColor = undefined;
  customActiveColor = undefined;
  language = "en";
  scale = ky ? "large" : "normal";
  viewStyle = DefaultViewMode;
  settingsPanelEnabled = false;
  assetLibraryPanelEnabled = true;
  assetLibraryPanelInsertAutoClose = () => false;
  assetLibraryPanelReplaceAutoClose = () => false;
  dockIconSize = "large";
  dockHideLabels = false;
  inspectorEnabled = false;
  hideUserInterface = false;
  smallViewportOptimization = true;
  navigationEnabled = false;
  dockEnabled = false;
  inspectorBarEnabled = false;
  navigationPosition;
  blocksTransformEnabled = true;
  blocksOpacityEnabled = true;
  legacyNonResponsivePanelPosition = false;
  blocks = {};
  actionEnabled = {
    close: false,
    back: false,
    save: false,
    exportFormats: [],
    share: false,
    download: false,
    load: false,
    archive: false,
  };
  colorLibraries = [];
  resetSettings() {
    this.initializeSettings();
  }
  get isDifferentThanConfigured() {
    return !(0, UR.default)(this.#c, this);
  }
  initializeSettings() {
    const e = this.#l;
    (this.language = e.locale ?? "en"),
      e.ui?.scale && (this.scale = e.ui?.scale),
      (this.theme = e.theme),
      (this.customBackgroundColor = undefined),
      (this.customAccentColor = undefined),
      (this.customActiveColor = undefined);
    const t = e.ui?.elements?.view;
    null != t && (this.viewStyle = t),
      (this.settingsPanelEnabled = zR(e.ui?.elements?.panels?.settings)),
      (this.assetLibraryPanelEnabled = zR(
        e.ui?.elements?.panels?.assetLibrary
      )),
      (this.assetLibraryPanelInsertAutoClose = () => {
        const t = e?.ui?.elements?.libraries?.insert?.autoClose;
        return null != t && "boolean" == typeof t
          ? t
          : null == t || "function" != typeof t || t();
      }),
      (this.assetLibraryPanelReplaceAutoClose = () => {
        const t = e?.ui?.elements?.libraries?.replace?.autoClose;
        return null != t && "boolean" == typeof t
          ? t
          : null == t || "function" != typeof t || t();
      }),
      (this.dockIconSize = e.ui?.elements?.dock?.iconSize ?? "large"),
      (this.dockHideLabels = e.ui?.elements?.dock?.hideLabels ?? false),
      (this.inspectorEnabled = zR(e.ui?.elements?.panels?.inspector)),
      (this.navigationEnabled = zR(e.ui?.elements?.navigation)),
      (this.dockEnabled = zR(e.ui?.elements?.dock)),
      (this.inspectorBarEnabled = zR(e.ui?.elements?.inspectorBar)),
      (this.navigationPosition =
        e.ui?.elements?.navigation?.position ?? NavigationPanelConfig.position),
      (this.hideUserInterface = zR(e.ui?.hide)),
      (this.smallViewportOptimization =
        !!e?.featureFlags?.smallViewportOptimization &&
        (e.ui?.smallViewportOptimization ?? true));
    const n = e.ui?.elements?.navigation?.action;
    if (
      ((this.actionEnabled.close = zR(n?.close)),
      (this.actionEnabled.back = zR(n?.back)),
      (this.actionEnabled.save = zR(n?.save)),
      (this.actionEnabled.share = zR(n?.share)),
      (this.actionEnabled.load = zR(n?.load)),
      zR(n?.export))
    ) {
      const e = {
        "application/pdf": MimeType.Pdf,
        "image/png": MimeType.Png,
        "video/mp4": MimeType.Mp4,
      };
      if ("object" == typeof n?.export && null !== n?.export) {
        const { format: t = [] } = n.export;
        this.actionEnabled.exportFormats = t.map((t) => e[t]).filter(Boolean);
      }
    }
    (this.actionEnabled.download = zR(n?.download)),
      (this.actionEnabled.archive = !!e?.featureFlags?.archiveSceneEnabled),
      (this.colorLibraries = e.ui.colorLibraries ?? []);
    const s = e.ui?.elements?.blocks;
    (this.blocksOpacityEnabled = zR(s?.opacity)),
      (this.blocksTransformEnabled = zR(s?.transform)),
      (this.legacyNonResponsivePanelPosition =
        !!e?.featureFlags?.legacyNonResponsivePanelPosition),
      (this.blocks = {
        "//ly.img.ubq/page": {
          format: zR(s?.["//ly.img.ubq/page"]?.format),
          manage: zR(s?.["//ly.img.ubq/page"]?.manage),
          maxDuration: s?.["//ly.img.ubq/page"]?.maxDuration ?? 1800,
          cropEnabled: zR(s?.["//ly.img.ubq/page"]?.crop),
          filtersEnabled: zR(s?.["//ly.img.ubq/page"]?.filters),
          adjustmentsEnabled: zR(s?.["//ly.img.ubq/page"]?.adjustments),
          effectsEnabled: zR(s?.["//ly.img.ubq/page"]?.effects),
          blurEnabled: zR(s?.["//ly.img.ubq/page"]?.blur),
        },
        "//ly.img.ubq/graphic": {
          cropEnabled: zR(s?.["//ly.img.ubq/graphic"]?.crop),
          filtersEnabled: zR(s?.["//ly.img.ubq/graphic"]?.filters),
          adjustmentsEnabled: zR(s?.["//ly.img.ubq/graphic"]?.adjustments),
          effectsEnabled: zR(s?.["//ly.img.ubq/graphic"]?.effects),
          blurEnabled: zR(s?.["//ly.img.ubq/graphic"]?.blur),
        },
        "//ly.img.ubq/text": {
          advancedEnabled: zR(s?.["//ly.img.ubq/text"]?.advanced),
          colorEnabled: zR(s?.["//ly.img.ubq/text"]?.color),
        },
      });
  }
};
export var qR = class {
  placeholderChange = 0;
  activeGroup;
  requestFocusForDesignElementId;
  requestFocus(e) {
    this.requestFocusForDesignElementId = e;
  }
  clearFocusRequest() {
    this.requestFocusForDesignElementId = undefined;
  }
  constructor() {
    dT(this, undefined, { autoBind: true });
  }
};

export var GR = (0, HR.createContext)({});
export var ZR = () => (0, HR.useContext)(GR);
export var KR = () => {
  const { engine: e } = ZR();
  if (!e) throw new Error("No engine store found in context");
  return e;
};
export var YR = () => {
  const { configuration: e } = ZR();
  if (!e) throw new Error("No engine store found in context");
  return e;
};
export var XR = () => {
  const { userInterface: e } = ZR();
  if (!e) throw new Error("No user interface store found in context");
  return e;
};

export var { fan: nV, merge: sV } = _streams;
export var iV = class {
  subscribe;
  value;
  constructor(e) {
    const t = _makeEngineChannel(
      sV(e.asset.onAssetSourceAdded, e.asset.onAssetSourceRemoved),
      () => e.asset.findAllSources(),
      undefined,
      { equals: JR.default }
    );
    (this.subscribe = nV(t.subscribe)), (this.value = t.value);
  }
};

export var aV = () => {};

export var uV = class extends Map {
  getOrCreate(e, t) {
    const n = this.get(e);
    if (undefined !== n) return n;
    {
      const n = t();
      return this.set(e, n), n;
    }
  }
};
export var dV = class {
  #u;
  blockApi;
  stream;
  #d;
  #p;
  #f;
  #h;
  constructor(e, t) {
    (this.blockApi = e.block),
      (this.stream = _getBlockStream(t, e)),
      (this.#u = t),
      (this.#d = new uV()),
      (this.#p = new uV()),
      (this.#f = new uV()),
      (this.#h = new uV());
  }
  get id() {
    return this.#u;
  }
  Int(e) {
    return this.#d.getOrCreate(e, () =>
      _makeEngineChannel(
        this.stream,
        () => this.blockApi.getInt(this.id, e),
        (t) => {
          this.blockApi.setInt(this.id, e, t);
        }
      )
    );
  }
  Float(e) {
    return this.#p.getOrCreate(e, () =>
      _makeEngineChannel(
        this.stream,
        () => this.blockApi.getFloat(this.id, e),
        (t) => {
          this.blockApi.setFloat(this.id, e, t);
        }
      )
    );
  }
  Bool(e) {
    return this.#f.getOrCreate(e, () =>
      _makeEngineChannel(
        this.stream,
        () => this.blockApi.getBool(this.id, e),
        (t) => {
          this.blockApi.setBool(this.id, e, t);
        }
      )
    );
  }
  String(e) {
    return this.#h.getOrCreate(e, () =>
      _makeEngineChannel(
        this.stream,
        () => this.blockApi.getString(this.id, e),
        (t) => {
          this.blockApi.setString(this.id, e, t);
        }
      )
    );
  }
};
export var pV = class extends dV {
  get isValid() {
    return this.blockApi.isValid(this.id);
  }
  get type() {
    return this.blockApi.getType(this.id);
  }
  get kind() {
    return this.blockApi.getKind(this.id);
  }
  get hasSoloPlaybackEnabledProperty() {
    return this.blockApi
      .findAllProperties(this.id)
      .some((e) => "playback/soloPlaybackEnabled" === e);
  }
  get hasPlaceholderBehavior() {
    return this.blockApi.supportsPlaceholderBehavior(this.id);
  }
  effects;
  isVisibleAtCurrentPlaybackTime;
  playbackTime;
  positionX;
  positionY;
  width;
  height;
  widthMode;
  heightMode;
  dimensions;
  origin;
  flipHorizontal;
  flipVertical;
  includedInExport;
  hasStroke;
  isStrokeEnabled;
  strokeWidth;
  strokePosition;
  strokeCornerGeometry;
  strokeStyle;
  horizontalTextAlignment;
  verticalTextAlignment;
  alwaysOnTop;
  alwaysOnBottom;
  rotation;
  fontSize;
  dropShadowOffset;
  dropShadowBlurRadius;
  isFillEnabled;
  textFontWeights;
  textFontStyles;
  textColors;
  canToggleBoldFont;
  canToggleItalicFont;
  typeface;
  isVisible;
  isTransformLocked;
  textCase;
  automaticFontSizeEnabled;
  minAutomaticFontSize;
  maxAutomaticFontSize;
  cutoutType;
  cutoutSmoothing;
  clipLinesOutsideOfFrame;
  constructor(e, t) {
    super(e, t),
      (this.#m = new uV()),
      (this.#g = new uV()),
      (this.effects = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getEffects(t),
        (e) => {
          for (let e = this.blockApi.getEffects(t).length - 1; e >= 0; e--)
            this.blockApi.removeEffect(t, e);
          e.forEach((e) => {
            this.blockApi.appendEffect(t, e);
          });
        },
        {
          equals: (e, t) =>
            e === t ||
            (null != e &&
              null != t &&
              e.length === t.length &&
              e.every((e, n) => e === t[n])),
        }
      )),
      (this.isVisibleAtCurrentPlaybackTime = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isVisibleAtCurrentPlaybackTime(t)
      )),
      (this.playbackTime = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getPlaybackTime(t),
        (e) => this.blockApi.setPlaybackTime(t, e)
      )),
      (this.positionX = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getPositionX(t),
        (e) => this.blockApi.setPositionX(t, e)
      )),
      (this.positionY = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getPositionY(t),
        (e) => this.blockApi.setPositionY(t, e)
      )),
      (this.width = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getWidth(t),
        (e) => this.blockApi.setWidth(t, e)
      )),
      (this.height = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getHeight(t),
        (e) => this.blockApi.setHeight(t, e)
      )),
      (this.widthMode = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getWidthMode(t),
        (e) => this.blockApi.setWidthMode(t, e)
      )),
      (this.heightMode = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getHeightMode(t),
        (e) => this.blockApi.setHeightMode(t, e)
      )),
      (this.dimensions = _makeEngineChannel(
        this.stream,
        () => ({
          x: this.blockApi.getFrameWidth(t),
          y: this.blockApi.getFrameHeight(t),
        }),
        ({ x: e, y: n }) => {
          this.blockApi.setWidth(t, e), this.blockApi.setHeight(t, n);
        },
        { equals: (e, t) => e.x === t?.x && e.y === t?.y }
      )),
      (this.origin = _makeEngineChannel(this.stream, () => ({
        x: this.blockApi.getFrameX(t),
        y: this.blockApi.getFrameY(t),
      }))),
      (this.flipHorizontal = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getFlipHorizontal(t),
        (e) => this.blockApi.setFlipHorizontal(t, e)
      )),
      (this.flipVertical = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getFlipVertical(t),
        (e) => this.blockApi.setFlipVertical(t, e)
      )),
      (this.includedInExport = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isIncludedInExport(t),
        (e) => {
          this.blockApi.setIncludedInExport(t, e);
        }
      )),
      (this.strokePosition = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getStrokePosition(t),
        (e) => {
          this.blockApi.setStrokePosition(t, e);
        }
      )),
      (this.strokeCornerGeometry = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getStrokeCornerGeometry(t),
        (e) => {
          this.blockApi.setStrokeCornerGeometry(t, e);
        }
      )),
      (this.textFontWeights = _makeEngineChannel(this.stream, () =>
        this.blockApi.getTextFontWeights(t)
      )),
      (this.textFontStyles = _makeEngineChannel(this.stream, () =>
        this.blockApi.getTextFontStyles(t)
      )),
      (this.textColors = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getTextColors(t),
        undefined,
        { equals: oV.default }
      )),
      (this.canToggleBoldFont = _makeEngineChannel(this.stream, () =>
        this.blockApi.canToggleBoldFont(t)
      )),
      (this.canToggleItalicFont = _makeEngineChannel(this.stream, () =>
        this.blockApi.canToggleItalicFont(t)
      )),
      (this.typeface = _makeEngineChannel(
        this.stream,
        () => {
          try {
            return this.blockApi.getTypeface(t);
          } catch {
            return;
          }
        },
        undefined,
        { equals: oV.default }
      )),
      (this.hasStroke = _makeEngineChannel(this.stream, () =>
        this.blockApi.supportsStroke(t)
      )),
      (this.isStrokeEnabled = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isStrokeEnabled(t),
        (e) => {
          this.blockApi.setStrokeEnabled(t, e);
        }
      )),
      (this.strokeWidth = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getStrokeWidth(t),
        (e) => {
          this.blockApi.setStrokeWidth(t, e);
        }
      )),
      (this.strokePosition = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getStrokePosition(t),
        (e) => {
          this.blockApi.setStrokePosition(t, e);
        }
      )),
      (this.strokeCornerGeometry = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getStrokeCornerGeometry(t),
        (e) => {
          this.blockApi.setStrokeCornerGeometry(t, e);
        }
      )),
      (this.strokeStyle = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getStrokeStyle(t),
        (e) => {
          this.blockApi.setStrokeStyle(t, e);
        }
      )),
      (this.horizontalTextAlignment = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getEnum(t, "text/horizontalAlignment"),
        (e) => {
          this.blockApi.setEnum(t, "text/horizontalAlignment", e);
        }
      )),
      (this.verticalTextAlignment = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getEnum(t, "text/verticalAlignment"),
        (e) => {
          this.blockApi.setEnum(t, "text/verticalAlignment", e);
        }
      )),
      (this.alwaysOnTop = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isAlwaysOnTop(t),
        (e) => {
          this.blockApi.setAlwaysOnTop(t, e);
        }
      )),
      (this.alwaysOnBottom = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isAlwaysOnBottom(t),
        (e) => {
          this.blockApi.setAlwaysOnBottom(t, e);
        }
      )),
      (this.rotation = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getRotation(t),
        (e) => {
          this.blockApi.setRotation(t, e);
        }
      )),
      (this.fontSize = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getFloat(t, "text/fontSize"),
        (e) => {
          this.blockApi.setFloat(t, "text/fontSize", e);
        }
      )),
      (this.dropShadowOffset = _makeEngineChannel(
        this.stream,
        () => ({
          x: this.blockApi.getDropShadowOffsetX(t),
          y: this.blockApi.getDropShadowOffsetY(t),
        }),
        (e) => {
          this.blockApi.setDropShadowOffsetX(t, e.x),
            this.blockApi.setDropShadowOffsetY(t, e.y);
        }
      )),
      (this.dropShadowBlurRadius = _makeEngineChannel(
        this.stream,
        () => ({
          x: this.blockApi.getDropShadowBlurRadiusX(t),
          y: this.blockApi.getDropShadowBlurRadiusY(t),
        }),
        (e) => {
          this.blockApi.setDropShadowBlurRadiusX(t, e.x),
            this.blockApi.setDropShadowBlurRadiusY(t, e.y);
        }
      )),
      (this.isFillEnabled = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isFillEnabled(t),
        (e) => {
          this.blockApi.setFillEnabled(t, e);
        }
      )),
      (this.isVisible = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isVisible(t),
        (e) => this.blockApi.setVisible(t, e)
      )),
      (this.isTransformLocked = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isTransformLocked(t),
        (e) => this.blockApi.setTransformLocked(t, e)
      )),
      (this.textCase = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getTextCases(t),
        (e) => this.blockApi.setTextCase(t, e)
      )),
      (this.automaticFontSizeEnabled = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getBool(t, "text/automaticFontSizeEnabled"),
        (e) => this.blockApi.setBool(t, "text/automaticFontSizeEnabled", e)
      )),
      (this.minAutomaticFontSize = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getFloat(t, "text/minAutomaticFontSize"),
        (e) => this.blockApi.setFloat(t, "text/minAutomaticFontSize", e)
      )),
      (this.maxAutomaticFontSize = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getFloat(t, "text/maxAutomaticFontSize"),
        (e) => this.blockApi.setFloat(t, "text/maxAutomaticFontSize", e)
      )),
      (this.cutoutType = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getEnum(t, "cutout/type"),
        (e) => this.blockApi.setEnum(t, "cutout/type", e)
      )),
      (this.cutoutSmoothing = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getFloat(t, "cutout/smoothing"),
        (e) => this.blockApi.setFloat(t, "cutout/smoothing", e)
      )),
      (this.clipLinesOutsideOfFrame = _makeEngineChannel(
        this.stream,
        () => this.blockApi.getBool(t, "text/clipLinesOutsideOfFrame"),
        (e) => this.blockApi.setBool(t, "text/clipLinesOutsideOfFrame", e)
      ));
  }
  #x = new Map();
  #m;
  #g;
  Color(e) {
    return this.#m.getOrCreate(e, () =>
      _makeEngineChannel(
        this.stream,
        () => this.blockApi.getColor(this.id, e),
        (t) => {
          this.blockApi.setColor(this.id, e, t);
        },
        { equals: oV.default }
      )
    );
  }
  GradientStops(e) {
    return this.#g.getOrCreate(e, () =>
      _makeEngineChannel(
        this.stream,
        () => this.blockApi.getGradientColorStops(this.id, e),
        (t) => {
          this.blockApi.setGradientColorStops(this.id, e, t);
        },
        { equals: oV.default }
      )
    );
  }
  getPropertyChannel(e) {
    if (!this.#x.has(e)) {
      const t = this.blockApi.getPropertyType(e);
      if ("Struct" === t)
        throw new Error("Struct properties are not supported");
      const n = this.id,
        s = this.blockApi;
      if (!s.isPropertyReadable(e))
        throw new Error(`Write-only property "${e}" is not supported`);
      if (!s.isPropertyWritable(e))
        throw new Error(`Read-only property "${e}" is not supported`);
      const [i, o] =
          "Bool" === t
            ? [s.getBool.bind(s, n, e), s.setBool.bind(s, n, e)]
            : "Double" === t
            ? [s.getDouble.bind(s, n, e), s.setDouble.bind(s, n, e)]
            : "Enum" === t
            ? [s.getEnum.bind(s, n, e), s.setEnum.bind(s, n, e)]
            : "Float" === t
            ? [s.getFloat.bind(s, n, e), s.setFloat.bind(s, n, e)]
            : "Int" === t
            ? [s.getInt.bind(s, n, e), s.setInt.bind(s, n, e)]
            : "String" === t
            ? [s.getString.bind(s, n, e), s.setString.bind(s, n, e)]
            : "Color" === t
            ? [s.getColorRGBA.bind(s, n, e), (t) => s.setColorRGBA(n, e, ...t)]
            : [aV, aV],
        r = _makeEngineChannel(this.stream, i, o);
      this.#x.set(e, r);
    }
    return this.#x.get(e);
  }
};
export var fV = class {
  engine;
  #b;
  entities = new uV();
  constructor(e) {
    (this.engine = e),
      (this.#b = e.event.subscribe([], (t) => {
        for (const n of t)
          "Destroyed" !== n.type ||
            e.block.isValid(n.block) ||
            this.entities.delete(n.block);
      }));
  }
  dispose() {
    this.#b?.(), (this.#b = undefined);
  }
};
export function hV(e, t, n, s) {
  return n.getOrCreate(e, () => {
    if (null == e || !t.block.isValid(e))
      throw new Error(`Tried to get an object for an invalid id '${e}'`);
    return s();
  });
}
export var mV = class extends fV {
  getBlock(e) {
    return hV(e, this.engine, this.entities, () => new pV(this.engine, e));
  }
};

export var xV = class {
  constructor(e) {
    const t = e.editor;
    this.editMode = _makeEngineChannel(
      (e) => t.onStateChanged(e),
      () => t.getEditMode(),
      (e) => t.setEditMode(e)
    );
  }
  editMode;
};

export var yV = class extends dV {
  enabled;
  constructor(e, t) {
    super(e, t),
      (this.enabled = _makeEngineChannel(
        this.stream,
        () => this.blockApi.isEffectEnabled(t),
        (e) => this.blockApi.setEffectEnabled(t, e)
      ));
  }
};
export var vV = class extends fV {
  getEffect(e) {
    return hV(e, this.engine, this.entities, () => new yV(this.engine, e));
  }
};

export var {
  map: _V,
  merge: EV,
  pipe: LV,
  startWith: PV,
  switchAll: AV,
} = _streams;
export var BV = class {
  constructor(e, t) {
    const n = e.scene,
      s = e.event,
      i = e.block,
      o = e.editor,
      r = LV(
        EV(n.onActiveChanged, o.onHistoryUpdated),
        PV(),
        _V(() => {
          const t = n.get();
          if (null == t) return;
          const s = _getBlockStream(t, e);
          return PV([])(s);
        }),
        AV
      );
    (this.mode = _makeEngineChannel(r, () =>
      null != n.get() ? n.getMode() : undefined
    )),
      (this.pages = _makeEngineChannel(
        (e) => s.subscribe([], e),
        () => n.getPages(),
        undefined,
        { equals: wV.default }
      )),
      (this.totalDuration = _makeEngineChannel(
        (e) => s.subscribe([], e),
        () => {
          const e = n.get();
          return null == e || "Video" !== n.getMode()
            ? 0
            : i.getTotalSceneDuration(e);
        }
      )),
      (this.playing = _makeEngineChannel(
        r,
        () => {
          const e = n.get();
          return null != e && i.isPlaying(e);
        },
        (e) => {
          const t = n.get();
          null != t && i.setPlaying(t, e);
        }
      )),
      (this.playbackTime = _makeEngineChannel(
        r,
        () => {
          const e = n.get();
          return null == e ? 0 : i.getPlaybackTime(e);
        },
        (e) => {
          const t = n.get();
          null != t && i.setPlaybackTime(t, e);
        }
      ));
    const a = () => {
      const e = n.get();
      return null != e ? t.getBlock(e) : undefined;
    };
    function l(e) {
      const t = [];
      let n = 0;
      for (const s of e) {
        const e = i.getDuration(s);
        t.push({ pageId: s, duration: e, start: n, end: (n += e) });
      }
      return t;
    }
    (this.block = { subscribe: LV(n.onActiveChanged, _V(a)), value: a }),
      (this.pageDurations = _makeEngineChannel(
        LV(
          this.pages.subscribe,
          _V((e) => PV()((t) => s.subscribe(e, () => t()))),
          AV,
          _V(() => l(this.pages.value()))
        ),
        () => l(this.pages.value()),
        undefined,
        { equals: wV.default }
      )),
      (this.layout = _makeEngineChannel(r, () => {
        const e = n.get();
        return null == e ? "Free" : i.getEnum(e, "scene/layout");
      })),
      (this.designUnit = _makeEngineChannel(
        r,
        () => n.getDesignUnit(),
        (e) => {
          n.setDesignUnit(e);
        }
      )),
      (this.pageFormatId = _makeEngineChannel(
        r,
        () => {
          const e = n.get();
          return null == e ? "" : i.getString(e, "scene/pageFormatId");
        },
        (e) => {
          const t = n.get();
          null != t && i.setString(t, "scene/pageFormatId", e);
        }
      )),
      (this.pageDimensions = _makeEngineChannel(
        r,
        () => {
          const e = n.get();
          if (null == e) return { width: 0, height: 0 };
          return {
            width: i.getFloat(e, "scene/pageDimensions/width"),
            height: i.getFloat(e, "scene/pageDimensions/height"),
          };
        },
        ({ width: e, height: t }) => {
          const s = n.get();
          null != s &&
            (i.setFloat(s, "scene/pageDimensions/width", e),
            i.setFloat(s, "scene/pageDimensions/height", t));
        }
      )),
      (this.aspectRatioLock = _makeEngineChannel(
        r,
        () => {
          const e = n.get();
          return null != e && i.getBool(e, "scene/aspectRatioLock");
        },
        (e) => {
          const t = n.get();
          null != t && i.setBool(t, "scene/aspectRatioLock", e);
        }
      )),
      (this.dpi = _makeEngineChannel(
        r,
        () => {
          const e = n.get();
          return null == e ? 1 : i.getFloat(e, "scene/dpi");
        },
        (e) => {
          const t = n.get();
          null != t && i.setFloat(t, "scene/dpi", e);
        }
      ));
    const c = _makeValueChannel(() => null);
    (c.value = e.reactor.decorateFunction(c.value, "overrideReady")),
      (this.ready = _makeEngineChannel(
        EV(r, c.subscribe),
        function () {
          const e = c.value();
          if (null !== e) return e;
          return null != n.get();
        },
        function (e) {
          c.update(e);
        }
      ));
  }
  ready;
  block;
  mode;
  totalDuration;
  pages;
  playing;
  playbackTime;
  pageDurations;
  layout;
  designUnit;
  pageFormatId;
  pageDimensions;
  aspectRatioLock;
  dpi;
};

export var OV = class {
  #y;
  allSelected;
  selectedPage;
  constructor(e, t) {
    this.#y = e.block;
    const n = _streams.makeSource((e) => this.#y.onSelectionChanged(e));
    (this.allSelected = _makeEngineChannel(
      n,
      () => this.#y.findAllSelected().map((e) => t.getBlock(e)),
      (e) => {
        this.deselectAll(), this.selectAll(e);
      },
      {
        equals: (e, t) =>
          e.length === t?.length && e.every((e, n) => e === t[n]),
      }
    )),
      (this.selectedPage = _makeEngineChannel(n, () =>
        this.allSelected.value().find((e) => "//ly.img.ubq/page" === e.type)
      ));
  }
  deselectAll = () => {
    for (const e of this.allSelected.value()) this.#y.setSelected(e.id, false);
  };
  selectAll = (e) => {
    for (const t of e) this.#y.setSelected(t, true);
  };
};
export var RV = function (e, t) {
  return {
    id: e,
    credits: t.asset.getCredits(e),
    license: t.asset.getLicense(e),
    findAssets: (n) => t.asset.findAssets(e, n),
    applyAsset: (n) => t.asset.apply(e, n),
    getGroups: () => t.asset.getGroups(e),
    removeAsset: (n) => t.asset.removeAssetFromSource(e, n),
    canManageAssets: t.asset.canManageAssets(e),
    addAsset: (n) => t.asset.addAssetToSource(e, n),
    getSupportedMimeTypes: () => t.asset.getSupportedMimeTypes(e),
  };
};
export function VV(e, t = "label") {
  return `assets.${e.replace(/\/\//i, "").replace(/\//g, ".")}.${t}`;
}
export var DV = async function (e) {
  if (e.type.startsWith("image")) {
    const t = await (function (e) {
      return new Promise((t, n) => {
        const s = new FileReader();
        s.readAsDataURL(e),
          (s.onload = (s) => {
            const i = new Image();
            if (
              s &&
              s.target &&
              s.target.result &&
              "string" == typeof s.target.result
            )
              if ("image/tiff" === e.type) {
                const e = s.target.result.replace(
                    "data:image/tiff;base64,",
                    ""
                  ),
                  n = atob(e),
                  i = n.length,
                  o = new Uint8Array(i);
                for (let e = 0; e < i; e++) o[e] = n.charCodeAt(e);
                const r = o.buffer,
                  { width: a, height: l } = (function (e) {
                    const t = new DataView(e),
                      n = 18761 === t.getUint16(0, false),
                      s = t.getUint32(4, n),
                      i = t.getUint16(s, n);
                    let o = 0,
                      r = 0,
                      a = false,
                      l = false;
                    for (let e = 0; e < i; e++) {
                      const i = s + 2 + 12 * e,
                        c = t.getUint16(i, n),
                        u = i + 8;
                      256 === c
                        ? a
                          ? console.error(
                              "TIFF image header includes multiple width tags. Possibly corrupted image."
                            )
                          : ((o = t.getUint16(u, n)), (a = true))
                        : 257 === c &&
                          (l
                            ? console.error(
                                "TIFF image header includes multiple height tags. Possibly corrupted image."
                              )
                            : ((r = t.getUint16(u, n)), (l = true)));
                    }
                    return { width: o, height: r };
                  })(r);
                t({ height: l, width: a });
              } else {
                const e = "image/svg+xml",
                  o = `data:${e};base64,`,
                  { result: r } = s.target;
                (i.src = r),
                  (i.onload = () => {
                    let { height: n, width: s } = i;
                    if (r.includes(o) && (n < 1 || s < 1)) {
                      const t = r.replace(o, ""),
                        i = new DOMParser().parseFromString(
                          atob(t),
                          e
                        ).documentElement;
                      (n = i.height.baseVal.value), (s = i.width.baseVal.value);
                    }
                    t({ height: n, width: s });
                  }),
                  (i.onerror = () => {
                    n(new Error("Could not measure image width/height"));
                  });
              }
            else n(new Error("Could not measure image width/height"));
          }),
          (s.onerror = n);
      });
    })(e);
    return { ...t, duration: 0 };
  }
  if (e.type.startsWith("video")) {
    const t = await (function (e) {
      return new Promise((t, n) => {
        try {
          const s = document.createElement("video");
          (s.src = URL.createObjectURL(e)),
            (s.onloadedmetadata = () => {
              t({
                height: s.videoHeight,
                width: s.videoWidth,
                duration: s.duration,
              });
            }),
            (s.onerror = () => {
              n(new Error("video measure failed"));
            });
        } catch {
          n(new Error("video measure failed"));
        }
      });
    })(e);
    return t;
  }
  if (e.type.startsWith("audio")) {
    const t = await (function (e) {
      return new Promise((t, n) => {
        try {
          const s = document.createElement("audio");
          (s.src = URL.createObjectURL(e)),
            (s.onloadedmetadata = () => {
              t(s.duration);
            }),
            (s.onerror = () => {
              n(new Error("audio measure failed"));
            });
        } catch {
          n(new Error("audio measure failed"));
        }
      });
    })(e);
    return { width: 0, height: 0, duration: t };
  }
  throw new Error(
    `Cannot measure assets width/height for the mime type ${e.type}`
  );
};
export var IV = () => {
  const e = DO().getUIEventEmitter();
  return (0, FV.useMemo)(() => (e ? e.emit : aV), [e]);
};
export var HV = (e, t) => {
  const n = (0, FV.useRef)(t);
  (0, FV.useEffect)(() => {
    n.current = t;
  }, [t]);
  const s = DO().getUIEventEmitter();
  (0, FV.useEffect)(() => {
    const t = () => n.current();
    return (
      s && e && s.on(e, t),
      () => {
        s && e && s.off(e, t);
      }
    );
  }, [s, e]);
};
export function NV(e, t) {
  const n = t.scene.getCurrentPage();
  if (null == n) return;
  const s = t.block.getChildren(n),
    i = s.reduce(
      (n, i) =>
        i !== e && "//ly.img.ubq/audio" === t.block.getType(i)
          ? Math.max(n, s.indexOf(i) + 1)
          : n,
      0
    );
  t.block.insertChild(n, e, i);
}
export function UV(e, t) {
  return e.block
    .getChildren(t)
    .find(
      (t) =>
        "//ly.img.ubq/track" === e.block.getType(t) &&
        e.block.isAlwaysOnBottom(t)
    );
}
export function zV(e, t) {
  const n = e.block.create("//ly.img.ubq/track");
  return e.block.appendChild(t, n), e.block.setAlwaysOnBottom(n, true), n;
}
export function $V(e, t) {
  let n = e.block.getParent(t);
  if (null != n) {
    for (; "//ly.img.ubq/track" !== e.block.getType(n); ) {
      const t = e.block.getParent(n);
      if (null == t) return;
      n = t;
    }
    return n;
  }
}
export function qV(e) {
  return (
    null == e ||
    !(e instanceof HTMLElement) ||
    "INPUT" === e.tagName ||
    "SELECT" === e.tagName ||
    "TEXTAREA" === e.tagName ||
    e.isContentEditable ||
    (document.getSelection() ?? "").toString().length > 0
  );
}
export var QV = class {
  engineFacade;
  data;
  perPageSourceElementPasteCounts = new Map();
  constructor(e) {
    this.engineFacade = e;
  }
  getPasteCount(e, t) {
    return (this.perPageSourceElementPasteCounts.get(e) ?? new Map()).get(t);
  }
  setPasteCount(e, t, n) {
    const s = this.perPageSourceElementPasteCounts.get(e) ?? new Map();
    s.set(t, n), this.perPageSourceElementPasteCounts.set(e, s);
  }
  clearPasteCount(e, t) {
    (this.perPageSourceElementPasteCounts.get(e) ?? new Map()).delete(t);
  }
  actionCopy() {
    const e = this.engineFacade.engine.block.findAllSelected(),
      t =
        this.engineFacade.cesdk?.feature.isEnabled("ly.img.duplicate", {
          engine: this.engineFacade.engine,
        }) ?? false;
    0 !== e.length &&
      t &&
      this.engineFacade.engine.block.saveToString(e).then((t) => {
        this.data = t;
        const n = this.engineFacade.engine.scene.getCurrentPage();
        null != n &&
          e.forEach((e) => {
            this.clearPasteCount(n, e);
          });
      });
  }
  actionPaste() {
    const e = this.data;
    e &&
      e.length > 0 &&
      this.engineFacade.legacyApi
        .execute("ubq/loadElements", { elementsContent: e, setHidden: true })
        .then((e) => {
          const t = new Map();
          if (
            (e.forEach((e) => {
              const n = this.engineFacade.engine.block.getType(e.id);
              n && t.set(e.id, n);
            }),
            e.length > 0)
          ) {
            const n = this.engineFacade
              .getPageManager()
              .getSelectedOrCurrentPage();
            this.engineFacade.engine.block
              .findAllSelected()
              .forEach((e) =>
                this.engineFacade.engine.block.setSelected(e, false)
              ),
              null != n &&
                e.forEach((e) => {
                  const s = e.sourceParent === n ? 1 : 0,
                    i = this.getPasteCount(n, e.sourceId) ?? s;
                  if ("//ly.img.ubq/page" === t.get(e.id))
                    this.engineFacade.engine.block.setVisible(e.id, true),
                      this.engineFacade.addPage(e.id);
                  else if ("//ly.img.ubq/audio" === t.get(e.id))
                    NV(e.id, this.engineFacade.engine),
                      this.engineFacade.engine.block.select(e.id);
                  else {
                    this.setPasteCount(n, e.sourceId, i + 1),
                      this.engineFacade.addOffsetToDesignElement(e.id, i),
                      this.engineFacade.engine.block.appendChild(n, e.id),
                      this.engineFacade.engine.block.setSelected(e.id, true),
                      this.engineFacade.engine.block.setVisible(e.id, true);
                    this.engineFacade
                      .getUIEventEmitter()
                      .emit("action.block.paste");
                  }
                });
          }
        });
  }
  getActions() {
    return {
      copy: () => {
        this.actionCopy();
      },
      paste: () => {
        this.actionPaste();
      },
    };
  }
  getHandlers() {
    return {
      copy: ({ target: e }) => {
        qV(e) || this.actionCopy();
      },
      paste: ({ target: e }) => {
        qV(e) || this.actionPaste();
      },
    };
  }
};
export function GV(e) {
  const t = Object.entries(e).find(([, e]) => e.default ?? false);
  return t ? { id: t[0], preset: t[1] } : undefined;
}

export var KV = class {
  engineFacade;
  engineStore;
  bleedMargin;
  bleedMarginEnabled;
  clipContent;
  _singlePageMode = false;
  get pages() {
    return this.engineFacade.engine.scene.getPages();
  }
  constructor(e, t, n) {
    (this.engineFacade = e),
      (this.engineStore = t),
      (this.bleedMargin = {
        left: n.bleedMargin,
        top: n.bleedMargin,
        right: n.bleedMargin,
        bottom: n.bleedMargin,
      }),
      (this.bleedMarginEnabled = n.bleedMarginEnabled),
      (this.clipContent = true),
      (this._singlePageMode = n.singlePageMode || false);
    const { block: s, event: i } = e.engine,
      o = (e) => {
        const t =
          e.length > 0
            ? {
                top: s.getFloat(e[0], "page/margin/top"),
                bottom: s.getFloat(e[0], "page/margin/bottom"),
                left: s.getFloat(e[0], "page/margin/left"),
                right: s.getFloat(e[0], "page/margin/right"),
              }
            : { top: 0, bottom: 0, left: 0, right: 0 };
        return (this.bleedMargin = t), t;
      },
      r = (e, t) => {
        (this.bleedMargin = t),
          e.forEach((e) => {
            s.setFloat(e, "page/margin/top", t.top),
              s.setFloat(e, "page/margin/bottom", t.bottom),
              s.setFloat(e, "page/margin/left", t.left),
              s.setFloat(e, "page/margin/right", t.right);
          });
      };
    this.channels = {
      bleedMargin: _makeEngineChannel(
        (e) => i.subscribe([], e),
        () => o(this.pages),
        (e) => r(this.pages, e),
        { equals: ZV.default }
      ),
      bleedMarginEnabled: _makeEngineChannel(
        (e) => i.subscribe([], e),
        () => (
          this.updateBleedMarginFromEngine(), this.getBleedMarginEnabled()
        ),
        (e) => this.setBleedMarginEnabled(e)
      ),
    };
  }
  add(e) {
    this.setPageName(e, ""),
      this.updatePageTitleTemplate(e),
      this.applyBleedMargin(e),
      this.applyBleedMarginEnabled(e),
      this.applyClipContent(e),
      this.setSinglePageVisibility(e);
  }
  getPage(e) {
    return this.getPages()[e];
  }
  getSelectedPage() {
    return this.engineFacade.channels.selection.selectedPage.value()?.id;
  }
  getSelectedOrCurrentPage() {
    const e = this.getSelectedPage(),
      t = this.engineFacade.engine.scene.getCurrentPage();
    return e ?? t ?? undefined;
  }
  getNextPage(e) {
    const t = this.getNextPageIndex(e);
    return this.getPages()[t];
  }
  getPreviousPage(e) {
    const t = this.getPreviousPageIndex(e);
    return this.getPages()[t];
  }
  getPageIndex(e) {
    return this.getPages().findIndex((t) => t === e);
  }
  getNextPageIndex(e) {
    return (this.getPageIndex(e) + 1) % this.getPages().length;
  }
  getPreviousPageIndex(e) {
    let t = this.getPageIndex(e) - 1;
    return t < 0 && (t = this.getPages().length - 1), t;
  }
  updatePageTitles() {
    this.pages.forEach((e) => {
      this.updatePageTitleTemplate(e);
    });
  }
  getBleedMargin() {
    return this.bleedMargin;
  }
  updateBleedMarginFromEngine() {
    if (0 === this.pages.length) return;
    const e = this.pages[0];
    (this.bleedMargin = {
      top: this.engineFacade.engine.block.getFloat(e, "page/margin/top"),
      bottom: this.engineFacade.engine.block.getFloat(e, "page/margin/bottom"),
      left: this.engineFacade.engine.block.getFloat(e, "page/margin/left"),
      right: this.engineFacade.engine.block.getFloat(e, "page/margin/right"),
    }),
      (this.bleedMarginEnabled = this.engineFacade.engine.block.getBool(
        e,
        "page/marginEnabled"
      ));
  }
  applyBleedMargin(e) {
    this.engineFacade.engine.block.setFloat(
      e,
      "page/margin/top",
      this.bleedMargin.top
    ),
      this.engineFacade.engine.block.setFloat(
        e,
        "page/margin/bottom",
        this.bleedMargin.bottom
      ),
      this.engineFacade.engine.block.setFloat(
        e,
        "page/margin/left",
        this.bleedMargin.left
      ),
      this.engineFacade.engine.block.setFloat(
        e,
        "page/margin/right",
        this.bleedMargin.right
      );
  }
  applyBleedMarginEnabled(e) {
    this.engineFacade.engine.block.setBool(
      e,
      "page/marginEnabled",
      this.bleedMarginEnabled
    );
  }
  getBleedMarginEnabled() {
    return this.bleedMarginEnabled;
  }
  setBleedMarginEnabled(e) {
    (this.bleedMarginEnabled = e),
      this.getPages().forEach((e) => {
        this.applyBleedMarginEnabled(e);
      });
  }
  getClipContent() {
    return this.clipContent;
  }
  setClipContent(e) {
    (this.clipContent = e),
      this.getPages().forEach((e) => {
        this.applyClipContent(e);
      });
  }
  applyClipContent(e) {
    this.engineFacade.engine.block.setClipped(e, this.clipContent);
  }
  updateClipContentFromEngine() {
    const e = this.getSelectedOrCurrentPage();
    null != e &&
      (this.clipContent = this.engineFacade.engine.block.isClipped(e));
  }
  setPageName(e, t) {
    this.engineFacade.engine.block.setName(e, t);
  }
  updatePageTitleTemplate(e) {
    const t = this.engineFacade.i18n;
    this.engineFacade.engine.block.setString(
      e,
      "page/titleTemplate",
      t.t("input.page.titleTemplate", {
        interpolation: { skipOnVariables: true },
        number: "{{ubq.page_index}}",
        separator: "{{ubq.separator}}",
        name: "{{ubq.name}}",
      })
    );
  }
  hasNextPage() {
    const e = this.getSelectedOrCurrentPage();
    return null != e && 0 !== this.getNextPageIndex(e);
  }
  hasPreviousPage() {
    const e = this.getSelectedOrCurrentPage();
    return (
      null != e && this.getPreviousPageIndex(e) !== this.getPages().length - 1
    );
  }
  setSinglePageVisibility(e) {
    this.singlePageMode &&
      this.getPages().forEach((t) => {
        this.engineFacade.engine.block.setVisible(t, e === t);
      });
  }
  async focusPage(e, t = false) {
    this.engineFacade.scrollToPage(e);
    const n = this.engineFacade.engine.scene.get(),
      s = null !== n && this.engineFacade.engine.scene.isZoomAutoFitEnabled(n);
    (t || s) && this.engineFacade.enableZoomAutoFit(e);
  }
  selectNextPage() {
    const e = this.getSelectedOrCurrentPage();
    if (null != e) {
      const t = this.getNextPageIndex(e);
      if (t !== this.getPageIndex(e)) {
        const e = this.getPage(t);
        this.setSinglePageVisibility(e), this.focusPage(e);
      }
    }
  }
  selectPreviousPage() {
    const e = this.getSelectedOrCurrentPage();
    if (null != e) {
      const t = this.getPreviousPageIndex(e);
      if (t !== this.getPageIndex(e)) {
        const e = this.getPage(t);
        this.setSinglePageVisibility(e), this.focusPage(e);
      }
    }
  }
  get singlePageMode() {
    return this._singlePageMode;
  }
  getPages() {
    return this.pages;
  }
  channels;
};
export var YV = KV;

export var JV = class {
  engineFacade;
  eventEmitter;
  history;
  previewHistory;
  canUndo;
  canRedo;
  constructor(e, t) {
    (this.engineFacade = e),
      (this.eventEmitter = t),
      (this.history = -1),
      (this.previewHistory = -1),
      this.eventEmitter.addGlobalListener(this.listener),
      (this.canUndo = _makeEngineChannel(e.engine.editor.onHistoryUpdated, () =>
        e.engine.editor.canUndo()
      )),
      (this.canRedo = _makeEngineChannel(e.engine.editor.onHistoryUpdated, () =>
        e.engine.editor.canRedo()
      ));
  }
  listener = (e) => {
    e.forEach(({ event: e, options: t }) => {
      ((e) => {
        switch (e) {
          case "element.register":
          case "element.group.change":
            return false;
          default:
            return true;
        }
      })(e) && this.addUndoStep(e, t?.resyncCameraFromSnapshot);
    });
  };
  addUndoStep = (e, t = false) => {
    this.engineFacade.legacyApi.execute("ubq/editor/history/createSnapshot", [
      e,
      t,
    ]);
  };
  undo = () => {
    this.engineFacade.engine.editor.undo(),
      this.EmitOnceOnNextHistoryUpdate("undo");
  };
  redo = () => {
    this.engineFacade.engine.editor.redo(),
      this.EmitOnceOnNextHistoryUpdate("redo");
  };
  EmitOnceOnNextHistoryUpdate(e) {
    const t = this.engineFacade.engine.editor.onHistoryUpdated(() => {
      this.engineFacade.getHistoryStateEmitter().emit(e), t();
    });
  }
  activatePreviewUndoStack = () => {
    (this.history = this.engineFacade.engine.editor.getActiveHistory()),
      (this.previewHistory = this.engineFacade.engine.editor.createHistory()),
      this.engineFacade.engine.editor.setActiveHistory(this.previewHistory),
      this.addUndoStep("preview");
  };
  deactivatePreviewUndoStack = () => {
    -1 !== this.previewHistory &&
      -1 !== this.history &&
      (this.engineFacade.engine.editor.setActiveHistory(this.history),
      this.engineFacade.engine.editor.destroyHistory(this.previewHistory),
      (this.previewHistory = -1));
  };
  reset() {
    const e = this.engineFacade.engine.editor.getActiveHistory(),
      t = this.engineFacade.engine.editor.createHistory();
    this.engineFacade.engine.editor.setActiveHistory(t),
      this.engineFacade.engine.editor.destroyHistory(e);
  }
  dispose() {
    -1 !== this.previewHistory && this.deactivatePreviewUndoStack(),
      this.eventEmitter.removeGlobalListener(this.listener),
      (this.engineFacade = null),
      (this.eventEmitter = null);
  }
};
export var eD = class {
  engineStore;
  configurationStore;
  get legacyApi() {
    return this.engine._legacyApi;
  }
  engine;
  cesdk;
  settings;
  i18n;
  channels;
  get root() {
    const e = this.engine.scene.get();
    if (null == e) throw new Error("Invalid null scene detected");
    return e;
  }
  get camera() {
    const [e] = this.engine.block.findByType("camera");
    return e;
  }
  pageManager;
  undoManager;
  uiEventEmitter;
  designElementLifecycleEmitter;
  historyStateEmitter;
  postUpdateEmitters;
  errorCallbackListeners = [];
  _configuration;
  copyPasteManager;
  log = (e, t) => {
    "Error" === t ? console.error(e) : console.log(e);
  };
  #v = [];
  constructor(e, t) {
    this.#v.push(() => {
      this.log = (e) => {
        console.log(e);
      };
    }),
      (this.log = t.configuration.logger),
      (this.engine = e),
      this.#v.push(
        this.engine.scene.onActiveChanged(() => {
          this.refreshAfterSceneChange();
        })
      );
    const n = new mV(this.engine);
    (this.channels = {
      block: n,
      effect: new vV(this.engine),
      camera: this.engine._camera,
      selection: new OV(this.engine, n),
      scene: new BV(this.engine, n),
      editor: new xV(this.engine),
      assetSourceIdsChannel: new iV(this.engine),
    }),
      this.#v.push(() => {
        this.channels.block.dispose(),
          this.channels.effect.dispose(),
          (this.channels = null);
      }),
      (this.i18n = t.i18n),
      (this._configuration = t.configuration),
      (this.configurationStore =
        t.configurationStore || new $R(this.configuration)),
      (this.settings = new $O(
        this.engine.editor,
        this.channels.scene,
        this.configuration
      )),
      (this.engineStore = t.engineStore || new qR()),
      this.#v.push(() => {
        (this._configuration = null),
          (this.configurationStore = null),
          (this.engineStore = null);
      }),
      this.#v.push(
        AB(() => {
          this.engine.editor.setSettingBool(
            "doubleClickToCropEnabled",
            this.configurationStore.blocks["//ly.img.ubq/graphic"].cropEnabled
          );
        })
      ),
      this.#v.push(
        AB(() => {
          this.i18n.changeLanguage(this.configurationStore.language);
        })
      ),
      this.#v.push(
        AB(() => {
          kO("background", this.configurationStore.customBackgroundColor),
            kO("active", this.configurationStore.customActiveColor),
            kO("accent", this.configurationStore.customAccentColor);
          const {
            r: e,
            g: t,
            b: n,
            a: s,
          } = bh("--ubq-foreground-default", { r: 0, g: 0, b: 0, a: 1 });
          this.engine.editor.setSettingColorRGBA(
            "page/title/color",
            e,
            t,
            n,
            s
          );
        })
      );
    const s = () => this.pageManager.updatePageTitles();
    this.i18n.on("languageChanged", s),
      this.initializeAssetRegistry(),
      this.initializePageManager(this.channels.scene.mode.value() ?? "Design"),
      this.#v.push(() => {
        this.i18n.off("languageChanged", s);
      }),
      this.initializeEventEmitter(),
      (this.undoManager = new JV(this, this.uiEventEmitter)),
      this.#v.push(() => {
        this.undoManager.dispose(), (this.undoManager = null);
      }),
      (this.engine._camera.clampCamera = true);
    {
      const e = () => {
        const e = this.engine.scene.get();
        if (null != e && this.engine.block.isValid(e)) {
          const { paddingX: t, paddingY: n } = this.getViewportPadding();
          if (null != e && this.engine.scene.isZoomAutoFitEnabled(e)) {
            const e = this.engine.scene.getCurrentPage();
            null != e &&
              this.engine.scene.enableZoomAutoFit(e, "Both", t, n, t, n);
          }
          this.channels.camera.viewportPadding.update({ x: t, y: n });
        }
      };
      this.#v.push(this.engine.addPreUpdateCallback(e));
    }
    {
      const e = () => {
        this.postUpdateEmitters &&
          this.postUpdateEmitters.forEach((e) => e.flush());
      };
      this.#v.push(this.engine.addPostUpdateCallback(e));
    }
    this.#v.push(
      this.engine.block.onSelectionChanged(() => {
        const e = this.engine.block.findAllSelected()[0];
        e && this.updateActiveGroup(e);
      })
    ),
      this.#v.push(
        this.engine.event.subscribe([], (e) => {
          e.some((e) => "Destroyed" === e.type) &&
            this.pageManager.updatePageTitles();
        })
      ),
      this.#v.push(
        this.historyStateEmitter.addGlobalListener((e) => {
          if (e.some((e) => "undo" === e.event || "redo" === e.event)) {
            const [e] = this.engine.block.findAllSelected();
            if (!e) return;
            const t = this.getParentPageOfDesignElement(e);
            if (null == t) return;
            this.pageManager.focusPage(t);
          }
        })
      ),
      (this.copyPasteManager = new QV(this));
  }
  get copyPasteHandlers() {
    return this.copyPasteManager.getHandlers();
  }
  get copyPasteActions() {
    return this.copyPasteManager.getActions();
  }
  dispose() {
    this.#v.reverse().forEach((e) => e()),
      (this.#v.length = 0),
      this.log("Engine disposed", "Info");
  }
  delaySceneReady() {
    this.channels.scene.ready.update(false);
    return async () => {
      let e,
        t = false;
      const n = () => {
        (t = true), clearTimeout(e);
      };
      this.#v.push(n),
        await new Promise((n) => {
          e = setTimeout(() => {
            t || n();
          }, 32);
        }),
        (0, FO.default)(this.#v, n),
        this.channels.scene.ready.update(null);
    };
  }
  async initializeEmptyScene(e = "Design", t) {
    const n = this.engine.block,
      s = this.engine.scene,
      i = this.delaySceneReady();
    let o;
    if (!t) {
      const n = GV(
        this.settings.customPageFormats.value() ||
          ("Design" === e ? CanvasSizeConfig : StandardResolutions)
      );
      if (!n) throw new Error("No default page format found");
      ({ id: o, preset: t } = n);
    }
    const r = "Video" === e ? s.createVideo() : s.create("VerticalStack");
    if (
      (s.setDesignUnit(t.unit),
      n.setFloat(r, "scene/dpi", 300),
      n.setFloat(r, "scene/pixelScaleFactor", 1),
      null != o && n.setString(r, "scene/pageFormatId", o),
      n.setFloat(r, "scene/pageDimensions/width", t.width),
      n.setFloat(r, "scene/pageDimensions/height", t.height),
      n.setBool(r, "scene/aspectRatioLock", true),
      "Design" === e)
    ) {
      const e = n.findByType("stack")[0];
      n.setFloat(e, "stack/spacing", 35),
        n.setBool(e, "stack/spacingInScreenspace", true),
        this.engine.editor.setSettingBool("page/title/show", true),
        this.engine.editor.setSettingBool("page/title/showOnSinglePage", false),
        this.engine.editor.setSettingBool(
          "page/title/showPageTitleTemplate",
          true
        ),
        this.engine.editor.setSettingBool("page/title/appendPageName", true),
        this.engine.editor.setSettingString("page/title/separator", "");
    } else
      "Video" === e &&
        this.engine.editor.setSettingBool("page/title/show", false);
    const a = await this.addPage();
    return (
      "Video" === e &&
        this.engine.block.setColor(
          this.engine.block.getFill(a),
          "fill/color/value",
          { r: 0, g: 0, b: 0, a: 1 }
        ),
      this.undoManager.reset(),
      await i(),
      this.engineStore.requestFocus(
        this.engine.block.findAllSelected()[0] ?? -1
      ),
      r
    );
  }
  async createSceneFromImage(e) {
    const t = this.delaySceneReady(),
      n = await this.engine.scene.createFromImage(
        e,
        300,
        1,
        "VerticalStack",
        35,
        true
      ),
      [s] = this.engine.block.findByType("page");
    if (null == s) throw new Error("No page found in scene");
    return await this.pageManager.add(s), await t(), n;
  }
  findTopMostPage() {
    return this.pageManager.getPages()[0];
  }
  async setupInitialScene() {
    const e = await this.initializeEmptyScene();
    return (
      this.undoManager.reset(),
      this.uiEventEmitter.emit("action.scene.new"),
      this.engineStore.requestFocus(
        this.engine.block.findAllSelected()[0] ?? -1
      ),
      e
    );
  }
  getViewportPadding(e, t) {
    const n =
        e ?? this.engine.block.getFloat(this.camera, "camera/resolution/width"),
      s =
        t ??
        this.engine.block.getFloat(this.camera, "camera/resolution/height"),
      i = "Presenter" === this.settings.roles.effectiveRole.value(),
      o = i ? 0.025 : 0.05,
      r = i ? 0.05 : 0.1;
    return {
      paddingX: (n / window.devicePixelRatio) * o,
      paddingY: (s / window.devicePixelRatio) * r,
    };
  }
  async focusBlock(e) {
    const { paddingX: t, paddingY: n } = this.getViewportPadding();
    await this.engine.scene.zoomToBlock(e, t, n, t, n);
  }
  enableZoomAutoFit(e) {
    const { paddingX: t, paddingY: n } = this.getViewportPadding();
    this.engine.scene.enableZoomAutoFit(e, "Both", t, n, t, n);
  }
  setPixelRatio(e) {
    this.engine.block.setFloat(this.camera, "camera/pixelRatio", e);
  }
  async refreshAfterSceneChange() {
    const e = this.findTopMostPage();
    e &&
      (this.pageManager.setSinglePageVisibility(e),
      await this.pageManager.focusPage(e, true),
      this.pageManager.updatePageTitles(),
      this.pageManager.updateBleedMarginFromEngine(),
      this.pageManager.updateClipContentFromEngine());
  }
  async export(e) {
    const t = [];
    let n;
    null != e.block
      ? (t.push(e.block), (n = [e.block]))
      : e.pages && e.pages.length > 0
      ? (t.push(...e.pages), (n = e.pages))
      : (t.push(...this.pageManager.getPages()), (n = t.map((e, t) => t)));
    const s = { ...e, pages: n };
    return {
      blobs: await Promise.all(
        t.map((e) =>
          this.engine.block.export(e, s.mimeType, {
            jpegQuality: s.jpegQuality,
            webpQuality: s.webpQuality,
            pngCompressionLevel: s.pngCompressionLevel,
            targetWidth: s.cover?.width,
            targetHeight: s.cover?.height,
            exportPdfWithHighCompatibility: s.exportPdfWithHighCompatibility,
            exportPdfWithUnderlayer: s.exportPdfWithUnderlayer,
            underlayerSpotColorName: s.underlayerSpotColorName,
            underlayerOffset: s.underlayerOffset,
          })
        )
      ),
      options: s,
    };
  }
  disableAllSoloPlayback() {
    const [e] = this.engine.block.findAllSelected();
    if (null == e) return;
    let t;
    if (
      this.engine.block.supportsPlaybackControl(e) &&
      this.engine.block.isSoloPlaybackEnabled(e)
    )
      t = e;
    else if (this.engine.block.supportsFill(e)) {
      const n = this.engine.block.getFill(e);
      null != n &&
        this.engine.block.isValid(n) &&
        this.engine.block.supportsPlaybackControl(n) &&
        this.engine.block.isSoloPlaybackEnabled(n) &&
        (t = n);
    }
    null != t &&
      (this.engine.block.isPlaying(t) && this.engine.block.setPlaying(t, false),
      this.engine.block.setSoloPlaybackEnabled(t, false),
      "Trim" === this.engine.editor.getEditMode() &&
        this.engine.editor.setEditMode("Transform"));
  }
  initializeAssetRegistry() {
    const e = this.i18n.options?.supportedLngs;
    (async function (e, t, n) {
      function s(t) {
        return Object.fromEntries(n.map((n) => [n, e(t, n)]));
      }
      function i(e) {
        return Object.fromEntries(n.map((n) => [n, t(e, n)]));
      }
      const o = {
        name: "Roboto",
        fonts: [
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Black.ttf",
            subFamily: "Black",
            weight: "heavy",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-BlackItalic.ttf",
            subFamily: "Black Italic",
            weight: "heavy",
            style: "italic",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Bold.ttf",
            subFamily: "Bold",
            weight: "bold",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-BoldItalic.ttf",
            subFamily: "Bold Italic",
            weight: "bold",
            style: "italic",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Italic.ttf",
            subFamily: "Italic",
            style: "italic",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Light.ttf",
            subFamily: "Light",
            weight: "light",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-LightItalic.ttf",
            subFamily: "Light Italic",
            weight: "light",
            style: "italic",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Medium.ttf",
            subFamily: "Medium",
            weight: "medium",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-MediumItalic.ttf",
            subFamily: "Medium Italic",
            weight: "medium",
            style: "italic",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Regular.ttf",
            subFamily: "Regular",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Thin.ttf",
            subFamily: "Thin",
            weight: "thin",
          },
          {
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-ThinItalic.ttf",
            subFamily: "Thin Italic",
            weight: "thin",
            style: "italic",
          },
        ],
      };
      return [
        {
          id: "title",
          label: s("title"),
          tags: i("title"),
          payload: { typeface: o },
          meta: {
            fontScale: 2,
            blockType: "//ly.img.ubq/text",
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Bold.ttf",
          },
        },
        {
          id: "headline",
          label: s("headline"),
          tags: i("headline"),
          payload: { typeface: o },
          meta: {
            fontScale: 1.4,
            blockType: "//ly.img.ubq/text",
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Medium.ttf",
          },
        },
        {
          id: "paragraph",
          label: s("paragraph"),
          tags: i("paragraph"),
          payload: { typeface: o },
          meta: {
            fontScale: 1,
            blockType: "//ly.img.ubq/text",
            uri: "https://cdn.img.ly/assets/v3/ly.img.typeface/fonts/Roboto/Roboto-Regular.ttf",
          },
        },
      ];
    })(
      (e, t) =>
        (function (e, t, n, s) {
          const i = s ? e.getFixedT(s) : e.t;
          return "ly.img.vectorpath" === t
            ? i(VV(n, "label"))
            : "ly.img.text" === t
            ? "title" === n
              ? i("libraries.ly.img.text.title.label")
              : "headline" === n
              ? i("libraries.ly.img.text.headline.label")
              : "paragraph" === n
              ? i("libraries.ly.img.text.paragraph.label")
              : n
            : i(VV(n, "label"), { defaultValue: n });
        })(this.i18n, "ly.img.text", e, t),
      (e, t) =>
        (function (e, t, n, s) {
          const i = s ? e.getFixedT(s) : e.t;
          return "ly.img.vectorpath" === t || "ly.img.text" === t
            ? []
            : i(VV(n, "tags"), { defaultValue: n, returnObjects: true });
        })(this.i18n, "ly.img.text", e, t),
      e ? e.filter((e) => "cimode" !== e) : ["en"]
    ).then((e) => {
      e.forEach((e) => {
        this.engine.asset.addAssetToSource("ly.img.text", e);
      }),
        this.engine.asset.assetSourceContentsChanged("ly.img.text");
    });
  }
  initializePageManager(e) {
    const t = "Design" === e ? CanvasSizeConfig : StandardResolutions,
      n = GV(t)?.preset;
    if (!n) throw new Error("No default page format preset found");
    const s = GO(BleedMarginConfig, n.unit).defaultBleedMargin,
      i = !!this.configuration.featureFlags?.singlePageMode;
    (this.pageManager = new YV(this, this.engineStore, {
      bleedMargin: s,
      bleedMarginEnabled: false,
      singlePageMode: i,
    })),
      this.#v.push(() => {
        this.pageManager = null;
      });
  }
  initializeEventEmitter() {
    (this.postUpdateEmitters = []),
      (this.designElementLifecycleEmitter = new EventEmitter("lifecycle")),
      this.designElementLifecycleEmitter.enableBatching({
        conflateBatching: true,
      }),
      this.postUpdateEmitters.push(this.designElementLifecycleEmitter),
      (this.uiEventEmitter = new EventEmitter("ui")),
      (this.historyStateEmitter = new EventEmitter("history-state")),
      this.#v.push(() => {
        this.historyStateEmitter.removeAllListeners(),
          (this.historyStateEmitter = null),
          this.uiEventEmitter.removeAllListeners(),
          (this.uiEventEmitter = null),
          this.designElementLifecycleEmitter.removeAllListeners(),
          (this.designElementLifecycleEmitter = null),
          this.postUpdateEmitters.forEach((e) => {
            e.removeAllListeners();
          }),
          (this.postUpdateEmitters.length = 0);
      }),
      this.legacyApi.setErrorCallback((e) => {
        this.log(e, "Error"),
          this.errorCallbackListeners.forEach((t) => {
            t(e);
          }),
          this.dispose();
      }, true),
      this.#v.push(() => {
        this.legacyApi.setErrorCallback(() => {}, false);
      }),
      this.#v.push(
        this.legacyApi.historyStream(() => {
          this.historyStateEmitter.emit("");
        })
      ),
      this.#v.push(
        this.legacyApi.designElementLifecycleStream("DesignBlockAddedEvent")(
          (e) => {
            this.designElementLifecycleEmitter.emit(e.entity, {
              lifecycleEvent: "DesignBlockAddedEvent",
            });
          }
        )
      ),
      this.#v.push(
        this.legacyApi.designElementLifecycleStream("DesignBlockRemovedEvent")(
          (e) => {
            this.designElementLifecycleEmitter.emit(e.entity, {
              lifecycleEvent: "DesignBlockRemovedEvent",
            });
          }
        )
      ),
      this.#v.push(
        this.legacyApi.designElementLifecycleStream("DesignBlockUpdatedEvent")(
          (e) => {
            this.designElementLifecycleEmitter.emit(e.entity, {
              lifecycleEvent: "DesignBlockUpdatedEvent",
              componentType: "" === e.typeName ? undefined : e.typeName,
            });
          }
        )
      );
  }
  updateActiveGroup(e) {
    if (e === this.getScene()) return;
    const t = this.engine.block.getParent(e);
    null !== t && "//ly.img.ubq/group" === this.engine.block.getType(t)
      ? (undefined !== this.engineStore.activeGroup &&
          this.engineStore.activeGroup === t) ||
        LB(() => {
          (this.engineStore.activeGroup = t),
            this.uiEventEmitter.emit("element.group.change"),
            this.engineStore.requestFocus(e);
        })
      : undefined !== this.engineStore.activeGroup &&
        LB(() => {
          (this.engineStore.activeGroup = undefined),
            this.uiEventEmitter.emit("element.group.change");
        });
  }
  addNotificationHandler(e) {
    const t = this.legacyApi.notificationStream(e);
    let n = false;
    const s = () => {
      n || ((n = true), t());
    };
    return this.#v.push(s), s;
  }
  scrollToPage(e) {
    this.engine.block.getFrameWidth(e);
    const t = this.getDesignElementFrameOrigin(e),
      n = this.getDesignElementFrameDimensions(e),
      s = {
        x: (t.x ?? 0) + 0.5 * (n.x ?? 0),
        y: (t.y ?? 0) + 0.5 * (n.y ?? 0),
      },
      i = this.getDesignElementFrameOrigin(this.camera);
    if (!i) return;
    const o = $d([0, 100], [i.x, s.x]),
      r = $d([0, 100], [i.y, s.y]),
      a = pp(0, 100, {
        onUpdate: (e) => {
          this.engine.block.setPositionX(this.camera, o(e)),
            this.engine.block.setPositionY(this.camera, r(e));
        },
        onComplete: () => {
          const e = this.#v.indexOf(a);
          e > -1 && this.#v.splice(e, 1);
        },
        duration: 0.3,
        ease: "easeOut",
      }).stop;
    this.#v.push(a);
  }
  uploadAsset(e, t, n, s) {
    return new Promise((i, o) => {
      if (n) {
        const r = async (t) => {
            const n = s?.addToAssetSource?.sourceId;
            if (n) {
              if (!t.groups) {
                const e =
                  s?.addToAssetSource?.group ??
                  (await this.engine.asset.getGroups(n))[0];
                t.groups = e ? [e] : undefined;
              }
              const i = this.getAssetSource(n);
              if (
                (undefined === t.meta?.mimeType &&
                  (t.meta = { ...t.meta, mimeType: e.type }),
                s?.skipRegister ||
                  (await i.addAsset(t),
                  this.engine.asset.assetSourceContentsChanged(i.id),
                  this.uiEventEmitter.emit("element.register")),
                s?.applyAssetAfterUpload)
              ) {
                const e = {
                  ...t,
                  context: { sourceId: n },
                  label: t.id,
                  tags: undefined,
                  active: false,
                };
                if ("replace" === s?.applyAssetTarget) {
                  const [t] = this.engine.block.findAllSelected(),
                    n = this.engine.block.getType(t),
                    s = this.engine.block.supportsFill(t)
                      ? this.engine.block.getFill(t)
                      : undefined,
                    o =
                      undefined !== s && this.engine.block.isValid(s)
                        ? this.engine.block.getType(s)
                        : undefined;
                  switch (true) {
                    case "//ly.img.ubq/fill/video" === o:
                      this.uiEventEmitter.emit("action.video.replace");
                      break;
                    case "//ly.img.ubq/audio" === n:
                      this.uiEventEmitter.emit("action.audio.replace");
                      break;
                    case "//ly.img.ubq/fill/image" === o:
                      this.uiEventEmitter.emit("action.image.replace");
                  }
                  await this.engine.asset.applyToBlock(i.id, e, t);
                } else await i.applyAsset(e);
              }
            }
          },
          a = (e) => {
            console.error(e), o(e.toString());
          };
        n(e, t, s?.addToAssetSource)
          .then((t) => {
            if (e.type.startsWith("image/"))
              (t.meta?.width && t.meta?.height) || s?.size
                ? ((t = {
                    ...t,
                    meta: {
                      ...t.meta,
                      width: t.meta?.width ?? s?.size?.width,
                      height: t.meta?.height ?? s?.size?.height,
                    },
                  }),
                  r(t).then(() => i(t)))
                : DV(e)
                    .then((e) => {
                      (t = {
                        ...t,
                        meta: { ...t.meta, width: e.width, height: e.height },
                      }),
                        r(t).then(() => i(t));
                    })
                    .catch(a);
            else if (e.type.startsWith("video/")) {
              const n = {
                  width: t.meta?.width || s?.size?.width,
                  height: t.meta?.height || s?.size?.height,
                },
                o = t.meta?.duration || s?.duration?.toString();
              n && o
                ? ((t = {
                    ...t,
                    meta: {
                      ...t.meta,
                      duration: o,
                      width: n.width,
                      height: n.height,
                    },
                  }),
                  r(t)
                    .then(() => i(t))
                    .catch(a))
                : DV(e)
                    .then((e) => {
                      (t = {
                        ...t,
                        meta: {
                          ...t.meta,
                          width: n?.width || e.width,
                          height: n?.height || e.height,
                          duration: (o || e.duration).toString(),
                        },
                      }),
                        r(t)
                          .then(() => i(t))
                          .catch(a);
                    })
                    .catch(a);
            } else if (e.type.startsWith("audio/")) {
              const n = t.meta?.duration || s?.duration?.toString();
              n
                ? ((t = { ...t, meta: { ...t.meta, duration: n } }),
                  r(t)
                    .then(() => i(t))
                    .catch(a))
                : DV(e)
                    .then((e) => {
                      (t = {
                        ...t,
                        meta: { ...t.meta, duration: e.duration.toString() },
                      }),
                        r(t)
                          .then(() => i(t))
                          .catch(a);
                    })
                    .catch(a);
            } else
              r(t)
                .then(() => i(t))
                .catch(a);
          })
          .catch(a);
      } else o(new Error("No upload handler configured"));
    });
  }
  async addPage(e) {
    let t = e;
    if (!t) {
      const e = this.pageManager.getBleedMargin(),
        n = this.pageManager.getBleedMarginEnabled();
      t = this.engine.block.create("page");
      const s = this.engine.block.getFloat(
          this.root,
          "scene/pageDimensions/width"
        ),
        i = this.engine.block.getFloat(
          this.root,
          "scene/pageDimensions/height"
        );
      this.engine.block.setWidth(t, s),
        this.engine.block.setHeight(t, i),
        this.engine.block.setFloat(t, "page/margin/left", e.left),
        this.engine.block.setFloat(t, "page/margin/right", e.right),
        this.engine.block.setFloat(t, "page/margin/top", e.top),
        this.engine.block.setFloat(t, "page/margin/bottom", e.bottom),
        this.engine.block.setBool(t, "page/marginEnabled", n),
        this.engine.block.setString(
          t,
          "page/titleTemplate",
          this.i18n.t("input.page.titleTemplate", {
            interpolation: { skipOnVariables: true },
            number: "{{ubq.page_index}}",
            separator: "{{ubq.separator}}",
            name: "{{ubq.name}}",
          })
        );
    }
    let n = this.root;
    if ("Free" !== this.engine.block.getEnum(this.root, "scene/layout")) {
      const e = this.engine.block.findByType("stack");
      for (const t of e)
        this.engine.block.getParent(t) === this.root && (n = t);
    }
    return (
      this.engine.block.appendChild(n, t),
      this.pageManager.add(t),
      this.engine.block.select(t),
      this.scrollToPage(t),
      this.uiEventEmitter.emit("action.page.add", { element: t }),
      t
    );
  }
  getDesignBlockContext() {
    return {
      configuration: this.configuration,
      engineStore: this.engineStore,
      engineFacade: this,
    };
  }
  async moveSelectedPageUp() {
    const e = this.pageManager.getSelectedPage();
    if (null == e) return;
    await this.movePageIdUp(e), this.scrollToPage(e);
    const t =
      "VerticalStack" ===
      this.engine.block.getEnum(this.engine.scene.get(), "scene/layout")
        ? "action.pageMove.up.description"
        : "action.pageMove.left.description";
    this.uiEventEmitter.emit(t, { elements: [e] });
  }
  async movePageIdUp(e) {
    const t = this.engine.block.getParent(e);
    if (!t) throw new Error("No parent");
    const n = this.engine.block.getChildren(t).indexOf(e);
    n > 0 && this.engine.block.insertChild(t, e, n - 1);
  }
  async moveSelectedPageDown() {
    const e = this.pageManager.getSelectedPage();
    if (null == e) return;
    await this.movePageIdDown(e), this.scrollToPage(e);
    const t =
      "VerticalStack" ===
      this.engine.block.getEnum(this.engine.scene.get(), "scene/layout")
        ? "action.pageMove.down.description"
        : "action.pageMove.right.description";
    this.uiEventEmitter.emit(t, { elements: [e] });
  }
  async movePageIdDown(e) {
    const t = this.engine.block.getParent(e);
    if (!t) throw new Error("No parent");
    const n = this.engine.block.getChildren(t),
      s = n.indexOf(e);
    s < n.length - 1 && this.engine.block.insertChild(t, e, s + 1);
  }
  async duplicateAndMoveDesignElement(e) {
    const t = this.engine.block.duplicate(e);
    return this.engine.block.select(t), this.addOffsetToDesignElement(t), t;
  }
  addOffsetToDesignElement(e, t = 1) {
    const n = this.getPageDimensions(),
      s = 0.02 * Math.min(n.width, n.height) * t;
    this.engine.block.setPositionX(e, this.engine.block.getPositionX(e) + s),
      this.engine.block.setPositionY(e, this.engine.block.getPositionY(e) + s);
  }
  async duplicatePageHierarchy(e) {
    const t = this.engine.block.duplicate(e);
    return (
      this.pageManager.add(t),
      this.engine.block.select(t),
      this.scrollToPage(t),
      t
    );
  }
  async duplicateSelectedDesignElements() {
    const e = this.engine.block.findAllSelected(),
      t = e.map(async (e) => {
        if ("//ly.img.ubq/page" === this.engine.block.getType(e)) {
          return await this.duplicatePageHierarchy(e);
        }
        return await this.duplicateAndMoveDesignElement(e);
      }),
      n = await Promise.all(t);
    return (
      this.uiEventEmitter.emit("action.block.duplicate", { elements: e }), n
    );
  }
  getParentPageOfDesignElement(e) {
    const t = this.engine.block.getType(e);
    if ("//ly.img.ubq/page" === t) return e;
    if ("//ly.img.ubq/scene" === t) return null;
    const n = this.engine.block.getParent(e);
    return null === n ? null : this.getParentPageOfDesignElement(n);
  }
  async getAllDesignElements() {
    return (await this.legacyApi.execute("ubq/scene/getAll")).map((e) => ({
      id: e.id,
      type: e.typeId,
      selectable: e.isSelectable,
    }));
  }
  getDesignElementFrameOrigin(e) {
    return {
      x: this.engine.block.getFrameX(e),
      y: this.engine.block.getFrameY(e),
    };
  }
  getDesignElementFrameDimensions(e) {
    return {
      x: this.engine.block.getFrameWidth(e),
      y: this.engine.block.getFrameHeight(e),
    };
  }
  getUndoManager() {
    return this.undoManager;
  }
  getPageManager() {
    return this.pageManager;
  }
  getUIEventEmitter() {
    return this.uiEventEmitter;
  }
  getDesignElementLifecycleEmitter() {
    return this.designElementLifecycleEmitter;
  }
  getAssetSource(e) {
    return RV(e, this.engine);
  }
  getHistoryStateEmitter() {
    return this.historyStateEmitter;
  }
  getScene() {
    return this.root;
  }
  updatePageFormat({ id: e, preset: t }) {
    const n = t.unit;
    this.engine.scene.setDesignUnit(n),
      this.engine.block.setString(this.root, "scene/pageFormatId", e),
      this.setPageDimensions({ width: t.width, height: t.height });
  }
  getPageDimensions() {
    return {
      width: this.engine.block.getFloat(
        this.root,
        "scene/pageDimensions/width"
      ),
      height: this.engine.block.getFloat(
        this.root,
        "scene/pageDimensions/height"
      ),
    };
  }
  setPageDimensions({ width: e, height: t }) {
    this.engine.block.setFloat(this.root, "scene/pageDimensions/width", e),
      this.engine.block.setFloat(this.root, "scene/pageDimensions/height", t),
      this.engine.block.resizeContentAware(
        [...this.pageManager.getPages()],
        e,
        t
      );
  }
  addTranslation(e, t, n) {
    this.i18n.addResource(n || this.locale, "custom", e, t);
  }
  addTranslations(e, t) {
    this.i18n.addResourceBundle(t || this.locale, "custom", e, true, true);
  }
  get configuration() {
    return this._configuration;
  }
  get locale() {
    return this.configuration.locale || FR;
  }
  addErrorCallbackListener(e) {
    return (
      this.errorCallbackListeners.push(e),
      () => {
        if (this.errorCallbackListeners) {
          const t = this.errorCallbackListeners.lastIndexOf(e);
          t > -1 && this.errorCallbackListeners.splice(t, 1);
        }
      }
    );
  }
  setTextFrameHeightAuto(e) {
    const t = this.engine.block.getFrameWidth(e);
    this.engine.block.setWidth(e, t),
      this.engine.block.setHeightMode(e, "Auto"),
      this.getUIEventEmitter().emit("action.text.autoHeight");
  }
  setTextFrameSizingFixed(e) {
    const t = this.engine.block.getFrameWidth(e),
      n = this.engine.block.getFrameHeight(e);
    this.engine.block.setWidth(e, t),
      this.engine.block.setHeight(e, n),
      this.getUIEventEmitter().emit("action.text.fixedFrame");
  }
  setTextFrameSizingAuto(e) {
    this.engine.block.setWidthMode(e, "Auto"),
      this.engine.block.setHeightMode(e, "Auto"),
      this.getUIEventEmitter().emit("action.text.autoSize");
  }
};

export var nD = () => {
  const e = DO(),
    [t, n] = (0, tD.useState)([]);
  return (
    (0, tD.useEffect)(() => {
      let t = true,
        s = true;
      const i = () => {
        e.getAllDesignElements().then((t) => {
          if (!s) return;
          const i = t.filter((t) => e.engine.block.isValid(t.id));
          n(i);
        });
      };
      i();
      const o = e.getDesignElementLifecycleEmitter().addGlobalListener((e) => {
          const n = e.some(({ options: e }) => {
            const { lifecycleEvent: t, componentType: n } = e;
            return (
              "DesignBlockUpdatedEvent" === t &&
              ("ubq/scene/Parent" === n ||
                "ubq/designblocks/DisableSelectionTag" === n)
            );
          });
          if (t) return (t = false), void i();
          n && i();
        }),
        r = e.getUIEventEmitter().on("element.group.change", i),
        a = e.channels.scene.ready.subscribe(i),
        l = e.settings.roles.effectiveRole.subscribe(i);
      return () => {
        (s = false), o(), r(), a(), l();
      };
    }, [e]),
    t
  );
};

export var oD = function () {
  return DO().channels;
};

export function aD(e) {
  return e instanceof Function ? e() : e;
}
export function lD(e, t) {
  if ("channel" in t && t.channel) {
    if (!t.channel.value) return { value: undefined, stale: true };
    if (t.channel.value() !== e.value) return { value: t.channel.value() };
  } else if ("value" in t) {
    if (e.stale) return t;
    if (t.value !== e.value) return t;
  }
  return e;
}
export var possibleHook3 = function (e, t) {
  const [n, s] = (0, rD.useReducer)(lD, { value: undefined }, () => ({
      value: e && e.value ? e.value() : aD(t),
    })),
    i = (0, rD.useRef)(e),
    o = i.current !== e;
  return (
    (i.current = e),
    (0, rD.useEffect)(
      () => (
        s({ channel: e || undefined }),
        e
          ? e.subscribe(function (e) {
              s({ value: e });
            })
          : aV
      ),
      [e]
    ),
    e && e?.value
      ? [e.value(), e.update]
      : o || !e || n.stale
      ? [aD(t), e ? e.update : undefined]
      : [n.value, e?.update]
  );
};
export function uD() {
  const { selection: e } = oD(),
    [t] = possibleHook3(e.allSelected),
    [n] = possibleHook3(e.selectedPage);
  return (0, iD.useMemo)(() => {
    const e = t.map((e) => ({ id: e.id, type: e.type, selectable: true })),
      s = e[0];
    return {
      selectedDesignElementsIds: e.map((e) => e.id),
      selectedDesignElements: e,
      selectedDesignElement: s,
      hasMultiSelection: e.length > 1,
      blocks: t,
      block: t[0],
      selectedPageBlock: n,
    };
  }, [t, n]);
}

if (ifUseStateNoAvailable)
  throw new Error("mobx-react-lite requires React with Hooks support");
if (
  !function (e, t, n) {
    var s = IT(e, n)[VP];
    lB();
    try {
      null != t ||
        (t = (function (e) {
          return jP(e, MP) || gP(e, MP, LP({}, e[MP])), e[MP];
        })(e)),
        kP(t).forEach(function (e) {
          return s.make_(e, t[e]);
        });
    } finally {
      cB();
    }
    return e;
  }
)
  throw new Error(
    "mobx-react-lite@3 requires mobx at least version 6 to be available"
  );
export function fD(e) {
  e();
}
export function mD(e) {
  return zB(JT(e, t));
  var t;
}
export var gD = false;
export function xD() {
  return gD;
}
export var bD = (function () {
  function e(e) {
    var t = this;
    Object.defineProperty(this, "finalize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: e,
    }),
      Object.defineProperty(this, "registrations", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Map(),
      }),
      Object.defineProperty(this, "sweepTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined,
      }),
      Object.defineProperty(this, "sweep", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function (e) {
          undefined === e && (e = 1e4),
            clearTimeout(t.sweepTimeout),
            (t.sweepTimeout = undefined);
          var n = Date.now();
          t.registrations.forEach(function (s, i) {
            n - s.registeredAt >= e &&
              (t.finalize(s.value), t.registrations.delete(i));
          }),
            t.registrations.size > 0 && t.scheduleSweep();
        },
      }),
      Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function () {
          t.sweep(0);
        },
      });
  }
  return (
    Object.defineProperty(e.prototype, "register", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function (e, t, n) {
        this.registrations.set(n, { value: t, registeredAt: Date.now() }),
          this.scheduleSweep();
      },
    }),
    Object.defineProperty(e.prototype, "unregister", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function (e) {
        this.registrations.delete(e);
      },
    }),
    Object.defineProperty(e.prototype, "scheduleSweep", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function () {
        undefined === this.sweepTimeout &&
          (this.sweepTimeout = setTimeout(this.sweep, 1e4));
      },
    }),
    e
  );
})();
export var yD = new (
  "undefined" != typeof FinalizationRegistry ? FinalizationRegistry : bD
)(function (e) {
  var t;
  null === (t = e.reaction) || undefined === t || t.dispose(),
    (e.reaction = null);
});
export var wD = function (e, t) {
  var n = "function" == typeof Symbol && e[Symbol.iterator];
  if (!n) return e;
  var s,
    i,
    o = n.call(e),
    r = [];
  try {
    for (; (undefined === t || t-- > 0) && !(s = o.next()).done; )
      r.push(s.value);
  } catch (e) {
    i = { error: e };
  } finally {
    try {
      s && !s.done && (n = o.return) && n.call(o);
    } finally {
      if (i) throw i.error;
    }
  }
  return r;
};
export var kD = function () {};
export var CD = iB;
export var jD = undefined !== CD.stateVersion;
export function SD(e) {
  e.reaction = new pB("observer".concat(e.name), function () {
    var t;
    jD || (e.stateVersion = Symbol()),
      null === (t = e.onStoreChange) || undefined === t || t.call(e);
  });
}
export function _D(e, t) {
  if ((undefined === t && (t = "observed"), xD())) return e();
  var n = hD.default.useRef(null),
    s = wD(hD.default.useState(), 2)[1];
  if (!n.current) {
    var i = {
      reaction: null,
      onStoreChange: null,
      stateVersion: Symbol(),
      name: t,
      subscribe: function (e) {
        return (
          yD.unregister(i),
          (i.onStoreChange = e),
          i.reaction || (SD(i), s(Symbol())),
          function () {
            var e;
            (i.onStoreChange = null),
              null === (e = i.reaction) || undefined === e || e.dispose(),
              (i.reaction = null);
          }
        );
      },
      getSnapshot: function () {
        return jD ? CD.stateVersion : i.stateVersion;
      },
    };
    n.current = i;
  }
  var o,
    r,
    a = n.current;
  if (
    (a.reaction || (SD(a), yD.register(n, a, a)),
    hD.default.useDebugValue(a.reaction, mD),
    (0, vD.useSyncExternalStore)(a.subscribe, a.getSnapshot, kD),
    a.reaction.track(function () {
      try {
        o = e();
      } catch (e) {
        r = e;
      }
    }),
    r)
  )
    throw r;
  return o;
}
export var LD = "function" == typeof Symbol && Symbol.for;
export var PD = LD
  ? Symbol.for("react.forward_ref")
  : "function" == typeof ED.forwardRef &&
    (0, ED.forwardRef)(function (e) {
      return null;
    }).$$typeof;
export var AD = LD
  ? Symbol.for("react.memo")
  : "function" == typeof ED.memo &&
    (0, ED.memo)(function (e) {
      return null;
    }).$$typeof;
export function mayBeUseMemp(e, t) {
  var n;
  if (AD && e.$$typeof === AD)
    throw new Error(
      "[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you."
    );
  if (xD()) return e;
  var s =
      null !== (n = null == t ? undefined : t.forwardRef) &&
      undefined !== n &&
      n,
    i = e,
    o = e.displayName || e.name;
  if (
    PD &&
    e.$$typeof === PD &&
    ((s = true), "function" != typeof (i = e.render))
  )
    throw new Error(
      "[mobx-react-lite] `render` property of ForwardRef was not a function"
    );
  var r,
    a,
    l = function (e, t) {
      return _D(function () {
        return i(e, t);
      }, o);
    };
  return (
    (l.displayName = e.displayName),
    Object.defineProperty(l, "name", {
      value: e.name,
      writable: true,
      configurable: true,
    }),
    e.contextTypes && (l.contextTypes = e.contextTypes),
    s && (l = (0, ED.forwardRef)(l)),
    (l = (0, ED.memo)(l)),
    (r = e),
    (a = l),
    Object.keys(r).forEach(function (e) {
      TD[e] ||
        Object.defineProperty(a, e, Object.getOwnPropertyDescriptor(r, e));
    }),
    l
  );
}
export var TD = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true,
  displayName: true,
};
export function MD(e) {
  var t = e.children,
    n = e.render,
    s = t || n;
  return "function" != typeof s ? null : _D(s);
}
MD.displayName = "Observer";
export var OD, RD;
(RD = pD.unstable_batchedUpdates) || (RD = fD), NB({ reactionScheduler: RD });
OD = yD.finalizeAllImmediately;
export function VD(e, t) {
  return (VD = Object.setPrototypeOf
    ? Object.setPrototypeOf.bind()
    : function (e, t) {
        return (e.__proto__ = t), e;
      })(e, t);
}
export function DD(e, t) {
  (e.prototype = Object.create(t.prototype)),
    (e.prototype.constructor = e),
    VD(e, t);
}
export var FD = (function () {
  function e() {
    this.listeners = [];
  }
  var t = e.prototype;
  return (
    (t.subscribe = function (e) {
      var t = this,
        n = e || function () {};
      return (
        this.listeners.push(n),
        this.onSubscribe(),
        function () {
          (t.listeners = t.listeners.filter(function (e) {
            return e !== n;
          })),
            t.onUnsubscribe();
        }
      );
    }),
    (t.hasListeners = function () {
      return this.listeners.length > 0;
    }),
    (t.onSubscribe = function () {}),
    (t.onUnsubscribe = function () {}),
    e
  );
})();
export function ID() {
  return (
    (ID = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var s in n)
              Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
          }
          return e;
        }),
    ID.apply(this, arguments)
  );
}
export var HD = "undefined" == typeof window;
export function ND() {}
export function UD(e) {
  return "number" == typeof e && e >= 0 && e !== 1 / 0;
}
export function zD(e) {
  return Array.isArray(e) ? e : [e];
}
export function $D(e, t) {
  return e.filter(function (e) {
    return -1 === t.indexOf(e);
  });
}
export function qD(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
export function QD(e, t, n) {
  return sF(e)
    ? "function" == typeof t
      ? ID({}, n, { queryKey: e, queryFn: t })
      : ID({}, t, { queryKey: e })
    : e;
}
export function GD(e, t, n) {
  return sF(e) ? [ID({}, t, { queryKey: e }), n] : [e || {}, t];
}
export function ZD(e, t) {
  var n = e.active,
    s = e.exact,
    i = e.fetching,
    o = e.inactive,
    r = e.predicate,
    a = e.queryKey,
    l = e.stale;
  if (sF(a))
    if (s) {
      if (t.queryHash !== KD(a, t.options)) return false;
    } else if (!XD(t.queryKey, a)) return false;
  var c = (function (e, t) {
    return (true === e && true === t) || (null == e && null == t)
      ? "all"
      : false === e && false === t
      ? "none"
      : (null != e ? e : !t)
      ? "active"
      : "inactive";
  })(n, o);
  if ("none" === c) return false;
  if ("all" !== c) {
    var u = t.isActive();
    if ("active" === c && !u) return false;
    if ("inactive" === c && u) return false;
  }
  return (
    ("boolean" != typeof l || t.isStale() === l) &&
    ("boolean" != typeof i || t.isFetching() === i) &&
    !(r && !r(t))
  );
}
export function WD(e, t) {
  var n = e.exact,
    s = e.fetching,
    i = e.predicate,
    o = e.mutationKey;
  if (sF(o)) {
    if (!t.options.mutationKey) return false;
    if (n) {
      if (YD(t.options.mutationKey) !== YD(o)) return false;
    } else if (!XD(t.options.mutationKey, o)) return false;
  }
  return (
    ("boolean" != typeof s || ("loading" === t.state.status) === s) &&
    !(i && !i(t))
  );
}
export function KD(e, t) {
  return ((null == t ? undefined : t.queryKeyHashFn) || YD)(e);
}
export function YD(e) {
  var t,
    n = zD(e);
  return (
    (t = n),
    JSON.stringify(t, function (e, t) {
      return tF(t)
        ? Object.keys(t)
            .sort()
            .reduce(function (e, n) {
              return (e[n] = t[n]), e;
            }, {})
        : t;
    })
  );
}
export function XD(e, t) {
  return JD(zD(e), zD(t));
}
export function JD(e, t) {
  return (
    e === t ||
    (typeof e == typeof t &&
      !(!e || !t || "object" != typeof e || "object" != typeof t) &&
      !Object.keys(t).some(function (n) {
        return !JD(e[n], t[n]);
      }))
  );
}
export function eF(e, t) {
  if (e === t) return e;
  var n = Array.isArray(e) && Array.isArray(t);
  if (n || (tF(e) && tF(t))) {
    for (
      var s = n ? e.length : Object.keys(e).length,
        i = n ? t : Object.keys(t),
        o = i.length,
        r = n ? [] : {},
        a = 0,
        l = 0;
      l < o;
      l++
    ) {
      var c = n ? l : i[l];
      (r[c] = eF(e[c], t[c])), r[c] === e[c] && a++;
    }
    return s === o && a === s ? e : r;
  }
  return t;
}
export function tF(e) {
  if (!nF(e)) return false;
  var t = e.constructor;
  if (undefined === t) return true;
  var n = t.prototype;
  return !!nF(n) && !!n.hasOwnProperty("isPrototypeOf");
}
export function nF(e) {
  return "[object Object]" === Object.prototype.toString.call(e);
}
export function sF(e) {
  return "string" == typeof e || Array.isArray(e);
}
export function iF(e) {
  Promise.resolve()
    .then(e)
    .catch(function (e) {
      return setTimeout(function () {
        throw e;
      });
    });
}
export function oF() {
  if ("function" == typeof AbortController) return new AbortController();
}
export var rF = new ((function (e) {
  function t() {
    var t;
    return (
      ((t = e.call(this) || this).setup = function (e) {
        var t;
        if (!HD && (null == (t = window) ? undefined : t.addEventListener)) {
          var n = function () {
            return e();
          };
          return (
            window.addEventListener("visibilitychange", n, false),
            window.addEventListener("focus", n, false),
            function () {
              window.removeEventListener("visibilitychange", n),
                window.removeEventListener("focus", n);
            }
          );
        }
      }),
      t
    );
  }
  DD(t, e);
  var n = t.prototype;
  return (
    (n.onSubscribe = function () {
      this.cleanup || this.setEventListener(this.setup);
    }),
    (n.onUnsubscribe = function () {
      var e;
      this.hasListeners() ||
        (null == (e = this.cleanup) || e.call(this),
        (this.cleanup = undefined));
    }),
    (n.setEventListener = function (e) {
      var t,
        n = this;
      (this.setup = e),
        null == (t = this.cleanup) || t.call(this),
        (this.cleanup = e(function (e) {
          "boolean" == typeof e ? n.setFocused(e) : n.onFocus();
        }));
    }),
    (n.setFocused = function (e) {
      (this.focused = e), e && this.onFocus();
    }),
    (n.onFocus = function () {
      this.listeners.forEach(function (e) {
        e();
      });
    }),
    (n.isFocused = function () {
      return "boolean" == typeof this.focused
        ? this.focused
        : "undefined" == typeof document ||
            [undefined, "visible", "prerender"].includes(
              document.visibilityState
            );
    }),
    t
  );
})(FD))();
export var aF = new ((function (e) {
  function t() {
    var t;
    return (
      ((t = e.call(this) || this).setup = function (e) {
        var t;
        if (!HD && (null == (t = window) ? undefined : t.addEventListener)) {
          var n = function () {
            return e();
          };
          return (
            window.addEventListener("online", n, false),
            window.addEventListener("offline", n, false),
            function () {
              window.removeEventListener("online", n),
                window.removeEventListener("offline", n);
            }
          );
        }
      }),
      t
    );
  }
  DD(t, e);
  var n = t.prototype;
  return (
    (n.onSubscribe = function () {
      this.cleanup || this.setEventListener(this.setup);
    }),
    (n.onUnsubscribe = function () {
      var e;
      this.hasListeners() ||
        (null == (e = this.cleanup) || e.call(this),
        (this.cleanup = undefined));
    }),
    (n.setEventListener = function (e) {
      var t,
        n = this;
      (this.setup = e),
        null == (t = this.cleanup) || t.call(this),
        (this.cleanup = e(function (e) {
          "boolean" == typeof e ? n.setOnline(e) : n.onOnline();
        }));
    }),
    (n.setOnline = function (e) {
      (this.online = e), e && this.onOnline();
    }),
    (n.onOnline = function () {
      this.listeners.forEach(function (e) {
        e();
      });
    }),
    (n.isOnline = function () {
      return "boolean" == typeof this.online
        ? this.online
        : "undefined" == typeof navigator ||
            undefined === navigator.onLine ||
            navigator.onLine;
    }),
    t
  );
})(FD))();
export function lF(e) {
  return Math.min(1e3 * Math.pow(2, e), 3e4);
}
export function cF(e) {
  return "function" == typeof (null == e ? undefined : e.cancel);
}
export var uF = function (e) {
  (this.revert = null == e ? undefined : e.revert),
    (this.silent = null == e ? undefined : e.silent);
};
export function dF(e) {
  return e instanceof uF;
}
export var pF = function (e) {
  var t,
    n,
    s,
    i,
    o = this,
    r = false;
  (this.abort = e.abort),
    (this.cancel = function (e) {
      return null == t ? undefined : t(e);
    }),
    (this.cancelRetry = function () {
      r = true;
    }),
    (this.continueRetry = function () {
      r = false;
    }),
    (this.continue = function () {
      return null == n ? undefined : n();
    }),
    (this.failureCount = 0),
    (this.isPaused = false),
    (this.isResolved = false),
    (this.isTransportCancelable = false),
    (this.promise = new Promise(function (e, t) {
      (s = e), (i = t);
    }));
  var a = function (t) {
      o.isResolved ||
        ((o.isResolved = true),
        null == e.onSuccess || e.onSuccess(t),
        null == n || n(),
        s(t));
    },
    l = function (t) {
      o.isResolved ||
        ((o.isResolved = true),
        null == e.onError || e.onError(t),
        null == n || n(),
        i(t));
    };
  !(function s() {
    if (!o.isResolved) {
      var i;
      try {
        i = e.fn();
      } catch (e) {
        i = Promise.reject(e);
      }
      (t = function (e) {
        if (
          !o.isResolved &&
          (l(new uF(e)), null == o.abort || o.abort(), cF(i))
        )
          try {
            i.cancel();
          } catch (e) {}
      }),
        (o.isTransportCancelable = cF(i)),
        Promise.resolve(i)
          .then(a)
          .catch(function (t) {
            var i, a;
            if (!o.isResolved) {
              var c,
                u = null != (i = e.retry) ? i : 3,
                d = null != (a = e.retryDelay) ? a : lF,
                p = "function" == typeof d ? d(o.failureCount, t) : d,
                f =
                  true === u ||
                  ("number" == typeof u && o.failureCount < u) ||
                  ("function" == typeof u && u(o.failureCount, t));
              if (!r && f)
                o.failureCount++,
                  null == e.onFail || e.onFail(o.failureCount, t),
                  ((c = p),
                  new Promise(function (e) {
                    setTimeout(e, c);
                  }))
                    .then(function () {
                      if (!rF.isFocused() || !aF.isOnline())
                        return new Promise(function (t) {
                          (n = t),
                            (o.isPaused = true),
                            null == e.onPause || e.onPause();
                        }).then(function () {
                          (n = undefined),
                            (o.isPaused = false),
                            null == e.onContinue || e.onContinue();
                        });
                    })
                    .then(function () {
                      r ? l(t) : s();
                    });
              else l(t);
            }
          });
    }
  })();
};
export var fF = new ((function () {
  function e() {
    (this.queue = []),
      (this.transactions = 0),
      (this.notifyFn = function (e) {
        e();
      }),
      (this.batchNotifyFn = function (e) {
        e();
      });
  }
  var t = e.prototype;
  return (
    (t.batch = function (e) {
      var t;
      this.transactions++;
      try {
        t = e();
      } finally {
        this.transactions--, this.transactions || this.flush();
      }
      return t;
    }),
    (t.schedule = function (e) {
      var t = this;
      this.transactions
        ? this.queue.push(e)
        : iF(function () {
            t.notifyFn(e);
          });
    }),
    (t.batchCalls = function (e) {
      var t = this;
      return function () {
        for (var n = arguments.length, s = new Array(n), i = 0; i < n; i++)
          s[i] = arguments[i];
        t.schedule(function () {
          e.apply(undefined, s);
        });
      };
    }),
    (t.flush = function () {
      var e = this,
        t = this.queue;
      (this.queue = []),
        t.length &&
          iF(function () {
            e.batchNotifyFn(function () {
              t.forEach(function (t) {
                e.notifyFn(t);
              });
            });
          });
    }),
    (t.setNotifyFunction = function (e) {
      this.notifyFn = e;
    }),
    (t.setBatchNotifyFunction = function (e) {
      this.batchNotifyFn = e;
    }),
    e
  );
})())();
export var hF = console;
export function mF() {
  return hF;
}
export var gF = (function () {
  function e(e) {
    (this.abortSignalConsumed = false),
      (this.hadObservers = false),
      (this.defaultOptions = e.defaultOptions),
      this.setOptions(e.options),
      (this.observers = []),
      (this.cache = e.cache),
      (this.queryKey = e.queryKey),
      (this.queryHash = e.queryHash),
      (this.initialState = e.state || this.getDefaultState(this.options)),
      (this.state = this.initialState),
      (this.meta = e.meta),
      this.scheduleGc();
  }
  var t = e.prototype;
  return (
    (t.setOptions = function (e) {
      var t;
      (this.options = ID({}, this.defaultOptions, e)),
        (this.meta = null == e ? undefined : e.meta),
        (this.cacheTime = Math.max(
          this.cacheTime || 0,
          null != (t = this.options.cacheTime) ? t : 3e5
        ));
    }),
    (t.setDefaultOptions = function (e) {
      this.defaultOptions = e;
    }),
    (t.scheduleGc = function () {
      var e = this;
      this.clearGcTimeout(),
        UD(this.cacheTime) &&
          (this.gcTimeout = setTimeout(function () {
            e.optionalRemove();
          }, this.cacheTime));
    }),
    (t.clearGcTimeout = function () {
      this.gcTimeout &&
        (clearTimeout(this.gcTimeout), (this.gcTimeout = undefined));
    }),
    (t.optionalRemove = function () {
      this.observers.length ||
        (this.state.isFetching
          ? this.hadObservers && this.scheduleGc()
          : this.cache.remove(this));
    }),
    (t.setData = function (e, t) {
      var n,
        s,
        i = this.state.data,
        o = (function (e, t) {
          return "function" == typeof e ? e(t) : e;
        })(e, i);
      return (
        (
          null == (n = (s = this.options).isDataEqual)
            ? undefined
            : n.call(s, i, o)
        )
          ? (o = i)
          : false !== this.options.structuralSharing && (o = eF(i, o)),
        this.dispatch({
          data: o,
          type: "success",
          dataUpdatedAt: null == t ? undefined : t.updatedAt,
        }),
        o
      );
    }),
    (t.setState = function (e, t) {
      this.dispatch({ type: "setState", state: e, setStateOptions: t });
    }),
    (t.cancel = function (e) {
      var t,
        n = this.promise;
      return (
        null == (t = this.retryer) || t.cancel(e),
        n ? n.then(ND).catch(ND) : Promise.resolve()
      );
    }),
    (t.destroy = function () {
      this.clearGcTimeout(), this.cancel({ silent: true });
    }),
    (t.reset = function () {
      this.destroy(), this.setState(this.initialState);
    }),
    (t.isActive = function () {
      return this.observers.some(function (e) {
        return false !== e.options.enabled;
      });
    }),
    (t.isFetching = function () {
      return this.state.isFetching;
    }),
    (t.isStale = function () {
      return (
        this.state.isInvalidated ||
        !this.state.dataUpdatedAt ||
        this.observers.some(function (e) {
          return e.getCurrentResult().isStale;
        })
      );
    }),
    (t.isStaleByTime = function (e) {
      return (
        undefined === e && (e = 0),
        this.state.isInvalidated ||
          !this.state.dataUpdatedAt ||
          !qD(this.state.dataUpdatedAt, e)
      );
    }),
    (t.onFocus = function () {
      var e,
        t = this.observers.find(function (e) {
          return e.shouldFetchOnWindowFocus();
        });
      t && t.refetch(), null == (e = this.retryer) || e.continue();
    }),
    (t.onOnline = function () {
      var e,
        t = this.observers.find(function (e) {
          return e.shouldFetchOnReconnect();
        });
      t && t.refetch(), null == (e = this.retryer) || e.continue();
    }),
    (t.addObserver = function (e) {
      -1 === this.observers.indexOf(e) &&
        (this.observers.push(e),
        (this.hadObservers = true),
        this.clearGcTimeout(),
        this.cache.notify({
          type: "observerAdded",
          query: this,
          observer: e,
        }));
    }),
    (t.removeObserver = function (e) {
      -1 !== this.observers.indexOf(e) &&
        ((this.observers = this.observers.filter(function (t) {
          return t !== e;
        })),
        this.observers.length ||
          (this.retryer &&
            (this.retryer.isTransportCancelable || this.abortSignalConsumed
              ? this.retryer.cancel({ revert: true })
              : this.retryer.cancelRetry()),
          this.cacheTime ? this.scheduleGc() : this.cache.remove(this)),
        this.cache.notify({
          type: "observerRemoved",
          query: this,
          observer: e,
        }));
    }),
    (t.getObserversCount = function () {
      return this.observers.length;
    }),
    (t.invalidate = function () {
      this.state.isInvalidated || this.dispatch({ type: "invalidate" });
    }),
    (t.fetch = function (e, t) {
      var n,
        s,
        i,
        o = this;
      if (this.state.isFetching)
        if (
          this.state.dataUpdatedAt &&
          (null == t ? undefined : t.cancelRefetch)
        )
          this.cancel({ silent: true });
        else if (this.promise) {
          var r;
          return null == (r = this.retryer) || r.continueRetry(), this.promise;
        }
      if ((e && this.setOptions(e), !this.options.queryFn)) {
        var a = this.observers.find(function (e) {
          return e.options.queryFn;
        });
        a && this.setOptions(a.options);
      }
      var l = zD(this.queryKey),
        c = oF(),
        u = { queryKey: l, pageParam: undefined, meta: this.meta };
      Object.defineProperty(u, "signal", {
        enumerable: true,
        get: function () {
          if (c) return (o.abortSignalConsumed = true), c.signal;
        },
      });
      var d,
        p,
        f = {
          fetchOptions: t,
          options: this.options,
          queryKey: l,
          state: this.state,
          fetchFn: function () {
            return o.options.queryFn
              ? ((o.abortSignalConsumed = false), o.options.queryFn(u))
              : Promise.reject("Missing queryFn");
          },
          meta: this.meta,
        };
      (null == (n = this.options.behavior) ? undefined : n.onFetch) &&
        (null == (d = this.options.behavior) || d.onFetch(f));
      ((this.revertState = this.state),
      this.state.isFetching &&
        this.state.fetchMeta ===
          (null == (s = f.fetchOptions) ? undefined : s.meta)) ||
        this.dispatch({
          type: "fetch",
          meta: null == (p = f.fetchOptions) ? undefined : p.meta,
        });
      return (
        (this.retryer = new pF({
          fn: f.fetchFn,
          abort: null == c || null == (i = c.abort) ? undefined : i.bind(c),
          onSuccess: function (e) {
            o.setData(e),
              null == o.cache.config.onSuccess ||
                o.cache.config.onSuccess(e, o),
              0 === o.cacheTime && o.optionalRemove();
          },
          onError: function (e) {
            (dF(e) && e.silent) || o.dispatch({ type: "error", error: e }),
              dF(e) ||
                (null == o.cache.config.onError || o.cache.config.onError(e, o),
                mF().error(e)),
              0 === o.cacheTime && o.optionalRemove();
          },
          onFail: function () {
            o.dispatch({ type: "failed" });
          },
          onPause: function () {
            o.dispatch({ type: "pause" });
          },
          onContinue: function () {
            o.dispatch({ type: "continue" });
          },
          retry: f.options.retry,
          retryDelay: f.options.retryDelay,
        })),
        (this.promise = this.retryer.promise),
        this.promise
      );
    }),
    (t.dispatch = function (e) {
      var t = this;
      (this.state = this.reducer(this.state, e)),
        fF.batch(function () {
          t.observers.forEach(function (t) {
            t.onQueryUpdate(e);
          }),
            t.cache.notify({ query: t, type: "queryUpdated", action: e });
        });
    }),
    (t.getDefaultState = function (e) {
      var t =
          "function" == typeof e.initialData ? e.initialData() : e.initialData,
        n =
          undefined !== e.initialData
            ? "function" == typeof e.initialDataUpdatedAt
              ? e.initialDataUpdatedAt()
              : e.initialDataUpdatedAt
            : 0,
        s = undefined !== t;
      return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: s ? (null != n ? n : Date.now()) : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchMeta: null,
        isFetching: false,
        isInvalidated: false,
        isPaused: false,
        status: s ? "success" : "idle",
      };
    }),
    (t.reducer = function (e, t) {
      var n, s;
      switch (t.type) {
        case "failed":
          return ID({}, e, { fetchFailureCount: e.fetchFailureCount + 1 });
        case "pause":
          return ID({}, e, { isPaused: true });
        case "continue":
          return ID({}, e, { isPaused: false });
        case "fetch":
          return ID(
            {},
            e,
            {
              fetchFailureCount: 0,
              fetchMeta: null != (n = t.meta) ? n : null,
              isFetching: true,
              isPaused: false,
            },
            !e.dataUpdatedAt && { error: null, status: "loading" }
          );
        case "success":
          return ID({}, e, {
            data: t.data,
            dataUpdateCount: e.dataUpdateCount + 1,
            dataUpdatedAt: null != (s = t.dataUpdatedAt) ? s : Date.now(),
            error: null,
            fetchFailureCount: 0,
            isFetching: false,
            isInvalidated: false,
            isPaused: false,
            status: "success",
          });
        case "error":
          var i = t.error;
          return dF(i) && i.revert && this.revertState
            ? ID({}, this.revertState)
            : ID({}, e, {
                error: i,
                errorUpdateCount: e.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: e.fetchFailureCount + 1,
                isFetching: false,
                isPaused: false,
                status: "error",
              });
        case "invalidate":
          return ID({}, e, { isInvalidated: true });
        case "setState":
          return ID({}, e, t.state);
        default:
          return e;
      }
    }),
    e
  );
})();
export var xF = (function (e) {
  function t(t) {
    var n;
    return (
      ((n = e.call(this) || this).config = t || {}),
      (n.queries = []),
      (n.queriesMap = {}),
      n
    );
  }
  DD(t, e);
  var n = t.prototype;
  return (
    (n.build = function (e, t, n) {
      var s,
        i = t.queryKey,
        o = null != (s = t.queryHash) ? s : KD(i, t),
        r = this.get(o);
      return (
        r ||
          ((r = new gF({
            cache: this,
            queryKey: i,
            queryHash: o,
            options: e.defaultQueryOptions(t),
            state: n,
            defaultOptions: e.getQueryDefaults(i),
            meta: t.meta,
          })),
          this.add(r)),
        r
      );
    }),
    (n.add = function (e) {
      this.queriesMap[e.queryHash] ||
        ((this.queriesMap[e.queryHash] = e),
        this.queries.push(e),
        this.notify({ type: "queryAdded", query: e }));
    }),
    (n.remove = function (e) {
      var t = this.queriesMap[e.queryHash];
      t &&
        (e.destroy(),
        (this.queries = this.queries.filter(function (t) {
          return t !== e;
        })),
        t === e && delete this.queriesMap[e.queryHash],
        this.notify({ type: "queryRemoved", query: e }));
    }),
    (n.clear = function () {
      var e = this;
      fF.batch(function () {
        e.queries.forEach(function (t) {
          e.remove(t);
        });
      });
    }),
    (n.get = function (e) {
      return this.queriesMap[e];
    }),
    (n.getAll = function () {
      return this.queries;
    }),
    (n.find = function (e, t) {
      var n = GD(e, t)[0];
      return (
        undefined === n.exact && (n.exact = true),
        this.queries.find(function (e) {
          return ZD(n, e);
        })
      );
    }),
    (n.findAll = function (e, t) {
      var n = GD(e, t)[0];
      return Object.keys(n).length > 0
        ? this.queries.filter(function (e) {
            return ZD(n, e);
          })
        : this.queries;
    }),
    (n.notify = function (e) {
      var t = this;
      fF.batch(function () {
        t.listeners.forEach(function (t) {
          t(e);
        });
      });
    }),
    (n.onFocus = function () {
      var e = this;
      fF.batch(function () {
        e.queries.forEach(function (e) {
          e.onFocus();
        });
      });
    }),
    (n.onOnline = function () {
      var e = this;
      fF.batch(function () {
        e.queries.forEach(function (e) {
          e.onOnline();
        });
      });
    }),
    t
  );
})(FD);
export var bF = (function () {
  function e(e) {
    (this.options = ID({}, e.defaultOptions, e.options)),
      (this.mutationId = e.mutationId),
      (this.mutationCache = e.mutationCache),
      (this.observers = []),
      (this.state = e.state || {
        context: undefined,
        data: undefined,
        error: null,
        failureCount: 0,
        isPaused: false,
        status: "idle",
        variables: undefined,
      }),
      (this.meta = e.meta);
  }
  var t = e.prototype;
  return (
    (t.setState = function (e) {
      this.dispatch({ type: "setState", state: e });
    }),
    (t.addObserver = function (e) {
      -1 === this.observers.indexOf(e) && this.observers.push(e);
    }),
    (t.removeObserver = function (e) {
      this.observers = this.observers.filter(function (t) {
        return t !== e;
      });
    }),
    (t.cancel = function () {
      return this.retryer
        ? (this.retryer.cancel(), this.retryer.promise.then(ND).catch(ND))
        : Promise.resolve();
    }),
    (t.continue = function () {
      return this.retryer
        ? (this.retryer.continue(), this.retryer.promise)
        : this.execute();
    }),
    (t.execute = function () {
      var e,
        t = this,
        n = "loading" === this.state.status,
        s = Promise.resolve();
      return (
        n ||
          (this.dispatch({
            type: "loading",
            variables: this.options.variables,
          }),
          (s = s
            .then(function () {
              null == t.mutationCache.config.onMutate ||
                t.mutationCache.config.onMutate(t.state.variables, t);
            })
            .then(function () {
              return null == t.options.onMutate
                ? undefined
                : t.options.onMutate(t.state.variables);
            })
            .then(function (e) {
              e !== t.state.context &&
                t.dispatch({
                  type: "loading",
                  context: e,
                  variables: t.state.variables,
                });
            }))),
        s
          .then(function () {
            return t.executeMutation();
          })
          .then(function (n) {
            (e = n),
              null == t.mutationCache.config.onSuccess ||
                t.mutationCache.config.onSuccess(
                  e,
                  t.state.variables,
                  t.state.context,
                  t
                );
          })
          .then(function () {
            return null == t.options.onSuccess
              ? undefined
              : t.options.onSuccess(e, t.state.variables, t.state.context);
          })
          .then(function () {
            return null == t.options.onSettled
              ? undefined
              : t.options.onSettled(
                  e,
                  null,
                  t.state.variables,
                  t.state.context
                );
          })
          .then(function () {
            return t.dispatch({ type: "success", data: e }), e;
          })
          .catch(function (e) {
            return (
              null == t.mutationCache.config.onError ||
                t.mutationCache.config.onError(
                  e,
                  t.state.variables,
                  t.state.context,
                  t
                ),
              mF().error(e),
              Promise.resolve()
                .then(function () {
                  return null == t.options.onError
                    ? undefined
                    : t.options.onError(e, t.state.variables, t.state.context);
                })
                .then(function () {
                  return null == t.options.onSettled
                    ? undefined
                    : t.options.onSettled(
                        undefined,
                        e,
                        t.state.variables,
                        t.state.context
                      );
                })
                .then(function () {
                  throw (t.dispatch({ type: "error", error: e }), e);
                })
            );
          })
      );
    }),
    (t.executeMutation = function () {
      var e,
        t = this;
      return (
        (this.retryer = new pF({
          fn: function () {
            return t.options.mutationFn
              ? t.options.mutationFn(t.state.variables)
              : Promise.reject("No mutationFn found");
          },
          onFail: function () {
            t.dispatch({ type: "failed" });
          },
          onPause: function () {
            t.dispatch({ type: "pause" });
          },
          onContinue: function () {
            t.dispatch({ type: "continue" });
          },
          retry: null != (e = this.options.retry) ? e : 0,
          retryDelay: this.options.retryDelay,
        })),
        this.retryer.promise
      );
    }),
    (t.dispatch = function (e) {
      var t = this;
      (this.state = (function (e, t) {
        switch (t.type) {
          case "failed":
            return ID({}, e, { failureCount: e.failureCount + 1 });
          case "pause":
            return ID({}, e, { isPaused: true });
          case "continue":
            return ID({}, e, { isPaused: false });
          case "loading":
            return ID({}, e, {
              context: t.context,
              data: undefined,
              error: null,
              isPaused: false,
              status: "loading",
              variables: t.variables,
            });
          case "success":
            return ID({}, e, {
              data: t.data,
              error: null,
              status: "success",
              isPaused: false,
            });
          case "error":
            return ID({}, e, {
              data: undefined,
              error: t.error,
              failureCount: e.failureCount + 1,
              isPaused: false,
              status: "error",
            });
          case "setState":
            return ID({}, e, t.state);
          default:
            return e;
        }
      })(this.state, e)),
        fF.batch(function () {
          t.observers.forEach(function (t) {
            t.onMutationUpdate(e);
          }),
            t.mutationCache.notify(t);
        });
    }),
    e
  );
})();
export var yF = (function (e) {
  function t(t) {
    var n;
    return (
      ((n = e.call(this) || this).config = t || {}),
      (n.mutations = []),
      (n.mutationId = 0),
      n
    );
  }
  DD(t, e);
  var n = t.prototype;
  return (
    (n.build = function (e, t, n) {
      var s = new bF({
        mutationCache: this,
        mutationId: ++this.mutationId,
        options: e.defaultMutationOptions(t),
        state: n,
        defaultOptions: t.mutationKey
          ? e.getMutationDefaults(t.mutationKey)
          : undefined,
        meta: t.meta,
      });
      return this.add(s), s;
    }),
    (n.add = function (e) {
      this.mutations.push(e), this.notify(e);
    }),
    (n.remove = function (e) {
      (this.mutations = this.mutations.filter(function (t) {
        return t !== e;
      })),
        e.cancel(),
        this.notify(e);
    }),
    (n.clear = function () {
      var e = this;
      fF.batch(function () {
        e.mutations.forEach(function (t) {
          e.remove(t);
        });
      });
    }),
    (n.getAll = function () {
      return this.mutations;
    }),
    (n.find = function (e) {
      return (
        undefined === e.exact && (e.exact = true),
        this.mutations.find(function (t) {
          return WD(e, t);
        })
      );
    }),
    (n.findAll = function (e) {
      return this.mutations.filter(function (t) {
        return WD(e, t);
      });
    }),
    (n.notify = function (e) {
      var t = this;
      fF.batch(function () {
        t.listeners.forEach(function (t) {
          t(e);
        });
      });
    }),
    (n.onFocus = function () {
      this.resumePausedMutations();
    }),
    (n.onOnline = function () {
      this.resumePausedMutations();
    }),
    (n.resumePausedMutations = function () {
      var e = this.mutations.filter(function (e) {
        return e.state.isPaused;
      });
      return fF.batch(function () {
        return e.reduce(function (e, t) {
          return e.then(function () {
            return t.continue().catch(ND);
          });
        }, Promise.resolve());
      });
    }),
    t
  );
})(FD);
export function vF() {
  return {
    onFetch: function (e) {
      e.fetchFn = function () {
        var t,
          n,
          s,
          i,
          o,
          r,
          a,
          l =
            null == (t = e.fetchOptions) || null == (n = t.meta)
              ? undefined
              : n.refetchPage,
          c =
            null == (s = e.fetchOptions) || null == (i = s.meta)
              ? undefined
              : i.fetchMore,
          u = null == c ? undefined : c.pageParam,
          d = "forward" === (null == c ? undefined : c.direction),
          p = "backward" === (null == c ? undefined : c.direction),
          f = (null == (o = e.state.data) ? undefined : o.pages) || [],
          h = (null == (r = e.state.data) ? undefined : r.pageParams) || [],
          m = oF(),
          g = null == m ? undefined : m.signal,
          x = h,
          b = false,
          y =
            e.options.queryFn ||
            function () {
              return Promise.reject("Missing queryFn");
            },
          v = function (e, t, n, s) {
            return (
              (x = s ? [t].concat(x) : [].concat(x, [t])),
              s ? [n].concat(e) : [].concat(e, [n])
            );
          },
          w = function (t, n, s, i) {
            if (b) return Promise.reject("Cancelled");
            if (undefined === s && !n && t.length) return Promise.resolve(t);
            var o = {
                queryKey: e.queryKey,
                signal: g,
                pageParam: s,
                meta: e.meta,
              },
              r = y(o),
              a = Promise.resolve(r).then(function (e) {
                return v(t, s, e, i);
              });
            cF(r) && (a.cancel = r.cancel);
            return a;
          };
        if (f.length)
          if (d) {
            var k = undefined !== u,
              C = k ? u : wF(e.options, f);
            a = w(f, k, C);
          } else if (p) {
            var j = undefined !== u,
              S = j ? u : kF(e.options, f);
            a = w(f, j, S, true);
          } else
            !(function () {
              x = [];
              var t = undefined === e.options.getNextPageParam,
                n = !l || !f[0] || l(f[0], 0, f);
              a = n ? w([], t, h[0]) : Promise.resolve(v([], h[0], f[0]));
              for (
                var s = function (n) {
                    a = a.then(function (s) {
                      if (!l || !f[n] || l(f[n], n, f)) {
                        var i = t ? h[n] : wF(e.options, s);
                        return w(s, t, i);
                      }
                      return Promise.resolve(v(s, h[n], f[n]));
                    });
                  },
                  i = 1;
                i < f.length;
                i++
              )
                s(i);
            })();
        else a = w([]);
        var _ = a.then(function (e) {
          return { pages: e, pageParams: x };
        });
        return (
          (_.cancel = function () {
            (b = true), null == m || m.abort(), cF(a) && a.cancel();
          }),
          _
        );
      };
    },
  };
}
export function wF(e, t) {
  return null == e.getNextPageParam
    ? undefined
    : e.getNextPageParam(t[t.length - 1], t);
}
export function kF(e, t) {
  return null == e.getPreviousPageParam
    ? undefined
    : e.getPreviousPageParam(t[0], t);
}
export function CF(e, t) {
  if (e.getNextPageParam && Array.isArray(t)) {
    var n = wF(e, t);
    return null != n && false !== n;
  }
}
export function jF(e, t) {
  if (e.getPreviousPageParam && Array.isArray(t)) {
    var n = kF(e, t);
    return null != n && false !== n;
  }
}
export var SF = (function () {
  function e(e) {
    undefined === e && (e = {}),
      (this.queryCache = e.queryCache || new xF()),
      (this.mutationCache = e.mutationCache || new yF()),
      (this.defaultOptions = e.defaultOptions || {}),
      (this.queryDefaults = []),
      (this.mutationDefaults = []);
  }
  var t = e.prototype;
  return (
    (t.mount = function () {
      var e = this;
      (this.unsubscribeFocus = rF.subscribe(function () {
        rF.isFocused() &&
          aF.isOnline() &&
          (e.mutationCache.onFocus(), e.queryCache.onFocus());
      })),
        (this.unsubscribeOnline = aF.subscribe(function () {
          rF.isFocused() &&
            aF.isOnline() &&
            (e.mutationCache.onOnline(), e.queryCache.onOnline());
        }));
    }),
    (t.unmount = function () {
      var e, t;
      null == (e = this.unsubscribeFocus) || e.call(this),
        null == (t = this.unsubscribeOnline) || t.call(this);
    }),
    (t.isFetching = function (e, t) {
      var n = GD(e, t)[0];
      return (n.fetching = true), this.queryCache.findAll(n).length;
    }),
    (t.isMutating = function (e) {
      return this.mutationCache.findAll(ID({}, e, { fetching: true })).length;
    }),
    (t.getQueryData = function (e, t) {
      var n;
      return null == (n = this.queryCache.find(e, t))
        ? undefined
        : n.state.data;
    }),
    (t.getQueriesData = function (e) {
      return this.getQueryCache()
        .findAll(e)
        .map(function (e) {
          return [e.queryKey, e.state.data];
        });
    }),
    (t.setQueryData = function (e, t, n) {
      var s = QD(e),
        i = this.defaultQueryOptions(s);
      return this.queryCache.build(this, i).setData(t, n);
    }),
    (t.setQueriesData = function (e, t, n) {
      var s = this;
      return fF.batch(function () {
        return s
          .getQueryCache()
          .findAll(e)
          .map(function (e) {
            var i = e.queryKey;
            return [i, s.setQueryData(i, t, n)];
          });
      });
    }),
    (t.getQueryState = function (e, t) {
      var n;
      return null == (n = this.queryCache.find(e, t)) ? undefined : n.state;
    }),
    (t.removeQueries = function (e, t) {
      var n = GD(e, t)[0],
        s = this.queryCache;
      fF.batch(function () {
        s.findAll(n).forEach(function (e) {
          s.remove(e);
        });
      });
    }),
    (t.resetQueries = function (e, t, n) {
      var s = this,
        i = GD(e, t, n),
        o = i[0],
        r = i[1],
        a = this.queryCache,
        l = ID({}, o, { active: true });
      return fF.batch(function () {
        return (
          a.findAll(o).forEach(function (e) {
            e.reset();
          }),
          s.refetchQueries(l, r)
        );
      });
    }),
    (t.cancelQueries = function (e, t, n) {
      var s = this,
        i = GD(e, t, n),
        o = i[0],
        r = i[1],
        a = undefined === r ? {} : r;
      undefined === a.revert && (a.revert = true);
      var l = fF.batch(function () {
        return s.queryCache.findAll(o).map(function (e) {
          return e.cancel(a);
        });
      });
      return Promise.all(l).then(ND).catch(ND);
    }),
    (t.invalidateQueries = function (e, t, n) {
      var s,
        i,
        o,
        r = this,
        a = GD(e, t, n),
        l = a[0],
        c = a[1],
        u = ID({}, l, {
          active:
            null == (s = null != (i = l.refetchActive) ? i : l.active) || s,
          inactive: null != (o = l.refetchInactive) && o,
        });
      return fF.batch(function () {
        return (
          r.queryCache.findAll(l).forEach(function (e) {
            e.invalidate();
          }),
          r.refetchQueries(u, c)
        );
      });
    }),
    (t.refetchQueries = function (e, t, n) {
      var s = this,
        i = GD(e, t, n),
        o = i[0],
        r = i[1],
        a = fF.batch(function () {
          return s.queryCache.findAll(o).map(function (e) {
            return e.fetch(
              undefined,
              ID({}, r, {
                meta: { refetchPage: null == o ? undefined : o.refetchPage },
              })
            );
          });
        }),
        l = Promise.all(a).then(ND);
      return (null == r ? undefined : r.throwOnError) || (l = l.catch(ND)), l;
    }),
    (t.fetchQuery = function (e, t, n) {
      var s = QD(e, t, n),
        i = this.defaultQueryOptions(s);
      undefined === i.retry && (i.retry = false);
      var o = this.queryCache.build(this, i);
      return o.isStaleByTime(i.staleTime)
        ? o.fetch(i)
        : Promise.resolve(o.state.data);
    }),
    (t.prefetchQuery = function (e, t, n) {
      return this.fetchQuery(e, t, n).then(ND).catch(ND);
    }),
    (t.fetchInfiniteQuery = function (e, t, n) {
      var s = QD(e, t, n);
      return (s.behavior = vF()), this.fetchQuery(s);
    }),
    (t.prefetchInfiniteQuery = function (e, t, n) {
      return this.fetchInfiniteQuery(e, t, n).then(ND).catch(ND);
    }),
    (t.cancelMutations = function () {
      var e = this,
        t = fF.batch(function () {
          return e.mutationCache.getAll().map(function (e) {
            return e.cancel();
          });
        });
      return Promise.all(t).then(ND).catch(ND);
    }),
    (t.resumePausedMutations = function () {
      return this.getMutationCache().resumePausedMutations();
    }),
    (t.executeMutation = function (e) {
      return this.mutationCache.build(this, e).execute();
    }),
    (t.getQueryCache = function () {
      return this.queryCache;
    }),
    (t.getMutationCache = function () {
      return this.mutationCache;
    }),
    (t.getDefaultOptions = function () {
      return this.defaultOptions;
    }),
    (t.setDefaultOptions = function (e) {
      this.defaultOptions = e;
    }),
    (t.setQueryDefaults = function (e, t) {
      var n = this.queryDefaults.find(function (t) {
        return YD(e) === YD(t.queryKey);
      });
      n
        ? (n.defaultOptions = t)
        : this.queryDefaults.push({ queryKey: e, defaultOptions: t });
    }),
    (t.getQueryDefaults = function (e) {
      var t;
      return e
        ? null ==
          (t = this.queryDefaults.find(function (t) {
            return XD(e, t.queryKey);
          }))
          ? undefined
          : t.defaultOptions
        : undefined;
    }),
    (t.setMutationDefaults = function (e, t) {
      var n = this.mutationDefaults.find(function (t) {
        return YD(e) === YD(t.mutationKey);
      });
      n
        ? (n.defaultOptions = t)
        : this.mutationDefaults.push({ mutationKey: e, defaultOptions: t });
    }),
    (t.getMutationDefaults = function (e) {
      var t;
      return e
        ? null ==
          (t = this.mutationDefaults.find(function (t) {
            return XD(e, t.mutationKey);
          }))
          ? undefined
          : t.defaultOptions
        : undefined;
    }),
    (t.defaultQueryOptions = function (e) {
      if (null == e ? undefined : e._defaulted) return e;
      var t = ID(
        {},
        this.defaultOptions.queries,
        this.getQueryDefaults(null == e ? undefined : e.queryKey),
        e,
        { _defaulted: true }
      );
      return !t.queryHash && t.queryKey && (t.queryHash = KD(t.queryKey, t)), t;
    }),
    (t.defaultQueryObserverOptions = function (e) {
      return this.defaultQueryOptions(e);
    }),
    (t.defaultMutationOptions = function (e) {
      return (null == e ? undefined : e._defaulted)
        ? e
        : ID(
            {},
            this.defaultOptions.mutations,
            this.getMutationDefaults(null == e ? undefined : e.mutationKey),
            e,
            { _defaulted: true }
          );
    }),
    (t.clear = function () {
      this.queryCache.clear(), this.mutationCache.clear();
    }),
    e
  );
})();
export var _F = (function (e) {
  function t(t, n) {
    var s;
    return (
      ((s = e.call(this) || this).client = t),
      (s.options = n),
      (s.trackedProps = []),
      (s.selectError = null),
      s.bindMethods(),
      s.setOptions(n),
      s
    );
  }
  DD(t, e);
  var n = t.prototype;
  return (
    (n.bindMethods = function () {
      (this.remove = this.remove.bind(this)),
        (this.refetch = this.refetch.bind(this));
    }),
    (n.onSubscribe = function () {
      1 === this.listeners.length &&
        (this.currentQuery.addObserver(this),
        EF(this.currentQuery, this.options) && this.executeFetch(),
        this.updateTimers());
    }),
    (n.onUnsubscribe = function () {
      this.listeners.length || this.destroy();
    }),
    (n.shouldFetchOnReconnect = function () {
      return LF(
        this.currentQuery,
        this.options,
        this.options.refetchOnReconnect
      );
    }),
    (n.shouldFetchOnWindowFocus = function () {
      return LF(
        this.currentQuery,
        this.options,
        this.options.refetchOnWindowFocus
      );
    }),
    (n.destroy = function () {
      (this.listeners = []),
        this.clearTimers(),
        this.currentQuery.removeObserver(this);
    }),
    (n.setOptions = function (e, t) {
      var n = this.options,
        s = this.currentQuery;
      if (
        ((this.options = this.client.defaultQueryObserverOptions(e)),
        undefined !== this.options.enabled &&
          "boolean" != typeof this.options.enabled)
      )
        throw new Error("Expected enabled to be a boolean");
      this.options.queryKey || (this.options.queryKey = n.queryKey),
        this.updateQuery();
      var i = this.hasListeners();
      i && PF(this.currentQuery, s, this.options, n) && this.executeFetch(),
        this.updateResult(t),
        !i ||
          (this.currentQuery === s &&
            this.options.enabled === n.enabled &&
            this.options.staleTime === n.staleTime) ||
          this.updateStaleTimeout();
      var o = this.computeRefetchInterval();
      !i ||
        (this.currentQuery === s &&
          this.options.enabled === n.enabled &&
          o === this.currentRefetchInterval) ||
        this.updateRefetchInterval(o);
    }),
    (n.getOptimisticResult = function (e) {
      var t = this.client.defaultQueryObserverOptions(e),
        n = this.client.getQueryCache().build(this.client, t);
      return this.createResult(n, t);
    }),
    (n.getCurrentResult = function () {
      return this.currentResult;
    }),
    (n.trackResult = function (e, t) {
      var n = this,
        s = {},
        i = function (e) {
          n.trackedProps.includes(e) || n.trackedProps.push(e);
        };
      return (
        Object.keys(e).forEach(function (t) {
          Object.defineProperty(s, t, {
            configurable: false,
            enumerable: true,
            get: function () {
              return i(t), e[t];
            },
          });
        }),
        (t.useErrorBoundary || t.suspense) && i("error"),
        s
      );
    }),
    (n.getNextResult = function (e) {
      var t = this;
      return new Promise(function (n, s) {
        var i = t.subscribe(function (t) {
          t.isFetching ||
            (i(),
            t.isError && (null == e ? undefined : e.throwOnError)
              ? s(t.error)
              : n(t));
        });
      });
    }),
    (n.getCurrentQuery = function () {
      return this.currentQuery;
    }),
    (n.remove = function () {
      this.client.getQueryCache().remove(this.currentQuery);
    }),
    (n.refetch = function (e) {
      return this.fetch(
        ID({}, e, {
          meta: { refetchPage: null == e ? undefined : e.refetchPage },
        })
      );
    }),
    (n.fetchOptimistic = function (e) {
      var t = this,
        n = this.client.defaultQueryObserverOptions(e),
        s = this.client.getQueryCache().build(this.client, n);
      return s.fetch().then(function () {
        return t.createResult(s, n);
      });
    }),
    (n.fetch = function (e) {
      var t = this;
      return this.executeFetch(e).then(function () {
        return t.updateResult(), t.currentResult;
      });
    }),
    (n.executeFetch = function (e) {
      this.updateQuery();
      var t = this.currentQuery.fetch(this.options, e);
      return (null == e ? undefined : e.throwOnError) || (t = t.catch(ND)), t;
    }),
    (n.updateStaleTimeout = function () {
      var e = this;
      if (
        (this.clearStaleTimeout(),
        !HD && !this.currentResult.isStale && UD(this.options.staleTime))
      ) {
        var t =
          qD(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
        this.staleTimeoutId = setTimeout(function () {
          e.currentResult.isStale || e.updateResult();
        }, t);
      }
    }),
    (n.computeRefetchInterval = function () {
      var e;
      return "function" == typeof this.options.refetchInterval
        ? this.options.refetchInterval(
            this.currentResult.data,
            this.currentQuery
          )
        : null != (e = this.options.refetchInterval) && e;
    }),
    (n.updateRefetchInterval = function (e) {
      var t = this;
      this.clearRefetchInterval(),
        (this.currentRefetchInterval = e),
        !HD &&
          false !== this.options.enabled &&
          UD(this.currentRefetchInterval) &&
          0 !== this.currentRefetchInterval &&
          (this.refetchIntervalId = setInterval(function () {
            (t.options.refetchIntervalInBackground || rF.isFocused()) &&
              t.executeFetch();
          }, this.currentRefetchInterval));
    }),
    (n.updateTimers = function () {
      this.updateStaleTimeout(),
        this.updateRefetchInterval(this.computeRefetchInterval());
    }),
    (n.clearTimers = function () {
      this.clearStaleTimeout(), this.clearRefetchInterval();
    }),
    (n.clearStaleTimeout = function () {
      this.staleTimeoutId &&
        (clearTimeout(this.staleTimeoutId), (this.staleTimeoutId = undefined));
    }),
    (n.clearRefetchInterval = function () {
      this.refetchIntervalId &&
        (clearInterval(this.refetchIntervalId),
        (this.refetchIntervalId = undefined));
    }),
    (n.createResult = function (e, t) {
      var n,
        s = this.currentQuery,
        i = this.options,
        o = this.currentResult,
        r = this.currentResultState,
        a = this.currentResultOptions,
        l = e !== s,
        c = l ? e.state : this.currentQueryInitialState,
        u = l ? this.currentResult : this.previousQueryResult,
        d = e.state,
        p = d.dataUpdatedAt,
        f = d.error,
        h = d.errorUpdatedAt,
        m = d.isFetching,
        g = d.status,
        x = false,
        b = false;
      if (t.optimisticResults) {
        var y = this.hasListeners(),
          v = !y && EF(e, t),
          w = y && PF(e, s, t, i);
        (v || w) && ((m = true), p || (g = "loading"));
      }
      if (
        t.keepPreviousData &&
        !d.dataUpdateCount &&
        (null == u ? undefined : u.isSuccess) &&
        "error" !== g
      )
        (n = u.data), (p = u.dataUpdatedAt), (g = u.status), (x = true);
      else if (t.select && undefined !== d.data)
        if (
          o &&
          d.data === (null == r ? undefined : r.data) &&
          t.select === this.selectFn
        )
          n = this.selectResult;
        else
          try {
            (this.selectFn = t.select),
              (n = t.select(d.data)),
              false !== t.structuralSharing &&
                (n = eF(null == o ? undefined : o.data, n)),
              (this.selectResult = n),
              (this.selectError = null);
          } catch (e) {
            mF().error(e), (this.selectError = e);
          }
      else n = d.data;
      if (
        undefined !== t.placeholderData &&
        undefined === n &&
        ("loading" === g || "idle" === g)
      ) {
        var k;
        if (
          (null == o ? undefined : o.isPlaceholderData) &&
          t.placeholderData === (null == a ? undefined : a.placeholderData)
        )
          k = o.data;
        else if (
          ((k =
            "function" == typeof t.placeholderData
              ? t.placeholderData()
              : t.placeholderData),
          t.select && undefined !== k)
        )
          try {
            (k = t.select(k)),
              false !== t.structuralSharing &&
                (k = eF(null == o ? undefined : o.data, k)),
              (this.selectError = null);
          } catch (e) {
            mF().error(e), (this.selectError = e);
          }
        undefined !== k && ((g = "success"), (n = k), (b = true));
      }
      return (
        this.selectError &&
          ((f = this.selectError),
          (n = this.selectResult),
          (h = Date.now()),
          (g = "error")),
        {
          status: g,
          isLoading: "loading" === g,
          isSuccess: "success" === g,
          isError: "error" === g,
          isIdle: "idle" === g,
          data: n,
          dataUpdatedAt: p,
          error: f,
          errorUpdatedAt: h,
          failureCount: d.fetchFailureCount,
          errorUpdateCount: d.errorUpdateCount,
          isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
          isFetchedAfterMount:
            d.dataUpdateCount > c.dataUpdateCount ||
            d.errorUpdateCount > c.errorUpdateCount,
          isFetching: m,
          isRefetching: m && "loading" !== g,
          isLoadingError: "error" === g && 0 === d.dataUpdatedAt,
          isPlaceholderData: b,
          isPreviousData: x,
          isRefetchError: "error" === g && 0 !== d.dataUpdatedAt,
          isStale: AF(e, t),
          refetch: this.refetch,
          remove: this.remove,
        }
      );
    }),
    (n.shouldNotifyListeners = function (e, t) {
      if (!t) return true;
      var n = this.options,
        s = n.notifyOnChangeProps,
        i = n.notifyOnChangePropsExclusions;
      if (!s && !i) return true;
      if ("tracked" === s && !this.trackedProps.length) return true;
      var o = "tracked" === s ? this.trackedProps : s;
      return Object.keys(e).some(function (n) {
        var s = n,
          r = e[s] !== t[s],
          a =
            null == o
              ? undefined
              : o.some(function (e) {
                  return e === n;
                }),
          l =
            null == i
              ? undefined
              : i.some(function (e) {
                  return e === n;
                });
        return r && !l && (!o || a);
      });
    }),
    (n.updateResult = function (e) {
      var t = this.currentResult;
      if (
        ((this.currentResult = this.createResult(
          this.currentQuery,
          this.options
        )),
        (this.currentResultState = this.currentQuery.state),
        (this.currentResultOptions = this.options),
        !(function (e, t) {
          if ((e && !t) || (t && !e)) return false;
          for (var n in e) if (e[n] !== t[n]) return false;
          return true;
        })(this.currentResult, t))
      ) {
        var n = { cache: true };
        false !== (null == e ? undefined : e.listeners) &&
          this.shouldNotifyListeners(this.currentResult, t) &&
          (n.listeners = true),
          this.notify(ID({}, n, e));
      }
    }),
    (n.updateQuery = function () {
      var e = this.client.getQueryCache().build(this.client, this.options);
      if (e !== this.currentQuery) {
        var t = this.currentQuery;
        (this.currentQuery = e),
          (this.currentQueryInitialState = e.state),
          (this.previousQueryResult = this.currentResult),
          this.hasListeners() &&
            (null == t || t.removeObserver(this), e.addObserver(this));
      }
    }),
    (n.onQueryUpdate = function (e) {
      var t = {};
      "success" === e.type
        ? (t.onSuccess = true)
        : "error" !== e.type || dF(e.error) || (t.onError = true),
        this.updateResult(t),
        this.hasListeners() && this.updateTimers();
    }),
    (n.notify = function (e) {
      var t = this;
      fF.batch(function () {
        e.onSuccess
          ? (null == t.options.onSuccess ||
              t.options.onSuccess(t.currentResult.data),
            null == t.options.onSettled ||
              t.options.onSettled(t.currentResult.data, null))
          : e.onError &&
            (null == t.options.onError ||
              t.options.onError(t.currentResult.error),
            null == t.options.onSettled ||
              t.options.onSettled(undefined, t.currentResult.error)),
          e.listeners &&
            t.listeners.forEach(function (e) {
              e(t.currentResult);
            }),
          e.cache &&
            t.client.getQueryCache().notify({
              query: t.currentQuery,
              type: "observerResultsUpdated",
            });
      });
    }),
    t
  );
})(FD);
export function EF(e, t) {
  return (
    (function (e, t) {
      return !(
        false === t.enabled ||
        e.state.dataUpdatedAt ||
        ("error" === e.state.status && false === t.retryOnMount)
      );
    })(e, t) ||
    (e.state.dataUpdatedAt > 0 && LF(e, t, t.refetchOnMount))
  );
}
export function LF(e, t, n) {
  if (false !== t.enabled) {
    var s = "function" == typeof n ? n(e) : n;
    return "always" === s || (false !== s && AF(e, t));
  }
  return false;
}
export function PF(e, t, n, s) {
  return (
    false !== n.enabled &&
    (e !== t || false === s.enabled) &&
    (!n.suspense || "error" !== e.state.status) &&
    AF(e, n)
  );
}
export function AF(e, t) {
  return e.isStaleByTime(t.staleTime);
}
export var BF = (function (e) {
  function t(t, n) {
    var s;
    return (
      ((s = e.call(this) || this).client = t),
      (s.queries = []),
      (s.result = []),
      (s.observers = []),
      (s.observersMap = {}),
      n && s.setQueries(n),
      s
    );
  }
  DD(t, e);
  var n = t.prototype;
  return (
    (n.onSubscribe = function () {
      var e = this;
      1 === this.listeners.length &&
        this.observers.forEach(function (t) {
          t.subscribe(function (n) {
            e.onUpdate(t, n);
          });
        });
    }),
    (n.onUnsubscribe = function () {
      this.listeners.length || this.destroy();
    }),
    (n.destroy = function () {
      (this.listeners = []),
        this.observers.forEach(function (e) {
          e.destroy();
        });
    }),
    (n.setQueries = function (e, t) {
      (this.queries = e), this.updateObservers(t);
    }),
    (n.getCurrentResult = function () {
      return this.result;
    }),
    (n.getOptimisticResult = function (e) {
      return this.findMatchingObservers(e).map(function (e) {
        return e.observer.getOptimisticResult(e.defaultedQueryOptions);
      });
    }),
    (n.findMatchingObservers = function (e) {
      var t = this,
        n = this.observers,
        s = e.map(function (e) {
          return t.client.defaultQueryObserverOptions(e);
        }),
        i = s.flatMap(function (e) {
          var t = n.find(function (t) {
            return t.options.queryHash === e.queryHash;
          });
          return null != t ? [{ defaultedQueryOptions: e, observer: t }] : [];
        }),
        o = i.map(function (e) {
          return e.defaultedQueryOptions.queryHash;
        }),
        r = s.filter(function (e) {
          return !o.includes(e.queryHash);
        }),
        a = n.filter(function (e) {
          return !i.some(function (t) {
            return t.observer === e;
          });
        }),
        l = r.map(function (e, n) {
          if (e.keepPreviousData) {
            var s = a[n];
            if (undefined !== s)
              return { defaultedQueryOptions: e, observer: s };
          }
          return { defaultedQueryOptions: e, observer: t.getObserver(e) };
        });
      return i.concat(l).sort(function (e, t) {
        return (
          s.indexOf(e.defaultedQueryOptions) -
          s.indexOf(t.defaultedQueryOptions)
        );
      });
    }),
    (n.getObserver = function (e) {
      var t = this.client.defaultQueryObserverOptions(e),
        n = this.observersMap[t.queryHash];
      return null != n ? n : new _F(this.client, t);
    }),
    (n.updateObservers = function (e) {
      var t = this;
      fF.batch(function () {
        var n = t.observers,
          s = t.findMatchingObservers(t.queries);
        s.forEach(function (t) {
          return t.observer.setOptions(t.defaultedQueryOptions, e);
        });
        var i = s.map(function (e) {
            return e.observer;
          }),
          o = Object.fromEntries(
            i.map(function (e) {
              return [e.options.queryHash, e];
            })
          ),
          r = i.map(function (e) {
            return e.getCurrentResult();
          }),
          a = i.some(function (e, t) {
            return e !== n[t];
          });
        (n.length !== i.length || a) &&
          ((t.observers = i),
          (t.observersMap = o),
          (t.result = r),
          t.hasListeners() &&
            ($D(n, i).forEach(function (e) {
              e.destroy();
            }),
            $D(i, n).forEach(function (e) {
              e.subscribe(function (n) {
                t.onUpdate(e, n);
              });
            }),
            t.notify()));
      });
    }),
    (n.onUpdate = function (e, t) {
      var n = this.observers.indexOf(e);
      -1 !== n &&
        ((this.result = (function (e, t, n) {
          var s = e.slice(0);
          return (s[t] = n), s;
        })(this.result, n, t)),
        this.notify());
    }),
    (n.notify = function () {
      var e = this;
      fF.batch(function () {
        e.listeners.forEach(function (t) {
          t(e.result);
        });
      });
    }),
    t
  );
})(FD);
export var TF = (function (e) {
  function t(t, n) {
    return e.call(this, t, n) || this;
  }
  DD(t, e);
  var n = t.prototype;
  return (
    (n.bindMethods = function () {
      e.prototype.bindMethods.call(this),
        (this.fetchNextPage = this.fetchNextPage.bind(this)),
        (this.fetchPreviousPage = this.fetchPreviousPage.bind(this));
    }),
    (n.setOptions = function (t, n) {
      e.prototype.setOptions.call(this, ID({}, t, { behavior: vF() }), n);
    }),
    (n.getOptimisticResult = function (t) {
      return (t.behavior = vF()), e.prototype.getOptimisticResult.call(this, t);
    }),
    (n.fetchNextPage = function (e) {
      var t;
      return this.fetch({
        cancelRefetch:
          null == (t = null == e ? undefined : e.cancelRefetch) || t,
        throwOnError: null == e ? undefined : e.throwOnError,
        meta: {
          fetchMore: {
            direction: "forward",
            pageParam: null == e ? undefined : e.pageParam,
          },
        },
      });
    }),
    (n.fetchPreviousPage = function (e) {
      var t;
      return this.fetch({
        cancelRefetch:
          null == (t = null == e ? undefined : e.cancelRefetch) || t,
        throwOnError: null == e ? undefined : e.throwOnError,
        meta: {
          fetchMore: {
            direction: "backward",
            pageParam: null == e ? undefined : e.pageParam,
          },
        },
      });
    }),
    (n.createResult = function (t, n) {
      var s,
        i,
        o,
        r,
        a,
        l,
        c = t.state;
      return ID({}, e.prototype.createResult.call(this, t, n), {
        fetchNextPage: this.fetchNextPage,
        fetchPreviousPage: this.fetchPreviousPage,
        hasNextPage: CF(n, null == (s = c.data) ? undefined : s.pages),
        hasPreviousPage: jF(n, null == (i = c.data) ? undefined : i.pages),
        isFetchingNextPage:
          c.isFetching &&
          "forward" ===
            (null == (o = c.fetchMeta) || null == (r = o.fetchMore)
              ? undefined
              : r.direction),
        isFetchingPreviousPage:
          c.isFetching &&
          "backward" ===
            (null == (a = c.fetchMeta) || null == (l = a.fetchMore)
              ? undefined
              : l.direction),
      });
    }),
    t
  );
})(_F);
fF.setBatchNotifyFunction(MF);
export var OF = console;
hF = OF;

export var VF = RF.default.createContext(undefined);
export var DF = RF.default.createContext(false);
export function FF(e) {
  return e && "undefined" != typeof window
    ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = VF),
      window.ReactQueryClientContext)
    : VF;
}
export var IF = function () {
  var e = RF.default.useContext(FF(RF.default.useContext(DF)));
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
};

export var UF;
export var zF = NF.default.createContext(
  ((UF = false),
  {
    clearReset: function () {
      UF = false;
    },
    reset: function () {
      UF = true;
    },
    isReset: function () {
      return UF;
    },
  })
);
export var $F = function () {
  return NF.default.useContext(zF);
};

export function QF(e, t) {
  var n = qF.default.useRef(false),
    s = qF.default.useState(0)[1],
    i = IF(),
    o = $F(),
    r = i.defaultQueryObserverOptions(e);
  (r.optimisticResults = true),
    r.onError && (r.onError = fF.batchCalls(r.onError)),
    r.onSuccess && (r.onSuccess = fF.batchCalls(r.onSuccess)),
    r.onSettled && (r.onSettled = fF.batchCalls(r.onSettled)),
    r.suspense &&
      ("number" != typeof r.staleTime && (r.staleTime = 1e3),
      0 === r.cacheTime && (r.cacheTime = 1)),
    (r.suspense || r.useErrorBoundary) &&
      (o.isReset() || (r.retryOnMount = false));
  var a,
    l,
    c,
    u = qF.default.useState(function () {
      return new t(i, r);
    })[0],
    d = u.getOptimisticResult(r);
  if (
    (qF.default.useEffect(
      function () {
        (n.current = true), o.clearReset();
        var e = u.subscribe(
          fF.batchCalls(function () {
            n.current &&
              s(function (e) {
                return e + 1;
              });
          })
        );
        return (
          u.updateResult(),
          function () {
            (n.current = false), e();
          }
        );
      },
      [o, u]
    ),
    qF.default.useEffect(
      function () {
        u.setOptions(r, { listeners: false });
      },
      [r, u]
    ),
    r.suspense && d.isLoading)
  )
    throw u
      .fetchOptimistic(r)
      .then(function (e) {
        var t = e.data;
        null == r.onSuccess || r.onSuccess(t),
          null == r.onSettled || r.onSettled(t, null);
      })
      .catch(function (e) {
        o.clearReset(),
          null == r.onError || r.onError(e),
          null == r.onSettled || r.onSettled(undefined, e);
      });
  if (
    d.isError &&
    !o.isReset() &&
    !d.isFetching &&
    ((a = r.suspense),
    (l = r.useErrorBoundary),
    (c = [d.error, u.getCurrentQuery()]),
    "function" == typeof l
      ? l.apply(undefined, c)
      : "boolean" == typeof l
      ? l
      : a)
  )
    throw d.error;
  return "tracked" === r.notifyOnChangeProps && (d = u.trackResult(d, r)), d;
}
export function GF(e, t, n) {
  return QF(QD(e, t, n), _F);
}
export function KF() {
  const e = DO(),
    [t, n] = possibleHook3(e.settings.roles.regularRole),
    [s, i] = possibleHook3(e.settings.roles.previewRole),
    [o] = possibleHook3(e.settings.roles.effectiveRole);
  return [
    o,
    {
      configuredRole: t,
      setConfiguredRole: n,
      previewRole: s,
      setPreviewRole: i,
    },
  ];
}
export var YF = function () {
  return DO().engine;
};

export function eI(e, t, n = { equals: XF.default }) {
  const { debugName: s, equals: i } = n,
    o = (0, JF.useRef)(t);
  o.current = t;
  const r = (0, JF.useRef)({ reaction: nI, engine: undefined }),
    [, a] = (0, JF.useState)(0);
  if (r.current.engine !== e)
    if (e) {
      const t = e.reactor.createReaction(s);
      r.current = { reaction: t, engine: e };
    } else r.current = { reaction: nI, engine: e };
  const l = r.current.reaction,
    c = (0, JF.useMemo)(() => {
      const t = () => (0, o.current)(e);
      return (function (e, t) {
        if (!t) return e;
        let n;
        return (...s) => {
          const i = e(...s);
          return t(i, n) || (n = i), n;
        };
      })(() => l.track(t), i);
    }, [l, i, e]),
    u = c();
  return (
    (0, JF.useEffect)(
      () =>
        l.subscribe(function () {
          a((e) => e + 1);
        }),
      [l]
    ),
    u
  );
}
export var tI = (e, t) => e === t;
export var nI = { track: (e) => e(), subscribe: () => function () {} };
export var WithEngineComp = function WithEngine(e, t) {
  return (function (e, t) {
    const n = t?.debugName,
      s = t?.useEngine;
    let i = 0;
    function o(t, o, ...r) {
      const a = s?.() ?? t.engine,
        l = (0, JF.useRef)();
      return (
        undefined === l.current && null != n && (l.current = n + i++),
        eI(a, e.bind(undefined, { ...t, engine: a }, o, ...r), {
          debugName: l.current,
          equals: tI,
        }) ?? null
      );
    }
    return (o.displayName = `withEngine(${e.displayName || e.name})`), o;
  })(e, { ...t, useEngine: YF });
};
export var iI = {
  "editor/inspect": ["Creator", "Adopter"],
  "editor/present": ["Presenter"],
  "editor/managePages": ["Creator"],
  "editor/zoom": ["Creator", "Adopter", "Presenter"],
  "ui/placeholder": ["Creator"],
  "ui/group": ["Creator"],
  "ui/copyPasteScene": ["Creator"],
  "ui/replaceAssetOnSelect": ["Adopter"],
  "ui/manageExportable": ["Creator"],
  "ui/fixLayers": ["Creator"],
  "ui/inspectScene": ["Creator"],
};
export function oI(e) {
  const [t] = KF();
  return iI[e].includes(t);
}
export function rI(e, t) {
  const n = YF();
  return eI(n, () =>
    null == t && null == (t = n.block.findAllSelected()[0])
      ? !!Array.isArray(e) && Array(e.length).fill(false)
      : Array.isArray(e)
      ? e.map((e) => n.block.isAllowedByScope(t, e))
      : n.block.isAllowedByScope(t, e)
  );
}
export var aI, lI;

export function dI() {
  const [e, t] = (0, cI.useState)(lI ?? { state: "pending" });
  return (
    (0, cI.useEffect)(() => {
      let e = true;
      return (
        (async function () {
          return (
            (aI ??= supportsVideoExport().then(
              (e) =>
                (lI = e
                  ? { state: "supported", supported: e }
                  : { state: "unsupported", supported: e }),
              (e) => (lI = { state: "unsupported", error: e, supported: false })
            )),
            aI
          );
        })().then((n) => {
          e && t(n);
        }),
        () => {
          e = false;
        }
      );
    }, []),
    e
  );
}
(window.Cypress || window.IS_PLAYWRIGHT) &&
  ((lI = { state: "supported", supported: true }), (aI = Promise.resolve(lI)));
export var pI = new SF({
  defaultOptions: { queries: { refetchOnWindowFocus: false } },
});

export var mI = -1;
export var gI = _B((e, t) => {
  e.requestFocusForDesignElementId = t;
});
export var xI = () => {
  const e = DO(),
    t = KR();
  return {
    clearFocusRequest: () => {
      t.clearFocusRequest();
    },
    focusElement: (e) => {
      t.requestFocus(e);
    },
    focusSelectedElement: () => {
      const [n] = e.engine.block.findAllSelected();
      t.requestFocus(n);
    },
    focusSelectedElementOrDocument: () => {
      const [n] = e.engine.block.findAllSelected();
      t.requestFocus(n ?? mI);
    },
    focusDocument: () => {
      t.requestFocus(mI);
    },
  };
};

export var PI = (0, _I.forwardRef)(function (
  { scope: e, label: t, className: n, ...s },
  i
) {
  const o = (0, _I.useRef)(null),
    { registerScope: r, unregisterScope: a, getScope: l } = useShortcutScope();
  return (
    (0, _I.useEffect)(() => {
      const t = o.current;
      if (!t) return;
      r(e, t);
      const n = document.getElementById("root-shadow"),
        s = rm && n?.shadowRoot ? n.shadowRoot : document;
      let i = false;
      const c = () => {
          i = true;
        },
        u = () => {
          i = false;
        },
        d = (t) => {
          i &&
            l(e)?.callbacks.forEach((e) => {
              e(t, s.activeElement);
            });
        };
      return (
        t.addEventListener("focus", c, true),
        t.addEventListener("blur", u, true),
        t.addEventListener("keydown", d),
        () => {
          t.removeEventListener("focus", c, true),
            t.removeEventListener("blur", u, true),
            t.removeEventListener("keydown", d),
            a(e);
        }
      );
    }, [l, r, e, a]),
    (0, LI.jsx)("div", {
      tabIndex: -1,
      role: "region",
      "aria-label": t,
      className: (0, SI.default)(EI, n),
      ref: Qg(o, i),
      ...s,
    })
  );
});
export var AI = "video-timeline";
export var BI = "editor";

export var FI = () => (0, DI.useContext)(WF);

export function HI(e) {
  const { a11y: t } = FI();
  return (0, II.jsx)(Ex, { ...e, start: t.headingsHierarchyStart });
}

export var UI = (e, t) => e.filter((e) => t.some((t) => e.type === t));
export var $I = (e) => {
  const t = FI(),
    { callback: n, options: s } = uploadHandler(t);
  return [
    n,
    {
      supportedMimeTypes: s.supportedMimeTypes
        ? s.supportedMimeTypes.filter((t) => e?.includes(t))
        : e,
      ...s,
    },
  ];
};

export var SetUploadContext = (0, qI.createContext)({
  setUpload: aV,
  setUploadError: aV,
  setUploadProgress: aV,
});
export var UploadContext = (0, qI.createContext)({
  upload: [],
  uploadError: undefined,
  uploadProgress: 0,
});
export function useSetUploadContext() {
  return (0, qI.useContext)(SetUploadContext);
}
export var YI = (e) => {
  const t = {};
  return (n, s) => {
    const i = s.size / e;
    t[s.name] = n * i;
    const o = Object.values(t).reduce((e, t) => e + t, 0);
    return { progress: o, track: (e) => e(o) };
  };
};
export var XI = (e) => {
  const {
      setUpload: t,
      setUploadProgress: n,
      setUploadError: s,
    } = useSetUploadContext(),
    i = DO(),
    [o, r] = $I(e);
  return {
    uploadHandler: (0, zI.useCallback)(
      (e) => async (r) => {
        try {
          if (o && r.length > 0) {
            e?.hideUploadModal || t(r.map(({ file: e }) => e));
            const s = r.reduce((e, { file: t }) => e + t.size, 0),
              a = YI(s),
              l = await Promise.all(
                r.map(
                  ({
                    file: t,
                    addToAssetSource: s,
                    skipRegister: r,
                    applyAssetAfterUpload: l,
                    applyAssetTarget: c,
                    size: u,
                  }) =>
                    i.uploadAsset(
                      t,
                      (s) => {
                        e?.hideUploadModal || a(s, t).track(n);
                      },
                      o,
                      {
                        size: u,
                        addToAssetSource: s,
                        skipRegister: r,
                        applyAssetAfterUpload: l,
                        applyAssetTarget: c,
                      }
                    )
                )
              );
            return e?.hideUploadModal || (t(undefined), n(undefined)), l;
          }
        } catch (t) {
          e?.hideUploadModal || s(String(t));
        }
        return Promise.resolve([]);
      },
      [o]
    ),
    uploadEnabled: !!o,
    uploadOptions: { supportedMimeTypes: r.supportedMimeTypes },
  };
};
export var JI = () => {
  const e = VO(),
    t = e.ui.findAllAssetLibraryEntries(),
    { uploadEnabled: n, uploadHandler: s, uploadOptions: i } = XI(),
    o = YF(),
    r = (0, NI.useCallback)(() => {
      const n = {};
      t.forEach((t) => {
        const s = e.ui.getAssetLibraryEntry(t);
        if (null == s) return;
        const i = o.asset.findAllSources();
        s.sourceIds.forEach((e) => {
          if (
            i.includes(e) &&
            null != s.canAdd &&
            ("function" == typeof s.canAdd ? s.canAdd(e) : s.canAdd)
          ) {
            const t = o.asset.getSupportedMimeTypes(e);
            n[e] = t;
          }
        });
      });
      return {
        allSupportedMimeTypes: Array.from(new Set(Object.values(n).flat())),
        sourcesSupportedMimeTypes: n,
      };
    }, [o.asset, t, e.ui]);
  return (0, NI.useCallback)(
    (t) => {
      if (n && t.length > 0) {
        const { allSupportedMimeTypes: n, sourcesSupportedMimeTypes: o } = r(),
          a = i.supportedMimeTypes
            ? UI(
                Array.from(t),
                i.supportedMimeTypes.filter((e) => n.includes(e))
              )
            : UI(Array.from(t), n);
        a.length > 0
          ? s()(
              a.map((e) => {
                const t = Object.keys(o).find((t) => o[t].includes(e.type));
                return {
                  file: e,
                  addToAssetSource: t ? { sourceId: t } : undefined,
                  applyAssetAfterUpload: true,
                };
              })
            )
          : e.ui.showNotification({
              type: "error",
              message: "warning.invalidType",
            });
      }
      return aV;
    },
    [e, s, n, i.supportedMimeTypes, r]
  );
};
export var eH = {
  block: "UBQ_CanvasDropLayer-module__block--jpUOe",
  isDragging: "UBQ_CanvasDropLayer-module__isDragging--ijDJs",
  isDraggingFile: "UBQ_CanvasDropLayer-module__isDraggingFile--GpNBc",
  dragOver: "UBQ_CanvasDropLayer-module__dragOver--QbKQM",
  message: "UBQ_CanvasDropLayer-module__message--XKdOW",
};

export var nH = function ({ editorContainer: e }) {
  const { t: t } = ZL(),
    { uploadEnabled: n } = XI(),
    s = JI(),
    [i, o] = (0, OI.useState)(0),
    [r, a] = (0, OI.useState)(false),
    [l, c] = (0, OI.useState)(),
    u = i > 0 && ("Files" !== l || n);
  return (
    (0, OI.useEffect)(() => {
      const t = (e) => {
          e.dataTransfer?.types.includes("Files") && c("Files"),
            e.dataTransfer?.types.includes("//ly.img.asset") &&
              c("//ly.img.asset"),
            o((e) => e + 1);
        },
        n = () => {
          o((e) => e - 1);
        },
        s = (e) => {
          e.dataTransfer?.types.includes("Files") && e.preventDefault();
        },
        i = (e) => {
          e.preventDefault(), o(0), a(false);
        };
      return (
        e.addEventListener("dragenter", t, false),
        e.addEventListener("dragleave", n, false),
        e.addEventListener("dragover", s, false),
        e.addEventListener("drop", i, false),
        () => {
          e.removeEventListener("dragenter", t, false),
            e.removeEventListener("dragleave", n, false),
            e.removeEventListener("dragover", s, false),
            e.removeEventListener("drop", i, false);
        }
      );
    }, [e]),
    (0, tH.jsx)(DynamicPresenceTransition, {
      children:
        u &&
        (0, tH.jsx)(Sd.div, {
          "data-cy": "canvas-drop-layer",
          initial: { opacity: 0 },
          animate: { opacity: 1 },
          exit: { opacity: 0 },
          transition: { duration: 0.15 },
          className: (0, MI.default)(eH.block, {
            [eH.isDragging]: u,
            [eH.isDraggingFile]: u && "Files" === l,
            [eH.dragOver]: r,
          }),
          onDragOver: (e) => {
            e.dataTransfer.types.includes("//ly.img.asset") &&
              e.preventDefault(),
              e.dataTransfer.types.includes("Files") && n && e.preventDefault();
          },
          onDragEnter: () => {
            a(true);
          },
          onDragLeave: () => {
            a(false);
          },
          onDrop: (e) => {
            e.dataTransfer.types.includes("//ly.img.asset") &&
              e.preventDefault(),
              e.dataTransfer.types.includes("Files") &&
                (e.preventDefault(), s(e.dataTransfer.files)),
              a(false);
          },
          children:
            "Files" === l &&
            (0, tH.jsxs)("div", {
              className: eH.message,
              children: [
                (0, tH.jsx)(IconUpload, { width: "32px", height: "32px" }),
                (0, tH.jsxs)("div", {
                  children: [
                    (0, tH.jsx)(HI, {
                      level: 1,
                      className: eH.heading,
                      children: t("component.dnd.prompt"),
                    }),
                    (0, tH.jsx)("p", {
                      children: t("component.dnd.description"),
                    }),
                  ],
                }),
              ],
            }),
        }),
    })
  );
};

export var rH = (e, t) => {
  switch (e) {
    case "//ly.img.ubq/page":
      return t("block.page");
    case "//ly.img.ubq/text":
      return t("block.text");
    case "//ly.img.ubq/group":
      return t("block.group");
    case "//ly.img.ubq/scene":
      return t("block.scene");
    case "//ly.img.ubq/audio":
      return t("block.audio");
    case "//ly.img.ubq/graphic":
      return t("block.graphic");
    default:
      return e;
  }
};
export var lH = () => {
  const e = DO(),
    { focusSelectedElement: t } = xI();
  return (0, aH.useMemo)(() => {
    const n = (t) => (n) =>
      e.legacyApi.sendKey({
        key: t,
        altKey: n.altKey,
        ctrlKey: n.ctrlKey,
        metaKey: n.metaKey,
        shiftKey: n.shiftKey,
      });
    return {
      up: n("arrowup"),
      down: n("arrowdown"),
      left: n("arrowleft"),
      right: n("arrowright"),
      enter: ((s = "enter"), (e) => n(s)(e).then(t)),
    };
    var s;
  }, [e, t]);
};

export var uH = "layer/move";
export var dH = "layer/resize";
export var pH = "layer/rotate";
export var fH = "layer/flip";
export var hH = "layer/crop";
export var mH = "layer/opacity";
export var gH = "layer/blendMode";
export var xH = "appearance/adjustments";
export var bH = "appearance/filter";
export var yH = "appearance/effect";
export var vH = "appearance/blur";
export var wH = "appearance/shadow";
export var kH = "appearance/animation";
export var CH = "text/edit";
export var jH = "text/character";
export var SH = "fill/change";
export var _H = "fill/changeType";
export var EH = "stroke/change";
export var LH = "shape/change";
export var PH = "lifecycle/destroy";
export var AH = "lifecycle/duplicate";
export var BH = "editor/select";
export var TH = () => {
  const e = YF(),
    { focusElement: t, focusDocument: n } = xI();
  return (0, cH.useMemo)(
    () => ({
      escape: async () => {
        const [s] = e.block.findAllSelected();
        if (!s) return;
        const i = e.block.getParent(s);
        if (!i) return;
        const o = "//ly.img.ubq/group" === e.block.getType(i),
          r = e.block.isAllowedByScope(i, BH);
        o && r
          ? (e.block.select(i), t(i))
          : (e.block
              .findAllSelected()
              .forEach((t) => e.block.setSelected(t, false)),
            n());
      },
    }),
    [e.block, n, t]
  );
};

export var RH = "canvas-action";
export var VH = `button[data-ubq-action=${RH}]`;
export var DH = (e, t, n) => {
  const s = t?.querySelector(VH);
  s && s.focus ? s.focus() : gI(e, n || mI);
};

export var HH = mayBeUseMemp(
  ({
    element: e,
    storeButtonRefCallback: t,
    clearFocusRequest: n,
    containerRef: s,
  }) => {
    const i = DO(),
      o = KR(),
      { requestFocusForDesignElementId: r } = o,
      { t: a } = ZL(),
      [l] = possibleHook3(i.channels.editor.editMode),
      c = !("Transform" === l),
      u = rH(e.type, a);
    return (0, IH.jsx)("button", {
      ref: (n) => t(e.id, n),
      type: "button",
      disabled: c,
      onFocus: async () => {
        const t = "//ly.img.ubq/page" === e.type,
          s = e.id,
          o = i.engine.scene.getCurrentPage(),
          a = i.engine.block.findAllSelected().length > 1;
        t &&
          s !== o &&
          null != s &&
          i.engine.block.isValid(s) &&
          !a &&
          i.scrollToPage(s),
          a || (r ? n() : i.engine.block.select(e.id));
      },
      onClick: () => {
        s && s.current && DH(o, s.current, e.id);
      },
      "aria-label": `${a("common.edit")}: ${u}`,
      "data-ubq-canvas-layer-id": e.id.toString(),
    });
  }
);
export var NH = sH.memo(
  mayBeUseMemp(function ({ containerRef: e }) {
    const { t: t } = ZL(),
      n = DO(),
      s = KR(),
      { requestFocusForDesignElementId: i } = s,
      { clearFocusRequest: o } = xI(),
      r = (0, iH.useRef)({}),
      a = nD(),
      l = a.filter(
        (e) => "//ly.img.ubq/track" !== e.type && (e.selectable || false)
      ),
      c = (e) => {
        ((e) => undefined !== r.current[e])(e) &&
          ((e) => {
            const t = r.current[e];
            t?.focus({ preventScroll: true });
          })(e);
      },
      u = (e, t) => {
        null !== t && (r.current[e] = t);
      };
    (0, iH.useEffect)(() => {
      i && c(i);
    }, [i, a]);
    const d = (0, iH.useRef)(null);
    YE({ elementRef: d, ...TH(), ...lH() });
    const p = undefined === s.activeGroup;
    return (0, IH.jsxs)("div", {
      className: FH,
      ref: d,
      children: [
        p
          ? (0, IH.jsx)(
              "button",
              {
                ref: (e) => {
                  u(mI, e);
                },
                type: "button",
                onFocus: () => {
                  i
                    ? o()
                    : n.engine.block
                        .findAllSelected()
                        .forEach((e) => n.engine.block.setSelected(e, false));
                },
                onClick: () => {
                  const e = document.getElementsByClassName(MH)[0];
                  if (e) {
                    const t = (0, oH.tabbable)(e)[0];
                    t && t.focus && t.focus();
                  }
                },
                "aria-label": `${t("common.edit")}: ${rH(
                  "//ly.img.ubq/scene",
                  t
                )}`,
                "data-ubq-canvas-layer-id": mI,
              },
              mI
            )
          : null,
        l.map((t) =>
          (0, IH.jsx)(
            HH,
            {
              element: t,
              containerRef: e,
              clearFocusRequest: o,
              storeButtonRefCallback: u,
            },
            t.id
          )
        ),
      ],
    });
  })
);
export var UH = NH;
export var zH = {
  block: "UBQ_CanvasState-module__block--Ra7-d",
  container: "UBQ_CanvasState-module__container--WWE5C",
  message: "UBQ_CanvasState-module__message--XHJD6",
  loadingSpinner: "UBQ_CanvasState-module__loadingSpinner--L697s",
};

export function qH() {
  const { t: e } = ZL(),
    t = e("component.canvas.state.loading"),
    n = e("component.canvas.state.loading.description");
  return (0, $H.jsx)("div", {
    className: zH.block,
    children: (0, $H.jsx)("div", {
      className: zH.container,
      "data-cy": "loading-engine",
      children: (0, $H.jsxs)("div", {
        className: zH.message,
        children: [
          (0, $H.jsx)(Hh, { className: zH.loadingSpinner }),
          (0, $H.jsxs)("div", {
            className: zH.info,
            children: [
              (0, $H.jsx)(HI, { level: 1, children: t }),
              (0, $H.jsx)("p", { children: n }),
            ],
          }),
        ],
      }),
    }),
  });
}

export function sN(e) {
  const [t, n] = (0, nN.useState)(false),
    s = () => n(true),
    i = () => n(false),
    o = e.current;
  return (
    (0, nN.useEffect)(
      () =>
        o
          ? (o.addEventListener("mouseover", s),
            o.addEventListener("mouseout", i),
            () => {
              o.removeEventListener("mouseover", s),
                o.removeEventListener("mouseout", i);
            })
          : aV,
      [o]
    ),
    t
  );
}
export var iN = 20;
export function oN(e, t, n, s) {
  const i = sN(s),
    o = 2 * parseInt(xh("--ubq-scale-base"), 10),
    r = oD(),
    [a] = possibleHook3(r.camera.scrollPercentage),
    [l] = possibleHook3(r.camera.sceneSize),
    c = a[n],
    u = l[n],
    d = t - o,
    p = u / d;
  if (Number.isNaN(c) || 0 === u)
    return {
      show: false,
      disabled: true,
      handleProps: { offset: 0, size: iN },
      scrollCoefficient: p,
    };
  const f = d / u,
    h = Math.max(Math.round(f * d), iN);
  return {
    show: d < u && (e || i),
    disabled: false,
    handleProps: { offset: (c / 100) * (d - h), size: h },
    scrollCoefficient: p,
  };
}
export var aN = mayBeUseMemp(function (e) {
  const t = DO().channels.camera,
    { onDragEnd: n, onDragStart: s, isScrolling: i, bcr: o } = e,
    r = (0, GH.useRef)(null),
    {
      show: a,
      disabled: l,
      handleProps: c,
      scrollCoefficient: u,
    } = oN(i, o?.width ?? 0, "x", r),
    [d, p] = (0, GH.useState)(false),
    f = o?.x && o?.width ? o.x + o.width : 0,
    h = o?.x ?? 0,
    m = f;
  return (0, rN.jsx)("div", {
    ref: r,
    "data-cy": "scrollBarX",
    "aria-hidden": true,
    className: (0, QH.default)(WH, XH, { [tN]: l, [KH]: a }),
    onClick: (e) => {
      if (e.target !== e.currentTarget) return;
      const n = e.clientX - h - c.offset,
        s = n > 0 ? n - c.size : n;
      t.scroll({ x: s * u, y: 0 });
    },
    children: (0, rN.jsx)(ZH.DraggableCore, {
      onStart: () => {
        s(), p(true);
      },
      onStop: () => {
        n(), p(false);
      },
      onDrag: (e, n) => {
        const s = e.clientX;
        return s < h
          ? t.scroll({ x: -c.offset * u, y: 0 })
          : s > m
          ? t.scroll({ x: c.offset * u, y: 0 })
          : t.scroll({ x: n.deltaX * u, y: 0 });
      },
      children: (0, rN.jsx)("div", {
        className: (0, QH.default)(YH, XH, { [eN]: d }),
        style: {
          transform: `translate3d(${c.offset}px, 0px, 0px)`,
          width: `${c.size}px`,
        },
      }),
    }),
  });
});

export var pN = mayBeUseMemp(function (e) {
  const t = DO().channels.camera,
    { onDragEnd: n, onDragStart: s, isScrolling: i, bcr: o } = e,
    r = (0, cN.useRef)(null),
    {
      show: a,
      disabled: l,
      handleProps: c,
      scrollCoefficient: u,
    } = oN(i, o?.height ?? 0, "y", r),
    [d, p] = (0, cN.useState)(false),
    f = o?.y && o?.height ? o.y + o.height : 0,
    h = o?.y ?? 0,
    m = f;
  return (0, dN.jsx)("div", {
    ref: r,
    "data-cy": "scrollBarY",
    "aria-hidden": true,
    className: (0, lN.default)(WH, JH, { [tN]: l, [KH]: a }),
    onClick: (e) => {
      if (e.target !== e.currentTarget) return;
      const n = e.clientY - h - c.offset,
        s = n > 0 ? n - c.size : n;
      t.scroll({ y: s * u, x: 0 });
    },
    children: (0, dN.jsx)(uN.DraggableCore, {
      onStart: () => {
        s(), p(true);
      },
      onStop: () => {
        n(), p(false);
      },
      onDrag: (e, n) => {
        const s = e.clientY;
        return s < h
          ? t.scroll({ y: -c.offset * u, x: 0 })
          : s > m
          ? t.scroll({ y: c.offset * u, x: 0 })
          : t.scroll({ y: n.deltaY * u, x: 0 });
      },
      children: (0, dN.jsx)("div", {
        className: (0, lN.default)(YH, JH, { [eN]: d }),
        style: {
          transform: `translate3d(0px, ${c.offset}px, 0px)`,
          height: `${c.size}px`,
        },
      }),
    }),
  });
});
export var fN = "top";
export var hN = "bottom";
export var mN = "right";
export var gN = "left";
export var xN = "auto";
export var bN = [fN, hN, mN, gN];
export var yN = "start";
export var vN = "end";
export var wN = "clippingParents";
export var kN = "viewport";
export var CN = "popper";
export var jN = "reference";
export var SN = bN.reduce(function (e, t) {
  return e.concat([t + "-" + yN, t + "-" + vN]);
}, []);
export var _N = [].concat(bN, [xN]).reduce(function (e, t) {
  return e.concat([t, t + "-" + yN, t + "-" + vN]);
}, []);
export var EN = [
  "beforeRead",
  "read",
  "afterRead",
  "beforeMain",
  "main",
  "afterMain",
  "beforeWrite",
  "write",
  "afterWrite",
];
export function LN(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
export function PN(e) {
  if (null == e) return window;
  if ("[object Window]" !== e.toString()) {
    var t = e.ownerDocument;
    return (t && t.defaultView) || window;
  }
  return e;
}
export function AN(e) {
  return e instanceof PN(e).Element || e instanceof Element;
}
export function BN(e) {
  return e instanceof PN(e).HTMLElement || e instanceof HTMLElement;
}
export function TN(e) {
  return (
    "undefined" != typeof ShadowRoot &&
    (e instanceof PN(e).ShadowRoot || e instanceof ShadowRoot)
  );
}
export var MN = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: function (e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function (e) {
      var n = t.styles[e] || {},
        s = t.attributes[e] || {},
        i = t.elements[e];
      BN(i) &&
        LN(i) &&
        (Object.assign(i.style, n),
        Object.keys(s).forEach(function (e) {
          var t = s[e];
          false === t
            ? i.removeAttribute(e)
            : i.setAttribute(e, true === t ? "" : t);
        }));
    });
  },
  effect: function (e) {
    var t = e.state,
      n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      };
    return (
      Object.assign(t.elements.popper.style, n.popper),
      (t.styles = n),
      t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
      function () {
        Object.keys(t.elements).forEach(function (e) {
          var s = t.elements[e],
            i = t.attributes[e] || {},
            o = Object.keys(
              t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]
            ).reduce(function (e, t) {
              return (e[t] = ""), e;
            }, {});
          BN(s) &&
            LN(s) &&
            (Object.assign(s.style, o),
            Object.keys(i).forEach(function (e) {
              s.removeAttribute(e);
            }));
        });
      }
    );
  },
  requires: ["computeStyles"],
};
export function ON(e) {
  return e.split("-")[0];
}
export var RN = Math.max;
export var VN = Math.min;
export var DN = Math.round;
export function FN() {
  var e = navigator.userAgentData;
  return null != e && e.brands
    ? e.brands
        .map(function (e) {
          return e.brand + "/" + e.version;
        })
        .join(" ")
    : navigator.userAgent;
}
export function IN() {
  return !/^((?!chrome|android).)*safari/i.test(FN());
}
export function HN(e, t, n) {
  undefined === t && (t = false), undefined === n && (n = false);
  var s = e.getBoundingClientRect(),
    i = 1,
    o = 1;
  t &&
    BN(e) &&
    ((i = (e.offsetWidth > 0 && DN(s.width) / e.offsetWidth) || 1),
    (o = (e.offsetHeight > 0 && DN(s.height) / e.offsetHeight) || 1));
  var r = (AN(e) ? PN(e) : window).visualViewport,
    a = !IN() && n,
    l = (s.left + (a && r ? r.offsetLeft : 0)) / i,
    c = (s.top + (a && r ? r.offsetTop : 0)) / o,
    u = s.width / i,
    d = s.height / o;
  return {
    width: u,
    height: d,
    top: c,
    right: l + u,
    bottom: c + d,
    left: l,
    x: l,
    y: c,
  };
}
export function NN(e) {
  var t = HN(e),
    n = e.offsetWidth,
    s = e.offsetHeight;
  return (
    Math.abs(t.width - n) <= 1 && (n = t.width),
    Math.abs(t.height - s) <= 1 && (s = t.height),
    { x: e.offsetLeft, y: e.offsetTop, width: n, height: s }
  );
}
export function UN(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t)) return true;
  if (n && TN(n)) {
    var s = t;
    do {
      if (s && e.isSameNode(s)) return true;
      s = s.parentNode || s.host;
    } while (s);
  }
  return false;
}
export function zN(e) {
  return PN(e).getComputedStyle(e);
}
export function $N(e) {
  return ["table", "td", "th"].indexOf(LN(e)) >= 0;
}
export function qN(e) {
  return ((AN(e) ? e.ownerDocument : e.document) || window.document)
    .documentElement;
}
export function QN(e) {
  return "html" === LN(e)
    ? e
    : e.assignedSlot || e.parentNode || (TN(e) ? e.host : null) || qN(e);
}
export function GN(e) {
  return BN(e) && "fixed" !== zN(e).position ? e.offsetParent : null;
}
export function ZN(e) {
  for (var t = PN(e), n = GN(e); n && $N(n) && "static" === zN(n).position; )
    n = GN(n);
  return n &&
    ("html" === LN(n) || ("body" === LN(n) && "static" === zN(n).position))
    ? t
    : n ||
        (function (e) {
          var t = /firefox/i.test(FN());
          if (/Trident/i.test(FN()) && BN(e) && "fixed" === zN(e).position)
            return null;
          var n = QN(e);
          for (
            TN(n) && (n = n.host);
            BN(n) && ["html", "body"].indexOf(LN(n)) < 0;

          ) {
            var s = zN(n);
            if (
              "none" !== s.transform ||
              "none" !== s.perspective ||
              "paint" === s.contain ||
              -1 !== ["transform", "perspective"].indexOf(s.willChange) ||
              (t && "filter" === s.willChange) ||
              (t && s.filter && "none" !== s.filter)
            )
              return n;
            n = n.parentNode;
          }
          return null;
        })(e) ||
        t;
}
export function WN(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
export function KN(e, t, n) {
  return RN(e, VN(t, n));
}
export function YN(e) {
  return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e);
}
export function XN(e, t) {
  return t.reduce(function (t, n) {
    return (t[n] = e), t;
  }, {});
}
export var JN = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: function (e) {
    var t,
      n = e.state,
      s = e.name,
      i = e.options,
      o = n.elements.arrow,
      r = n.modifiersData.popperOffsets,
      a = ON(n.placement),
      l = WN(a),
      c = [gN, mN].indexOf(a) >= 0 ? "height" : "width";
    if (o && r) {
      var u = (function (e, t) {
          return YN(
            "number" !=
              typeof (e =
                "function" == typeof e
                  ? e(Object.assign({}, t.rects, { placement: t.placement }))
                  : e)
              ? e
              : XN(e, bN)
          );
        })(i.padding, n),
        d = NN(o),
        p = "y" === l ? fN : gN,
        f = "y" === l ? hN : mN,
        h =
          n.rects.reference[c] +
          n.rects.reference[l] -
          r[l] -
          n.rects.popper[c],
        m = r[l] - n.rects.reference[l],
        g = ZN(o),
        x = g ? ("y" === l ? g.clientHeight || 0 : g.clientWidth || 0) : 0,
        b = h / 2 - m / 2,
        y = u[p],
        v = x - d[c] - u[f],
        w = x / 2 - d[c] / 2 + b,
        k = KN(y, w, v),
        C = l;
      n.modifiersData[s] = (((t = {})[C] = k), (t.centerOffset = k - w), t);
    }
  },
  effect: function (e) {
    var t = e.state,
      n = e.options.element,
      s = undefined === n ? "[data-popper-arrow]" : n;
    null != s &&
      ("string" != typeof s || (s = t.elements.popper.querySelector(s))) &&
      UN(t.elements.popper, s) &&
      (t.elements.arrow = s);
  },
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
export function eU(e) {
  return e.split("-")[1];
}
export var tU = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
export function nU(e) {
  var t,
    n = e.popper,
    s = e.popperRect,
    i = e.placement,
    o = e.variation,
    r = e.offsets,
    a = e.position,
    l = e.gpuAcceleration,
    c = e.adaptive,
    u = e.roundOffsets,
    d = e.isFixed,
    p = r.x,
    f = undefined === p ? 0 : p,
    h = r.y,
    m = undefined === h ? 0 : h,
    g = "function" == typeof u ? u({ x: f, y: m }) : { x: f, y: m };
  (f = g.x), (m = g.y);
  var x = r.hasOwnProperty("x"),
    b = r.hasOwnProperty("y"),
    y = gN,
    v = fN,
    w = window;
  if (c) {
    var k = ZN(n),
      C = "clientHeight",
      j = "clientWidth";
    if (
      (k === PN(n) &&
        "static" !== zN((k = qN(n))).position &&
        "absolute" === a &&
        ((C = "scrollHeight"), (j = "scrollWidth")),
      i === fN || ((i === gN || i === mN) && o === vN))
    )
      (v = hN),
        (m -=
          (d && k === w && w.visualViewport ? w.visualViewport.height : k[C]) -
          s.height),
        (m *= l ? 1 : -1);
    if (i === gN || ((i === fN || i === hN) && o === vN))
      (y = mN),
        (f -=
          (d && k === w && w.visualViewport ? w.visualViewport.width : k[j]) -
          s.width),
        (f *= l ? 1 : -1);
  }
  var S,
    _ = Object.assign({ position: a }, c && tU),
    E =
      true === u
        ? (function (e) {
            var t = e.x,
              n = e.y,
              s = window.devicePixelRatio || 1;
            return { x: DN(t * s) / s || 0, y: DN(n * s) / s || 0 };
          })({ x: f, y: m })
        : { x: f, y: m };
  return (
    (f = E.x),
    (m = E.y),
    l
      ? Object.assign(
          {},
          _,
          (((S = {})[v] = b ? "0" : ""),
          (S[y] = x ? "0" : ""),
          (S.transform =
            (w.devicePixelRatio || 1) <= 1
              ? "translate(" + f + "px, " + m + "px)"
              : "translate3d(" + f + "px, " + m + "px, 0)"),
          S)
        )
      : Object.assign(
          {},
          _,
          (((t = {})[v] = b ? m + "px" : ""),
          (t[y] = x ? f + "px" : ""),
          (t.transform = ""),
          t)
        )
  );
}
export var sU = { passive: true };
export var iU = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function () {},
  effect: function (e) {
    var t = e.state,
      n = e.instance,
      s = e.options,
      i = s.scroll,
      o = undefined === i || i,
      r = s.resize,
      a = undefined === r || r,
      l = PN(t.elements.popper),
      c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return (
      o &&
        c.forEach(function (e) {
          e.addEventListener("scroll", n.update, sU);
        }),
      a && l.addEventListener("resize", n.update, sU),
      function () {
        o &&
          c.forEach(function (e) {
            e.removeEventListener("scroll", n.update, sU);
          }),
          a && l.removeEventListener("resize", n.update, sU);
      }
    );
  },
  data: {},
};
export var oU = { left: "right", right: "left", bottom: "top", top: "bottom" };
export function rU(e) {
  return e.replace(/left|right|bottom|top/g, function (e) {
    return oU[e];
  });
}
export var aU = { start: "end", end: "start" };
export function lU(e) {
  return e.replace(/start|end/g, function (e) {
    return aU[e];
  });
}
export function cU(e) {
  var t = PN(e);
  return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
export function uU(e) {
  return HN(qN(e)).left + cU(e).scrollLeft;
}
export function dU(e) {
  var t = zN(e),
    n = t.overflow,
    s = t.overflowX,
    i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + s);
}
export function pU(e) {
  return ["html", "body", "#document"].indexOf(LN(e)) >= 0
    ? e.ownerDocument.body
    : BN(e) && dU(e)
    ? e
    : pU(QN(e));
}
export function fU(e, t) {
  var n;
  undefined === t && (t = []);
  var s = pU(e),
    i = s === (null == (n = e.ownerDocument) ? undefined : n.body),
    o = PN(s),
    r = i ? [o].concat(o.visualViewport || [], dU(s) ? s : []) : s,
    a = t.concat(r);
  return i ? a : a.concat(fU(QN(r)));
}
export function hU(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height,
  });
}
export function mU(e, t, n) {
  return t === kN
    ? hU(
        (function (e, t) {
          var n = PN(e),
            s = qN(e),
            i = n.visualViewport,
            o = s.clientWidth,
            r = s.clientHeight,
            a = 0,
            l = 0;
          if (i) {
            (o = i.width), (r = i.height);
            var c = IN();
            (c || (!c && "fixed" === t)) &&
              ((a = i.offsetLeft), (l = i.offsetTop));
          }
          return { width: o, height: r, x: a + uU(e), y: l };
        })(e, n)
      )
    : AN(t)
    ? (function (e, t) {
        var n = HN(e, false, "fixed" === t);
        return (
          (n.top = n.top + e.clientTop),
          (n.left = n.left + e.clientLeft),
          (n.bottom = n.top + e.clientHeight),
          (n.right = n.left + e.clientWidth),
          (n.width = e.clientWidth),
          (n.height = e.clientHeight),
          (n.x = n.left),
          (n.y = n.top),
          n
        );
      })(t, n)
    : hU(
        (function (e) {
          var t,
            n = qN(e),
            s = cU(e),
            i = null == (t = e.ownerDocument) ? undefined : t.body,
            o = RN(
              n.scrollWidth,
              n.clientWidth,
              i ? i.scrollWidth : 0,
              i ? i.clientWidth : 0
            ),
            r = RN(
              n.scrollHeight,
              n.clientHeight,
              i ? i.scrollHeight : 0,
              i ? i.clientHeight : 0
            ),
            a = -s.scrollLeft + uU(e),
            l = -s.scrollTop;
          return (
            "rtl" === zN(i || n).direction &&
              (a += RN(n.clientWidth, i ? i.clientWidth : 0) - o),
            { width: o, height: r, x: a, y: l }
          );
        })(qN(e))
      );
}
export function gU(e, t, n, s) {
  var i =
      "clippingParents" === t
        ? (function (e) {
            var t = fU(QN(e)),
              n =
                ["absolute", "fixed"].indexOf(zN(e).position) >= 0 && BN(e)
                  ? ZN(e)
                  : e;
            return AN(n)
              ? t.filter(function (e) {
                  return AN(e) && UN(e, n) && "body" !== LN(e);
                })
              : [];
          })(e)
        : [].concat(t),
    o = [].concat(i, [n]),
    r = o[0],
    a = o.reduce(function (t, n) {
      var i = mU(e, n, s);
      return (
        (t.top = RN(i.top, t.top)),
        (t.right = VN(i.right, t.right)),
        (t.bottom = VN(i.bottom, t.bottom)),
        (t.left = RN(i.left, t.left)),
        t
      );
    }, mU(e, r, s));
  return (
    (a.width = a.right - a.left),
    (a.height = a.bottom - a.top),
    (a.x = a.left),
    (a.y = a.top),
    a
  );
}
export function xU(e) {
  var t,
    n = e.reference,
    s = e.element,
    i = e.placement,
    o = i ? ON(i) : null,
    r = i ? eU(i) : null,
    a = n.x + n.width / 2 - s.width / 2,
    l = n.y + n.height / 2 - s.height / 2;
  switch (o) {
    case fN:
      t = { x: a, y: n.y - s.height };
      break;
    case hN:
      t = { x: a, y: n.y + n.height };
      break;
    case mN:
      t = { x: n.x + n.width, y: l };
      break;
    case gN:
      t = { x: n.x - s.width, y: l };
      break;
    default:
      t = { x: n.x, y: n.y };
  }
  var c = o ? WN(o) : null;
  if (null != c) {
    var u = "y" === c ? "height" : "width";
    switch (r) {
      case yN:
        t[c] = t[c] - (n[u] / 2 - s[u] / 2);
        break;
      case vN:
        t[c] = t[c] + (n[u] / 2 - s[u] / 2);
    }
  }
  return t;
}
export function bU(e, t) {
  undefined === t && (t = {});
  var n = t,
    s = n.placement,
    i = undefined === s ? e.placement : s,
    o = n.strategy,
    r = undefined === o ? e.strategy : o,
    a = n.boundary,
    l = undefined === a ? wN : a,
    c = n.rootBoundary,
    u = undefined === c ? kN : c,
    d = n.elementContext,
    p = undefined === d ? CN : d,
    f = n.altBoundary,
    h = undefined !== f && f,
    m = n.padding,
    g = undefined === m ? 0 : m,
    x = YN("number" != typeof g ? g : XN(g, bN)),
    b = p === CN ? jN : CN,
    y = e.rects.popper,
    v = e.elements[h ? b : p],
    w = gU(AN(v) ? v : v.contextElement || qN(e.elements.popper), l, u, r),
    k = HN(e.elements.reference),
    C = xU({ reference: k, element: y, strategy: "absolute", placement: i }),
    j = hU(Object.assign({}, y, C)),
    S = p === CN ? j : k,
    _ = {
      top: w.top - S.top + x.top,
      bottom: S.bottom - w.bottom + x.bottom,
      left: w.left - S.left + x.left,
      right: S.right - w.right + x.right,
    },
    E = e.modifiersData.offset;
  if (p === CN && E) {
    var L = E[i];
    Object.keys(_).forEach(function (e) {
      var t = [mN, hN].indexOf(e) >= 0 ? 1 : -1,
        n = [fN, hN].indexOf(e) >= 0 ? "y" : "x";
      _[e] += L[n] * t;
    });
  }
  return _;
}
export var yU = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: function (e) {
    var t = e.state,
      n = e.options,
      s = e.name;
    if (!t.modifiersData[s]._skip) {
      for (
        var i = n.mainAxis,
          o = undefined === i || i,
          r = n.altAxis,
          a = undefined === r || r,
          l = n.fallbackPlacements,
          c = n.padding,
          u = n.boundary,
          d = n.rootBoundary,
          p = n.altBoundary,
          f = n.flipVariations,
          h = undefined === f || f,
          m = n.allowedAutoPlacements,
          g = t.options.placement,
          x = ON(g),
          b =
            l ||
            (x === g || !h
              ? [rU(g)]
              : (function (e) {
                  if (ON(e) === xN) return [];
                  var t = rU(e);
                  return [lU(e), t, lU(t)];
                })(g)),
          y = [g].concat(b).reduce(function (e, n) {
            return e.concat(
              ON(n) === xN
                ? (function (e, t) {
                    undefined === t && (t = {});
                    var n = t,
                      s = n.placement,
                      i = n.boundary,
                      o = n.rootBoundary,
                      r = n.padding,
                      a = n.flipVariations,
                      l = n.allowedAutoPlacements,
                      c = undefined === l ? _N : l,
                      u = eU(s),
                      d = u
                        ? a
                          ? SN
                          : SN.filter(function (e) {
                              return eU(e) === u;
                            })
                        : bN,
                      p = d.filter(function (e) {
                        return c.indexOf(e) >= 0;
                      });
                    0 === p.length && (p = d);
                    var f = p.reduce(function (t, n) {
                      return (
                        (t[n] = bU(e, {
                          placement: n,
                          boundary: i,
                          rootBoundary: o,
                          padding: r,
                        })[ON(n)]),
                        t
                      );
                    }, {});
                    return Object.keys(f).sort(function (e, t) {
                      return f[e] - f[t];
                    });
                  })(t, {
                    placement: n,
                    boundary: u,
                    rootBoundary: d,
                    padding: c,
                    flipVariations: h,
                    allowedAutoPlacements: m,
                  })
                : n
            );
          }, []),
          v = t.rects.reference,
          w = t.rects.popper,
          k = new Map(),
          C = true,
          j = y[0],
          S = 0;
        S < y.length;
        S++
      ) {
        var _ = y[S],
          E = ON(_),
          L = eU(_) === yN,
          P = [fN, hN].indexOf(E) >= 0,
          A = P ? "width" : "height",
          B = bU(t, {
            placement: _,
            boundary: u,
            rootBoundary: d,
            altBoundary: p,
            padding: c,
          }),
          T = P ? (L ? mN : gN) : L ? hN : fN;
        v[A] > w[A] && (T = rU(T));
        var M = rU(T),
          O = [];
        if (
          (o && O.push(B[E] <= 0),
          a && O.push(B[T] <= 0, B[M] <= 0),
          O.every(function (e) {
            return e;
          }))
        ) {
          (j = _), (C = false);
          break;
        }
        k.set(_, O);
      }
      if (C)
        for (
          var R = function (e) {
              var t = y.find(function (t) {
                var n = k.get(t);
                if (n)
                  return n.slice(0, e).every(function (e) {
                    return e;
                  });
              });
              if (t) return (j = t), "break";
            },
            V = h ? 3 : 1;
          V > 0;
          V--
        ) {
          if ("break" === R(V)) break;
        }
      t.placement !== j &&
        ((t.modifiersData[s]._skip = true),
        (t.placement = j),
        (t.reset = true));
    }
  },
  requiresIfExists: ["offset"],
  data: { _skip: false },
};
export function vU(e, t, n) {
  return (
    undefined === n && (n = { x: 0, y: 0 }),
    {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x,
    }
  );
}
export function wU(e) {
  return [fN, mN, hN, gN].some(function (t) {
    return e[t] >= 0;
  });
}
export var kU = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: function (e) {
    var t = e.state,
      n = e.name,
      s = t.rects.reference,
      i = t.rects.popper,
      o = t.modifiersData.preventOverflow,
      r = bU(t, { elementContext: "reference" }),
      a = bU(t, { altBoundary: true }),
      l = vU(r, s),
      c = vU(a, i, o),
      u = wU(l),
      d = wU(c);
    (t.modifiersData[n] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: c,
      isReferenceHidden: u,
      hasPopperEscaped: d,
    }),
      (t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": d,
      }));
  },
};
export var CU = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: function (e) {
    var t = e.state,
      n = e.options,
      s = e.name,
      i = n.offset,
      o = undefined === i ? [0, 0] : i,
      r = _N.reduce(function (e, n) {
        return (
          (e[n] = (function (e, t, n) {
            var s = ON(e),
              i = [gN, fN].indexOf(s) >= 0 ? -1 : 1,
              o =
                "function" == typeof n
                  ? n(Object.assign({}, t, { placement: e }))
                  : n,
              r = o[0],
              a = o[1];
            return (
              (r = r || 0),
              (a = (a || 0) * i),
              [gN, mN].indexOf(s) >= 0 ? { x: a, y: r } : { x: r, y: a }
            );
          })(n, t.rects, o)),
          e
        );
      }, {}),
      a = r[t.placement],
      l = a.x,
      c = a.y;
    null != t.modifiersData.popperOffsets &&
      ((t.modifiersData.popperOffsets.x += l),
      (t.modifiersData.popperOffsets.y += c)),
      (t.modifiersData[s] = r);
  },
};
export var jU = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: function (e) {
    var t = e.state,
      n = e.name;
    t.modifiersData[n] = xU({
      reference: t.rects.reference,
      element: t.rects.popper,
      strategy: "absolute",
      placement: t.placement,
    });
  },
  data: {},
};
export var SU = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: function (e) {
    var t = e.state,
      n = e.options,
      s = e.name,
      i = n.mainAxis,
      o = undefined === i || i,
      r = n.altAxis,
      a = undefined !== r && r,
      l = n.boundary,
      c = n.rootBoundary,
      u = n.altBoundary,
      d = n.padding,
      p = n.tether,
      f = undefined === p || p,
      h = n.tetherOffset,
      m = undefined === h ? 0 : h,
      g = bU(t, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }),
      x = ON(t.placement),
      b = eU(t.placement),
      y = !b,
      v = WN(x),
      w = "x" === v ? "y" : "x",
      k = t.modifiersData.popperOffsets,
      C = t.rects.reference,
      j = t.rects.popper,
      S =
        "function" == typeof m
          ? m(Object.assign({}, t.rects, { placement: t.placement }))
          : m,
      _ =
        "number" == typeof S
          ? { mainAxis: S, altAxis: S }
          : Object.assign({ mainAxis: 0, altAxis: 0 }, S),
      E = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
      L = { x: 0, y: 0 };
    if (k) {
      if (o) {
        var P,
          A = "y" === v ? fN : gN,
          B = "y" === v ? hN : mN,
          T = "y" === v ? "height" : "width",
          M = k[v],
          O = M + g[A],
          R = M - g[B],
          V = f ? -j[T] / 2 : 0,
          D = b === yN ? C[T] : j[T],
          F = b === yN ? -j[T] : -C[T],
          I = t.elements.arrow,
          H = f && I ? NN(I) : { width: 0, height: 0 },
          N = t.modifiersData["arrow#persistent"]
            ? t.modifiersData["arrow#persistent"].padding
            : { top: 0, right: 0, bottom: 0, left: 0 },
          U = N[A],
          z = N[B],
          $ = KN(0, C[T], H[T]),
          q = y ? C[T] / 2 - V - $ - U - _.mainAxis : D - $ - U - _.mainAxis,
          Q = y ? -C[T] / 2 + V + $ + z + _.mainAxis : F + $ + z + _.mainAxis,
          G = t.elements.arrow && ZN(t.elements.arrow),
          Z = G ? ("y" === v ? G.clientTop || 0 : G.clientLeft || 0) : 0,
          W = null != (P = null == E ? undefined : E[v]) ? P : 0,
          K = M + Q - W,
          Y = KN(f ? VN(O, M + q - W - Z) : O, M, f ? RN(R, K) : R);
        (k[v] = Y), (L[v] = Y - M);
      }
      if (a) {
        var X,
          J = "x" === v ? fN : gN,
          ee = "x" === v ? hN : mN,
          te = k[w],
          ne = "y" === w ? "height" : "width",
          se = te + g[J],
          ie = te - g[ee],
          oe = -1 !== [fN, gN].indexOf(x),
          re = null != (X = null == E ? undefined : E[w]) ? X : 0,
          ae = oe ? se : te - C[ne] - j[ne] - re + _.altAxis,
          le = oe ? te + C[ne] + j[ne] - re - _.altAxis : ie,
          ce =
            f && oe
              ? (function (e, t, n) {
                  var s = KN(e, t, n);
                  return s > n ? n : s;
                })(ae, te, le)
              : KN(f ? ae : se, te, f ? le : ie);
        (k[w] = ce), (L[w] = ce - te);
      }
      t.modifiersData[s] = L;
    }
  },
  requiresIfExists: ["offset"],
};
export function _U(e, t, n) {
  undefined === n && (n = false);
  var s,
    i,
    o = BN(t),
    r =
      BN(t) &&
      (function (e) {
        var t = e.getBoundingClientRect(),
          n = DN(t.width) / e.offsetWidth || 1,
          s = DN(t.height) / e.offsetHeight || 1;
        return 1 !== n || 1 !== s;
      })(t),
    a = qN(t),
    l = HN(e, r, n),
    c = { scrollLeft: 0, scrollTop: 0 },
    u = { x: 0, y: 0 };
  return (
    (o || (!o && !n)) &&
      (("body" !== LN(t) || dU(a)) &&
        (c =
          (s = t) !== PN(s) && BN(s)
            ? { scrollLeft: (i = s).scrollLeft, scrollTop: i.scrollTop }
            : cU(s)),
      BN(t)
        ? (((u = HN(t, true)).x += t.clientLeft), (u.y += t.clientTop))
        : a && (u.x = uU(a))),
    {
      x: l.left + c.scrollLeft - u.x,
      y: l.top + c.scrollTop - u.y,
      width: l.width,
      height: l.height,
    }
  );
}
export function EU(e) {
  var t = new Map(),
    n = new Set(),
    s = [];
  function i(e) {
    n.add(e.name),
      []
        .concat(e.requires || [], e.requiresIfExists || [])
        .forEach(function (e) {
          if (!n.has(e)) {
            var s = t.get(e);
            s && i(s);
          }
        }),
      s.push(e);
  }
  return (
    e.forEach(function (e) {
      t.set(e.name, e);
    }),
    e.forEach(function (e) {
      n.has(e.name) || i(e);
    }),
    s
  );
}
export var LU = { placement: "bottom", modifiers: [], strategy: "absolute" };
export function PU() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function (e) {
    return !(e && "function" == typeof e.getBoundingClientRect);
  });
}
export function AU(e) {
  undefined === e && (e = {});
  var t = e,
    n = t.defaultModifiers,
    s = undefined === n ? [] : n,
    i = t.defaultOptions,
    o = undefined === i ? LU : i;
  return function (e, t, n) {
    undefined === n && (n = o);
    var i,
      r,
      a = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, LU, o),
        modifiersData: {},
        elements: { reference: e, popper: t },
        attributes: {},
        styles: {},
      },
      l = [],
      c = false,
      u = {
        state: a,
        setOptions: function (n) {
          var i = "function" == typeof n ? n(a.options) : n;
          d(),
            (a.options = Object.assign({}, o, a.options, i)),
            (a.scrollParents = {
              reference: AN(e)
                ? fU(e)
                : e.contextElement
                ? fU(e.contextElement)
                : [],
              popper: fU(t),
            });
          var r = (function (e) {
            var t = EU(e);
            return EN.reduce(function (e, n) {
              return e.concat(
                t.filter(function (e) {
                  return e.phase === n;
                })
              );
            }, []);
          })(
            (function (e) {
              var t = e.reduce(function (e, t) {
                var n = e[t.name];
                return (
                  (e[t.name] = n
                    ? Object.assign({}, n, t, {
                        options: Object.assign({}, n.options, t.options),
                        data: Object.assign({}, n.data, t.data),
                      })
                    : t),
                  e
                );
              }, {});
              return Object.keys(t).map(function (e) {
                return t[e];
              });
            })([].concat(s, a.options.modifiers))
          );
          return (
            (a.orderedModifiers = r.filter(function (e) {
              return e.enabled;
            })),
            a.orderedModifiers.forEach(function (e) {
              var t = e.name,
                n = e.options,
                s = undefined === n ? {} : n,
                i = e.effect;
              if ("function" == typeof i) {
                var o = i({ state: a, name: t, instance: u, options: s }),
                  r = function () {};
                l.push(o || r);
              }
            }),
            u.update()
          );
        },
        forceUpdate: function () {
          if (!c) {
            var e = a.elements,
              t = e.reference,
              n = e.popper;
            if (PU(t, n)) {
              (a.rects = {
                reference: _U(t, ZN(n), "fixed" === a.options.strategy),
                popper: NN(n),
              }),
                (a.reset = false),
                (a.placement = a.options.placement),
                a.orderedModifiers.forEach(function (e) {
                  return (a.modifiersData[e.name] = Object.assign({}, e.data));
                });
              for (var s = 0; s < a.orderedModifiers.length; s++)
                if (true !== a.reset) {
                  var i = a.orderedModifiers[s],
                    o = i.fn,
                    r = i.options,
                    l = undefined === r ? {} : r,
                    d = i.name;
                  "function" == typeof o &&
                    (a =
                      o({ state: a, options: l, name: d, instance: u }) || a);
                } else (a.reset = false), (s = -1);
            }
          }
        },
        update:
          ((i = function () {
            return new Promise(function (e) {
              u.forceUpdate(), e(a);
            });
          }),
          function () {
            return (
              r ||
                (r = new Promise(function (e) {
                  Promise.resolve().then(function () {
                    (r = undefined), e(i());
                  });
                })),
              r
            );
          }),
        destroy: function () {
          d(), (c = true);
        },
      };
    if (!PU(e, t)) return u;
    function d() {
      l.forEach(function (e) {
        return e();
      }),
        (l = []);
    }
    return (
      u.setOptions(n).then(function (e) {
        !c && n.onFirstUpdate && n.onFirstUpdate(e);
      }),
      u
    );
  };
}
export var BU = AU({
  defaultModifiers: [
    iU,
    jU,
    {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: function (e) {
        var t = e.state,
          n = e.options,
          s = n.gpuAcceleration,
          i = undefined === s || s,
          o = n.adaptive,
          r = undefined === o || o,
          a = n.roundOffsets,
          l = undefined === a || a,
          c = {
            placement: ON(t.placement),
            variation: eU(t.placement),
            popper: t.elements.popper,
            popperRect: t.rects.popper,
            gpuAcceleration: i,
            isFixed: "fixed" === t.options.strategy,
          };
        null != t.modifiersData.popperOffsets &&
          (t.styles.popper = Object.assign(
            {},
            t.styles.popper,
            nU(
              Object.assign({}, c, {
                offsets: t.modifiersData.popperOffsets,
                position: t.options.strategy,
                adaptive: r,
                roundOffsets: l,
              })
            )
          )),
          null != t.modifiersData.arrow &&
            (t.styles.arrow = Object.assign(
              {},
              t.styles.arrow,
              nU(
                Object.assign({}, c, {
                  offsets: t.modifiersData.arrow,
                  position: "absolute",
                  adaptive: false,
                  roundOffsets: l,
                })
              )
            )),
          (t.attributes.popper = Object.assign({}, t.attributes.popper, {
            "data-popper-placement": t.placement,
          }));
      },
      data: {},
    },
    MN,
    CU,
    yU,
    SU,
    JN,
    kU,
  ],
});
export var TU = "tippy-content";
export var MU = "tippy-backdrop";
export var OU = "tippy-arrow";
export var RU = "tippy-svg-arrow";
export var VU = { passive: true, capture: true };
export var DU = function () {
  return document.body;
};
export function FU(e, t, n) {
  if (Array.isArray(e)) {
    var s = e[t];
    return null == s ? (Array.isArray(n) ? n[t] : n) : s;
  }
  return e;
}
export function IU(e, t) {
  var n = {}.toString.call(e);
  return 0 === n.indexOf("[object") && n.indexOf(t + "]") > -1;
}
export function HU(e, t) {
  return "function" == typeof e ? e.apply(undefined, t) : e;
}
export function NU(e, t) {
  return 0 === t
    ? e
    : function (s) {
        clearTimeout(n),
          (n = setTimeout(function () {
            e(s);
          }, t));
      };
  var n;
}
export function UU(e) {
  return [].concat(e);
}
export function zU(e, t) {
  -1 === e.indexOf(t) && e.push(t);
}
export function $U(e) {
  return [].slice.call(e);
}
export function qU(e) {
  return Object.keys(e).reduce(function (t, n) {
    return undefined !== e[n] && (t[n] = e[n]), t;
  }, {});
}
export function QU() {
  return document.createElement("div");
}
export function GU(e) {
  return ["Element", "Fragment"].some(function (t) {
    return IU(e, t);
  });
}
export function ZU(e) {
  return GU(e)
    ? [e]
    : (function (e) {
        return IU(e, "NodeList");
      })(e)
    ? $U(e)
    : Array.isArray(e)
    ? e
    : $U(document.querySelectorAll(e));
}
export function WU(e, t) {
  e.forEach(function (e) {
    e && (e.style.transitionDuration = t + "ms");
  });
}
export function KU(e, t) {
  e.forEach(function (e) {
    e && e.setAttribute("data-state", t);
  });
}
export function YU(e, t, n) {
  var s = t + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function (t) {
    e[s](t, n);
  });
}
export function XU(e, t) {
  for (var n = t; n; ) {
    var s;
    if (e.contains(n)) return true;
    n =
      null == n.getRootNode || null == (s = n.getRootNode())
        ? undefined
        : s.host;
  }
  return false;
}
export var JU = { isTouch: false };
export var ez = 0;
export function tz() {
  JU.isTouch ||
    ((JU.isTouch = true),
    window.performance && document.addEventListener("mousemove", nz));
}
export function nz() {
  var e = performance.now();
  e - ez < 20 &&
    ((JU.isTouch = false), document.removeEventListener("mousemove", nz)),
    (ez = e);
}
export function sz() {
  var e,
    t = document.activeElement;
  if ((e = t) && e._tippy && e._tippy.reference === e) {
    var n = t._tippy;
    t.blur && !n.state.isVisible && t.blur();
  }
}
export var iz =
  !!("undefined" != typeof window && "undefined" != typeof document) &&
  !!window.msCrypto;
export var oz = Object.assign(
  {
    appendTo: DU,
    aria: { content: "auto", expanded: "auto" },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function () {},
    onBeforeUpdate: function () {},
    onCreate: function () {},
    onDestroy: function () {},
    onHidden: function () {},
    onHide: function () {},
    onMount: function () {},
    onShow: function () {},
    onShown: function () {},
    onTrigger: function () {},
    onUntrigger: function () {},
    onClickOutside: function () {},
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null,
  },
  {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false,
  },
  {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999,
  }
);
export var rz = Object.keys(oz);
export function az(e) {
  var t = (e.plugins || []).reduce(function (t, n) {
    var s,
      i = n.name,
      o = n.defaultValue;
    i && (t[i] = undefined !== e[i] ? e[i] : null != (s = oz[i]) ? s : o);
    return t;
  }, {});
  return Object.assign({}, e, t);
}
export function lz(e, t) {
  var n = Object.assign(
    {},
    t,
    { content: HU(t.content, [e]) },
    t.ignoreAttributes
      ? {}
      : (function (e, t) {
          return (
            t ? Object.keys(az(Object.assign({}, oz, { plugins: t }))) : rz
          ).reduce(function (t, n) {
            var s = (e.getAttribute("data-tippy-" + n) || "").trim();
            if (!s) return t;
            if ("content" === n) t[n] = s;
            else
              try {
                t[n] = JSON.parse(s);
              } catch (e) {
                t[n] = s;
              }
            return t;
          }, {});
        })(e, t.plugins)
  );
  return (
    (n.aria = Object.assign({}, oz.aria, n.aria)),
    (n.aria = {
      expanded: "auto" === n.aria.expanded ? t.interactive : n.aria.expanded,
      content:
        "auto" === n.aria.content
          ? t.interactive
            ? null
            : "describedby"
          : n.aria.content,
    }),
    n
  );
}
export var cz = function () {
  return "innerHTML";
};
export function uz(e, t) {
  e[cz()] = t;
}
export function dz(e) {
  var t = QU();
  return (
    true === e
      ? (t.className = OU)
      : ((t.className = RU), GU(e) ? t.appendChild(e) : uz(t, e)),
    t
  );
}
export function pz(e, t) {
  GU(t.content)
    ? (uz(e, ""), e.appendChild(t.content))
    : "function" != typeof t.content &&
      (t.allowHTML ? uz(e, t.content) : (e.textContent = t.content));
}
export function fz(e) {
  var t = e.firstElementChild,
    n = $U(t.children);
  return {
    box: t,
    content: n.find(function (e) {
      return e.classList.contains(TU);
    }),
    arrow: n.find(function (e) {
      return e.classList.contains(OU) || e.classList.contains(RU);
    }),
    backdrop: n.find(function (e) {
      return e.classList.contains(MU);
    }),
  };
}
export function hz(e) {
  var t = QU(),
    n = QU();
  (n.className = "tippy-box"),
    n.setAttribute("data-state", "hidden"),
    n.setAttribute("tabindex", "-1");
  var s = QU();
  function i(n, s) {
    var i = fz(t),
      o = i.box,
      r = i.content,
      a = i.arrow;
    s.theme
      ? o.setAttribute("data-theme", s.theme)
      : o.removeAttribute("data-theme"),
      "string" == typeof s.animation
        ? o.setAttribute("data-animation", s.animation)
        : o.removeAttribute("data-animation"),
      s.inertia
        ? o.setAttribute("data-inertia", "")
        : o.removeAttribute("data-inertia"),
      (o.style.maxWidth =
        "number" == typeof s.maxWidth ? s.maxWidth + "px" : s.maxWidth),
      s.role ? o.setAttribute("role", s.role) : o.removeAttribute("role"),
      (n.content === s.content && n.allowHTML === s.allowHTML) ||
        pz(r, e.props),
      s.arrow
        ? a
          ? n.arrow !== s.arrow &&
            (o.removeChild(a), o.appendChild(dz(s.arrow)))
          : o.appendChild(dz(s.arrow))
        : a && o.removeChild(a);
  }
  return (
    (s.className = TU),
    s.setAttribute("data-state", "hidden"),
    pz(s, e.props),
    t.appendChild(n),
    n.appendChild(s),
    i(e.props, e.props),
    { popper: t, onUpdate: i }
  );
}
hz.$$tippy = true;
export var mz = 1;
export var gz = [];
export var xz = [];
export function bz(e, t) {
  var n,
    s,
    i,
    o,
    r,
    a,
    l,
    c,
    u = lz(e, Object.assign({}, oz, az(qU(t)))),
    d = false,
    p = false,
    f = false,
    h = false,
    m = [],
    g = NU(G, u.interactiveDebounce),
    x = mz++,
    b = (c = u.plugins).filter(function (e, t) {
      return c.indexOf(e) === t;
    }),
    y = {
      id: x,
      reference: e,
      popper: QU(),
      popperInstance: null,
      props: u,
      state: {
        isEnabled: true,
        isVisible: false,
        isDestroyed: false,
        isMounted: false,
        isShown: false,
      },
      plugins: b,
      clearDelayTimeouts: function () {
        clearTimeout(n), clearTimeout(s), cancelAnimationFrame(i);
      },
      setProps: function (t) {
        0;
        if (y.state.isDestroyed) return;
        M("onBeforeUpdate", [y, t]), q();
        var n = y.props,
          s = lz(e, Object.assign({}, n, qU(t), { ignoreAttributes: true }));
        (y.props = s),
          $(),
          n.interactiveDebounce !== s.interactiveDebounce &&
            (V(), (g = NU(G, s.interactiveDebounce)));
        n.triggerTarget && !s.triggerTarget
          ? UU(n.triggerTarget).forEach(function (e) {
              e.removeAttribute("aria-expanded");
            })
          : s.triggerTarget && e.removeAttribute("aria-expanded");
        R(), T(), k && k(n, s);
        y.popperInstance &&
          (Y(),
          J().forEach(function (e) {
            requestAnimationFrame(e._tippy.popperInstance.forceUpdate);
          }));
        M("onAfterUpdate", [y, t]);
      },
      setContent: function (e) {
        y.setProps({ content: e });
      },
      show: function () {
        0;
        var e = y.state.isVisible,
          t = y.state.isDestroyed,
          n = !y.state.isEnabled,
          s = JU.isTouch && !y.props.touch,
          i = FU(y.props.duration, 0, oz.duration);
        if (e || t || n || s) return;
        if (L().hasAttribute("disabled")) return;
        if ((M("onShow", [y], false), false === y.props.onShow(y))) return;
        (y.state.isVisible = true), E() && (w.style.visibility = "visible");
        T(), H(), y.state.isMounted || (w.style.transition = "none");
        if (E()) {
          var o = A();
          WU([o.box, o.content], 0);
        }
        (a = function () {
          var e;
          if (y.state.isVisible && !h) {
            if (
              ((h = true),
              w.offsetHeight,
              (w.style.transition = y.props.moveTransition),
              E() && y.props.animation)
            ) {
              var t = A(),
                n = t.box,
                s = t.content;
              WU([n, s], i), KU([n, s], "visible");
            }
            O(),
              R(),
              zU(xz, y),
              null == (e = y.popperInstance) || e.forceUpdate(),
              M("onMount", [y]),
              y.props.animation &&
                E() &&
                (function (e, t) {
                  U(e, t);
                })(i, function () {
                  (y.state.isShown = true), M("onShown", [y]);
                });
          }
        }),
          (function () {
            var e,
              t = y.props.appendTo,
              n = L();
            e =
              (y.props.interactive && t === DU) || "parent" === t
                ? n.parentNode
                : HU(t, [n]);
            e.contains(w) || e.appendChild(w);
            (y.state.isMounted = true), Y(), false;
          })();
      },
      hide: function () {
        0;
        var e = !y.state.isVisible,
          t = y.state.isDestroyed,
          n = !y.state.isEnabled,
          s = FU(y.props.duration, 1, oz.duration);
        if (e || t || n) return;
        if ((M("onHide", [y], false), false === y.props.onHide(y))) return;
        (y.state.isVisible = false),
          (y.state.isShown = false),
          (h = false),
          (d = false),
          E() && (w.style.visibility = "hidden");
        if ((V(), N(), T(true), E())) {
          var i = A(),
            o = i.box,
            r = i.content;
          y.props.animation && (WU([o, r], s), KU([o, r], "hidden"));
        }
        O(),
          R(),
          y.props.animation
            ? E() &&
              (function (e, t) {
                U(e, function () {
                  !y.state.isVisible &&
                    w.parentNode &&
                    w.parentNode.contains(w) &&
                    t();
                });
              })(s, y.unmount)
            : y.unmount();
      },
      hideWithInteractivity: function (e) {
        0;
        P().addEventListener("mousemove", g), zU(gz, g), g(e);
      },
      enable: function () {
        y.state.isEnabled = true;
      },
      disable: function () {
        y.hide(), (y.state.isEnabled = false);
      },
      unmount: function () {
        0;
        y.state.isVisible && y.hide();
        if (!y.state.isMounted) return;
        X(),
          J().forEach(function (e) {
            e._tippy.unmount();
          }),
          w.parentNode && w.parentNode.removeChild(w);
        (xz = xz.filter(function (e) {
          return e !== y;
        })),
          (y.state.isMounted = false),
          M("onHidden", [y]);
      },
      destroy: function () {
        0;
        if (y.state.isDestroyed) return;
        y.clearDelayTimeouts(),
          y.unmount(),
          q(),
          delete e._tippy,
          (y.state.isDestroyed = true),
          M("onDestroy", [y]);
      },
    };
  if (!u.render) return y;
  var v = u.render(y),
    w = v.popper,
    k = v.onUpdate;
  w.setAttribute("data-tippy-root", ""),
    (w.id = "tippy-" + y.id),
    (y.popper = w),
    (e._tippy = y),
    (w._tippy = y);
  var C = b.map(function (e) {
      return e.fn(y);
    }),
    j = e.hasAttribute("aria-expanded");
  return (
    $(),
    R(),
    T(),
    M("onCreate", [y]),
    u.showOnCreate && ee(),
    w.addEventListener("mouseenter", function () {
      y.props.interactive && y.state.isVisible && y.clearDelayTimeouts();
    }),
    w.addEventListener("mouseleave", function () {
      y.props.interactive &&
        y.props.trigger.indexOf("mouseenter") >= 0 &&
        P().addEventListener("mousemove", g);
    }),
    y
  );
  function S() {
    var e = y.props.touch;
    return Array.isArray(e) ? e : [e, 0];
  }
  function _() {
    return "hold" === S()[0];
  }
  function E() {
    var e;
    return !(null == (e = y.props.render) || !e.$$tippy);
  }
  function L() {
    return l || e;
  }
  function P() {
    var e,
      t,
      n = L().parentNode;
    return n
      ? null != (t = UU(n)[0]) && null != (e = t.ownerDocument) && e.body
        ? t.ownerDocument
        : document
      : document;
  }
  function A() {
    return fz(w);
  }
  function B(e) {
    return (y.state.isMounted && !y.state.isVisible) ||
      JU.isTouch ||
      (o && "focus" === o.type)
      ? 0
      : FU(y.props.delay, e ? 0 : 1, oz.delay);
  }
  function T(e) {
    undefined === e && (e = false),
      (w.style.pointerEvents = y.props.interactive && !e ? "" : "none"),
      (w.style.zIndex = "" + y.props.zIndex);
  }
  function M(e, t, n) {
    var s;
    (undefined === n && (n = true),
    C.forEach(function (n) {
      n[e] && n[e].apply(n, t);
    }),
    n) && (s = y.props)[e].apply(s, t);
  }
  function O() {
    var t = y.props.aria;
    if (t.content) {
      var n = "aria-" + t.content,
        s = w.id;
      UU(y.props.triggerTarget || e).forEach(function (e) {
        var t = e.getAttribute(n);
        if (y.state.isVisible) e.setAttribute(n, t ? t + " " + s : s);
        else {
          var i = t && t.replace(s, "").trim();
          i ? e.setAttribute(n, i) : e.removeAttribute(n);
        }
      });
    }
  }
  function R() {
    !j &&
      y.props.aria.expanded &&
      UU(y.props.triggerTarget || e).forEach(function (e) {
        y.props.interactive
          ? e.setAttribute(
              "aria-expanded",
              y.state.isVisible && e === L() ? "true" : "false"
            )
          : e.removeAttribute("aria-expanded");
      });
  }
  function V() {
    P().removeEventListener("mousemove", g),
      (gz = gz.filter(function (e) {
        return e !== g;
      }));
  }
  function D(t) {
    if (!JU.isTouch || (!f && "mousedown" !== t.type)) {
      var n = (t.composedPath && t.composedPath()[0]) || t.target;
      if (!y.props.interactive || !XU(w, n)) {
        if (
          UU(y.props.triggerTarget || e).some(function (e) {
            return XU(e, n);
          })
        ) {
          if (JU.isTouch) return;
          if (y.state.isVisible && y.props.trigger.indexOf("click") >= 0)
            return;
        } else M("onClickOutside", [y, t]);
        true === y.props.hideOnClick &&
          (y.clearDelayTimeouts(),
          y.hide(),
          (p = true),
          setTimeout(function () {
            p = false;
          }),
          y.state.isMounted || N());
      }
    }
  }
  function F() {
    f = true;
  }
  function I() {
    f = false;
  }
  function H() {
    var e = P();
    e.addEventListener("mousedown", D, true),
      e.addEventListener("touchend", D, VU),
      e.addEventListener("touchstart", I, VU),
      e.addEventListener("touchmove", F, VU);
  }
  function N() {
    var e = P();
    e.removeEventListener("mousedown", D, true),
      e.removeEventListener("touchend", D, VU),
      e.removeEventListener("touchstart", I, VU),
      e.removeEventListener("touchmove", F, VU);
  }
  function U(e, t) {
    var n = A().box;
    function s(e) {
      e.target === n && (YU(n, "remove", s), t());
    }
    if (0 === e) return t();
    YU(n, "remove", r), YU(n, "add", s), (r = s);
  }
  function z(t, n, s) {
    undefined === s && (s = false),
      UU(y.props.triggerTarget || e).forEach(function (e) {
        e.addEventListener(t, n, s),
          m.push({ node: e, eventType: t, handler: n, options: s });
      });
  }
  function $() {
    var e;
    _() &&
      (z("touchstart", Q, { passive: true }),
      z("touchend", Z, { passive: true })),
      ((e = y.props.trigger), e.split(/\s+/).filter(Boolean)).forEach(function (
        e
      ) {
        if ("manual" !== e)
          switch ((z(e, Q), e)) {
            case "mouseenter":
              z("mouseleave", Z);
              break;
            case "focus":
              z(iz ? "focusout" : "blur", W);
              break;
            case "focusin":
              z("focusout", W);
          }
      });
  }
  function q() {
    m.forEach(function (e) {
      var t = e.node,
        n = e.eventType,
        s = e.handler,
        i = e.options;
      t.removeEventListener(n, s, i);
    }),
      (m = []);
  }
  function Q(e) {
    var t,
      n = false;
    if (y.state.isEnabled && !K(e) && !p) {
      var s = "focus" === (null == (t = o) ? undefined : t.type);
      (o = e),
        (l = e.currentTarget),
        R(),
        !y.state.isVisible &&
          IU(e, "MouseEvent") &&
          gz.forEach(function (t) {
            return t(e);
          }),
        "click" === e.type &&
        (y.props.trigger.indexOf("mouseenter") < 0 || d) &&
        false !== y.props.hideOnClick &&
        y.state.isVisible
          ? (n = true)
          : ee(e),
        "click" === e.type && (d = !n),
        n && !s && te(e);
    }
  }
  function G(e) {
    var t = e.target,
      n = L().contains(t) || w.contains(t);
    ("mousemove" === e.type && n) ||
      ((function (e, t) {
        var n = t.clientX,
          s = t.clientY;
        return e.every(function (e) {
          var t = e.popperRect,
            i = e.popperState,
            o = e.props.interactiveBorder,
            r = i.placement.split("-")[0],
            a = i.modifiersData.offset;
          if (!a) return true;
          var l = "bottom" === r ? a.top.y : 0,
            c = "top" === r ? a.bottom.y : 0,
            u = "right" === r ? a.left.x : 0,
            d = "left" === r ? a.right.x : 0,
            p = t.top - s + l > o,
            f = s - t.bottom - c > o,
            h = t.left - n + u > o,
            m = n - t.right - d > o;
          return p || f || h || m;
        });
      })(
        J()
          .concat(w)
          .map(function (e) {
            var t,
              n = null == (t = e._tippy.popperInstance) ? undefined : t.state;
            return n
              ? {
                  popperRect: e.getBoundingClientRect(),
                  popperState: n,
                  props: u,
                }
              : null;
          })
          .filter(Boolean),
        e
      ) &&
        (V(), te(e)));
  }
  function Z(e) {
    K(e) ||
      (y.props.trigger.indexOf("click") >= 0 && d) ||
      (y.props.interactive ? y.hideWithInteractivity(e) : te(e));
  }
  function W(e) {
    (y.props.trigger.indexOf("focusin") < 0 && e.target !== L()) ||
      (y.props.interactive && e.relatedTarget && w.contains(e.relatedTarget)) ||
      te(e);
  }
  function K(e) {
    return !!JU.isTouch && _() !== e.type.indexOf("touch") >= 0;
  }
  function Y() {
    X();
    var t = y.props,
      n = t.popperOptions,
      s = t.placement,
      i = t.offset,
      o = t.getReferenceClientRect,
      r = t.moveTransition,
      l = E() ? fz(w).arrow : null,
      c = o
        ? { getBoundingClientRect: o, contextElement: o.contextElement || L() }
        : e,
      u = [
        { name: "offset", options: { offset: i } },
        {
          name: "preventOverflow",
          options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } },
        },
        { name: "flip", options: { padding: 5 } },
        { name: "computeStyles", options: { adaptive: !r } },
        {
          name: "$$tippy",
          enabled: true,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function (e) {
            var t = e.state;
            if (E()) {
              var n = A().box;
              ["placement", "reference-hidden", "escaped"].forEach(function (
                e
              ) {
                "placement" === e
                  ? n.setAttribute("data-placement", t.placement)
                  : t.attributes.popper["data-popper-" + e]
                  ? n.setAttribute("data-" + e, "")
                  : n.removeAttribute("data-" + e);
              }),
                (t.attributes.popper = {});
            }
          },
        },
      ];
    E() && l && u.push({ name: "arrow", options: { element: l, padding: 3 } }),
      u.push.apply(u, (null == n ? undefined : n.modifiers) || []),
      (y.popperInstance = BU(
        c,
        w,
        Object.assign({}, n, { placement: s, onFirstUpdate: a, modifiers: u })
      ));
  }
  function X() {
    y.popperInstance && (y.popperInstance.destroy(), (y.popperInstance = null));
  }
  function J() {
    return $U(w.querySelectorAll("[data-tippy-root]"));
  }
  function ee(e) {
    y.clearDelayTimeouts(), e && M("onTrigger", [y, e]), H();
    var t = B(true),
      s = S(),
      i = s[0],
      o = s[1];
    JU.isTouch && "hold" === i && o && (t = o),
      t
        ? (n = setTimeout(function () {
            y.show();
          }, t))
        : y.show();
  }
  function te(e) {
    if ((y.clearDelayTimeouts(), M("onUntrigger", [y, e]), y.state.isVisible)) {
      if (
        !(
          y.props.trigger.indexOf("mouseenter") >= 0 &&
          y.props.trigger.indexOf("click") >= 0 &&
          ["mouseleave", "mousemove"].indexOf(e.type) >= 0 &&
          d
        )
      ) {
        var t = B(false);
        t
          ? (s = setTimeout(function () {
              y.state.isVisible && y.hide();
            }, t))
          : (i = requestAnimationFrame(function () {
              y.hide();
            }));
      }
    } else N();
  }
}
export function yz(e, t) {
  undefined === t && (t = {});
  var n = oz.plugins.concat(t.plugins || []);
  document.addEventListener("touchstart", tz, VU),
    window.addEventListener("blur", sz);
  var s = Object.assign({}, t, { plugins: n }),
    i = ZU(e),
    o = i.reduce(function (e, t) {
      var n = t && bz(t, s);
      return n && e.push(n), e;
    }, []);
  return GU(e) ? o[0] : o;
}
(yz.defaultProps = oz),
  (yz.setDefaultProps = function (e) {
    Object.keys(e).forEach(function (t) {
      oz[t] = e[t];
    });
  }),
  (yz.currentInput = JU);
Object.assign({}, MN, {
  effect: function (e) {
    var t = e.state,
      n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      };
    Object.assign(t.elements.popper.style, n.popper),
      (t.styles = n),
      t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow);
  },
});
export var vz = {
  name: "sticky",
  defaultValue: false,
  fn: function (e) {
    var t = e.reference,
      n = e.popper;
    function s(t) {
      return true === e.props.sticky || e.props.sticky === t;
    }
    var i = null,
      o = null;
    function r() {
      var a = s("reference")
          ? (e.popperInstance
              ? e.popperInstance.state.elements.reference
              : t
            ).getBoundingClientRect()
          : null,
        l = s("popper") ? n.getBoundingClientRect() : null;
      ((a && wz(i, a)) || (l && wz(o, l))) &&
        e.popperInstance &&
        e.popperInstance.update(),
        (i = a),
        (o = l),
        e.state.isMounted && requestAnimationFrame(r);
    }
    return {
      onMount: function () {
        e.props.sticky && r();
      },
    };
  },
};
export function wz(e, t) {
  return (
    !e ||
    !t ||
    e.top !== t.top ||
    e.right !== t.right ||
    e.bottom !== t.bottom ||
    e.left !== t.left
  );
}
yz.setDefaultProps({ render: hz });
export var kz = yz;

export function Sz(e, t) {
  if (null == e) return {};
  var n,
    s,
    i = {},
    o = Object.keys(e);
  for (s = 0; s < o.length; s++) (n = o[s]), t.indexOf(n) >= 0 || (i[n] = e[n]);
  return i;
}
export var _z = "undefined" != typeof window && "undefined" != typeof document;
export function Ez(e, t) {
  e &&
    ("function" == typeof e && e(t),
    {}.hasOwnProperty.call(e, "current") && (e.current = t));
}
export function Lz() {
  return _z && document.createElement("div");
}
export function Pz(e, t) {
  if (e === t) return true;
  if ("object" == typeof e && null != e && "object" == typeof t && null != t) {
    if (Object.keys(e).length !== Object.keys(t).length) return false;
    for (var n in e) {
      if (!t.hasOwnProperty(n)) return false;
      if (!Pz(e[n], t[n])) return false;
    }
    return true;
  }
  return false;
}
export function Az(e) {
  var t = [];
  return (
    e.forEach(function (e) {
      t.find(function (t) {
        return Pz(e, t);
      }) || t.push(e);
    }),
    t
  );
}
export var Bz = _z ? Cz.useLayoutEffect : Cz.useEffect;
export function Tz(e, t, n) {
  n.split(/\s+/).forEach(function (n) {
    n && e.classList[t](n);
  });
}
export var Mz = {
  name: "className",
  defaultValue: "",
  fn: function (e) {
    var t = e.popper.firstElementChild,
      n = function () {
        var t;
        return !!(null == (t = e.props.render) ? undefined : t.$$tippy);
      };
    function s() {
      (e.props.className && !n()) || Tz(t, "add", e.props.className);
    }
    return {
      onCreate: s,
      onBeforeUpdate: function () {
        n() && Tz(t, "remove", e.props.className);
      },
      onAfterUpdate: s,
    };
  },
};
export function Oz(e) {
  return function (t) {
    var n = t.children,
      s = t.content,
      i = t.visible,
      o = t.singleton,
      r = t.render,
      a = t.reference,
      l = t.disabled,
      c = undefined !== l && l,
      u = t.ignoreAttributes,
      d = undefined === u || u,
      p =
        (t.__source,
        t.__self,
        Sz(t, [
          "children",
          "content",
          "visible",
          "singleton",
          "render",
          "reference",
          "disabled",
          "ignoreAttributes",
          "__source",
          "__self",
        ])),
      f = undefined !== i,
      h = undefined !== o,
      m = (0, Cz.useState)(false),
      g = m[0],
      x = m[1],
      b = (0, Cz.useState)({}),
      y = b[0],
      v = b[1],
      w = (0, Cz.useState)(),
      k = w[0],
      C = w[1],
      j = (function (e) {
        var t = (0, Cz.useRef)();
        return (
          t.current || (t.current = "function" == typeof e ? e() : e), t.current
        );
      })(function () {
        return { container: Lz(), renders: 1 };
      }),
      S = Object.assign({ ignoreAttributes: d }, p, { content: j.container });
    f && ((S.trigger = "manual"), (S.hideOnClick = false)), h && (c = true);
    var _ = S,
      E = S.plugins || [];
    r &&
      (_ = Object.assign({}, S, {
        plugins:
          h && null != o.data
            ? [].concat(E, [
                {
                  fn: function () {
                    return {
                      onTrigger: function (e, t) {
                        var n = o.data.children.find(function (e) {
                          return e.instance.reference === t.currentTarget;
                        });
                        (e.state.$$activeSingletonInstance = n.instance),
                          C(n.content);
                      },
                    };
                  },
                },
              ])
            : E,
        render: function () {
          return { popper: j.container };
        },
      }));
    var L = [a].concat(n ? [n.type] : []);
    return (
      Bz(function () {
        var t = a;
        a && a.hasOwnProperty("current") && (t = a.current);
        var n = e(
          t || j.ref || Lz(),
          Object.assign({}, _, { plugins: [Mz].concat(S.plugins || []) })
        );
        return (
          (j.instance = n),
          c && n.disable(),
          i && n.show(),
          h &&
            o.hook({
              instance: n,
              content: s,
              props: _,
              setSingletonContent: C,
            }),
          x(true),
          function () {
            n.destroy(), null == o || o.cleanup(n);
          }
        );
      }, L),
      Bz(function () {
        var e;
        if (1 !== j.renders) {
          var t,
            n,
            r,
            a,
            l = j.instance;
          l.setProps(
            ((t = l.props),
            (n = _),
            Object.assign({}, n, {
              popperOptions: Object.assign(
                {},
                t.popperOptions,
                n.popperOptions,
                {
                  modifiers: Az(
                    [].concat(
                      (null == (r = t.popperOptions)
                        ? undefined
                        : r.modifiers) || [],
                      (null == (a = n.popperOptions)
                        ? undefined
                        : a.modifiers) || []
                    )
                  ),
                }
              ),
            }))
          ),
            null == (e = l.popperInstance) || e.forceUpdate(),
            c ? l.disable() : l.enable(),
            f && (i ? l.show() : l.hide()),
            h &&
              o.hook({
                instance: l,
                content: s,
                props: _,
                setSingletonContent: C,
              });
        } else j.renders++;
      }),
      Bz(function () {
        var e;
        if (r) {
          var t = j.instance;
          t.setProps({
            popperOptions: Object.assign({}, t.props.popperOptions, {
              modifiers: [].concat(
                (
                  (null == (e = t.props.popperOptions)
                    ? undefined
                    : e.modifiers) || []
                ).filter(function (e) {
                  return "$$tippyReact" !== e.name;
                }),
                [
                  {
                    name: "$$tippyReact",
                    enabled: true,
                    phase: "beforeWrite",
                    requires: ["computeStyles"],
                    fn: function (e) {
                      var t,
                        n = e.state,
                        s = null == (t = n.modifiersData) ? undefined : t.hide;
                      (y.placement === n.placement &&
                        y.referenceHidden ===
                          (null == s ? undefined : s.isReferenceHidden) &&
                        y.escaped ===
                          (null == s ? undefined : s.hasPopperEscaped)) ||
                        v({
                          placement: n.placement,
                          referenceHidden:
                            null == s ? undefined : s.isReferenceHidden,
                          escaped: null == s ? undefined : s.hasPopperEscaped,
                        }),
                        (n.attributes.popper = {});
                    },
                  },
                ]
              ),
            }),
          });
        }
      }, [y.placement, y.referenceHidden, y.escaped].concat(L)),
      Cz.default.createElement(
        Cz.default.Fragment,
        null,
        n
          ? (0, Cz.cloneElement)(n, {
              ref: function (e) {
                (j.ref = e), Ez(n.ref, e);
              },
            })
          : null,
        g &&
          (0, jz.createPortal)(
            r
              ? r(
                  (function (e) {
                    var t = { "data-placement": e.placement };
                    return (
                      e.referenceHidden && (t["data-reference-hidden"] = ""),
                      e.escaped && (t["data-escaped"] = ""),
                      t
                    );
                  })(y),
                  k,
                  j.instance
                )
              : s,
            j.container
          )
      )
    );
  };
}
export var Rz = function (e, t) {
  return (0, Cz.forwardRef)(function (n, s) {
    var i = n.children,
      o = Sz(n, ["children"]);
    return Cz.default.createElement(
      e,
      Object.assign({}, t, o),
      i
        ? (0, Cz.cloneElement)(i, {
            ref: function (e) {
              Ez(s, e), Ez(i.ref, e);
            },
          })
        : null
    );
  });
};
export var Vz = Rz(Oz(kz));

export var Fz = ((e) => (
  (e[(e.Hidden = -1)] = "Hidden"),
  (e[(e.Default = 0)] = "Default"),
  (e[(e.Canvas = 1)] = "Canvas"),
  (e[(e.Caret = 1)] = "Caret"),
  (e[(e.CanvasScrollLayer = 4)] = "CanvasScrollLayer"),
  (e[(e.CanvasActions = 7)] = "CanvasActions"),
  (e[(e.DropDownList = 10)] = "DropDownList"),
  (e[(e.Notification = 12)] = "Notification"),
  (e[(e.CanvasLockLayer = 13)] = "CanvasLockLayer"),
  (e[(e.Inspector = 14)] = "Inspector"),
  (e[(e.InspectorLockButton = 20)] = "InspectorLockButton"),
  (e[(e.SubInspector = 30)] = "SubInspector"),
  (e[(e.InspectorLockLayer = 35)] = "InspectorLockLayer"),
  (e[(e.BodyLockLayer = 40)] = "BodyLockLayer"),
  (e[(e.Library = 50)] = "Library"),
  (e[(e.SettingsPanel = 55)] = "SettingsPanel"),
  (e[(e.Modal = 60)] = "Modal"),
  (e[(e.DndLayer = 65)] = "DndLayer"),
  (e[(e.UploadModal = 70)] = "UploadModal"),
  e
))(Fz || {});
export var Iz = Fz;

export function Nz() {
  const { legacyNonResponsivePanelPosition: e } = YR(),
    { width: t } = iL("embedViewport");
  return !e && t < 600;
}

export var $z = class {
  values = new Map();
  constructor() {
    dT(this);
  }
};
export var qz = mayBeUseMemp(
  WithEngineComp(function ({
    builderRenderFunction: e,
    createBuilder: t,
    engine: n,
    payload: s,
  }) {
    const i = Nz(),
      [o] = (0, Hz.useState)(() => new $z()),
      r = [],
      a = t(r);
    return (
      e({
        builder: new UIComponents(a),
        state: function (e, t) {
          return {
            get value() {
              return o.values.get(e) ?? t;
            },
            setValue: (t) => {
              _B(() => o.values.set(e, t))();
            },
          };
        },
        engine: n,
        payload: s,
        renderOptimizedSmallViewport: i,
      }),
      (0, zz.jsx)(zz.Fragment, {
        children: r.map(({ id: e, node: t }) =>
          (0, zz.jsx)(Hz.default.Fragment, { children: t }, e)
        ),
      })
    );
  })
);

export var Zz = (0, Qz.forwardRef)(
  (
    { onClick: e, children: t, withoutInput: n = false, className: s, ...i },
    o
  ) => {
    const r = (0, Qz.useRef)(null),
      { width: a } = iL(),
      [l, c] = (0, Qz.useState)(true),
      { initialWidth: u, setInitialWidth: d } = (0, Qz.useContext)(
        InitialWidthContext
      );
    (0, Qz.useEffect)(() => {
      const e = r.current?.parentElement,
        t = e?.offsetWidth;
      t && t > u && d(t),
        0 !== u && u > a && c(false),
        0 !== u && u <= a && c(true);
    }, [u, a, d]);
    const p = document.querySelector(`.${gh}`),
      f = DO(),
      h = KR();
    return (
      Xy(
        ["esc"],
        () => {
          const e = rm ? p?.shadowRoot?.activeElement : document.activeElement;
          if (e && r.current && Array.from(r.current.children).includes(e)) {
            const e = f.engine.block.findAllSelected()[0];
            if (null == e) return;
            gI(h, e);
          }
        },
        { elementRef: r }
      ),
      (0, Gz.jsx)(Gz.Fragment, {
        children: n
          ? "function" == typeof t
            ? t({ showLabel: l })
            : l && t
          : (0, Gz.jsx)(CompCustomButton, {
              ref: Qg(o, r),
              className: s,
              onClick: (t) => {
                e && (t && t.stopPropagation(), e(t));
              },
              ...i,
              "data-ubq-action": RH,
              variant: i.variant ?? "plain",
              children: "function" == typeof t ? t({ showLabel: l }) : l && t,
            }),
      })
    );
  }
);
Zz.displayName = "CanvasAction";
export var Wz = Zz;
export var Kz = Wz;

export var a$ = { 16: { BGRemove: n$, Vectorize: i$ }, 24: { AiImage: e$ } };
export var l$ = function ({ icon: e, iconSize: t }) {
  const n = (0, o$.useMemo)(() => {
    const t = e.match(/@imgly\/icons\/(.+)/);
    if (null != t) return t[1];
  }, [e]);
  if (n) {
    const e = "normal" === t ? 16 : 24,
      s = a$[e][n] || a$[24][n] || a$[16][n];
    if (null != s) return (0, r$.jsx)(s, { width: `${e}px`, height: `${e}px` });
  }
  return (0, r$.jsx)(CompCustomIcon, { icon: e, iconSize: t });
};

export var f$ = mayBeUseMemp(function ({ iconSize: e, customIcon: t }) {
  const { theme: n } = (0, Xz.useContext)(Sh.Context),
    { scale: s } = YR(),
    i = e ?? s;
  if (null == t) return null;
  if ("string" == typeof t && t.startsWith("@"))
    return (0, p$.jsx)(l$, { icon: t, iconSize: i });
  const o = "function" == typeof t ? t({ theme: n, iconSize: i }) : t;
  return (0,
  p$.jsx)("div", { className: (0, Yz.default)(c$, { [u$]: "large" === i, [d$]: "normal" === i }), style: { backgroundImage: `url(${o})`, backgroundSize: "contain" } });
});

export var k$ = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { hideUserInterface: t } = YR(),
      n = XR(),
      { t: s } = ZL();
    if (t) return null;
    const i = e.editor.getEditMode(),
      [o, r] = n.getCanvasMenuOrder({ editMode: i });
    return (0, reactJsx2.jsx)(reactJsx2.Fragment, {
      children: o.map((t, i) => {
        const o = t.id,
          a = `${r}.${o}.${i}`,
          l = n.registeredComponents[o];
        if (null == l) return null;
        if ("react" === l.type) {
          const e = l.component;
          return (0, reactJsx2.jsx)(e, {}, a);
        }
        const c = { componentId: o };
        return (0, reactJsx2.jsx)(
          qz,
          {
            builderRenderFunction: l.render,
            createBuilder: (t) => new CanvasMenuBuilder(t, s, c, e),
          },
          a
        );
      }),
    });
  })
);
export function C$(e, t = 0) {
  const n = document.querySelector("#root-shadow"),
    s = n?.shadowRoot ?? document.documentElement,
    i = document.createElement("div");
  (i.style.display = "none"), (i.style.width = e), s.appendChild(i);
  try {
    const e = parseInt(getComputedStyle(i).getPropertyValue("width"), 10);
    return s.removeChild(i), Number.isNaN(e) ? t : e;
  } catch (e) {
    return s.removeChild(i), t;
  }
}
export var S$ = null;
export var _$ = new Set();
export function E$(e, t) {
  const n = (0, j$.useRef)(
      document.querySelector(`.${gh}`) ?? document.documentElement
    ),
    s = ov(t),
    [i, o] = (0, j$.useState)(() => {
      const s = getComputedStyle(n.current).getPropertyValue(e).trim();
      return t?.(s) ?? s;
    });
  return (
    (0, j$.useEffect)(() => {
      const t = n.current,
        i = () => {
          const n = getComputedStyle(t).getPropertyValue(e).trim(),
            i = s?.(n) ?? n;
          o(i);
        };
      return (
        _$.add(i),
        S$ ||
          (function (e) {
            (S$ = new MutationObserver(() => {
              _$.forEach((e) => e());
            })).observe(e, {
              attributes: true,
              attributeOldValue: true,
              childList: false,
              characterData: false,
            });
          })(t),
        () => {
          _$.delete(i), 0 === _$.size && (S$?.disconnect(), (S$ = null));
        }
      );
    }, [s, e]),
    i
  );
}
export var L$ = "UBQ_CanvasMenu-module__block--hk7CF";

export var InitialWidthContext = (0, Dz.createContext)({
  initialWidth: 0,
  setInitialWidth: () => {},
});
export var T$ = WithEngineComp(function ({
  engine: e,
  children: t,
  boundaryElement: n,
}) {
  const s = (0, Dz.useRef)(null),
    [i, o] = (0, Dz.useState)(0);
  (0, Dz.useEffect)(() => {
    const e = s.current?.offsetWidth ?? 0;
    return (
      o(e),
      () => {
        o(0);
      }
    );
  }, [t]);
  const r = (0, Dz.useMemo)(
      () => ({ initialWidth: i, setInitialWidth: o }),
      [i]
    ),
    a = E$("--ubq-scale-base", (e) => C$(e, 4)),
    l = e.block.findAllSelected(),
    [c] = l;
  if (null == c) return null;
  const u = l.length > 1,
    d = e.block.getFlipVertical(c),
    p = e.block.getRotation(c),
    f = e.editor.unstable_isInteractionHappening(),
    h = e.block.isVisibleAtCurrentPlaybackTime(c),
    m = !f && h,
    g = Math.floor((180 * Math.abs(p)) / Math.PI),
    x = d ? g < 45 : g > 135 && g < 225;
  return (0, A$.jsx)(oj, {
    children: (0, A$.jsx)(Vz, {
      className: P$,
      animation: "shift-away",
      interactive: true,
      zIndex: Iz.CanvasActions,
      appendTo: "parent",
      sticky: true,
      visible: m,
      plugins: [vz],
      content: (0, A$.jsx)(InitialWidthContext.Provider, {
        value: r,
        children: (0, A$.jsx)("div", {
          ref: s,
          className: L$,
          "data-cy": "canvas-actions",
          children: (0, A$.jsx)(k$, {}),
        }),
      }),
      duration: [300, 50],
      popperOptions: {
        placement: "top",
        modifiers: [
          {
            name: "flip",
            options: { fallbackPlacements: ["bottom", "auto"] },
          },
          {
            name: "preventOverflow",
            options: {
              mainAxis: true,
              altAxis: true,
              boundary: n,
              padding: 2 * a,
            },
          },
          {
            name: "offset",
            options: {
              offset: ({ placement: e }) =>
                (("bottom" === e && !x) || ("top" === e && x)) && !u
                  ? [0, 12 * a]
                  : [0, 4 * a],
            },
          },
        ],
      },
      children: t,
    }),
  });
});

export function O$() {
  const e = oD().selection.allSelected,
    [t] = possibleHook3(e);
  return t[0];
}

export var q$ = V$.forwardRef(function (
  {
    width: e,
    height: t,
    rotation: n,
    position: s = { x: 0, y: 0 },
    style: i = {},
    children: o,
    isDisabled: r,
    isPage: a,
    draggingState: l,
    isDeleting: c,
    className: u,
    ...d
  },
  p
) {
  const f = n * (180 / Math.PI),
    h = Math.floor(s.x - e / 2),
    m = Math.ceil(s.x + e / 2),
    g = Math.floor(s.y - t / 2),
    x = m - h,
    b = Math.ceil(s.y + t / 2) - g,
    y = x / 2,
    v = b / 2,
    w = h + y,
    k = g + v;
  return (0, $$.jsx)("div", {
    "data-cy": "canvas-frame",
    onClick: (e) => {
      e.stopPropagation();
    },
    className: (0, R$.default)(D$, u, {
      [I$]: r,
      [H$]: a,
      [N$]: l,
      [U$]: !a,
      [z$]: !a && c,
      [F$]: r || a,
    }),
    ref: p,
    style: {
      width: x,
      height: b,
      ...i,
      transform: `translate3d(${w}px, ${k}px, 0px) rotate(${f}deg) translate3d(${-y}px, ${-v}px, 0px)`,
    },
    ...d,
    children: o,
  });
});

export var G$ = (0, M$.forwardRef)(function (e, t) {
  const n = O$(),
    s = (function (e, t) {
      const n = DO(),
        [s, i] = (0, sD.useState)(() => t(n)),
        o = (0, sD.useRef)({ component: e, getEngineValue: t });
      return (
        (o.current = { component: e, getEngineValue: t }),
        (0, sD.useEffect)(
          () =>
            n.getDesignElementLifecycleEmitter().addGlobalListener((e) => {
              const t = n.engine.block.findAllSelected()[0],
                s = n.engine.scene.get();
              if (
                e.some(
                  ({ event: e, options: n }) =>
                    (e === t || e === s) &&
                    n?.componentType === o.current.component &&
                    "DesignBlockRemovedEvent" !== n?.lifecycleEvent
                )
              ) {
                const e = o.current.getEngineValue(n);
                i(e);
              }
            }),
          [n]
        ),
        (0, sD.useEffect)(() => {
          const e = n.engine.editor,
            t = n.engine.block,
            s = n.engine.block.findAllSelected()[0],
            r = undefined === s ? "" : t.getType(s);
          return e.onHistoryUpdated(() => {
            const e = n.engine.block.findAllSelected()[0];
            if (undefined === e) return;
            if (!t.isValid(e)) return;
            if (r !== t.getType(e)) return;
            const s = o.current.getEngineValue(n);
            i(s);
          });
        }, [n]),
        s
      );
    })("ubq/designblocks/DesignBlockFrame", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (0 === t.length)
        return { position: { x: 0, y: 0 }, width: 0, height: 0 };
      const [n, s, i, o] = e.block.getScreenSpaceBoundingBoxXYWH(t);
      return {
        position: { x: n + i / 2, y: s + o / 2 },
        width: i,
        height: o,
      };
    }),
    i = n && "//ly.img.ubq/page" === n.type;
  return n
    ? (0, Q$.jsx)(q$, {
        ref: t,
        style: { pointerEvents: "none" },
        position: s.position,
        width: s.width,
        height: s.height,
        rotation: 0,
        isPage: i,
      })
    : null;
});

export var W$ = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, block: t, ...n }) {
    const [s] = KF(),
      { hideUserInterface: i } = YR(),
      o = e.block.isVisible(t);
    return i || !o
      ? null
      : (0, Z$.jsx)(T$, { ...n, children: (0, Z$.jsx)(G$, {}) }, s);
  })
);

export var X$ = { x: 0, y: 0, width: 0, height: 0 };
export var J$ = mayBeUseMemp(
  WithEngineComp(function ({
    canvasControls: e,
    editorContainer: t,
    engine: n,
  }) {
    const { t: s } = ZL(),
      i = DO(),
      o = YR(),
      { focusSelectedElementOrDocument: r } = xI(),
      a = n.element,
      l = (0, hI.useRef)(null),
      [c, u] = (0, hI.useState)(null);
    c !== l.current && u(l.current);
    const d = rv(c) ?? X$,
      [p, f] = (0, hI.useState)(false);
    n.editor.setSettingBool("touch/dragStartCanSelect", !ky);
    const h = oI("editor/present");
    Xy(["down"], () => {
      h && i.getPageManager().selectNextPage();
    }),
      Xy(["up"], () => {
        h && i.getPageManager().selectPreviousPage();
      });
    const [m] = possibleHook3(i.channels.scene.ready),
      { selectedBlock: g, fillType: x } = eI(n, () => {
        const e = n.block.findAllSelected()[0],
          t = null != e && n.block.hasFill(e) ? n.block.getFill(e) : undefined;
        return {
          selectedBlock: e,
          fillType:
            null != t && n.block.isValid(t) ? n.block.getType(t) : undefined,
        };
      });
    !(function ({ engine: { editor: e } }) {
      (0, K$.useEffect)(() => {
        const t = () => {
            e.setEditMode("Transform");
          },
          n = (e) => {
            um.isActive() && e.preventDefault();
            const t = e?.detail;
            "INPUT" === t?.tagName && e.preventDefault();
          };
        return (
          document.addEventListener("cesdk-refocus", n),
          document.addEventListener("cesdk-blur", t),
          () => {
            document.removeEventListener("cesdk-refocus", n),
              document.removeEventListener("cesdk-blur", t);
          }
        );
      }, [e]);
    })(i);
    const [b] = possibleHook3(i.channels.editor.editMode);
    (0, hI.useEffect)(() => {
      m
        ? a.style.removeProperty("visibility")
        : (a.style.visibility = "hidden");
    }, [m, a]);
    const y = (0, hI.useCallback)(
      (e) => {
        if (e) {
          a.setAttribute("aria-label", s("component.canvas")),
            a.setAttribute("data-ubq-canvas", "ubq-canvas");
          e.parentElement.insertBefore(a, e);
        } else a.remove();
      },
      [a, s]
    );
    if (
      ((0, hI.useEffect)(() => {
        const e = (0, fI.default)(f, 900, {
            leading: false,
            trailing: true,
            maxWait: 900,
          }),
          t = i.channels.camera.scrollPercentage.subscribe(() => {
            f(true), e(false);
          });
        return () => {
          t(), e.cancel();
        };
      }, [i.channels.camera.scrollPercentage]),
      (0, hI.useEffect)(() => (c ? n.setWheelEventTarget(c) : aV), [c, n]),
      !m)
    )
      return (0, Y$.jsxs)(
        "div",
        {
          className: TI,
          "data-ubq-canvas": "ubq-canvas-container",
          ref: l,
          children: [
            (0, Y$.jsx)(qH, {}),
            (0, Y$.jsx)(
              "div",
              {
                id: "ubq-canvas-position",
                ref: y,
                style: { display: "none" },
              },
              "canvasPosition"
            ),
          ],
        },
        "container"
      );
    const v = !o.hideUserInterface && !h,
      w = "Crop" !== b && null != a && null != g;
    return (0, Y$.jsxs)(PI, {
      scope: "canvas",
      label: s("editor.scope.canvas"),
      className: TI,
      "data-ubq-canvas": "ubq-canvas-container",
      ref: l,
      onMouseUp: (e) => {
        e.target === a && r();
      },
      children: [
        v && (0, Y$.jsx)(UH, { containerRef: l }),
        v && e,
        v && (0, Y$.jsx)(nH, { editorContainer: t }),
        v &&
          w &&
          (0, Y$.jsx)(
            W$,
            { block: g, boundaryElement: l.current ?? undefined },
            `${g}-${x}`
          ),
        (0, Y$.jsx)(
          "div",
          { id: "ubq-canvas-position", ref: y, style: { display: "none" } },
          "canvasPosition"
        ),
        (0, Y$.jsx)(aN, {
          bcr: d,
          isScrolling: p,
          onDragStart: () => f(true),
          onDragEnd: () => f(false),
        }),
        (0, Y$.jsx)(pN, {
          bcr: d,
          isScrolling: p,
          onDragStart: () => f(true),
          onDragEnd: () => f(false),
        }),
      ],
    });
  })
);
export var eq = J$;

export var nq = class extends Error {};
export function sq({ error: e }) {
  const { t: t } = ZL(),
    n = !!e.message,
    s = t(
      e instanceof nq
        ? "component.canvas.state.unsupported"
        : "component.canvas.state.error"
    );
  return (0, tq.jsxs)(Yw, {
    show: true,
    type: "error",
    "aria-label": s,
    children: [
      (0, tq.jsx)(Ex, { level: 1, children: s }),
      n && (0, tq.jsx)("p", { children: e.message }),
    ],
  });
}
export var oq = class extends UIComponentBuilder {
  constructor(e, t, n, s) {
    super("CanvasBarBuilder", e, t, n, s);
  }
  toString() {
    return "CanvasBarBuilder";
  }
};
export var rq = {
  block: "UBQ_CanvasBars-module__block--hQNKs",
  bar: "UBQ_CanvasBars-module__bar--cPGyA",
  renderOptimizedSmallViewport:
    "UBQ_CanvasBars-module__renderOptimizedSmallViewport--NSAIy",
  bottom: "UBQ_CanvasBars-module__bottom--AFs8k",
  top: "UBQ_CanvasBars-module__top--k8O0E",
};

export var lq = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, position: t }) {
    const { t: n } = ZL(),
      s = XR(),
      i = e.editor.getEditMode(),
      [o, r] = s.getCanvasBarOrder(t, { editMode: i });
    return (0, aq.jsx)("div", {
      className: (0, iq.default)(rq.bar, rq[t]),
      "data-cy": `canvas-bar-${t}`,
      children: o.map((t, i) => {
        const o = t.id,
          a = `${r}.${o}.${i}`,
          l = s.registeredComponents[o];
        if (null == l) return null;
        if ("react" === l.type) {
          const e = l.component;
          return (0, aq.jsx)(e, {}, a);
        }
        const c = { componentId: o };
        return (0, aq.jsx)(
          qz,
          {
            builderRenderFunction: l.render,
            createBuilder: (t) => new oq(t, n, c, e),
          },
          a
        );
      }),
    });
  })
);
export var cq = mayBeUseMemp(function () {
  const { hideUserInterface: e } = YR();
  return e
    ? null
    : (0, aq.jsxs)("div", {
        className: rq.block,
        children: [
          (0, aq.jsx)(lq, { position: "top" }),
          (0, aq.jsx)(lq, { position: "bottom" }),
        ],
      });
});

export var pq = mayBeUseMemp(function () {
  const e = VO(),
    { getCurrentDialog: t } = XR(),
    { t: n } = ZL(),
    s = t(),
    i = s?.content ?? "",
    o = s?.type,
    r = s?.size,
    a = s?.progress,
    l = s?.cancel,
    { title: c, message: u } = (function (e, t) {
      const n =
        "string" != typeof t && t.title
          ? e(t.title, { defaultValue: t.title })
          : undefined;
      let s;
      s =
        "string" == typeof t
          ? [e(t, { defaultValue: t })]
          : Array.isArray(t.message)
          ? t.message.map((t) => e(t, { defaultValue: t }))
          : [e(t.message, { defaultValue: t.message })];
      return { title: n, message: s };
    })(n, i);
  let d = s?.actions ?? [];
  return (
    (d = Array.isArray(d) ? d : [d]),
    (0, dq.jsx)(hx, {
      children: (0, dq.jsxs)(Yw, {
        clickOutsideToClose: s?.clickOutsideToClose,
        show: null != s,
        "aria-label": "dialog",
        type: o,
        size: r,
        progress: a,
        onClose: () => {
          s && (e.ui.closeDialog(s.id), s.onClose?.());
        },
        footer: (0, dq.jsxs)(Yw.Footer, {
          children: [
            l
              ? (0, dq.jsx)(CompCustomButton, {
                  name: "close-modal",
                  variant: l.variant,
                  color: l.color,
                  onClick: () => {
                    l.onClick({ id: s.id });
                  },
                  children: n(l.label, { defaultValue: l.label }),
                })
              : null,
            (0, dq.jsx)("div", {
              className: uq,
              children: d.map((e) =>
                (0, dq.jsx)(
                  CompCustomButton,
                  {
                    name: "close-modal",
                    variant: e.variant,
                    color: e.color,
                    onClick: () => {
                      s && e.onClick({ id: s.id });
                    },
                    children: n(e.label, { defaultValue: e.label }),
                  },
                  e?.label
                )
              ),
            }),
          ],
        }),
        children: [
          c && (0, dq.jsx)(Ex, { level: 1, multiline: true, children: c }),
          u.map((e) => (0, dq.jsx)("p", { children: e }, e)),
        ],
      }),
    })
  );
});

export var mq = function () {
  return (0, hq.jsx)("hr", { className: fq });
};
export var Nq = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, className: t }) {
    const { t: n } = ZL(),
      s = XR(),
      { dockIconSize: i, dockHideLabels: o } = YR(),
      r = Nz(),
      a = e.editor.getEditMode(),
      [l, c] = s.getDockOrder({ editMode: a }),
      u = r ? "horizontal" : "vertical";
    return (0, Hq.jsx)(yj, {
      className: t,
      size: o ? "small" : "big",
      "data-cy": "dock",
      hideLabels: o,
      horizontal: "horizontal" === u,
      children: l.map((t, r) => {
        const a = t.id,
          l = `${c}.${a}.${r}`,
          d = s.registeredComponents[a];
        if (null == d) return null;
        if ("react" === d.type) {
          const e = d.component;
          return (0, Hq.jsx)(e, {}, l);
        }
        const p = {
          componentId: a,
          hideLabels: o,
          iconSize: i,
          orientation: u,
        };
        return (0, Hq.jsx)(
          qz,
          {
            payload: { ...t },
            builderRenderFunction: d.render,
            createBuilder: (t) => new DockBuilder(t, n, p, e),
          },
          l
        );
      }),
    });
  })
);
export var oQ = function () {
  const { t: e } = ZL(),
    t = IV(),
    n = O$(),
    [s, i] = possibleHook3(n?.clipLinesOutsideOfFrame, false),
    [o] = possibleHook3(n?.heightMode, "Auto"),
    r = (e) => {
      e !== s &&
        (i(e),
        t(
          e
            ? "input.clipLines.on.description"
            : "input.clipLines.off.description"
        ));
    };
  return (0, iQ.jsxs)(Yk, {
    children: [
      (0, iQ.jsx)(Sv, { children: e("input.clipLines") }),
      (0, iQ.jsxs)(CompLayout1, {
        children: [
          (0, iQ.jsx)(Ly, {
            label: e("input.clipLines.on.description"),
            children: (0, iQ.jsx)(CompCustomButton, {
              name: "clipLinesOn",
              className: sQ,
              onClick: () => r(true),
              isActive: s,
              "aria-label": e("input.clipLines.on.description"),
              isDisabled: "Absolute" !== o,
              children: e("common.on"),
            }),
          }),
          (0, iQ.jsx)(Ly, {
            label: e("input.clipLines.off.description"),
            children: (0, iQ.jsx)(CompCustomButton, {
              name: "clipLinesOff",
              className: sQ,
              onClick: () => r(false),
              isActive: !s,
              "aria-label": e("input.clipLines.off.description"),
              isDisabled: "Absolute" !== o,
              children: e("common.off"),
            }),
          }),
        ],
      }),
    ],
  });
};
export var mQ = function () {
  const e = IV(),
    { t: t } = ZL(),
    n = O$(),
    [s, i] = possibleHook3(n?.textCase, ["Normal"]),
    o = (t) => () => {
      i(t), e("action.text.changeCase");
    },
    r = (e) => 1 === s.length && s[0] === e;
  return (0, hQ.jsxs)(Yk, {
    children: [
      (0, hQ.jsx)(Sv, {
        htmlFor: "textCase",
        children: t("property.textCase"),
      }),
      (0, hQ.jsxs)(CompLayout1, {
        children: [
          (0, hQ.jsx)(Ly, {
            label: t("property.textCase.normal"),
            children: (0, hQ.jsx)(CompCustomButton, {
              name: "textCaseAsTyped",
              "data-cy": "textCaseAsTyped",
              onClick: o("Normal"),
              isActive: r("Normal"),
              "aria-label": t("property.textCase.normal"),
              children: (0, hQ.jsx)(aQ, {}),
            }),
          }),
          (0, hQ.jsx)(Ly, {
            label: t("property.textCase.uppercase"),
            children: (0, hQ.jsx)(CompCustomButton, {
              name: "textCaseUppercase",
              "data-cy": "textCaseUppercase",
              onClick: o("Uppercase"),
              isActive: r("Uppercase"),
              "aria-label": t("property.textCase.uppercase"),
              children: (0, hQ.jsx)(fQ, {}),
            }),
          }),
          (0, hQ.jsx)(Ly, {
            label: t("property.textCase.lowercase"),
            children: (0, hQ.jsx)(CompCustomButton, {
              name: "textCaseLowercase",
              "data-cy": "textCaseLowercase",
              onClick: o("Lowercase"),
              isActive: r("Lowercase"),
              "aria-label": t("property.textCase.lowercase"),
              children: (0, hQ.jsx)(cQ, {}),
            }),
          }),
          (0, hQ.jsx)(Ly, {
            label: t("property.textCase.titlecase"),
            children: (0, hQ.jsx)(CompCustomButton, {
              name: "textCaseTitlecase",
              "data-cy": "textCaseTitlecase",
              onClick: o("Titlecase"),
              isActive: r("Titlecase"),
              "aria-label": t("property.textCase.titlecase"),
              children: (0, hQ.jsx)(dQ, {}),
            }),
          }),
        ],
      }),
    ],
  });
};

export var jQ = {
  block: "UBQ_PanelPortal-module__block--Zlqwp",
  fullWidth: "UBQ_PanelPortal-module__fullWidth--AJvKV",
  verticalPanel: "UBQ_PanelPortal-module__verticalPanel--gxFvi",
};

export function _Q({ children: e }) {
  return (0, SQ.jsx)(tk, { layer: "panelLeft", children: e });
}
export function EQ({ children: e }) {
  return (0, SQ.jsx)(tk, { layer: "panelRight", children: e });
}
export function LQ({ children: e, className: t }) {
  return (0, SQ.jsx)(tk.Container, {
    layer: "panelLeft",
    className: (0, kQ.default)(jQ.block, t),
    children: e,
  });
}
export function PQ({ children: e, className: t }) {
  return (0, SQ.jsx)(tk.Container, {
    layer: "panelRight",
    className: (0, kQ.default)(jQ.block, t),
    children: e,
  });
}
export function AQ({ panelPosition: e }) {
  const t = Nz(),
    { width: n } = iL(),
    s = { [jQ.fullWidth]: n < 480 || t, [jQ.verticalPanel]: t };
  switch (e) {
    case "left":
      return (0, SQ.jsx)(LQ, { className: (0, kQ.default)(s) });
    case "right":
      return (0, SQ.jsx)(PQ, { className: (0, kQ.default)(s) });
    default:
      return null;
  }
}
export function BQ(e, t) {
  const n = t.getPanelState(e)?.open ?? false,
    s = (0, CQ.useCallback)(
      (s) => {
        const i = "function" == typeof s ? s(n) : s;
        t.setPanelState(e, { open: i });
      },
      [e, n, t]
    );
  return [n, s];
}
export var TQ = mayBeUseMemp(
  ({ id: e, group: t, panelPosition: n, children: s }) => {
    const i = XR(),
      [o, r] = BQ(e, i);
    switch (
      ((0, CQ.useEffect)(
        () => () => {
          o && r(false);
        },
        [o, r]
      ),
      (0, CQ.useEffect)(() => {
        i.getPanelState(e)?.group !== t &&
          i.setPanelState(e, { open: false, group: t });
      }, [e, t, i]),
      n)
    ) {
      case "left":
        return (0, SQ.jsx)(_Q, {
          children: "function" == typeof s ? s({ isOpen: o, setIsOpen: r }) : s,
        });
      case "right":
        return (0, SQ.jsx)(EQ, {
          children: "function" == typeof s ? s({ isOpen: o, setIsOpen: r }) : s,
        });
      default:
        return null;
    }
  }
);

export var NQ = function (e) {
  return XR().getPanelFloating(e);
};
export var UQ = function (e) {
  return XR().getPanelPosition(e);
};

export var PanelPositionContext = (0, xQ.createContext)({
  id: "",
  animationComplete: true,
  panelPosition: "left",
  context: "close",
  closable: true,
  isOpen: false,
  setIsOpen: () => {},
});
export function PanelPositionContextProvider({
  id: e,
  animationComplete: t,
  panelPosition: n,
  isOpen: s,
  setIsOpen: i,
  context: o,
  closable: r,
  onClose: a,
  children: l,
}) {
  const c = (0, xQ.useMemo)(
    () => ({
      id: e,
      animationComplete: t,
      panelPosition: n,
      isOpen: s,
      setIsOpen: i,
      context: o,
      closable: r,
      onClose: a,
    }),
    [e, t, n, o, r, a, s, i]
  );
  return (0, zQ.jsx)(PanelPositionContext.Provider, { value: c, children: l });
}
export function QQ({
  id: e,
  group: t,
  panelPosition: n,
  floating: s,
  onClose: i,
  closable: o = true,
  context: r = "close",
  show: a,
  children: l,
  focusTrapActive: c,
  ...u
}) {
  const d = UQ("//ly.img.panel/assetLibrary"),
    p = Nz(),
    f = UQ(e),
    h = NQ(e),
    m = XR(),
    g = m.getPanelState(e),
    [x, b] = BQ(e, m),
    y =
      null != g?.sessionOptions?.closableByUser
        ? g?.sessionOptions?.closableByUser
        : o,
    v = p ? "left" : n || f,
    w = !!p || (null != s ? s : h);
  return (0, zQ.jsx)(TQ, {
    id: e,
    group: t,
    panelPosition: v,
    children: () =>
      (0, zQ.jsx)(rC, {
        show: null != a ? a : x,
        position: v,
        floating: w,
        borderLeft: "left" === v && "left" === d,
        borderRight: "right" === v && "right" === d,
        animationDirection: p ? "vertical" : "horizontal",
        ...u,
        children: ({ animationComplete: t }) =>
          (0, zQ.jsx)(PanelPositionContextProvider, {
            id: e,
            animationComplete: t,
            panelPosition: v,
            context: r,
            closable: y,
            onClose: i,
            isOpen: x,
            setIsOpen: b,
            children: (0, zQ.jsx)(dm, {
              active: null != c ? c : t,
              focusTrapOptions: {
                preventScroll: true,
                escapeDeactivates: false,
                clickOutsideDeactivates: true,
              },
              children: (0, zQ.jsx)("div", {
                className: MQ,
                children:
                  "function" == typeof l
                    ? l({ animationComplete: t, isOpen: x, setIsOpen: b })
                    : t && l,
              }),
            }),
          }),
      }),
  });
}
export function GQ({ panelId: e, onClick: t }) {
  const { t: n } = ZL(),
    s = Nz(),
    i = n("common.close"),
    o = s ? (0, zQ.jsx)(yQ, {}) : (0, zQ.jsx)(mv, {});
  return (0, zQ.jsx)(Ly, {
    label: i,
    children: (0, zQ.jsx)(CompCustomButton, {
      "aria-label": i,
      name: `panel.close.${e}`,
      "data-cy": `panel.close.${e}`,
      variant: "regular",
      onClick: t,
      icon: o,
    }),
  });
}
export function ZQ({ panelId: e, onClick: t }) {
  const { t: n } = ZL(),
    s = n("common.back");
  return (0, zQ.jsx)(Ly, {
    label: s,
    children: (0, zQ.jsx)(CompCustomButton, {
      "aria-label": s,
      name: `panel.back.${e}`,
      "data-cy": `panel.back.${e}`,
      variant: "regular",
      onClick: t,
      icon: (0, zQ.jsx)(wQ, {}),
    }),
  });
}
(QQ.Header = mayBeUseMemp(function ({ overlay: e, children: t, action: n }) {
  const {
    id: s,
    animationComplete: i,
    panelPosition: o,
    context: r,
    closable: a,
    onClose: l,
    isOpen: c,
    setIsOpen: u,
  } = (0, xQ.useContext)(PanelPositionContext);
  let d = "right";
  "back" === r
    ? (d = "left")
    : "close" === r &&
      ("left" === o && (d = "right"), "right" === o && (d = "left"));
  const p = a && "left" === d,
    f = a && "right" === d,
    h =
      "close" === r
        ? (0, zQ.jsx)(GQ, {
            panelId: s,
            onClick: () => {
              l?.(), u(false);
            },
          })
        : (0, zQ.jsx)(ZQ, {
            panelId: s,
            onClick: () => {
              l?.(), u(false);
            },
          });
  return (0,
  zQ.jsxs)(zQ.Fragment, { children: [e && (0, zQ.jsx)("section", { className: OQ, children: e }), (0, zQ.jsxs)("section", { className: (0, gQ.default)(OQ, { [RQ]: e }), children: [p && (0, zQ.jsx)("div", { className: DQ, children: p ? h : undefined }), "function" == typeof t ? t({ animationComplete: i, isOpen: c, setIsOpen: u }) : i && t, (f || n) && (0, zQ.jsxs)("div", { className: FQ, children: [n, f ? h : undefined] })] }), (0, zQ.jsx)(Sw, {})] });
})),
  (QQ.Title = function ({ children: e, action: t }) {
    const { a11y: n } = FI();
    return (0, zQ.jsxs)(zQ.Fragment, {
      children: [
        (0, zQ.jsx)(Ex, {
          className: IQ,
          level: 1,
          start: n.headingsHierarchyStart,
          "data-cy": "panel-title",
          children: e,
        }),
        (0, zQ.jsx)("div", { className: VQ, children: t }),
      ],
    });
  }),
  (QQ.Content = function ({ children: e }) {
    const {
      animationComplete: t,
      isOpen: n,
      setIsOpen: s,
    } = (0, xQ.useContext)(PanelPositionContext);
    return (0, zQ.jsx)("div", {
      className: HQ,
      children:
        "function" == typeof e
          ? e({ animationComplete: t, isOpen: n, setIsOpen: s })
          : t && e,
    });
  });
export var WQ = mayBeUseMemp(QQ);

export var YQ = { block: "UBQ_SliderInput-module__block--pFy3O" };

export function JQ({
  min: e,
  max: t,
  step: n,
  centeredZeroPosition: s = true,
  snapOffset: i = t / 20,
  onChange: o,
  onRelease: r,
  id: a,
  name: l,
  value: c,
  defaultValue: u,
  label: d,
  isDisabled: p = false,
  ...f
}) {
  const { t: h } = ZL(),
    m = n ?? PercentageHelper.stepFromMinMax(e, t),
    [g] = (0, KQ.useState)({ enabled: true, snapped: false });
  function x(e) {
    return parseFloat(e.toFixed(3));
  }
  return (0, XQ.jsx)("div", {
    className: YQ.block,
    "data-cy": "slider-input",
    children: (0, XQ.jsx)(Dk, {
      value: c,
      id: a,
      name: l,
      defaultValue: x(u ?? 0),
      min: x(e),
      max: x(t),
      step: x(m),
      "data-cy": l.replace(/\//g, "-"),
      onChange: (e) => {
        if ("change" === e.nativeEvent.type) return;
        const t = Math.fround(parseFloat(e.currentTarget.value));
        g.enabled && undefined !== u && Math.abs(t - u) < i
          ? g.snapped
            ? o?.(u)
            : (u === t && (g.snapped = true), o?.(t))
          : ((g.snapped = false), o?.(t)),
          g.enabled || (g.enabled = true);
      },
      onNumberInputChange: (e) => {
        o?.(e);
      },
      onKeyDown: () => {
        g.enabled = false;
      },
      onRelease: r,
      disabled: p,
      centeredZeroPosition: s,
      toggleNumberInputAriaLabel: h("input.sliderInput.toggleNumberInput"),
      ...f,
    }),
  });
}
export var eG = function ({ id: e, name: t, ...n }) {
  return (0, XQ.jsx)(Pv, {
    name: t,
    label: n.label,
    isDisabled: n.isDisabled,
    children: (e) => (0, XQ.jsx)(JQ, { ...e, ...n }),
  });
};
export var tG = eG;

export var sG = WithEngineComp(function ({
  block: e,
  property: t,
  engine: n,
  ...s
}) {
  switch (n.block.getPropertyType(t)) {
    case "Int":
      return (0, nG.jsx)(iG, { block: e, property: t, ...s });
    case "Float":
      return (0, nG.jsx)(oG, { block: e, property: t, ...s });
    default:
      return null;
  }
});
export var iG = WithEngineComp(function ({
  property: e,
  block: t,
  engine: n,
  ...s
}) {
  const i = IV();
  return n.block.isValid(t)
    ? (0, nG.jsx)(tG, {
        name: e,
        value: n.block.getInt(t, e),
        onChange: (s) => {
          n.block.setInt(t, e, s);
        },
        onRelease: () => {
          i("action.property.update");
        },
        ...s,
      })
    : null;
});
export var oG = WithEngineComp(function ({
  property: e,
  block: t,
  engine: n,
  ...s
}) {
  const i = IV();
  return n.block.isValid(t)
    ? (0, nG.jsx)(tG, {
        name: e,
        value: n.block.getFloat(t, e),
        onChange: (s) => {
          n.block.setFloat(t, e, s);
        },
        onRelease: () => {
          i("action.property.update");
        },
        ...s,
      })
    : null;
});
export var rG = sG;

export var lG = WithEngineComp(function ({
  engine: e,
  block: t,
  inBar: n = false,
  deniedByScopeBehavior: s = "disable",
}) {
  const { t: i } = ZL(),
    o = e.block.isAllowedByScope(t, dH),
    r = e.block.isAllowedByScope(t, jH),
    a = VO();
  return (o && r) || "hide" !== s
    ? n
      ? (0, aG.jsxs)(CompCustomButton, {
          name: "advanced-text-inspector",
          isDisabled: !r && !o,
          "data-cy": "advanced-text-properties-panel",
          onClick: () => {
            a.ui.openPanel("//ly.img.panel/inspector/text/advanced");
          },
          children: [i("input.text.advanced.description"), (0, aG.jsx)(zq, {})],
        })
      : (0, aG.jsx)(Pv, {
          name: "advanced-text-inspector",
          label: i("input.text.advanced"),
          isDisabled: !r && !o,
          children: (e) =>
            (0, aG.jsxs)(CompCustomButton, {
              ...e,
              isDisabled: !r && !o,
              "data-cy": "advanced-text-properties-panel",
              onClick: () => {
                a.ui.openPanel("//ly.img.panel/inspector/text/advanced");
              },
              children: [
                i("input.text.advanced.description"),
                (0, aG.jsx)(zq, {}),
              ],
            }),
        })
    : null;
});
export var cG = WithEngineComp(function ({ engine: e, children: t }) {
  const n = VO().feature.isEnabled("ly.img.text.advanced", { engine: e }),
    [s] = e.block.findAllSelected();
  if (null == s) return null;
  return "//ly.img.ubq/text" === e.block.getType(s) && n
    ? t({ block: s })
    : null;
});
export function uG({ block: e }) {
  const { t: t } = ZL(),
    n = VO(),
    s = NQ("//ly.img.panel/inspector"),
    i = UQ("//ly.img.panel/inspector"),
    o = Nz(),
    {
      isTextAutoSizeActive: r,
      isTextAutoHeightActive: a,
      isTextFixedSizeActive: l,
    } = (function (e) {
      const t = YF(),
        { widthMode: n, heightMode: s } = eI(t, () => ({
          widthMode: t.block.getWidthMode(e),
          heightMode: t.block.getHeightMode(e),
        }));
      return {
        isTextAutoSizeActive: "Auto" === n && "Auto" === s,
        isTextAutoHeightActive: "Auto" !== n && "Auto" === s,
        isTextFixedSizeActive: "Auto" !== n && "Auto" !== s,
      };
    })(e),
    c = (0, nQ.useRef)(null),
    u = (0, nQ.useRef)({ autoSize: false, autoHeight: true, fixedSize: false });
  return (
    (0, nQ.useEffect)(() => {
      const s = n.ui.isPanelOpen("//ly.img.panel/inspector/text/advanced"),
        { autoSize: i, autoHeight: o, fixedSize: d } = u.current;
      s ||
        e !== c.current ||
        (r === i && a === o && l === d) ||
        (r && n.ui.showNotification(t("action.text.autoSize.notification")),
        a && n.ui.showNotification(t("action.text.autoHeight.notification")),
        l && n.ui.showNotification(t("action.text.fixedFrame.notification")),
        (u.current = { autoSize: r, autoHeight: a, fixedSize: l })),
        (c.current = e);
    }, [r, a, l, n, t, e]),
    (0, aG.jsx)(WQ, {
      id: "//ly.img.panel/inspector/text/advanced",
      group: "subInspector",
      "data-cy": "subinspector-panel",
      floating: s,
      panelPosition: o ? "left" : i,
      children: (0, aG.jsx)(dG, {
        block: e,
        textModeActiveStates: {
          isTextAutoSizeActive: r,
          isTextAutoHeightActive: a,
          isTextFixedSizeActive: l,
        },
      }),
    })
  );
}
export var dG = WithEngineComp(function ({
  engine: e,
  block: t,
  textModeActiveStates: n,
}) {
  const { t: s } = ZL(),
    i = DO(),
    {
      isTextAutoSizeActive: o,
      isTextAutoHeightActive: r,
      isTextFixedSizeActive: a,
    } = n,
    { verticalAlignment: l } = eI(e, () => ({
      verticalAlignment: e.block.getEnum(t, "text/verticalAlignment"),
    }));
  return (0, aG.jsxs)(aG.Fragment, {
    children: [
      (0, aG.jsx)(WQ.Header, {
        children: (0, aG.jsx)(WQ.Title, { children: s("input.text.advanced") }),
      }),
      (0, aG.jsx)(WQ.Content, {
        children: (0, aG.jsxs)(Qk, {
          children: [
            (0, aG.jsxs)(Yk, {
              children: [
                (0, aG.jsx)(Sv, {
                  children: s("property.textAlignment.vertical"),
                }),
                (0, aG.jsxs)(CompButtonGroup, {
                  children: [
                    (0, aG.jsx)(Ly, {
                      label: s("property.textAlignment.vertical.top"),
                      children: (0, aG.jsx)(CompCustomButton, {
                        name: "alignTextTop",
                        icon: (0, aG.jsx)(Wq, {}),
                        isActive: "Top" === l,
                        onClick: () => {
                          e.block.setEnum(t, "text/verticalAlignment", "Top");
                        },
                      }),
                    }),
                    (0, aG.jsx)(Ly, {
                      label: s("property.textAlignment.vertical.center"),
                      children: (0, aG.jsx)(CompCustomButton, {
                        name: "alignTextVerticalCenter",
                        icon: (0, aG.jsx)(Gq, {}),
                        isActive: "Center" === l,
                        onClick: () => {
                          e.block.setEnum(
                            t,
                            "text/verticalAlignment",
                            "Center"
                          );
                        },
                      }),
                    }),
                    (0, aG.jsx)(Ly, {
                      label: s("property.textAlignment.vertical.bottom"),
                      children: (0, aG.jsx)(CompCustomButton, {
                        name: "alignTextBottom",
                        icon: (0, aG.jsx)(qq, {}),
                        isActive: "Bottom" === l,
                        onClick: () => {
                          e.block.setEnum(
                            t,
                            "text/verticalAlignment",
                            "Bottom"
                          );
                        },
                      }),
                    }),
                  ],
                }),
              ],
            }),
            (0, aG.jsxs)(Yk, {
              children: [
                (0, aG.jsx)(Sv, { children: s("property.autoSize") }),
                (0, aG.jsxs)(CompButtonGroup, {
                  children: [
                    (0, aG.jsx)(Ly, {
                      label: s("property.autoSize.autoSize.description"),
                      children: (0, aG.jsx)(CompCustomButton, {
                        name: "autoSize",
                        icon: (0, aG.jsx)(Jq, {}),
                        isActive: o,
                        onClick: () => {
                          i.setTextFrameSizingAuto(t);
                        },
                      }),
                    }),
                    (0, aG.jsx)(Ly, {
                      label: s("property.autoSize.autoHeight.description"),
                      children: (0, aG.jsx)(CompCustomButton, {
                        name: "autoHeight",
                        icon: (0, aG.jsx)(Yq, {}),
                        isActive: r,
                        onClick: () => {
                          i.setTextFrameHeightAuto(t);
                        },
                      }),
                    }),
                    (0, aG.jsx)(Ly, {
                      label: s("property.autoSize.fixedFrame.description"),
                      children: (0, aG.jsx)(CompCustomButton, {
                        name: "fixedFrame",
                        icon: (0, aG.jsx)(tQ, {}),
                        isActive: a,
                        onClick: () => {
                          i.setTextFrameSizingFixed(t);
                        },
                      }),
                    }),
                  ],
                }),
              ],
            }),
            (0, aG.jsx)(oQ, {}),
            (0, aG.jsx)(Yk, { children: (0, aG.jsx)(Sw, {}) }),
            (0, aG.jsx)(Yk, {
              children: (0, aG.jsx)(rG, {
                block: t,
                property: "text/lineHeight",
                label: s("property.lineHeight"),
                centeredZeroPosition: false,
                min: 0.5,
                max: 2.5,
              }),
            }),
            (0, aG.jsx)(Yk, {
              children: (0, aG.jsx)(rG, {
                block: t,
                property: "text/paragraphSpacing",
                label: s("property.paragraphSpacing"),
                centeredZeroPosition: false,
                min: 0,
                max: 2.5,
              }),
            }),
            (0, aG.jsx)(Yk, { children: (0, aG.jsx)(Sw, {}) }),
            (0, aG.jsx)(Yk, { children: (0, aG.jsx)(mQ, {}) }),
            (0, aG.jsx)(Yk, {
              children: (0, aG.jsx)(rG, {
                block: t,
                property: "text/letterSpacing",
                label: s("property.letterSpacing"),
                centeredZeroPosition: false,
                min: -0.15,
                max: 1.4,
              }),
            }),
          ],
        }),
      }),
    ],
  });
});
(uG.SupportGuard = cG),
  (uG.Control = function ({ inBar: e }) {
    return (0, aG.jsx)(cG, {
      children: ({ block: t }) => (0, aG.jsx)(lG, { block: t, inBar: e }),
    });
  });
export var pG = uG;
export function xG({ entry: e, sourceId: t, group: n }) {
  if (null != e.title) {
    if ("function" != typeof e.title) return e.title;
    {
      const s = e.title({ group: n, sourceId: t });
      if (null != s) return s;
    }
  }
  return n
    ? t
      ? [
          `libraries.${e.id}.${t}.${n}.label`,
          `libraries.${t}.${n}.label`,
          `libraries.${e.id}.${n}.label`,
        ]
      : `libraries.${e.id}.${n}.label`
    : t
    ? [
        `libraries.${e.id}.${t}.label`,
        `libraries.${t}.label`,
        `libraries.${e.id}.label`,
      ]
    : `libraries.${e.id}.label`;
}
export var bG = function (e, { entry: t, sourceId: n, group: s }, i) {
  const o = xG({ entry: t, sourceId: n, group: s });
  return e(o, { defaultValue: i ?? o });
};

export var jG = (e, t) => {
  if (t.label) return t.label;
  switch (t.view) {
    case "entriesOverview":
      return e("component.library.breadcrumbRoot");
    case "sourcesOverview":
      return bG(e, { entry: t.entry });
    case "groupsOverview":
      return bG(e, { entry: t.entry, sourceId: t.source.id });
    default:
      return bG(e, { entry: t.entry, sourceId: t.source.id, group: t.group });
  }
};
export var SG = function ({ locationStack: e, popLocation: t }) {
  const { t: n } = ZL();
  if (0 === e.length) return null;
  const s = e[0],
    i = e[e.length - 1],
    o = e[e.length - 2];
  return (0, CG.jsxs)("div", {
    className: yG,
    "data-cy": "asset-library-breadcrumb",
    children: [
      (0, CG.jsx)(
        CompCustomButton,
        {
          "aria-label": n("common.back"),
          name: "backToLibrary",
          "data-cy": "asset-library-breadcrumb--back",
          variant: "plain",
          onClick: t,
          className: wG,
          children: e.length > 2 ? "..." : jG(n, s),
        },
        "library"
      ),
      (0, CG.jsx)("div", { className: kG, children: "/" }),
      o &&
        o !== s &&
        (0, CG.jsxs)(CG.Fragment, {
          children: [
            (0, CG.jsx)(
              CompCustomButton,
              {
                "aria-label": n("common.back"),
                name: "backToLastSource",
                "data-cy": "backToLastSource",
                variant: "plain",
                onClick: t,
                className: wG,
                children: jG(n, o),
              },
              "backToLastSource"
            ),
            (0, CG.jsx)("div", { className: kG, children: "/" }),
          ],
        }),
      (0, CG.jsx)("div", { className: vG, children: jG(n, i) }),
    ],
  });
};
export var _G = SG;

export var AG = { block: "UBQ_AssetConfirmationDialog-module__block--V6elC" };

export var TG = function ({
  assetSourceId: e,
  show: t,
  onDialogAbort: n,
  onDialogConfirm: s,
}) {
  const { t: i } = ZL(),
    {
      headline: o,
      body: r,
      confirm: a,
      abort: l,
    } = (function (e, t) {
      return {
        headline: e(`libraries.${t}.confirmation.headline`),
        body: e(`libraries.${t}.confirmation.body`),
        confirm: e(`libraries.${t}.confirmation.confirm`),
        abort: e(`libraries.${t}.confirmation.abort`),
      };
    })(i, e);
  return (0, BG.jsx)(hx, {
    children: (0, BG.jsxs)(Yw, {
      className: AG.block,
      type: "warning",
      show: t,
      clickOutsideToClose: false,
      "aria-label": `${o}. ${r}`,
      onClose: n,
      footer: (0, BG.jsxs)(Yw.Footer, {
        children: [
          (0, BG.jsx)(CompCustomButton, {
            name: "template-preset-dialog-button-abort",
            onClick: n,
            children: l,
          }),
          (0, BG.jsx)(CompCustomButton, {
            color: "accent",
            name: "template-preset-dialog-button-confirm",
            onClick: s,
            children: a,
          }),
        ],
      }),
      children: [
        (0, BG.jsx)(HI, { level: 1, children: o }),
        (0, BG.jsx)("p", { className: AG.dialogContent, children: r }),
      ],
    }),
  });
};

export var VG = {
  wrapper: "UBQ_AssetLibraryCard-module__wrapper--stQdN",
  stack: "UBQ_AssetLibraryCard-module__stack--qnDzG",
  hasChildren: "UBQ_AssetLibraryCard-module__hasChildren--yUxxD",
  labelInside: "UBQ_AssetLibraryCard-module__labelInside--OMslE",
  block: "UBQ_AssetLibraryCard-module__block--z689o",
  label: "UBQ_AssetLibraryCard-module__label---NNY5",
  isPreview: "UBQ_AssetLibraryCard-module__isPreview--7ZqFG",
  labelBelow: "UBQ_AssetLibraryCard-module__labelBelow--sZi-b",
  singleLineLabel: "UBQ_AssetLibraryCard-module__singleLineLabel--cyXzB",
  containsLabel: "UBQ_AssetLibraryCard-module__containsLabel--tsqhH",
  hasBackground: "UBQ_AssetLibraryCard-module__hasBackground--XuHUW",
  dragPreview: "UBQ_AssetLibraryCard-module__dragPreview--OmKMq",
  below: "UBQ_AssetLibraryCard-module__below--ULAsZ",
  active: "UBQ_AssetLibraryCard-module__active--2-GY4",
  singleLineTruncation:
    "UBQ_AssetLibraryCard-module__singleLineTruncation--QqQ8w",
  multiLineTruncation:
    "UBQ_AssetLibraryCard-module__multiLineTruncation--yNIbR",
  border: "UBQ_AssetLibraryCard-module__border--QhSq0",
  spotColorIndicator: "UBQ_AssetLibraryCard-module__spotColorIndicator--7iifr",
};

export var WG = function ({ className: e, label: t, value: n, setValue: s }) {
  const { t: i } = ZL(),
    o = IV();
  return (0, ZG.jsxs)(Yk, {
    className: e,
    children: [
      (0, ZG.jsx)(Sv, { children: t }),
      (0, ZG.jsxs)(CompLayout1, {
        children: [
          (0, ZG.jsx)(CompCustomButton, {
            name: "property-toggle-on",
            activeStateStyle: "outline",
            isActive: n,
            onClick: () => {
              s(true), o("action.property.update");
            },
            children: i("common.on"),
          }),
          (0, ZG.jsx)(CompCustomButton, {
            name: "property-toggle-off",
            activeStateStyle: "outline",
            isActive: !n,
            onClick: () => {
              s(false), o("action.property.update");
            },
            children: i("common.off"),
          }),
        ],
      }),
    ],
  });
};
export function KG(e) {
  return `property.${e.replace(/\//g, ".")}`;
}
export var XG = function ({
  className: e,
  label: t,
  property: n,
  value: s,
  setValue: i,
  options: o,
}) {
  const { t: r } = ZL(),
    a = IV();
  function l(e) {
    return r(`${KG(n)}.${e}`);
  }
  return (0, YG.jsxs)(Yk, {
    className: e,
    children: [
      (0, YG.jsx)(Sv, { children: t }),
      (0, YG.jsxs)(bw, {
        children: [
          (e, { isOpen: t }) =>
            (0, YG.jsxs)(CompCustomButton, {
              name: "property-toggle-on",
              activeStateStyle: "outline",
              ...e,
              children: [
                l(s),
                t
                  ? (0, YG.jsx)(IconChevronDown, {})
                  : (0, YG.jsx)(IconChevronUp, {}),
              ],
            }),
          () =>
            (0, YG.jsx)(bw.Options, {
              value: s,
              onChange: (e) => {
                i(e), a("action.property.update");
              },
              children: o.map((e) =>
                (0, YG.jsx)(bw.Option, { value: e, children: l(e) }, e)
              ),
            }),
        ],
      }),
    ],
  });
};

export var eZ = WithEngineComp(function ({
  className: e,
  label: t,
  min: n,
  max: s,
  step: i,
  defaultValue: o,
  value: r,
  setValue: a,
}) {
  const l = IV();
  return (0, JG.jsx)(Yk, {
    className: e,
    children: (0, JG.jsx)(tG, {
      name: "asset-property-slider",
      label: t,
      min: n,
      max: s,
      defaultValue: o,
      step: i,
      value: r,
      centeredZeroPosition: false,
      onChange: (e) => {
        a(e);
      },
      onRelease: () => {
        l("action.property.update");
      },
    }),
  });
});

export var nZ = function ({ asset: e }) {
  const { t: t } = ZL(),
    { a11y: n } = FI(),
    s = YF(),
    i = IV(),
    [o, r] = (0, NG.useState)();
  (0, NG.useEffect)(() => {
    const e = document.querySelector("#root-shadow"),
      t = (e?.shadowRoot ?? document.documentElement).querySelector(
        "#asset-library-content"
      );
    t && r(t);
  }, []);
  const { properties: a, isDirty: l } = (0, NG.useMemo)(
    () => ({
      properties: e.payload?.properties,
      isDirty: e.payload?.properties?.some((e) => e.value !== e.defaultValue),
    }),
    [e.payload?.properties]
  );
  function c(e) {
    return t(KG(e));
  }
  return (0, tZ.jsxs)(Cx, {
    className: UG,
    disableFocusTrap: true,
    boundary: { element: o, padding: 4 },
    children: [
      (e) =>
        (0, tZ.jsx)(CompCustomButton, {
          name: "property-popover",
          className: zG,
          variant: "plain",
          ...e,
          children: (0, tZ.jsx)("div", {
            className: $G,
            children: (0, tZ.jsx)(HG, {}),
          }),
        }),
      ({ closePopover: o }) =>
        (0, tZ.jsxs)(tZ.Fragment, {
          children: [
            (0, tZ.jsxs)("section", {
              className: qG,
              children: [
                (0, tZ.jsx)(Ex, {
                  className: QG,
                  level: 2,
                  start: n.headingsHierarchyStart,
                  children: t("component.propertyPopover.header"),
                }),
                (0, tZ.jsxs)("div", {
                  className: GG,
                  children: [
                    (0, tZ.jsxs)(CompCustomButton, {
                      name: "reset-properties",
                      onClick: () => {
                        a?.forEach((t) => {
                          t.value !== t.defaultValue &&
                            s.asset.unstable_applyProperty(
                              e.context.sourceId,
                              e,
                              { ...t, value: t.defaultValue }
                            );
                        }),
                          i("action.property.reset");
                      },
                      variant: "plain",
                      isDisabled: !l,
                      children: [t("common.reset"), (0, tZ.jsx)(FG, {})],
                    }),
                    (0, tZ.jsx)(Ly, {
                      label: t("common.close"),
                      children: (0, tZ.jsx)(CompCustomButton, {
                        "aria-label": t("common.close"),
                        name: "close-property-popover",
                        variant: "plain",
                        onClick: o,
                        icon: (0, tZ.jsx)(mv, {}),
                      }),
                    }),
                  ],
                }),
              ],
            }),
            a?.map((t) => {
              switch (t.type) {
                case "Boolean":
                  return (0, tZ.jsx)(
                    WG,
                    {
                      label: c(t.property),
                      setValue: (n) => {
                        s.asset.unstable_applyProperty(e.context.sourceId, e, {
                          ...t,
                          value: n,
                        });
                      },
                      ...t,
                    },
                    t.property
                  );
                case "Int":
                case "Double":
                case "Float":
                  return (0, tZ.jsx)(
                    eZ,
                    {
                      label: c(t.property),
                      setValue: (n) => {
                        s.asset.unstable_applyProperty(e.context.sourceId, e, {
                          ...t,
                          value: n,
                        });
                      },
                      ...t,
                    },
                    t.property
                  );
                case "Enum":
                  return (0, tZ.jsx)(
                    XG,
                    {
                      label: c(t.property),
                      setValue: (n) => {
                        s.asset.unstable_applyProperty(e.context.sourceId, e, {
                          ...t,
                          value: n,
                        });
                      },
                      ...t,
                    },
                    t.property
                  );
                default:
                  return null;
              }
            }),
          ],
        }),
    ],
  });
};

export var iZ = function ({
  entry: e,
  asset: t,
  isPreview: n,
  matchCardHeightToLabelLines: s = "multi",
  children: i,
  onClick: o,
  ...r
}) {
  const a = (0, RG.useRef)(null),
    l = YF(),
    c = FI(),
    u = t.meta ? t.meta.width : 0,
    d = t.meta ? t.meta.height : 0,
    { cardBackgroundPreferences: p } = e,
    { background: f, backgroundType: h } = (0, RG.useMemo)(() => {
      if ("function" == typeof p) {
        const e = p(t);
        if ("image" === e.type)
          return { background: e.url, backgroundType: "image" };
        {
          const { viewBox: n, width: s = "100%", height: i = "100%", ...o } = e;
          return {
            background: (0, sZ.jsx)("svg", {
              width: u,
              style: { height: i, width: s },
              viewBox: n,
              xmlns: "http://www.w3.org/2000/svg",
              "aria-label": t.label,
              className: VG.svg,
              fill: "currentColor",
              children: (0, sZ.jsx)("path", {
                ...o,
                style: { height: "100%" },
              }),
            }),
            backgroundType: "svgVectorPath",
          };
        }
      }
      for (const e of p) {
        const n = (0, OG.default)(t, e.path, undefined);
        if (null != n)
          return "image" === e.type
            ? {
                background: l.editor.getAbsoluteURI(n),
                backgroundType: "image",
              }
            : {
                background: (0, sZ.jsx)("svg", {
                  width: u,
                  style: { height: "100%", width: "100%" },
                  viewBox: `0 0 ${u} ${d}`,
                  xmlns: "http://www.w3.org/2000/svg",
                  "aria-label": t.label,
                  className: VG.svg,
                  fill: "currentColor",
                  children: (0, sZ.jsx)("path", {
                    d: n,
                    style: { height: "100%" },
                  }),
                }),
                backgroundType: "svgVectorPath",
              };
      }
      return { background: undefined, backgroundType: undefined };
    }, [t, d, u, p, l.editor]),
    m = e.cardLabel?.(t),
    g = "inside" === (e.cardLabelPosition?.(t) ?? "inside"),
    x = e.cardLabelTruncateLines?.(t) ?? "multi",
    b = Math.random().toString().replace("0.", ""),
    y = `assetLibraryCard-${e.id}-${b}`,
    v = "SpotColor" === t.payload?.color?.colorSpace;
  return (0, sZ.jsxs)("div", {
    ref: a,
    className: VG.wrapper,
    draggable: true,
    onDragStart: (e) => {
      if ((e.dataTransfer.setData("//ly.img.asset", t.id), a?.current)) {
        a.current.classList.add(VG.dragPreview);
        const { x: t, y: n } = a.current.getBoundingClientRect();
        e.dataTransfer.setDragImage(a.current, e.clientX - t, e.clientY - n),
          requestAnimationFrame(() => {
            a?.current?.classList.remove(VG.dragPreview);
          });
      }
    },
    onDragEnd: (e) => {
      "none" === e.dataTransfer.dropEffect || t.active || o();
    },
    children: [
      (0, sZ.jsxs)(Gb, {
        className: (0, MG.default)(VG.stack, {
          [VG.labelBelow]: !g,
          [VG.labelInside]: g,
          [VG.singleLineLabel]: "single" === s || n,
          [VG.hasChildren]: i,
          [VG.isPreview]: n,
        }),
        children: [
          (0, sZ.jsxs)(hk, {
            ...r,
            className: (0, MG.default)(VG.block, r.className, {
              [VG.containsLabel]: !!m,
              [VG.hasBackground]: "image" === h,
              [VG.border]: e.cardBorder,
            }),
            style: { ...r.style, ...(e.cardStyle ? e.cardStyle(t) : {}) },
            backgroundImage: "image" === h ? f : undefined,
            backgroundType: n ? e.previewBackgroundType : e.gridBackgroundType,
            name: y,
            id: y,
            isActive: t.active,
            onClick: () => {
              t.active || o();
            },
            children: [
              m &&
                g &&
                (0, sZ.jsx)("span", {
                  className: VG.label,
                  style: e.cardLabelStyle ? e.cardLabelStyle(t) : {},
                  children: (0, sZ.jsx)("span", {
                    className:
                      "single" === x
                        ? VG.singleLineTruncation
                        : VG.multiLineTruncation,
                    children: m,
                  }),
                }),
              "svgVectorPath" === h && f,
            ],
          }),
          i,
          v &&
            (0, sZ.jsx)("div", {
              className: VG.spotColorIndicator,
              style: {
                backgroundImage: `url(${c.ui.baseURL}spot-color-indicator-l.svg)`,
              },
            }),
          t.payload?.properties && t.active
            ? (0, sZ.jsx)(nZ, { asset: t })
            : null,
        ],
      }),
      !g &&
        (0, sZ.jsx)("label", {
          htmlFor: y,
          className: (0, MG.default)(VG.label, VG.below, {
            [VG.active]: t.active,
          }),
          style: e.cardLabelStyle ? e.cardLabelStyle(t) : {},
          children: (0, sZ.jsx)("span", {
            className:
              "single" === x ? VG.singleLineTruncation : VG.multiLineTruncation,
            children: m,
          }),
        }),
    ],
  });
};
export var gZ = function ({ asset: e, onClick: t }) {
  const n = (0, cZ.useRef)(null),
    [s, i] = (0, cZ.useState)(null),
    [o, r] = (0, cZ.useState)(true),
    [a, l] = (0, cZ.useState)(false),
    [c, u] = (0, cZ.useState)(""),
    [d, p] = (0, cZ.useState)(""),
    f = e.meta?.duration,
    h = o ? (0, mZ.jsx)(lZ, {}) : (0, mZ.jsx)(rZ, {}),
    m = a ? (0, mZ.jsx)(Hh, { className: fZ }) : h;
  function g() {
    if (s && f) {
      const { currentTime: e } = s,
        { periodString: t, timeString: n } = xS(parseFloat(f) - e - 1);
      t && u(t), n && p(`-${n}`);
    }
  }
  function x(e) {
    const { periodString: t, timeString: n } = xS(parseFloat(e));
    t && u(t), n && p(n);
  }
  return (
    (0, cZ.useEffect)(
      () => (
        s && f && x(f),
        () => {
          s?.pause();
        }
      ),
      [s, f]
    ),
    (0, mZ.jsx)("div", {
      className: uZ,
      "data-expanded": !o || a,
      children: (0, mZ.jsxs)("div", {
        className: dZ,
        children: [
          (0, mZ.jsx)(CompCustomButton, {
            name: "playPause",
            variant: "plain",
            className: pZ,
            disabled: a,
            onClick: async (n) => {
              if ((n?.stopPropagation(), s))
                if (o) {
                  t(s);
                  const n = e?.meta?.previewUri ?? e?.meta?.uri;
                  if (0 === s.children.length && "string" == typeof n) {
                    const e = document.createElement("source");
                    (e.src = n), s.appendChild(e);
                  }
                  await s.play();
                } else s.pause();
            },
            children: m,
          }),
          c && d && (0, mZ.jsx)("time", { dateTime: c, children: d }),
          (0, mZ.jsx)("audio", {
            ref: i,
            preload: "metadata",
            style: { position: "absolute" },
            onLoadStart: () => {
              l(true);
            },
            onCanPlay: () => {
              l(false);
            },
            onPlay: () => {
              r(false),
                g(),
                (n.current = setInterval(() => {
                  g();
                }, 1e3));
            },
            onPause: () => {
              s &&
                f &&
                (r(true), (s.currentTime = 0), clearInterval(n.current), x(f));
            },
          }),
        ],
      }),
    })
  );
};
export var CZ = {
  block: "UBQ_AssetContextPopover-module__block--mBBDc",
  button: "UBQ_AssetContextPopover-module__button--zAa38",
  content: "UBQ_AssetContextPopover-module__content--ZKSmX",
  heading: "UBQ_AssetContextPopover-module__heading--IoULF",
  license: "UBQ_AssetContextPopover-module__license--FjDkN",
  credits: "UBQ_AssetContextPopover-module__credits--lIm0T",
  tags: "UBQ_AssetContextPopover-module__tags--1JGaE",
  tag: "UBQ_AssetContextPopover-module__tag--Ao6oh",
  licenseUrl: "UBQ_AssetContextPopover-module__licenseUrl--XuFgL",
  confirmationDialog:
    "UBQ_AssetContextPopover-module__confirmationDialog---Y73-",
};

export function SZ({ asset: e, sourceCredits: t }) {
  return e.credits && t
    ? (0, jZ.jsxs)("div", {
        className: CZ.credits,
        children: [
          "By ",
          (0, jZ.jsx)(EZ, { asset: e, ...e.credits }),
          " on",
          " ",
          (0, jZ.jsx)(EZ, { asset: e, ...t }),
        ],
      })
    : e.credits
    ? (0, jZ.jsxs)("div", {
        className: CZ.credits,
        children: ["By ", (0, jZ.jsx)(EZ, { asset: e, ...e.credits })],
      })
    : t
    ? (0, jZ.jsxs)("div", {
        className: CZ.credits,
        children: ["On ", (0, jZ.jsx)(EZ, { asset: e, ...t })],
      })
    : null;
}
export function _Z({ asset: e, license: t }) {
  if (!t) return null;
  const { name: n, url: s } = t;
  return (0, jZ.jsxs)("div", {
    className: CZ.license,
    children: [
      n,
      s &&
        (0, jZ.jsx)(dj, {
          url: s,
          utm: e.utm,
          className: CZ.licenseUrl,
          children: (0, jZ.jsx)(bZ, {}),
        }),
    ],
  });
}
export function EZ({ asset: e, name: t, url: n }) {
  return n
    ? (0, jZ.jsx)(dj, { url: n, utm: e.utm, children: t })
    : (0, jZ.jsx)(jZ.Fragment, { children: "name" });
}
export var LZ = function ({ asset: e, entry: t, sourceId: n, className: s }) {
  const { t: i } = ZL(),
    o = VO(),
    r = YF(),
    { canRemove: a } = t,
    l = (0, kZ.useMemo)(
      () => null != a && ("function" == typeof a ? a(n) : a),
      [a, n]
    ),
    [c, u] = (0, kZ.useState)(false),
    d = r.asset.getLicense(n),
    p = r.asset.getCredits(n);
  if (!(l || !!e?.license || !!d)) return null;
  const f = e.label || e.meta?.filename || e.id,
    h = e.credits?.url || e.license?.url || d?.url || l;
  return (0, jZ.jsx)("div", {
    className: (0, wZ.default)(CZ.block, s),
    "data-expanded": c,
    children: (0, jZ.jsxs)(Cx, {
      disableFocusTrap: !h,
      onOpen: () => {
        u(true);
      },
      onClose: () => {
        u(false);
      },
      children: [
        (e) =>
          (0, jZ.jsx)(CompCustomButton, {
            name: "credicts-screen",
            ...e,
            variant: "plain",
            className: CZ.button,
            children: (0, jZ.jsx)(CC, {}),
          }),
        () =>
          (0, jZ.jsxs)(jZ.Fragment, {
            children: [
              (0, jZ.jsxs)("div", {
                className: CZ.content,
                children: [
                  f &&
                    (0, jZ.jsx)(Ex, {
                      level: 3,
                      typographySize: "large",
                      className: CZ.heading,
                      multiline: true,
                      children: f,
                    }),
                  (0, jZ.jsx)(SZ, { asset: e, sourceCredits: p }),
                  e?.tags &&
                    (0, jZ.jsxs)(jZ.Fragment, {
                      children: [
                        (0, jZ.jsx)(Sw, {}),
                        (0, jZ.jsx)("div", {
                          className: CZ.tags,
                          children: e.tags.map((e) =>
                            (0, jZ.jsx)(
                              "span",
                              { className: CZ.tag, children: e },
                              e
                            )
                          ),
                        }),
                      ],
                    }),
                  (e.license || d) &&
                    (0, jZ.jsxs)(jZ.Fragment, {
                      children: [
                        (0, jZ.jsx)(Sw, {}),
                        (0, jZ.jsx)(_Z, {
                          asset: e,
                          license: e.license || d,
                        }),
                      ],
                    }),
                ],
              }),
              l &&
                (0, jZ.jsxs)(jZ.Fragment, {
                  children: [
                    (0, jZ.jsx)(Sw, {}),
                    (0, jZ.jsx)("footer", {
                      children: (0, jZ.jsx)(CompCustomButton, {
                        name: "remove-asset-button",
                        icon: (0, jZ.jsx)(vZ, {}),
                        variant: "plain",
                        color: "danger",
                        onClick: () => {
                          o.ui.showDialog({
                            type: "error",
                            content: {
                              title: i(
                                "component.library.removeAssetConfirmation"
                              ),
                              message: i(
                                "component.library.removeAssetConfirmation.description"
                              ),
                            },
                            actions: [
                              {
                                color: "danger",
                                label: i("common.delete"),
                                onClick: ({ id: t }) => {
                                  r.asset.removeAssetFromSource(n, e.id),
                                    r.asset.assetSourceContentsChanged(n),
                                    o.ui.closeDialog(t);
                                },
                              },
                            ],
                            cancel: {
                              variant: "plain",
                              label: i("common.cancel"),
                              onClick: ({ id: e }) => {
                                o.ui.closeDialog(e);
                              },
                            },
                          });
                        },
                        children: i("common.delete"),
                      }),
                    }),
                  ],
                }),
            ],
          }),
      ],
    }),
  });
};
export var OZ = function ({ isLoading: e }) {
  return e
    ? (0, MZ.jsx)("div", {
        className: BZ,
        children: (0, MZ.jsx)(AZ, { className: TZ }),
      })
    : null;
};

export var FZ = function ({
  children: e,
  isLoading: t,
  entry: n,
  asset: s,
  sourceId: i,
}) {
  return (0, DZ.jsxs)("div", {
    className: RZ,
    children: [
      e,
      (0, DZ.jsx)(OZ, { isLoading: t }),
      (0, DZ.jsx)(LZ, { asset: s, entry: n, sourceId: i, className: VZ }),
    ],
  });
};
export var qZ = {
  block: "UBQ_LocalSourceSectionHeaderUpload-module__block--MyifH",
};

export var GZ = function ({ sourceId: e, group: t, onUpload: n }) {
  const s = YF(),
    { t: i } = ZL(),
    o = (0, $Z.useMemo)(
      () => (e ? s.asset.getSupportedMimeTypes(e) : []),
      [s.asset, e]
    ),
    { uploadEnabled: r, uploadOptions: a } = XI(o),
    l = i("component.library.addFile");
  return r && null != e && n
    ? (0, QZ.jsxs)(lL, {
        name: "Upload",
        className: (0, zZ.default)(qZ.block),
        onFileChanged: (s) => {
          n(s, { sourceId: e, group: t });
        },
        accept: a.supportedMimeTypes?.join(","),
        multiple: true,
        children: [(0, QZ.jsx)(HZ, { className: qZ.icon }), l],
      })
    : null;
};
export var ZZ = GZ;

export var XZ = function ({
  sourceId: e,
  group: t,
  cardProps: n,
  masonryItemProps: s,
  onUpload: i,
}) {
  const o = YF(),
    { t: r } = ZL(),
    a = (0, UZ.useMemo)(
      () => (e ? o.asset.getSupportedMimeTypes(e) : []),
      [o.asset, e]
    ),
    { uploadEnabled: l, uploadOptions: c } = XI(a),
    u = r("component.library.addFile");
  return !s && l && i
    ? (0, YZ.jsx)(ZZ, {
        sourceId: e,
        onUpload: (n) => {
          i(n, { sourceId: e, group: t });
        },
      })
    : s && null != e && l && i
    ? (0, YZ.jsx)(
        _j.Item,
        {
          height: s.height,
          width: s.width,
          gap: s.gap,
          children: (0, YZ.jsx)(lL, {
            name: "Upload",
            onFileChanged: (n) => {
              i(n, { sourceId: e, group: t });
            },
            accept: c.supportedMimeTypes?.join(","),
            multiple: true,
            children: (e) =>
              (0, YZ.jsx)(hk, {
                ...n,
                "aria-label": u,
                className: (0, NZ.default)(n.className, WZ),
                ...e,
                children: (0, YZ.jsxs)("div", {
                  className: KZ,
                  children: [
                    (0, YZ.jsx)(HZ, {}),
                    (0, YZ.jsx)("span", { children: u }),
                  ],
                }),
              }),
          }),
        },
        "prepend-item"
      )
    : null;
};
export var JZ = XZ;

export var tW = (0, eW.createContext)({
  currentPlayingElement: null,
  setCurrentPlayingElement: () => aV,
});
export var nW = function () {
  const [e, t] = (0, eW.useState)(null);
  return { currentPlayingElement: e, setCurrentPlayingElement: t };
};

export var iW = function ({ onSelect: e }) {
  const t = ax(),
    [n, s] = (0, sW.useState)({});
  return {
    isAdding: (e) => n[e],
    handleSelect: (n) => async () => {
      e &&
        (s((e) => ({ ...e, [n.id]: true })),
        await e(n),
        t.current && s((e) => ({ ...e, [n.id]: false })));
    },
  };
};

export var rW = function (e, t) {
  const n = YF(),
    { canAdd: s } = e,
    i = 1 === t.length ? t[0] : undefined;
  return (0, oW.useMemo)(
    () =>
      null != i &&
      (!!n.asset.canManageAssets(i) ||
        (null != s && ("function" == typeof s ? s(i) : s))),
    [n.asset, s, i]
  );
};

export var hW = function ({ onLoad: e, hasMoreToLoad: t, isLoading: n }) {
  const { t: s } = ZL(),
    i = (0, cW.useRef)(null),
    o = ov(e),
    r = mp(i);
  return (
    (0, cW.useEffect)(() => {
      r && t && !n && o();
    }, [t, r, n, o]),
    (0, fW.jsxs)("div", {
      className: (0, lW.default)(uW, { [dW]: !t }),
      children: [
        (0, fW.jsx)("div", { ref: i, className: pW }),
        r && n ? (0, fW.jsx)(Hh, {}) : s("component.library.noMoreItems"),
      ],
    })
  );
};
export var bW = {
  grid: "UBQ_AssetLibraryGridSkeleton-module__grid--G6I7Y",
  label: "UBQ_AssetLibraryGridSkeleton-module__label--gdSHY",
  gradient: "UBQ_AssetLibraryGridSkeleton-module__gradient--M3qR-",
  labelContainer: "UBQ_AssetLibraryGridSkeleton-module__labelContainer--saTFS",
  prependedSourceUIComponentContainer:
    "UBQ_AssetLibraryGridSkeleton-module__prependedSourceUIComponentContainer--D38b8",
  cardWrapper: "UBQ_AssetLibraryGridSkeleton-module__cardWrapper--1za-F",
  animatedBackground:
    "UBQ_AssetLibraryGridSkeleton-module__animatedBackground--zsW4c",
  placeHolderShimmer:
    "UBQ_AssetLibraryGridSkeleton-module__placeHolderShimmer--4-W5d",
  loadingSpinnerIcon:
    "UBQ_AssetLibraryGridSkeleton-module__loadingSpinnerIcon---60AY",
  loading: "UBQ_AssetLibraryGridSkeleton-module__loading--nAVXg",
};

export function vW({
  children: e,
  isLoading: t,
  masonryGridWidth: n,
  masonryGridColumnCount: s,
}) {
  return (0, yW.jsx)(_j, {
    width: n,
    columnCount: s,
    className: bW.grid,
    children: ({ columnWidth: n, gap: s }) => [
      ...wW.map((e, i) => {
        const o = {
          height: hk.Height.Auto,
          backgroundType: "contain",
          disabled: true,
        };
        return (0, yW.jsx)(
          _j.Item,
          {
            height: e,
            width: n,
            gap: s,
            children: (0, yW.jsx)("div", {
              className: (0, xW.default)(bW.cardWrapper, {
                [bW.animatedBackground]: t,
              }),
              children: (0, yW.jsx)(hk, { ...o }),
            }),
          },
          i
        );
      }),
      (0, yW.jsx)("div", { className: bW.gradient }, "gradient"),
      (0, yW.jsx)(
        "div",
        { className: bW.labelContainer, children: e },
        "label"
      ),
    ],
  });
}
export var wW = [60, 100, 70, 120, 110, 90, 70];
export var kW = function ({
  sourceId: e,
  group: t,
  isError: n,
  isLoading: s,
  masonryGridWidth: i,
  masonryGridColumnCount: o,
  prependedSourceUIComponent: r,
  onUpload: a,
}) {
  const { t: l } = ZL();
  return n && !s
    ? (0, yW.jsxs)(vW, {
        masonryGridWidth: i,
        masonryGridColumnCount: o,
        children: [
          (0, yW.jsx)(gW, {}),
          (0, yW.jsx)("span", {
            className: bW.label,
            children: l("component.library.error"),
          }),
        ],
      })
    : s
    ? (0, yW.jsxs)(vW, {
        isLoading: true,
        masonryGridWidth: i,
        masonryGridColumnCount: o,
        children: [
          (0, yW.jsx)(AZ, { className: bW.loadingSpinnerIcon }),
          (0, yW.jsx)("span", {
            className: bW.label,
            children: l("component.library.loading"),
          }),
        ],
      })
    : (0, yW.jsxs)(vW, {
        masonryGridWidth: i,
        masonryGridColumnCount: o,
        children: [
          (0, yW.jsx)("span", {
            className: bW.label,
            children: l("component.library.noItems"),
          }),
          r &&
            (0, yW.jsx)("div", {
              className: bW.prependedSourceUIComponentContainer,
              children: (0, yW.jsx)(r, {
                sourceId: e,
                group: t,
                isPreview: false,
                cardProps: {
                  className: bW.prependedSourceUIComponent,
                  height: hk.Height.Auto,
                },
                onUpload: a,
              }),
            }),
        ],
      });
};

export var jW = mayBeUseMemp(function ({
  query: e,
  group: t,
  entry: n,
  source: s,
  onUpload: i,
  ...o
}) {
  const { t: r } = ZL(),
    a = YF(),
    l = YR(),
    [c, u] = (0, PG.useState)(1),
    d = (0, PG.useRef)(null),
    { currentPlayingElement: p, setCurrentPlayingElement: f } = (0,
    PG.useContext)(tW);
  (0, PG.useEffect)(() => {
    const e = new Set(),
      t = new ResizeObserver(() => {
        const t = setTimeout(function () {
          if (d.current) {
            e.delete(t);
            const n = getComputedStyle(d.current),
              s = parseFloat(n.paddingLeft),
              i = parseFloat(n.paddingRight);
            u(d.current.clientWidth - s - i);
          }
        }, 0);
        e.add(t);
      });
    return (
      d.current && t.observe(d.current),
      () => {
        t.disconnect();
        for (const t of e) clearTimeout(t);
        e.clear();
      }
    );
  }, [d]);
  const h = [];
  n.includeGroups && h.push(...n.includeGroups), t && h.push(t);
  const {
    data: m,
    isFetching: g,
    isFetchingNextPage: x,
    fetchNextPage: b,
    hasNextPage: y,
    isError: v,
    refetch: w,
  } = QF(
    QD(
      [
        "ubq",
        "assets",
        s.id,
        {
          query: e,
          perPage: n.previewLength,
          groups: h,
          excludeGroups: n.excludeGroups,
        },
      ],
      ({ pageParam: t = 0 }) =>
        s.findAssets({
          query: e,
          groups: h,
          excludeGroups: n.excludeGroups,
          page: t,
          locale: l.language,
          perPage: 30,
        }),
      { retry: 3, getNextPageParam: (e) => e.nextPage }
    ),
    TF
  );
  (0, PG.useEffect)(
    () =>
      a.asset.onAssetSourceUpdated((e) => {
        e === s.id && w();
      }),
    [a.asset, w, s.id]
  );
  const { isAdding: k, handleSelect: C } = iW(o),
    j = g || x,
    S =
      (0, LG.default)(
        (0, EG.default)(
          m?.pages?.map((e) =>
            e.assets.map((t) => ({ ...t, page: e.currentPage }))
          )
        ),
        "id"
      ) || [],
    _ = rW(n, [s.id]) ? JZ : undefined,
    E = (0, PG.useRef)(null),
    [L, P] = (0, PG.useState)(false),
    A = DO(),
    [, { previewRole: B, setPreviewRole: T }] = KF();
  return (0, CW.jsxs)("div", {
    ref: d,
    className: aW,
    children: [
      0 === S.length &&
        (0, CW.jsx)(kW, {
          sourceId: s.id,
          group: t,
          isError: v,
          isLoading: j,
          masonryGridWidth: c,
          masonryGridColumnCount: n.gridColumns,
          onUpload: i,
          prependedSourceUIComponent: _,
        }),
      (0, CW.jsx)(TG, {
        assetSourceId: s.id,
        show: L,
        onDialogAbort: () => {
          P(false);
        },
        onDialogConfirm: async () => {
          if (
            (("ly.img.template" !== n.id && "ly.img.video.template" !== n.id) ||
              (null !== B &&
                LB(() => {
                  A.getUndoManager().deactivatePreviewUndoStack(), T(null);
                })),
            E.current)
          ) {
            const e = C(E.current);
            await e(), P(false);
          }
        },
      }),
      (0, CW.jsx)(_j, {
        width: c,
        columnCount: n.gridColumns,
        children: ({ columnWidth: e, gap: o }) => {
          const a = {},
            l = parseInt(
              xh("--ubq-typography-label-s-line_height", {
                fallback: "14px",
              }),
              10
            ),
            c = parseInt(xh("--ubq-margin-s", { fallback: "8px" }), 10),
            {
              gridItemHeight: u,
              cardLabelPosition: d,
              gridBackgroundType: h,
            } = n;
          switch (u) {
            case "square":
            case "auto":
              a.height = hk.Height.Auto;
              break;
            default:
              a.height = hk.Height.Short;
          }
          let m = 1;
          const g = S.length > 0 ? n.cardLabelTruncateLines?.(S[0]) : "multi",
            x = "square" === u && S.every((e) => "below" === d?.(e)),
            b = S.every((e) => n.cardLabelTruncateLines?.(e) === g)
              ? g
              : "multi",
            y = l * ("single" === b ? 1 : 2) + 2 * c,
            v = S.map((t, i) => {
              const g = undefined !== t.payload?.color,
                v = t.meta?.width ?? (g ? 2.25 : 1),
                w = t.meta?.height ?? 1,
                j = x ? b : n.cardLabelTruncateLines?.(t) ?? "multi",
                S = x
                  ? y
                  : "below" === d?.(t)
                  ? l * ("single" === j ? 1 : 2) + 2 * c
                  : 0,
                _ = "contain" === h ? 2 * c : 0,
                L = ("auto" === u ? (e - _) / (v / w) + _ : e) + S;
              0 === i && (m = L);
              const A = k(t.id),
                B = r(
                  t.label ??
                    ("function" == typeof n.cardLabel
                      ? n.cardLabel(t)
                      : n.cardLabel) ??
                    t.meta?.filename ??
                    ""
                ),
                T = {
                  ...a,
                  "data-cy": `assetLibraryCard-${t.id}`,
                  disabled: A,
                  "aria-label": B,
                  matchCardHeightToLabelLines: j,
                  onClick: async () => {
                    if (
                      "boolean" == typeof n.promptBeforeApply
                        ? n.promptBeforeApply
                        : n.promptBeforeApply?.show &&
                          (!n.promptBeforeApply.sourceIds ||
                            n.promptBeforeApply.sourceIds?.includes(s.id))
                    )
                      (E.current = t), P(true);
                    else {
                      const e = C(t);
                      await e();
                    }
                  },
                },
                M = t.meta?.mimeType?.includes("audio");
              return (0, CW.jsx)(
                _j.Item,
                {
                  height: L,
                  width: e,
                  gap: o,
                  children: (0, CW.jsx)(FZ, {
                    isLoading: A,
                    entry: n,
                    asset: t,
                    sourceId: s.id,
                    children: (0, CW.jsx)(iZ, {
                      entry: n,
                      asset: t,
                      ...T,
                      className: hZ,
                      children:
                        M &&
                        (0, CW.jsx)(gZ, {
                          asset: t,
                          onClick: (e) => {
                            p && p.pause(), f(e);
                          },
                        }),
                    }),
                  }),
                },
                `${t.id}-${t.page}`
              );
            });
          return [
            S.length > 0 &&
              _ &&
              (0, CW.jsx)(
                _,
                {
                  sourceId: s.id,
                  group: t,
                  isPreview: false,
                  cardProps: a,
                  masonryItemProps: { height: m, width: e, gap: o },
                  onUpload: i,
                },
                "prepend-item"
              ),
            ...v,
          ];
        },
      }),
      (0, CW.jsx)(
        hW,
        {
          isLoading: j,
          hasMoreToLoad: y,
          onLoad: async () => {
            y && (await b());
          },
        },
        "loading-anchor"
      ),
    ],
  });
});
export var SW = jW;

export var PW = function ({ isLoading: e }) {
  const [t, n] = (0, _W.useState)(false);
  yv(() => {
    n(true);
  }, 200);
  const [s, i] = $E((e, t) => {
    const n = parseFloat(e.paddingLeft),
      s = parseFloat(e.paddingRight);
    return t.clientWidth - n - s;
  }, 1);
  return t
    ? (0, LW.jsx)("div", {
        ref: s,
        className: EW,
        children: (0, LW.jsx)(kW, {
          sourceId: "",
          isLoading: e,
          masonryGridWidth: i,
          masonryGridColumnCount: 3,
        }),
      })
    : null;
};

export var TW = function () {
  const [e, t] = $E((e, t) => {
    const n = parseFloat(e.paddingLeft),
      s = parseFloat(e.paddingRight);
    return t.clientWidth - n - s;
  }, 1);
  return (0, BW.jsx)("div", {
    ref: e,
    className: AW,
    children: (0, BW.jsx)(kW, {
      sourceId: "",
      masonryGridWidth: t,
      masonryGridColumnCount: 3,
    }),
  });
};
export var IW = function (e, t) {
  const n = e.reduce((e, t) => e + (t?.total ?? 0), 0),
    s = (0, FW.default)(...e.map((e) => e?.assets ?? []));
  return {
    assets: (0, DW.default)(s).filter(Boolean).slice(0, t),
    total: n,
    currentPage: 1,
    nextPage: undefined,
  };
};
export var HW = {
  block: "UBQ_AssetLibrarySection-module__block--GjBKH",
  visible: "UBQ_AssetLibrarySection-module__visible--jDroU",
  header: "UBQ_AssetLibrarySection-module__header--zaDtl",
  heading: "UBQ_AssetLibrarySection-module__heading--wwrkD",
  moreButton: "UBQ_AssetLibrarySection-module__moreButton--evCHL",
  previews: "UBQ_AssetLibrarySection-module__previews--tS0xD",
  scrollContainer: "UBQ_AssetLibrarySection-module__scrollContainer--vz2MB",
  paginationContainer:
    "UBQ_AssetLibrarySection-module__paginationContainer--4-kTI",
  paginationButton: "UBQ_AssetLibrarySection-module__paginationButton--ZB0fn",
  paginationButtonLeft:
    "UBQ_AssetLibrarySection-module__paginationButtonLeft--Jzbym",
  paginationButtonRight:
    "UBQ_AssetLibrarySection-module__paginationButtonRight----DAi",
  moreIcon: "UBQ_AssetLibrarySection-module__moreIcon--dBquf",
  inlineMoreButtonContainer:
    "UBQ_AssetLibrarySection-module__inlineMoreButtonContainer--lv-sU",
  inlineMoreButton: "UBQ_AssetLibrarySection-module__inlineMoreButton--Zqp2y",
};

export var qW =
  "UBQ_AssetLibrarySectionSkeleton-module__animatedBackground--PGO2X";
export var QW =
  "UBQ_AssetLibrarySectionSkeleton-module__loadingSpinnerIcon---n0-v";

export var ZW = function ({
  min: e,
  cardProps: t,
  isLoading: n,
  isError: s,
  isEmpty: i,
}) {
  const { t: o } = ZL();
  return (0, GW.jsxs)(GW.Fragment, {
    children: [
      (0, UW.default)(e).map((e, s) =>
        (0, GW.jsx)(
          "div",
          {
            className: (0, NW.default)(t.className, { [qW]: n }),
            children: (0, GW.jsx)(hk, { ...t }, s),
          },
          s
        )
      ),
      (0, GW.jsx)("div", {
        className: zW,
        children: s
          ? (0, GW.jsxs)(GW.Fragment, {
              children: [
                (0, GW.jsx)(gW, {}),
                (0, GW.jsx)("span", {
                  className: $W,
                  children: o("component.library.error"),
                }),
              ],
            })
          : n
          ? (0, GW.jsxs)(GW.Fragment, {
              children: [
                (0, GW.jsx)(AZ, { className: QW }),
                (0, GW.jsx)("span", {
                  className: $W,
                  children: o("component.library.loading"),
                }),
              ],
            })
          : i
          ? o("component.library.noItems")
          : "",
      }),
    ],
  });
};

export function KW({ className: e, onClick: t, icon: n }) {
  return (0, WW.jsx)(Sd.button, {
    type: "button",
    className: (0, RW.default)(HW.paginationButton, e),
    onClick: t,
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
    transition: { type: "tween", duration: 0.2 },
    children: n,
  });
}
export var YW = mayBeUseMemp(function ({
  label: e,
  query: t,
  entry: n,
  sources: s,
  group: i,
  isDisabled: o,
  onEnter: r,
  "data-cy": a,
  onUpload: l,
  ...c
}) {
  const { t: u } = ZL(),
    d = YF(),
    p = YR(),
    { currentPlayingElement: f, setCurrentPlayingElement: h } = (0,
    VW.useContext)(tW),
    { id: m, previewLength: g } = n,
    x = rW(
      n,
      s.map((e) => e.id)
    )
      ? ZZ
      : undefined,
    b = g,
    y = [];
  n.includeGroups && y.push(...n.includeGroups), i && y.push(i);
  const v = (function (e) {
    var t = ZF.default.useRef(false),
      n = ZF.default.useState(0)[1],
      s = IF(),
      i = (0, ZF.useMemo)(
        function () {
          return e.map(function (e) {
            var t = s.defaultQueryObserverOptions(e);
            return (t.optimisticResults = true), t;
          });
        },
        [e, s]
      ),
      o = ZF.default.useState(function () {
        return new BF(s, i);
      })[0],
      r = o.getOptimisticResult(i);
    return (
      ZF.default.useEffect(
        function () {
          t.current = true;
          var e = o.subscribe(
            fF.batchCalls(function () {
              t.current &&
                n(function (e) {
                  return e + 1;
                });
            })
          );
          return function () {
            (t.current = false), e();
          };
        },
        [o]
      ),
      ZF.default.useEffect(
        function () {
          o.setQueries(i, { listeners: false });
        },
        [i, o]
      ),
      r
    );
  })(
    s.map((e) => ({
      queryKey: [
        "ubq",
        "assets",
        e.id,
        {
          query: t,
          perPage: n.previewLength,
          groups: y,
          excludeGroups: n.excludeGroups,
        },
      ],
      queryFn: () =>
        e.findAssets({
          groups: y,
          excludeGroups: n.excludeGroups,
          query: t,
          perPage: 10,
          page: 0,
          locale: p.language,
        }),
    }))
  );
  (0, VW.useEffect)(
    () =>
      d.asset.onAssetSourceUpdated((e) => {
        const t = s.findIndex((t) => t.id === e);
        -1 !== t && v[t].refetch();
      }),
    [d.asset, v, s]
  );
  const {
      data: w,
      isError: k,
      isLoading: C,
    } = (0, VW.useMemo)(
      () => ({
        data: IW(
          v.filter((e) => undefined !== e.data).map((e) => e.data),
          10
        ),
        isError: v.some((e) => e.isError),
        isLoading: v.some((e) => e.isLoading),
      }),
      [v]
    ),
    { isAdding: j, handleSelect: S } = iW(c),
    _ = (0, VW.useMemo)(() => w?.assets || [], [w]),
    E = w ? w.total : undefined,
    [L, { contentWidth: P, gridGap: A }] = $E(
      (e, t) => {
        const n = parseFloat(e.paddingLeft),
          s = parseFloat(e.paddingRight),
          i = parseFloat(e.gridColumnGap);
        return { contentWidth: t.clientWidth - n - s, gridGap: i };
      },
      { contentWidth: 1, gridGap: 1 }
    ),
    B = Math.max(b, Math.min(3, _.length)),
    T = (P - (B - 1) * A) / B,
    M = {
      className: HW.card,
      height: hk.Height.ExtraShort,
      style: { height: `${T}px` },
      backgroundType: "contain",
    },
    O = { ...M, disabled: true },
    R = 0 === _.length || k || C,
    [V, D] = (0, VW.useState)(false),
    F = 100 / B,
    I = L.current
      ? parseFloat(
          getComputedStyle(L.current).getPropertyValue("--ubq-margin-s")
        )
      : 8,
    H = `calc(${F}% - ${(I / B) * (B - 1) + "px"})`,
    N = (0, VW.useRef)(null),
    [U, z] = (0, VW.useState)(0),
    [$, q] = (0, VW.useState)(false);
  function Q(e) {
    if (N.current && L.current) {
      const t = parseFloat(getComputedStyle(L.current).marginInline),
        n = N.current.clientWidth - t - I,
        s = U % (n / B),
        i = { behavior: "smooth", left: "next" === e ? n - s : -1 * (n + s) };
      N.current.scrollBy(i);
    }
  }
  return (
    (0, VW.useEffect)(() => {
      q(
        (function () {
          if (N.current && L.current) {
            const e = N.current.scrollWidth,
              t = L.current.clientWidth,
              n = parseFloat(getComputedStyle(L.current).marginInline);
            return U >= e - t - 2 * n - t / B / 2;
          }
          return false;
        })()
      );
    }, [L, U, _, B]),
    (0, WW.jsxs)("div", {
      className: (0, RW.default)(HW.block, { [HW.visible]: T > 1 }),
      "data-cy": a,
      children: [
        (0, WW.jsxs)("div", {
          className: HW.header,
          children: [
            (0, WW.jsx)(HI, { className: HW.heading, level: 2, children: e }),
            x &&
              (0, WW.jsx)(x, {
                sourceId: 1 === s.length ? s[0].id : undefined,
                group: i,
                onUpload: l,
              }),
            (0, WW.jsx)(Ly, {
              label: u("component.library.enterSection"),
              children: (0, WW.jsx)(CompCustomButton, {
                name: `${a}--enter`,
                variant: "plain",
                onClick: r,
                className: HW.moreButton,
                isDisabled: o,
                children: (0, WW.jsx)("span", {
                  children:
                    null == E || (null != E && E > 999)
                      ? u("common.more")
                      : `${u("common.more")} (${E})`,
                }),
              }),
            }),
          ],
        }),
        (0, WW.jsxs)("div", {
          className: HW.paginationContainer,
          children: [
            (0, WW.jsxs)(DynamicPresenceTransition, {
              children: [
                0 !== U &&
                  (0, WW.jsx)(
                    KW,
                    {
                      className: HW.paginationButtonLeft,
                      onClick: () => Q("previous"),
                      icon: (0, WW.jsx)(wQ, {}),
                    },
                    "pagination-previous"
                  ),
                !$ &&
                  (0, WW.jsx)(
                    KW,
                    {
                      className: HW.paginationButtonRight,
                      onClick: () => Q("next"),
                      icon: (0, WW.jsx)(zq, {}),
                    },
                    "pagination-next"
                  ),
              ],
            }),
            (0, WW.jsx)("div", {
              className: HW.scrollContainer,
              ref: N,
              onScroll: (e) => {
                const t = e.target.scrollLeft;
                z(t);
              },
              children: (0, WW.jsxs)("div", {
                ref: L,
                className: HW.previews,
                style: {
                  gridTemplateColumns: `repeat(${B}, ${H})`,
                  gridAutoColumns: H,
                },
                children: [
                  R
                    ? (0, WW.jsx)(ZW, {
                        min: b,
                        cardProps: O,
                        isLoading: C,
                        isError: k,
                        isEmpty: 0 === _.length,
                      })
                    : _.map((e) => {
                        const t = `${m}-${e.id}`,
                          s = j(e.id),
                          i = u(
                            e.label ??
                              ("function" == typeof n.cardLabel
                                ? n.cardLabel(e)
                                : n.cardLabel) ??
                              e.meta?.filename ??
                              ""
                          ),
                          r = {
                            ...M,
                            style: {
                              ...M.style,
                              ...(n.cardStyle ? n.cardStyle(e) : {}),
                            },
                            name: `assetLibraryCard-${e.id}`,
                            "data-cy": `assetLibraryCard-${e.id}`,
                            disabled: o || s,
                            "aria-label": i,
                            onClick: async () => {
                              if (
                                "boolean" == typeof n.promptBeforeApply
                                  ? n.promptBeforeApply
                                  : n.promptBeforeApply?.show &&
                                    (!n.promptBeforeApply.sourceIds ||
                                      n.promptBeforeApply.sourceIds.includes(
                                        e.context.sourceId
                                      ))
                              )
                                D(true);
                              else {
                                const t = S(e);
                                await t();
                              }
                            },
                          },
                          a = e.meta?.mimeType?.includes("audio");
                        return (0, WW.jsxs)(
                          FZ,
                          {
                            isLoading: s,
                            entry: n,
                            asset: e,
                            sourceId: e.context.sourceId,
                            children: [
                              (0, WW.jsx)(TG, {
                                assetSourceId: e.context.sourceId,
                                show: V,
                                onDialogAbort: () => {
                                  D(false);
                                },
                                onDialogConfirm: async () => {
                                  const t = S(e);
                                  await t(), D(false);
                                },
                              }),
                              (0, WW.jsx)(iZ, {
                                isPreview: true,
                                entry: n,
                                asset: e,
                                ...r,
                                className: hZ,
                                children:
                                  a &&
                                  (0, WW.jsx)(gZ, {
                                    asset: e,
                                    onClick: (e) => {
                                      f && f.pause(), h(e);
                                    },
                                  }),
                              }),
                            ],
                          },
                          t
                        );
                      }),
                  !R &&
                    E &&
                    E > 10 &&
                    (0, WW.jsx)("div", {
                      className: HW.inlineMoreButtonContainer,
                      children: (0, WW.jsx)(CompCustomButton, {
                        name: "scrollable_section-action-more",
                        className: HW.inlineMoreButton,
                        onClick: r,
                        children: (0, WW.jsx)(OW, {}),
                      }),
                    }),
                ],
              }),
            }),
          ],
        }),
      ],
    })
  );
});
export var XW = YW;

export var tK = function ({
  query: e,
  sections: t,
  onEnter: n,
  onSelect: s,
  onUpload: i,
}) {
  const { t: o } = ZL();
  return 0 === t.length
    ? (0, eK.jsx)("div", { className: JW, children: (0, eK.jsx)(TW, {}) })
    : (0, eK.jsx)("div", {
        className: JW,
        children: t.map((r, a) => {
          const { entry: l } = r,
            c = a,
            u = r.label ?? bG(o, { entry: l, group: r.group });
          return (0, eK.jsxs)(
            "div",
            {
              children: [
                (0, eK.jsx)(XW, {
                  query: e,
                  label: u,
                  entry: l,
                  group: r.group,
                  sources: r.sources,
                  onSelect: s,
                  onEnter: () => {
                    n?.(r);
                  },
                  "data-cy": r.dataCy || `asset-library-section-${l.id}`,
                  onUpload: i,
                }),
                a < t.length - 1 && (0, eK.jsx)(Sw, {}),
              ],
            },
            c
          );
        }),
      });
};
export var nK = tK;
export var sK = async function (e, t) {
  if (!e.getGroups)
    throw new Error(`Expected source ${e.id} to have getGroups method`);
  const n = await e.getGroups(),
    s = t.excludeGroups || [];
  return n.filter((e) => !s.some((t) => t === e));
};

export var aK = function ({ onSelect: e, onUpload: t }) {
  const { t: n } = ZL(),
    {
      query: s,
      navigation: {
        isLoading: i,
        locationStack: o,
        currentLocation: r,
        pushLocation: a,
        popLocation: l,
        clearLocationStack: c,
      },
    } = BK(),
    u = {
      className: oK,
      transition: { ease: "easeIn", duration: 0.2 },
      initial: { opacity: 0.25 },
      animate: { opacity: 1 },
    },
    { currentPlayingElement: d, setCurrentPlayingElement: p } = nW(),
    f = (0, gG.useMemo)(
      () => ({ currentPlayingElement: d, setCurrentPlayingElement: p }),
      [d, p]
    );
  return (0, rK.jsx)(tW.Provider, {
    value: f,
    children: (0, rK.jsx)("div", {
      id: "asset-library-content",
      className: iK,
      children: (0, rK.jsx)(DynamicPresenceTransition, {
        initial: false,
        children: (() => {
          if (i) return (0, rK.jsx)(PW, { isLoading: i });
          switch (r?.view) {
            case "entriesOverview":
              return (0, rK.jsx)(
                Sd.div,
                {
                  ...u,
                  children: (0, rK.jsx)(nK, {
                    query: s,
                    sections: r.entries
                      .map((e) => {
                        const t = e.getSources();
                        return (
                          !(!t || 0 === t.length) && { entry: e, sources: t }
                        );
                      })
                      .filter(Boolean),
                    onEnter: async ({ entry: e, sources: t }) => {
                      if (t.length > 1)
                        a({ entry: e, view: "sourcesOverview", sources: t });
                      else {
                        if (1 !== t.length)
                          throw new Error(`No source defined for ${e.id}`);
                        {
                          const n = t[0],
                            s = await sK(n, e);
                          s.length > 1 && e.showGroupOverview
                            ? a({
                                entry: e,
                                view: "groupsOverview",
                                source: n,
                                groups: s,
                              })
                            : a({ entry: e, view: "grid", source: n });
                        }
                      }
                    },
                    onSelect: e,
                    onUpload: t,
                  }),
                },
                "initial"
              );
            case "groupsOverview": {
              const { entry: i, source: d, groups: p } = r;
              return (0, rK.jsxs)(
                Sd.div,
                {
                  ...u,
                  children: [
                    o.length > 1 &&
                      (0, rK.jsxs)(rK.Fragment, {
                        children: [
                          (0, rK.jsx)(_G, {
                            locationStack: o,
                            pushLocation: a,
                            popLocation: l,
                            clearLocationStack: c,
                          }),
                          (0, rK.jsx)(Sw, {}),
                        ],
                      }),
                    (0, rK.jsx)(nK, {
                      query: s,
                      sections: p.map((e) => ({
                        entry: i,
                        sources: [d],
                        label: bG(n, { entry: i, group: e, sourceId: d.id }),
                        group: e,
                      })),
                      onEnter: ({ group: e }) => {
                        a({ view: "grid", entry: i, source: d, group: e });
                      },
                      onSelect: e,
                      onUpload: t,
                    }),
                  ],
                },
                `${r.entry.id}.${o.length}`
              );
            }
            case "sourcesOverview": {
              const { entry: i, sources: d } = r;
              return (0, rK.jsxs)(
                Sd.div,
                {
                  ...u,
                  children: [
                    o.length > 1 &&
                      (0, rK.jsxs)(rK.Fragment, {
                        children: [
                          (0, rK.jsx)(_G, {
                            locationStack: o,
                            pushLocation: a,
                            popLocation: l,
                            clearLocationStack: c,
                          }),
                          (0, rK.jsx)(Sw, {}),
                        ],
                      }),
                    (0, rK.jsx)(nK, {
                      query: s,
                      sections: d.map((e) => ({
                        entry: i,
                        sources: [e],
                        label: bG(n, { entry: i, sourceId: e.id }),
                        dataCy: `asset-library-section-${e.id}`,
                      })),
                      onEnter: async (e) => {
                        const t = e.sources[0],
                          n = await sK(t, i);
                        n.length > 1 && i.showGroupOverview
                          ? a({
                              entry: i,
                              view: "groupsOverview",
                              source: t,
                              groups: n,
                            })
                          : a({
                              entry: i,
                              view: "grid",
                              source: t,
                              label: e.label,
                            });
                      },
                      onSelect: e,
                      onUpload: t,
                    }),
                  ],
                },
                `${r.entry.id}.${o.length}`
              );
            }
            case "grid":
              return (0, rK.jsxs)(
                Sd.div,
                {
                  ...u,
                  children: [
                    o.length > 1 &&
                      (0, rK.jsxs)(rK.Fragment, {
                        children: [
                          (0, rK.jsx)(_G, {
                            locationStack: o,
                            pushLocation: a,
                            popLocation: l,
                            clearLocationStack: c,
                          }),
                          (0, rK.jsx)(Sw, {}),
                        ],
                      }),
                    (0, rK.jsx)(SW, {
                      query: s,
                      entry: r.entry,
                      source: r.source,
                      group: r.group,
                      onSelect: e,
                      onUpload: t,
                    }),
                  ],
                },
                `${r.entry.id}.${o.length}`
              );
            default:
              return null;
          }
        })(),
      }),
    }),
  });
};
export var lK = aK;
export var dK = Ny;

export var bK =
  "UBQ_AssetLibrarySearch-module__clearSearchIconContainer--pxocd";

export var CK = function ({
  placeholder: e,
  defaultValue: t = "",
  className: n,
}) {
  const { t: s } = ZL(),
    i = (0, fK.useRef)(null),
    { setQuery: o, navigation: r } = BK(),
    [a, l] = (0, fK.useState)(t),
    { isReady: c, clear: u, debounce: d } = nL(),
    p = (0, fK.useMemo)(() => {
      const e = r.locationStack[0];
      if (e)
        return "dockGroupId" in e
          ? e.dockGroupId
          : "entry" in e
          ? e.entry.id
          : undefined;
    }, [r.locationStack]);
  return (
    (0, fK.useEffect)(() => {
      u(), o(t), l(t);
    }, [p, u, t, o]),
    Xy(
      ["enter"],
      () => {
        false === c() && (u(), o(a));
      },
      { global: true, elementRef: i }
    ),
    (0, kK.jsx)("div", {
      className: (0, pK.default)(hK, n),
      children: (0, kK.jsxs)("div", {
        className: gK,
        children: [
          (0, kK.jsx)(dK, {
            ref: i,
            className: mK,
            value: a,
            onChange: (e) => {
              const { value: t } = e.target;
              l(t), "" === t ? (u(), o("")) : d(() => o(t));
            },
            placeholder: e,
            "data-cy": "librarySearch",
          }),
          (0, kK.jsx)("div", {
            className: xK,
            children: (0, kK.jsx)(uK, { className: vK }),
          }),
          (0, kK.jsx)("div", {
            className: (0, pK.default)(bK, { [yK]: !a }),
            children: (0, kK.jsx)(CompCustomButton, {
              name: "clear-search",
              "aria-label": s("component.library.clearSearch"),
              variant: "plain",
              isDisabled: !a,
              onClick: () => {
                l(""), o("");
              },
              children: (0, kK.jsx)(mv, { className: wK }),
            }),
          }),
        ],
      }),
    })
  );
};
export var jK = CK;
export var SK = async function (e) {
  if (1 === e.length) {
    const t = e[0],
      n = e[0].getSources();
    if (n.length > 1) return { view: "sourcesOverview", entry: t, sources: n };
    if (1 === n.length) {
      const e = n[0],
        s = await sK(e, t);
      return s.length > 1 && t.showGroupOverview
        ? { view: "groupsOverview", entry: t, source: e, groups: s }
        : { view: "grid", entry: t, source: e };
    }
  }
  return { view: "entriesOverview", entries: e ?? [] };
};

export var EK = [];
export var LK = function ({ assetPanelOpen: e, initialLocation: t = EK }) {
  const n = (0, _K.useRef)(true);
  (0, _K.useEffect)(
    () => (
      (n.current = true),
      () => {
        n.current = false;
      }
    ),
    []
  );
  const s = (0, _K.useCallback)(() => ("function" == typeof t ? t() : t), [t]),
    i = (0, _K.useCallback)(async () => {
      const e = s();
      if (e instanceof Promise) {
        r((e) => ({ ...e, isLoading: true }));
        const t = await e;
        n.current && r({ locationStack: t, isLoading: false });
      } else r({ locationStack: e, isLoading: false });
    }, [s]),
    [o, r] = (0, _K.useState)({ isLoading: false, locationStack: [] });
  (0, _K.useEffect)(() => {
    i();
  }, [i]),
    (0, _K.useEffect)(() => {
      e || i();
    }, [e, i]);
  const a = o.locationStack[o.locationStack.length - 1];
  return {
    ...o,
    currentLocation: a,
    pushLocation: (e) => {
      r((t) => ({ ...t, locationStack: [...t.locationStack, e] }));
    },
    popLocation: () => {
      r((e) => ({ ...e, locationStack: e.locationStack.slice(0, -1) }));
    },
    resetLocationStack: (e) => {
      r((t) => ({ ...t, locationStack: e }));
    },
    clearLocationStack: () => {
      i();
    },
    assetPanelOpen: e,
  };
};

export var AK = (0, mG.createContext)(null);
export function BK() {
  const e = (0, mG.useContext)(AK);
  if (!e)
    throw new Error(
      "useAssetLibrary must be used within an AssetLibrary component"
    );
  return e;
}
export function TK({ children: e, entries: t, assetPanelOpen: n }) {
  const [s, i] = (0, mG.useState)(""),
    o = (0, mG.useCallback)(async () => {
      if (!t) return [];
      return [await SK(t)];
    }, [t]),
    r = LK({ initialLocation: o, assetPanelOpen: n }),
    a = (0, mG.useMemo)(
      () => ({ query: s, setQuery: i, navigation: r }),
      [s, r]
    );
  return (0, PK.jsx)(AK.Provider, { value: a, children: e });
}
(TK.Search = jK), (TK.Content = lK);
export var MK = TK;
export var NK = function ({
  label: e,
  children: t,
  isEnabled: n,
  toggleProperty: s,
  isVisible: i = true,
  withButtonLabel: o = false,
  enabledIcon: r,
  disabledIcon: a,
  enabledButtonLabel: l,
  disabledButtonLabel: c,
  ...u
}) {
  const { t: d } = ZL(),
    p = d(n ? "input.propertyToggle.disable" : "input.propertyToggle.enable", {
      property: e,
    }),
    f = d("input.propertyToggle.enable", { property: e }),
    h = IV(),
    m = r ?? DK,
    g = a ?? RK,
    x = l ?? d("input.propertyToggle.visible"),
    b = c ?? d("input.propertyToggle.hidden");
  return (0, HK.jsxs)(HK.Fragment, {
    children: [
      t,
      i
        ? (0, HK.jsx)(Ly, {
            label: p,
            "data-cy": `${p}-tooltip`,
            children: o
              ? (0, HK.jsxs)(CompCustomButton, {
                  "aria-label": f,
                  name: "toggleProperty",
                  className: FK,
                  variant: "plain",
                  onClick: () => {
                    s((e) => !e), h("action.property.update");
                  },
                  isActive: n,
                  activeStateStyle: "none",
                  ...u,
                  children: [
                    n ? x : b,
                    n ? (0, HK.jsx)(m, {}) : (0, HK.jsx)(g, {}),
                  ],
                })
              : (0, HK.jsx)(Zp, {
                  "aria-label": f,
                  name: "toggleProperty",
                  className: FK,
                  onClick: () => {
                    s((e) => !e), h("action.property.update");
                  },
                  "aria-pressed": n,
                  "data-active": n,
                  ...u,
                  children: n ? (0, HK.jsx)(m, {}) : (0, HK.jsx)(g, {}),
                }),
          })
        : null,
    ],
  });
};

export var zK = function () {
  return (0, UK.jsx)("div", { className: IK });
};

export var qK = new RegExp("//ly.img.ubq/(.*)");
export var QK = function (e) {
  const t = e.match(qK);
  return t ? t[1] : e;
};
export function GK(e) {
  return !!e;
}
export function ZK(e, t, n) {
  return e
    .map((e) =>
      null == e.id
        ? (console.warn("Omitting entry without any id configured: ", e), null)
        : WK(e, t, n)
    )
    .filter(GK);
}
export function WK(e, t, n) {
  const s = n ?? t.asset.findAllSources();
  return {
    showGroupOverview: true,
    previewLength: 3,
    gridColumns: 3,
    gridItemHeight: "square",
    previewBackgroundType: "contain",
    gridBackgroundType: "contain",
    cardBackgroundPreferences: [
      { path: "meta.vectorPath", type: "svgVectorPath" },
      { path: "meta.thumbUri", type: "image" },
    ],
    cardLabelPosition: () => "inside",
    cardLabelTruncateLines: () => "multi",
    ...e,
    getSources: () =>
      (e.sourceIds ?? []).filter((e) => !!s.includes(e)).map((e) => RV(e, t)),
  };
}
export var KK, YK;
export var XK = WK;

export var tY = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO().feature.isEnabled("ly.img.animations", { engine: e }),
      [s] = e.block.findAllSelected();
    if (null == s) return null;
    return e.block.supportsAnimation(s) && n ? t({ block: s }) : null;
  })
);
export var nY = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    {
      ui: { baseURL: n },
    } = FI(),
    s = t("libraries.ly.img.animations.ly.img.animations.label"),
    i = (0, $K.useMemo)(
      () => [
        XK(
          {
            id: "ly.img.animations",
            sourceIds: ["ly.img.animations"],
            cardLabel: (e) => {
              const n = e.id.split("/");
              return t(`property.animation.${n[n.length - 1]}`);
            },
            cardLabelPosition: () => "below",
            gridBackgroundType: "cover",
            previewBackgroundType: "cover",
            cardBackgroundPreferences: (e) => {
              const t = e.id.split("/"),
                s = t[t.length - 1];
              return "none" === s
                ? {
                    type: "svgVectorPath",
                    viewBox: "0 0 24 24",
                    width: 40,
                    height: 40,
                    d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm3.394 4.192a7 7 0 0 1 9.799-9.799l-9.8 9.8Zm1.414 1.414a7 7 0 0 0 9.799-9.799l-9.8 9.8Z",
                    fillRule: "evenodd",
                    clipRule: "evenodd",
                  }
                : { type: "image", url: `${n}animations/${s}.png` };
            },
          },
          e,
          e.asset.findAllSources()
        ),
      ],
      [n, e, t]
    );
  return (0, eY.jsxs)(eY.Fragment, {
    children: [
      (0, eY.jsx)(WQ.Header, {
        children: (0, eY.jsx)(WQ.Title, { children: s }),
      }),
      (0, eY.jsx)(WQ.Content, {
        children: ({ isOpen: t }) =>
          (0, eY.jsx)("div", {
            className: JK,
            children: (0, eY.jsx)(MK, {
              entries: i,
              assetPanelOpen: t,
              children: (0, eY.jsx)(MK.Content, {
                onSelect: async (t) => {
                  const n = t.context.sourceId;
                  await e.asset.apply(n, t);
                },
              }),
            }),
          }),
      }),
    ],
  });
});
export var sY = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    block: t,
    inBar: n = false,
    deniedByScopeBehavior: s = "disable",
  }) {
    const { t: i } = ZL(),
      o = VO(),
      r = XR(),
      [a] = BQ("//ly.img.panel/inspector/animation", r);
    function l() {
      a
        ? o.ui.closePanel("//ly.img.panel/inspector/animation")
        : o.ui.openPanel("//ly.img.panel/inspector/animation");
    }
    const c = e.block.isAllowedByScope(t, kH),
      u = e.block.getInAnimation(t),
      d = e.block.getOutAnimation(t),
      p = e.block.getLoopAnimation(t),
      f = e.block.isValid(u),
      h = e.block.isValid(d),
      m = e.block.isValid(p),
      g = f || h || m,
      x = i("input.animations"),
      b = (0, $K.useMemo)(() => {
        if (!g) return i("common.select");
        const t = [];
        return (
          f && t.push(iY(i, e.block.getType(u))),
          h && t.push(iY(i, e.block.getType(d))),
          m && t.push(iY(i, e.block.getType(p))),
          t.join(", ")
        );
      }, [e.block, g, f, m, h, u, p, d, i]);
    return c || "hide" !== s
      ? n
        ? (0, eY.jsx)(Ly, {
            label: i("input.animations.description"),
            children: (0, eY.jsx)(CompCustomButton, {
              name: x,
              variant: a ? "regular" : "plain",
              icon: (0, eY.jsx)(hG, {}),
              isActive: g,
              activeStateStyle: "pill",
              onClick: l,
              isDisabled: !c,
              "data-cy": "animations",
              children: x,
            }),
          })
        : (0, eY.jsxs)(Yk, {
            children: [
              (0, eY.jsx)(Sv, {
                isDisabled: !c,
                children: i("common.presets"),
              }),
              (0, eY.jsx)(Ly, {
                label: i("input.animations.description"),
                children: (0, eY.jsxs)(CompCustomButton, {
                  name: x,
                  variant: "regular",
                  icon: (0, eY.jsx)(hG, {}),
                  isActive: g,
                  activeStateStyle: "pill",
                  onClick: l,
                  isDisabled: !c,
                  "data-cy": "animations",
                  children: [b, (0, eY.jsx)(zq, {})],
                }),
              }),
              (0, eY.jsx)(zK, {}),
            ],
          })
      : null;
  })
);
export function iY(e, t) {
  return e(`property.${QK(t).replace(/\//g, ".")}`);
}
((YK = KK || (KK = {})).SupportGuard = tY),
  (YK.PanelContent = nY),
  (YK.Control = function (e) {
    return (0, eY.jsx)(tY, {
      children: ({ block: t }) => (0, eY.jsx)(sY, { block: t, ...e }),
    });
  });
export var oY = KK;
export function YY(e, t, n) {
  return n.map(({ name: n, get: s }) => [n, s(e, t)]);
}
export var JY = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const [t] = e.block.findAllSelected(),
      { viewStyle: n } = YR();
    return (0,
    XY.jsx)(WQ, { id: "//ly.img.panel/inspector/placeholderSettings", group: "defaultUIInspectors", context: "advanced" === n ? "back" : "close", children: ({ setIsOpen: e }) => (null == t ? null : (0, XY.jsx)(eX, { block: t, setIsOpen: e }, t)) });
  })
);
export var eX = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, block: t, setIsOpen: n }) {
    const { t: s } = ZL(),
      i = IV(),
      o = FI(),
      r = (0, uY.useMemo)(
        () =>
          (function (e, t, n, s) {
            return [
              {
                name: "layer-options",
                label: t("component.placeholder.general"),
                description: t("component.placeholder.general.description"),
                show: (e, t) =>
                  !(
                    "Video" === e.scene.getMode() &&
                    "//ly.img.ubq/page" === e.block.getType(t)
                  ),
                entries: [
                  {
                    scope: mH,
                    label: t("scope.layer.opacity"),
                    icon: RY,
                    show: (e, t) => e.block.supportsOpacity(t),
                  },
                  {
                    scope: gH,
                    label: t("scope.layer.blendMode"),
                    icon: xY,
                    show: (e, t) => {
                      const n = e.block.getType(t);
                      return (
                        "//ly.img.ubq/audio" !== n &&
                        "//ly.img.ubq/page" !== n &&
                        e.block.supportsBlendMode(t)
                      );
                    },
                  },
                  {
                    scope: AH,
                    label: t("scope.lifecycle.duplicate"),
                    icon: SY,
                  },
                  {
                    scope: PH,
                    label: t("scope.lifecycle.destroy"),
                    icon: vZ,
                  },
                ],
              },
              {
                name: "arrange",
                label: t("component.placeholder.arrange"),
                description: t("component.placeholder.arrange.description"),
                show: (e, t) => "//ly.img.ubq/page" !== e.block.getType(t),
                entries: [
                  { scope: uH, label: t("scope.layer.move"), icon: MY },
                  { scope: dH, label: t("scope.layer.resize"), icon: zY },
                  {
                    scope: pH,
                    label: t("scope.layer.rotate"),
                    icon: NY,
                    show: (e, t) => "//ly.img.ubq/audio" !== e.block.getType(t),
                  },
                  {
                    scope: fH,
                    label: t("scope.layer.flip"),
                    icon: BY,
                    show: (e, t) => "//ly.img.ubq/audio" !== e.block.getType(t),
                  },
                ],
              },
              {
                name: "fill",
                label: t("component.placeholder.fill"),
                description: t("component.placeholder.fill.description"),
                show: (e, t) => "//ly.img.ubq/audio" === e.block.getType(t),
                entries: [
                  {
                    name: `scope-${SH}`,
                    label: t("scope.fill.change"),
                    icon: IY,
                    set: (e, t, n) => {
                      e.block.setScopeEnabled(t, SH, n);
                    },
                    get: (e, t) => e.block.isScopeEnabled(t, SH),
                  },
                ],
              },
              {
                name: "fill",
                label: t("component.placeholder.fill"),
                description: t("component.placeholder.fill.description"),
                show: (e, t) =>
                  e.block.supportsFill(t) && "sticker" !== e.block.getKind(t),
                entries: [
                  {
                    name: `scope-${SH}`,
                    label: t("scope.fill.change"),
                    icon: IY,
                    set: (e, t, n) => {
                      if ((e.block.setScopeEnabled(t, SH, n), true === n))
                        return;
                      e.block.setScopeEnabled(t, _H, false);
                      const s = e.block.getFill(t);
                      e.block.supportsPlaceholderBehavior(s) &&
                        e.block.setPlaceholderBehaviorEnabled(s, false),
                        e.block.supportsPlaceholderControls(t) &&
                          (e.block.setPlaceholderControlsButtonEnabled(
                            t,
                            false
                          ),
                          e.block.setPlaceholderControlsOverlayEnabled(
                            t,
                            false
                          ));
                    },
                    get: (e, t) => e.block.isScopeEnabled(t, SH),
                  },
                  {
                    name: `scope-${_H}`,
                    label: t("scope.fill.changeType"),
                    icon: IY,
                    indentation: true,
                    show: (e, t) => {
                      const n = e.block.getType(t);
                      return (
                        "//ly.img.ubq/graphic" === n ||
                        "//ly.img.ubq/page" === n
                      );
                    },
                    isDisabled: (e, t) =>
                      !e.block.isScopeEnabled(t, "fill/change"),
                    set: (e, t, n) => {
                      e.block.setScopeEnabled(t, _H, n);
                    },
                    get: (e, t) => e.block.isScopeEnabled(t, _H),
                  },
                  {
                    name: "act-as-placeholder",
                    label: t("property.placeholderBehavior.description"),
                    icon: DY,
                    indentation: true,
                    show: (e, t) => {
                      const n = e.block.getFill(t);
                      return e.block.supportsPlaceholderBehavior(n);
                    },
                    isDisabled: (e, t) =>
                      !e.block.isScopeEnabled(t, "fill/change"),
                    get: (e, t) => {
                      const n = e.block.getFill(t);
                      return (
                        e.block.supportsPlaceholderBehavior(n) &&
                        e.block.isPlaceholderBehaviorEnabled(n) &&
                        e.block.isPlaceholderControlsButtonEnabled(t) &&
                        e.block.isPlaceholderControlsOverlayEnabled(t)
                      );
                    },
                    set: (e, t, n) => {
                      const s = e.block.getFill(t);
                      e.block.supportsPlaceholderBehavior(s) &&
                        (e.block.setPlaceholderBehaviorEnabled(s, n),
                        e.block.setPlaceholderControlsButtonEnabled(t, n),
                        e.block.setPlaceholderControlsOverlayEnabled(t, n));
                    },
                  },
                  {
                    scope: hH,
                    label: t("scope.layer.crop"),
                    icon: wY,
                    show: (e, t) => e.block.supportsCrop(t),
                  },
                ],
              },
              {
                name: "shape",
                label: t("component.placeholder.shape"),
                description: t("component.placeholder.shape.description"),
                show: (e, t) => {
                  const n = e.block.supportsShape(t)
                      ? e.block.getShape(t)
                      : undefined,
                    s =
                      null != n && e.block.isValid(n)
                        ? e.block.getType(n)
                        : undefined;
                  return !(
                    "sticker" === e.block.getKind(t) ||
                    ("//ly.img.ubq/shape/line" !== s &&
                      "//ly.img.ubq/shape/star" !== s &&
                      "//ly.img.ubq/shape/polygon" !== s &&
                      "//ly.img.ubq/shape/rect" !== s)
                  );
                },
                entries: [
                  { scope: LH, label: t("scope.shape.change"), icon: qY },
                ],
              },
              {
                name: "stroke",
                label: t("component.placeholder.stroke"),
                description: t("component.placeholder.stroke.description"),
                show: (e, t) => {
                  const n = e.block.supportsShape(t)
                      ? e.block.getShape(t)
                      : undefined,
                    s =
                      null != n &&
                      e.block.isValid(n) &&
                      "//ly.img.ubq/shape/line" === e.block.getType(n);
                  return (
                    e.block.supportsStroke(t) &&
                    "sticker" !== e.block.getKind(t) &&
                    !s
                  );
                },
                entries: [
                  { scope: EH, label: t("scope.stroke.change"), icon: GY },
                ],
              },
              {
                name: "text",
                label: t("component.placeholder.text"),
                description: t("component.placeholder.text.description"),
                show: (e, t) => "//ly.img.ubq/text" === e.block.getType(t),
                entries: [
                  {
                    name: CH,
                    label: t("scope.text.edit"),
                    icon: gk,
                    get: (e, t) => e.block.isScopeEnabled(t, CH),
                    set: (e, t, n) => {
                      e.block.setScopeEnabled(t, CH, n),
                        !n &&
                          e.block.supportsPlaceholderBehavior(t) &&
                          e.block.setPlaceholderBehaviorEnabled(t, false);
                    },
                  },
                  {
                    name: "act-as-placeholder",
                    label: t("property.placeholderBehavior.description"),
                    icon: DY,
                    indentation: true,
                    isDisabled: (e, t) =>
                      !e.block.isScopeEnabled(t, "text/edit"),
                    get: (e, t) =>
                      e.block.supportsPlaceholderBehavior(t) &&
                      e.block.isPlaceholderBehaviorEnabled(t),
                    set: (e, t, n) => {
                      e.block.supportsPlaceholderBehavior(t) &&
                        e.block.setPlaceholderBehaviorEnabled(t, n);
                    },
                  },
                  { scope: jH, label: t("scope.text.character"), icon: WY },
                ],
              },
              {
                name: "appearance",
                label: t("component.placeholder.appearance"),
                description: t("component.placeholder.appearance.description"),
                show: (e, t) =>
                  e.block.supportsEffects(t) ||
                  e.block.supportsBlur(t) ||
                  e.block.supportsDropShadow(t),
                entries: [
                  {
                    scope: xH,
                    label: t("scope.appearance.adjustments"),
                    icon: mY,
                    show: (e, t) =>
                      e.block.supportsEffects(t) &&
                      "sticker" !== e.block.getKind(t),
                  },
                  {
                    scope: bH,
                    label: t("scope.appearance.filter"),
                    icon: PY,
                    show: (e, t) =>
                      e.block.supportsEffects(t) &&
                      "sticker" !== e.block.getKind(t),
                  },
                  {
                    scope: yH,
                    label: t("scope.appearance.effect"),
                    icon: EY,
                    show: (e, t) =>
                      e.block.supportsEffects(t) &&
                      "sticker" !== e.block.getKind(t),
                  },
                  {
                    scope: vH,
                    label: t("scope.appearance.blur"),
                    icon: yY,
                    show: (e, t) =>
                      e.block.supportsBlur(t) &&
                      "sticker" !== e.block.getKind(t),
                  },
                  {
                    scope: wH,
                    label: t("scope.appearance.shadow"),
                    icon: CY,
                    show: (e, t) =>
                      "//ly.img.ubq/page" !== e.block.getType(t) &&
                      e.block.supportsDropShadow(t),
                  },
                  {
                    scope: kH,
                    label: t("scope.appearance.animations"),
                    icon: hG,
                    show: (e, t) => {
                      const n = e.block.getType(t);
                      return (
                        "Video" === e.scene.getMode() &&
                        ("//ly.img.ubq/graphic" === n ||
                          "//ly.img.ubq/text" === n)
                      );
                    },
                  },
                ],
              },
            ]
              .filter((t) => !t.show || t.show?.(e, n, s))
              .map((t) => ({
                ...t,
                entries: t.entries.filter((t) => !t.show || t.show?.(e, n, s)),
              }))
              .map((e) => ({
                ...e,
                entries: e.entries.map((e) => {
                  if ("scope" in e) {
                    const { scope: t, ...n } = e;
                    return {
                      ...n,
                      name: `scope-${t}`,
                      set: (e, n, s) => e.block.setScopeEnabled(n, t, s),
                      get: (e, n) => e.block.isScopeEnabled(n, t),
                    };
                  }
                  return e;
                }),
              }));
          })(e, s, t, o),
        [t, o, e, s]
      ),
      a = (0, uY.useMemo)(
        () => r.reduce((e, t) => e.concat(t.entries), []),
        [r]
      ),
      l = e.block.isValid(t) && a.every(({ get: n }) => n(e, t)),
      c = (0, uY.useCallback)(
        () => a.map(({ set: n }) => n(e, t, !l)),
        [a, l, t, e]
      ),
      u = (0, uY.useRef)(false),
      d = (0, uY.useCallback)(() => {
        (u.current = true),
          (function (e, t, n) {
            const s = e.block.isPlaceholderEnabled(t),
              i = n.some(({ get: n }) => n(e, t));
            !i || s
              ? !i && s && e.block.setPlaceholderEnabled(t, false)
              : e.block.setPlaceholderEnabled(t, true);
          })(e, t, a);
      }, [a, t, e]);
    return (
      (0, uY.useEffect)(() => {
        const n = e.block.isPlaceholderEnabled(t),
          s = YY(e, t, a);
        return () => {
          if (!u.current || !e.block.isValid(t)) return;
          const o = e.block.isPlaceholderEnabled(t);
          if (!n && o) return void i("action.placeholder.create");
          if (n && !o) return void i("action.placeholder.remove");
          const r = YY(e, t, a);
          (0, cY.default)(s, r) || i("action.placeholder.change");
        };
      }, [a, t, i, e]),
      (0, uY.useEffect)(
        () =>
          e.block.onSelectionChanged(() => {
            0 === e.block.findAllSelected().length && n(false);
          }),
        [e.block, n]
      ),
      (0, XY.jsxs)(XY.Fragment, {
        children: [
          (0, XY.jsx)(WQ.Header, {
            action: (0, XY.jsx)(CompCustomButton, {
              name: l ? "disable-all" : "enable-all",
              onClick: () => {
                c(), d();
              },
              children: s(
                l
                  ? "component.placeholder.disableAll"
                  : "component.placeholder.enableAll"
              ),
            }),
            children: (0, XY.jsx)(WQ.Title, {
              children: s("component.placeholder.create"),
            }),
          }),
          (0, XY.jsx)(WQ.Content, {
            children: r.map((e) =>
              (0, XY.jsx)(tX, { block: t, ...e, onChange: d }, e.name)
            ),
          }),
        ],
      })
    );
  })
);
export var tX = WithEngineComp(
  ({
    label: e,
    description: t,
    name: n,
    entries: s,
    block: i,
    onChange: o,
  }) => {
    const r = YF(),
      a = r.block.isValid(i) ? s.map((e) => e.get(r, i)) : undefined,
      l = a?.some(Boolean) ?? false,
      c = a?.every(Boolean) ?? false;
    return (0, XY.jsx)(Qk, {
      title: e,
      headingAreaRight: (0, XY.jsx)(nb, {
        name: `enable-all-${n}-checkbox`,
        label: t,
        onChange: (e) => {
          s.forEach((t) => t.set(r, i, e)), o();
        },
        hideLabel: true,
        checked: c,
        indeterminate: l && !c,
      }),
      children: (0, XY.jsx)(tb, {
        children: s.map((e) =>
          (0, XY.jsx)(nX, { entry: e, block: i, onChange: o }, e.name)
        ),
      }),
    });
  }
);
export var nX = WithEngineComp(({ entry: e, block: t, onChange: n }) => {
  const s = YF(),
    i = s.block.isValid(t),
    { name: o, label: r, icon: a, indentation: l } = e,
    c = `enable-${o}-checkbox`,
    u = i && e.get(s, t),
    d = l ? fY : pY,
    p = !("scope" in e) && i && !!e.isDisabled?.(s, t);
  return (0, XY.jsx)(
    nb,
    {
      name: c,
      className: d,
      label: r,
      icon: (0, XY.jsx)(a, {}),
      checked: u,
      onChange: (i) => {
        e.set(s, t, i), n();
      },
      isDisabled: p,
    },
    c
  );
});
export var sX = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, tooltip: t, children: n, ...s }) {
    const { t: i } = ZL(),
      o = XR(),
      [r, a] = BQ("//ly.img.panel/inspector/placeholderSettings", o),
      [l] = e.block.findAllSelected();
    if (!l) return null;
    const c = e.block.isPlaceholderEnabled(l),
      u = (0, XY.jsx)(CompCustomButton, {
        className: (0, lY.default)({ [dY]: c }),
        icon: (0, XY.jsx)(aY, {}),
        "aria-label": i("component.placeholder.settings"),
        name: "placeholdersettings-configure_placeholder",
        variant: "regular",
        "data-cy": "placeholder-settings",
        onClick: () => a(!r),
        ...s,
        children: n,
      });
    return t ? (0, XY.jsx)(Ly, { label: t, children: u }) : u;
  })
);
export var iX = { Panel: JY, Button: sX };

export function rX(e) {
  switch (e) {
    case "Pixel":
      return "px";
    case "Millimeter":
      return "mm";
    case "Inch":
      return "in";
    default:
      throw new Error(`Unknown unit: ${e}`);
  }
}

export var aX = (e) =>
  e.map((e, t) => ({ ...e, position: e.stop, id: t.toString(), index: t }));
export var lX = (e, t) => {
  if (e.length !== t.length) return aX(t);
  const n = e.slice(),
    s = t.slice(),
    i = [];
  let o;
  if (
    (s.forEach((e, t) => {
      const s = n.findIndex((t) => t.stop === e.stop);
      -1 !== s
        ? (i.push({ ...e, index: t, id: n[s].id }), n.splice(s, 1))
        : (o = t);
    }),
    undefined !== o)
  ) {
    if (1 !== n.length) return aX(t);
    i.push({ ...s[o], index: o, id: n[0].id });
  }
  return i;
};
export var cX = ({ stop: e }, { stop: t }) => (e < t ? -1 : e > t ? 1 : 0);
export var uX = (e, t, n) => {
  let s = e;
  if (t > n || n < t || t === n)
    throw new Error("Parameter `min` must be smaller than `max`");
  for (; s <= t; ) s += n - t;
  for (; s > n; ) s -= n - t;
  return s;
};
export var dX = (e, t) => {
  const n = (e.end.x - e.start.x) * t,
    s = e.end.y - e.start.y,
    i = (180 * Math.atan2(s, n)) / Math.PI;
  return uX(i - 90, -180, 180);
};
export var pX = (e) => {
  const t = Math.max(Math.abs(e.x), Math.abs(e.y));
  return 0 === t
    ? { x: 0.5, y: 0.5 }
    : { x: (e.x / t) * 0.5 + 0.5, y: (e.y / t) * 0.5 + 0.5 };
};
export var fX = Math.sqrt(2);
export var hX = (e, t) => {
  const n = ((e + 90) / 180) * Math.PI,
    s = {
      x: (Math.cos(n + Math.PI) / t) * fX,
      y: Math.sin(n + Math.PI) * fX,
    },
    i = { x: (Math.cos(n) / t) * fX, y: Math.sin(n) * fX };
  return { start: pX(s), end: pX(i) };
};
export function CX({
  label: e,
  icon: t,
  isPropertyEnabled: n,
  active: s = false,
  activeStateStyle: i = "pill",
  buttonContent: o,
  renderButton: r,
  ...a
}) {
  const { t: l } = ZL();
  return (0, kX.jsx)(SX, {
    renderButton:
      r ??
      function ({ isActive: r, ...a }) {
        return (0, kX.jsx)(CompCustomButton, {
          variant: r ? "regular" : "plain",
          icon: (0, kX.jsxs)(Gb, {
            className: (0, bX.default)(vX, { [wX]: !n }),
            children: [t, !n && (0, kX.jsx)(Yb, {})],
          }),
          isActive: s,
          activeStateStyle: i,
          ...a,
          children: o ?? e,
        });
      },
    label: e,
    closeButtonIcon: mv,
    closeButtonLabel: l("common.close"),
    isPropertyEnabled: n,
    ...a,
  });
}
export function jX({ onReset: e, isDisabled: t, dataCy: n }) {
  const { t: s } = ZL();
  return e
    ? (0, kX.jsxs)(CompCustomButton, {
        name: "reset",
        onClick: e,
        "aria-label": s("common.reset"),
        "data-cy": `reset-${n}-subInspector`,
        variant: "plain",
        isDisabled: t,
        children: [s("common.reset"), (0, kX.jsx)(FG, {})],
      })
    : null;
}
export var SX = mayBeUseMemp(function ({
  panelId: e,
  groupId: t,
  isOpen: n,
  setIsOpen: s,
  onClose: i,
  onReset: o,
  resettable: r,
  label: a,
  ariaLabel: l,
  tooltip: c,
  children: u,
  "data-cy": d,
  isDisabled: p,
  headerActions: f,
  renderButton: h,
  onOpenStateChanged: m,
}) {
  const g = ov(i),
    x = ov(m),
    b = UQ("//ly.img.panel/inspector"),
    y = XR(),
    [v, w] = BQ(e, y),
    k = ov(s),
    C = Nz(),
    j = NQ("//ly.img.panel/inspector"),
    S = n ?? v,
    _ = k ?? w,
    [E, L] = (0, yX.useState)(false),
    P = (0, yX.useCallback)(() => {
      const e = !S;
      _(e), x?.(e), false === e && g?.();
    }, [S, _, g, x]);
  yv(
    () => {
      L(() => S);
    },
    S ? 200 : undefined
  );
  const A = {
    name: a,
    "aria-label": l ?? a,
    "data-cy": d,
    onClick: P,
    isDisabled: p,
    isActive: S,
  };
  return (0, kX.jsxs)(kX.Fragment, {
    children: [
      (0, kX.jsxs)(WQ, {
        id: e,
        "data-cy": "subinspector-panel",
        group: t,
        panelPosition: C ? "left" : b,
        focusTrapActive: E,
        show: S,
        floating: j,
        onClose: () => {
          k?.(false), m?.(false), g?.();
        },
        children: [
          (0, kX.jsx)(WQ.Header, {
            action: (0, kX.jsxs)(kX.Fragment, {
              children: [
                (0, kX.jsx)(jX, { onReset: o, isDisabled: !r, dataCy: d }),
                f,
              ],
            }),
            children: (0, kX.jsx)(WQ.Title, { children: a }),
          }),
          (0, kX.jsx)(WQ.Content, { children: u }),
        ],
      }),
      c ? (0, kX.jsx)(Ly, { label: c, children: h(A) }) : h(A),
    ],
  });
});
export var _X = function ({
  label: e,
  valueLabel: t,
  active: n = false,
  activeStateStyle: s = "pill",
  buttonContent: i,
  renderButton: o,
  ...r
}) {
  const { t: a } = ZL();
  return (0, kX.jsx)(SX, {
    renderButton:
      o ??
      function ({ isActive: e, ...o }) {
        return (0, kX.jsxs)(CompCustomButton, {
          variant: "regular",
          icon: (0, kX.jsx)(Gb, { children: r.icon }),
          isActive: n,
          activeStateStyle: s,
          ...o,
          children: [i ?? t, (0, kX.jsx)(zq, {})],
        });
      },
    label: e,
    closeButtonLabel: a("common.back"),
    ...r,
  });
};
export var EX = _X;

export var HX = { button: "UBQ_ColorModeSelect-module__button--8-8sX" };

export var UX = ["Linear"];
export var zX = {
  Linear: (0, NX.jsx)(OX, {}, "ColorGradientLinearIcon"),
  Radial: (0, NX.jsx)(VX, {}, "ColorGradientRadialIcon"),
  Conical: (0, NX.jsx)(TX, {}, "ColorGradientAngularIcon"),
};
export var $X = (e) => ({
  Linear: e("property.fillType.gradient"),
  Radial: e("property.gradientType.radial"),
  Conical: e("property.gradientType.conical"),
});
export var qX = (e) => ({
  Linear: e("property.fillType.gradient.description"),
  Radial: e("property.gradientType.radial.description"),
  Conical: e("property.gradientType.conical.description"),
});
export function QX({ mode: e, setMode: t, isDisabled: n = false }) {
  const { t: s } = ZL(),
    i = IV(),
    o = (0, IX.useMemo)(() => $X(s), []),
    r = (0, IX.useMemo)(() => qX(s), []),
    a = s("property.fillType.solid.description"),
    l = s("property.fillType.solid");
  return (0, NX.jsx)(Yk, {
    children: (0, NX.jsxs)(CompLayout1, {
      equalWidth: true,
      children: [
        (0, NX.jsx)(CompCustomButton, {
          icon: (0, NX.jsx)(FX, {}, "ColorSolidIcon"),
          name: "fillType-solid",
          className: HX.button,
          "aria-label": a,
          isActive: "Solid" === e,
          isDisabled: n,
          onClick: () => {
            t("Solid"), i("action.property.update");
          },
          children: (0, NX.jsx)("span", { children: l }),
        }),
        UX.map((s) =>
          (0, NX.jsx)(
            CompCustomButton,
            {
              icon: zX[s],
              name: s.toString(),
              className: HX.button,
              "aria-label": r[s],
              isActive: "Gradient" === e,
              isDisabled: n,
              onClick: () => {
                t("Gradient"), i("action.property.update");
              },
              children: (0, NX.jsx)("span", { children: o[s] }),
            },
            s
          )
        ),
      ],
    }),
  });
}
export var GX = {
  block: "UBQ_ColorSelection-module__block--hQIfN",
  noPopover: "UBQ_ColorSelection-module__noPopover--K51bl",
  sectionRow: "UBQ_ColorSelection-module__sectionRow--R-VVL",
  multilineSectionRow: "UBQ_ColorSelection-module__multilineSectionRow--SB1m7",
  header: "UBQ_ColorSelection-module__header--59n9c",
  heading: "UBQ_ColorSelection-module__heading--3lEKT",
  section: "UBQ_ColorSelection-module__section--R1UZS",
  hueSlider: "UBQ_ColorSelection-module__hueSlider--WQXI2",
  opacitySlider: "UBQ_ColorSelection-module__opacitySlider--PI-Wu",
};

export var oJ = "";
export var rJ = (e, t, n) => {
  const { position: s } = t.payload,
    { internalGradientStops: i, dragTarget: o, activeStopIndex: r } = e,
    a = i.slice(),
    l = a.findIndex(({ id: e }) => e === o);
  if (-1 === l) return e;
  a[l] = { ...a[l], stop: wk(s, 0, 1) };
  if (
    a
      .map(({ stop: e }) => e)
      .sort()
      .some((e, t, n) => 0 !== t && e - n[t - 1] < 0.001)
  )
    return e;
  const c = a
    .slice()
    .sort(cX)
    .map((e, t) => ({ ...e, index: t }));
  let u = r;
  return (
    c.some(({ id: e, index: t }) => e === o && t !== r && ((u = t), true)),
    n(((e) => e.map((e) => ({ stop: e.stop, color: e.color })))(c)),
    { ...e, internalGradientStops: c, activeStopIndex: u }
  );
};
export var aJ = (e) => (t, n) => {
  switch (n.type) {
    case 0:
      return { ...t, activeStopIndex: n.payload };
    case 3:
      return {
        ...t,
        activeStopIndex: n.payload.index,
        dragTarget: n.payload.id,
      };
    case 4:
      return { ...t, dragTarget: oJ };
    case 5:
      return {
        ...t,
        internalGradientStops: lX(t.internalGradientStops, n.payload),
      };
    case 1:
      return rJ(t, n, e);
    case 2:
      return ((e, t, n) => {
        const { id: s, index: i, position: o } = t.payload;
        return {
          ...rJ(
            { ...e, activeStopIndex: i, dragTarget: s },
            { type: 1, payload: { position: o } },
            n
          ),
          dragTarget: oJ,
        };
      })(t, n, e);
    default:
      return t;
  }
};
export var lJ = (e) => ({ type: 0, payload: e });
export var cJ = (e, t, n) => ({
  type: 2,
  payload: { id: e, index: t, position: n },
});
export var uJ = [];
export var dJ = () => {};
export var pJ = ({
  gradientStops: e = uJ,
  setGradientStops: t = dJ,
  initialState: n,
}) => {
  const [s, i] = (0, iJ.useReducer)(aJ(t), n);
  return (
    (0, iJ.useEffect)(() => {
      s.dragTarget === oJ && i({ type: 5, payload: e });
    }, [e, s.dragTarget]),
    [s, i]
  );
};

export var hJ = WithEngineComp(function ({
  engine: e,
  gradientStops: t,
  controlPoints: n,
  setControlPoints: s,
  state: i,
  dispatch: o,
  aspectRatio: r,
  isDisabled: a,
}) {
  const { t: l } = ZL(),
    c = (0, WX.useMemo)(
      () => PO(t?.map((e) => e.color) ?? [], e.editor),
      [t, e.editor]
    ),
    { activeStopIndex: u, dragTarget: d, internalGradientStops: p } = i,
    [f, h] = (0, WX.useState)(0),
    [m, g] = (0, WX.useState)(0),
    x = (e) => {
      0 === m && null !== e && g(e.offsetWidth);
    };
  return (0, fJ.jsxs)(fJ.Fragment, {
    children: [
      (0, fJ.jsxs)("div", {
        ref: (e) => {
          null !== e && h(e.offsetWidth - m);
        },
        className: (0, ZX.default)(XX, { [eJ]: a }),
        children: [
          (0, fJ.jsx)("div", {
            className: JX,
            style: { background: vb(c) },
            children: "",
          }),
          0 !== f &&
            p
              .sort(({ id: e }, { id: t }) => e.localeCompare(t))
              .map((t) => {
                const { id: n, index: s, stop: i, color: r } = t,
                  c = s === u,
                  h = PO(r, e.editor),
                  { name: g, hex: b } = gO(h);
                return (0, fJ.jsx)(
                  KX.default,
                  {
                    axis: "x",
                    bounds: "parent",
                    disabled: a,
                    position: { x: i * f, y: 0 },
                    onStart: () => {
                      o({ type: 3, payload: { id: n, index: s } });
                    },
                    onDrag: (e, t) => {
                      o(
                        ((e) => ({ type: 1, payload: { position: e } }))(
                          t.x / f
                        )
                      );
                    },
                    onStop: () => {
                      setTimeout(() => {
                        o({ type: 4 });
                      }, 20);
                    },
                    children: (0, fJ.jsx)("button", {
                      type: "button",
                      name: `color-stop-${n}`,
                      "aria-label": l("input.gradient.colorStop.description", {
                        stopType: l(
                          c
                            ? "input.gradient.colorStop.active"
                            : "input.gradient.colorStop"
                        ),
                        index: s + 1,
                        total: p.length,
                        position: (100 * i).toFixed(0),
                        colorName: g,
                        colorValue: b,
                        action: c
                          ? ""
                          : ` ${l("input.gradient.activateColorStop")}`,
                      }),
                      ref: 0 === m ? x : undefined,
                      className: (0, ZX.default)({
                        [nJ]: d === n,
                        [tJ]: s === u,
                      }),
                      style: { background: yb(h) },
                      disabled: a,
                      onClick: () => {
                        d === oJ && o(lJ(s));
                      },
                      onKeyDown: (e) => {
                        "ArrowLeft" === e.key
                          ? o(cJ(n, s, i - 1 / 16))
                          : "ArrowRight" === e.key && o(cJ(n, s, i + 1 / 16));
                      },
                      children: (0, fJ.jsx)("div", {
                        className: (0, ZX.default)(sJ, { [tJ]: c }),
                      }),
                    }),
                  },
                  n
                );
              }),
        ],
      }),
      (0, fJ.jsxs)(Yk, {
        children: [
          (0, fJ.jsx)(Sv, {
            htmlFor: "gradient-angle",
            isDisabled: a,
            children: l("input.gradient.gradientAngle"),
          }),
          (0, fJ.jsx)(zv, {
            name: "gradient-angle",
            id: "gradient-angle",
            value: dX(n, r),
            isDisabled: a,
            onChange: (e) => {
              undefined !== e && s({ ...n, ...hX(e, r) });
            },
            unitLabel: "",
            min: -360,
            max: 360,
            step: 1,
          }),
          (0, fJ.jsx)(CompCustomButton, {
            name: "rotate-angle",
            "aria-label": l("input.gradient.rotate"),
            className: YX,
            isDisabled: a,
            onClick: () => {
              s({ ...n, ...hX(dX(n, r) + 45, r) });
            },
            children: (0, fJ.jsx)(NY, {}),
          }),
        ],
      }),
    ],
  });
});

export function gJ({
  colorSpace: e,
  color: t,
  setColor: n,
  hsvColor: s,
  setHSVColor: i,
  rgbaColor: o,
  isPropertyEnabled: r,
  includeAlpha: a = true,
  onRelease: l,
}) {
  const { t: c } = ZL(),
    u = YF();
  (0, AX.useEffect)(() => {
    const e = hO(o);
    var t, n;
    (t = mO(e, 4)),
      (n = mO(s, 4)),
      (t.h !== n.h || t.s !== n.s || t.v !== n.v) &&
        (0 === e.s && (e.h = s.h),
        0 === e.v && (e.s = s.s),
        ((0 === e.h && 1 === s.h) || (1 === e.h && 0 === s.h)) && (e.h = s.h),
        i(e));
  }, [t]);
  const d = (0, AX.useCallback)(
      (t, s = undefined) => {
        const r = (function (e) {
            const { h: t, s: n, v: s } = e,
              i = Math.floor(6 * t),
              o = 6 * t - i,
              r = s * (1 - n),
              a = s * (1 - o * n),
              l = s * (1 - (1 - o) * n);
            let c = 0,
              u = 0,
              d = 0;
            switch (i % 6) {
              case 0:
                (c = s), (u = l), (d = r);
                break;
              case 1:
                (c = a), (u = s), (d = r);
                break;
              case 2:
                (c = r), (u = s), (d = l);
                break;
              case 3:
                (c = r), (u = a), (d = s);
                break;
              case 4:
                (c = l), (u = r), (d = s);
                break;
              case 5:
                (c = s), (u = r), (d = a);
            }
            return { r: c, g: u, b: d };
          })(t),
          a = { ...r, a: s ?? o.a };
        if ("CMYK" === e) {
          const e = u.editor.convertColorToColorSpace(a, "CMYK");
          n(e);
        } else n(a);
        i(t);
      },
      [e, u.editor, o.a, n, i]
    ),
    p = (function (e) {
      const { r: t, g: n, b: s } = e,
        i = Math.max(t, n, s),
        o = Math.min(t, n, s);
      let r = 0,
        a = 0;
      const l = (i + o) / 2;
      if (i === o) (a = 0), (r = 0);
      else {
        const e = i - o;
        switch (((a = l > 0.5 ? e / (2 - i - o) : e / (i + o)), i)) {
          case t:
            r = (n - s) / e + (n < s ? 6 : 0);
            break;
          case n:
            r = (s - t) / e + 2;
            break;
          case s:
            r = (t - n) / e + 4;
        }
        r /= 6;
      }
      return { h: r, s: a, l: l };
    })(o),
    { name: f } = gO(o),
    h = c("component.colorPicker.hsl.description", {
      componentName: c("component.colorPicker.hueGradient"),
      nearestColorName: f,
      hue: (360 * p.h).toFixed(2),
      saturation: (100 * p.s).toFixed(2),
      lightness: (100 * p.l).toFixed(2),
    }),
    m = `${c("common.hue")}: ${mO(s, 2).h}`;
  return (0, mJ.jsxs)(mJ.Fragment, {
    children: [
      (0, mJ.jsx)(fv, {
        value: s,
        onChange: (e) => {
          const t = a && 0 === o.a;
          d(e, t ? 1 : o.a);
        },
        className: GX.saturationBrightnessSelector,
        "aria-label": h,
        isDisabled: !r,
        onRelease: l,
      }),
      (0, mJ.jsx)(Yk, {
        className: GX.sectionRow,
        children: (0, mJ.jsx)(tG, {
          label: c("common.hue"),
          name: "hue",
          min: 0,
          max: 1,
          step: 0.01,
          value: s.h,
          onChange: (e) => {
            d({ ...s, h: e ?? 0 });
          },
          hideTrackBackground: true,
          "aria-label": m,
          className: GX.hueSlider,
          isDisabled: !r,
          onRelease: l,
        }),
      }),
    ],
  });
}
export function xJ({
  color: e,
  rgbaColor: t,
  onOpacityChange: n,
  onTintChange: s,
  isDisabled: i = false,
  includeAlpha: o = true,
  onRelease: r,
}) {
  const { t: a } = ZL();
  return (0, mJ.jsxs)(mJ.Fragment, {
    children: [
      isRGBAColor(e) &&
        o &&
        (0, mJ.jsx)(Yk, {
          className: GX.sectionRow,
          children: (0, mJ.jsx)(tG, {
            label: a("common.opacity"),
            name: "opacity",
            "data-cy": "opacitySlider",
            min: 0,
            max: 1,
            step: 0.01,
            value: e.a,
            onChange: (e) => {
              n?.(e);
            },
            hideTrackBackground: true,
            style: {
              backgroundImage: `linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(${
                255 * e.r
              }, ${255 * e.g}, ${255 * e.b}, 1) 100%), url('${XS}')`,
            },
            className: GX.opacitySlider,
            "aria-label": `${a("common.opacity")}: ${e.a}`,
            isDisabled: i,
            onRelease: r,
          }),
        }),
      !isRGBAColor(e) &&
        (0, mJ.jsx)(Yk, {
          className: GX.sectionRow,
          children: (0, mJ.jsx)(tG, {
            label: a("common.tint"),
            name: "opacity",
            "data-cy": "tintSlider",
            min: 0,
            max: 1,
            step: 0.01,
            value: e.tint,
            onChange: (e) => {
              s?.(e);
            },
            hideTrackBackground: true,
            style: {
              backgroundImage: `linear-gradient(to right, rgba(255, 255, 255, 1) 0%, rgba(${
                255 * t.r
              }, ${255 * t.g}, ${255 * t.b}, 1) 100%)`,
            },
            className: GX.opacitySlider,
            "aria-label": `${a("common.tint")}: ${e.tint}`,
            isDisabled: i,
            onRelease: r,
          }),
        }),
    ],
  });
}
export function bJ({
  color: e,
  onColorChange: t,
  isDisabled: n = false,
  onRelease: s,
}) {
  const { t: i } = ZL(),
    o = (n) => (s) => {
      if (undefined === s) return;
      const i = Math.min(255, Math.max(0, Number(s || 0))),
        o = { ...e, [n]: i / 255 };
      t(o);
    };
  return (0, mJ.jsxs)(mJ.Fragment, {
    children: [
      (0, mJ.jsx)(Yk, {
        className: GX.sectionRow,
        children: (0, mJ.jsx)(Pv, {
          name: "hex",
          label: "Hex",
          inline: false,
          bottom: true,
          isDisabled: n,
          children: (o) =>
            (0, mJ.jsx)(Yy, {
              innerLabel: "#",
              "data-cy": "hexInput",
              value: e,
              onChange: (e) => {
                t(e);
              },
              ...o,
              "aria-label": (e) =>
                `${i("component.colorPicker.colorItem.hexInput")}: ${e}`,
              isDisabled: n,
              onRelease: s,
            }),
        }),
      }),
      (0, mJ.jsxs)(Yk, {
        className: GX.sectionRow,
        children: [
          (0, mJ.jsx)(Sv, { isDisabled: n, children: "RGB" }),
          (0, mJ.jsx)(Jh, {
            children: ["r", "g", "b"].map((t) => {
              const r = SO(i, t);
              return (0, mJ.jsx)(
                zv,
                {
                  name: `rgb-${t}`,
                  unitLabel: t.toUpperCase(),
                  tooltipLabel: r,
                  "data-cy": `rgb-${t}`,
                  min: 0,
                  max: 255,
                  "aria-label": `${r} ${Math.round(255 * e[t])}`,
                  value: Math.round(255 * e[t]),
                  onChange: o(t),
                  onRelease: s,
                  isDisabled: n,
                },
                t
              );
            }),
          }),
        ],
      }),
    ],
  });
}
export function yJ({
  color: e,
  onColorChange: t,
  isDisabled: n = false,
  onRelease: s,
}) {
  const { t: i } = ZL(),
    o = (n) => (s) => {
      if (undefined === s) return;
      const i = Math.min(100, Math.max(0, Number(s || 0))),
        o = { ...e, [n]: i / 100 };
      t(o);
    };
  return (0, mJ.jsxs)(Yk, {
    className: (0, PX.default)(GX.sectionRow, GX.multilineSectionRow),
    children: [
      (0, mJ.jsx)(Sv, { isDisabled: n, children: "CMYK" }),
      (0, mJ.jsx)(sm, {
        children: ["c", "m", "y", "k"].map((t) => {
          const r = jO(i, t);
          return (0, mJ.jsx)(
            zv,
            {
              name: `cmyk-${t}`,
              unitLabel: t.toUpperCase(),
              tooltipLabel: r,
              "data-cy": `cmyk-${t}`,
              min: 0,
              max: 100,
              "aria-label": `${r} ${Math.round(100 * e[t])}`,
              value: Math.round(100 * e[t]),
              onChange: o(t),
              onRelease: s,
              isDisabled: n,
            },
            t
          );
        }),
      }),
    ],
  });
}
export var vJ = function ({
  name: e,
  colorMode: t = "Solid",
  setColorMode: n,
  color: s,
  setColor: i,
  includeAlpha: o,
  isDisabled: r = false,
  isPropertyEnabled: a = true,
  label: l,
  "aria-label": c,
  "aria-labelledby": u,
  renderReference: d,
  previewColor: p,
  popoverOptions: f,
  closeOnWheel: h = false,
  hidePreviewLabel: m = false,
  customPreviewLabel: g,
  hideChevron: x = false,
  onRelease: b,
  mode: y = "default",
  headingActionRight: v,
  donutHole: w,
  showHeader: k = true,
  onContainerClick: C,
  showGradientControls: j = false,
  gradientState: S,
  gradientDispatch: _,
  gradientStops: E,
  gradientControlPoints: L,
  setGradientControlPoints: P,
  gradientAspectRatio: A,
}) {
  const { t: B } = ZL(),
    T = YF(),
    M = (0, AX.useMemo)(() => LO(s), [s]),
    O = (0, AX.useMemo)(() => PO(s, T.editor), [s, T.editor]),
    [R, V] = (0, AX.useState)(() => hO(O)),
    D = (0, AX.useCallback)(
      (e) => {
        i(e);
        const t = PO(s, T.editor);
        V(hO(t));
      },
      [s, T.editor, i]
    ),
    F = p || 0 === O.a ? p : O,
    I = d && ((e) => d({ ...e, previewColor: F })),
    H = {
      gradientStops: E,
      gradientControlPoints: L,
      setGradientControlPoints: P,
      gradientState: S,
      gradientDispatch: _,
      gradientAspectRatio: A,
    };
  return (0, mJ.jsx)(By, {
    name: e,
    label: l,
    "aria-label": c,
    isDisabled: r,
    isPropertyEnabled: a,
    closeOnWheel: h,
    previewColor: F,
    popoverOptions: f,
    "aria-labelledby": u,
    hidePreviewLabel: m,
    customPreviewLabel: g,
    invertedLabel: j,
    hideChevron: x,
    renderReference: I,
    mode: y,
    donutHole: w,
    children: (0, mJ.jsx)(E_, {
      isDisabled: r,
      onClick: C,
      label: B(
        r ? "input.propertyToggle.disable" : "input.propertyToggle.enable",
        { property: l }
      ),
      children: (0, mJ.jsxs)("div", {
        className: (0, PX.default)(GX.block, {
          [GX.noPopover]: "none" === y,
        }),
        children: [
          k &&
            (0, mJ.jsxs)("header", {
              className: GX.header,
              children: [
                (0, mJ.jsx)(Ex, {
                  level: 3,
                  className: GX.heading,
                  children: l,
                }),
                v,
              ],
            }),
          "SpotColor" !== M && j && n
            ? (0, mJ.jsxs)(mJ.Fragment, {
                children: [
                  (0, mJ.jsx)(QX, { mode: t, setMode: n, isDisabled: !a }),
                  "Gradient" === t &&
                  ((N = H),
                  null != N.gradientStops &&
                    null != N.gradientControlPoints &&
                    null != N.setGradientControlPoints &&
                    null != N.gradientState &&
                    null != N.gradientDispatch &&
                    null != N.gradientAspectRatio)
                    ? (0, mJ.jsx)(hJ, {
                        gradientStops: H.gradientStops,
                        controlPoints: H.gradientControlPoints,
                        setControlPoints: H.setGradientControlPoints,
                        state: H.gradientState,
                        dispatch: H.gradientDispatch,
                        aspectRatio: H.gradientAspectRatio,
                        isDisabled: !a,
                      })
                    : null,
                ],
              })
            : null,
          "SpotColor" !== M &&
            (0, mJ.jsx)("section", {
              className: GX.section,
              children: (0, mJ.jsx)(gJ, {
                hsvColor: R,
                setHSVColor: V,
                color: s,
                setColor: i,
                rgbaColor: O,
                isPropertyEnabled: a,
                includeAlpha: o,
                colorSpace: M,
                onRelease: b,
              }),
            }),
          (0, mJ.jsx)(xJ, {
            color: s,
            rgbaColor: O,
            onOpacityChange: (e) => {
              isRGBAColor(s) && D({ ...s, a: e });
            },
            onTintChange: (e) => {
              isRGBAColor(s) || D({ ...s, tint: e });
            },
            isDisabled: !a,
            includeAlpha: o,
            onRelease: b,
          }),
          "sRGB" === M &&
            (0, mJ.jsx)("section", {
              className: GX.section,
              children: (0, mJ.jsx)(bJ, {
                color: s,
                isDisabled: !a,
                onColorChange: D,
                onRelease: b,
              }),
            }),
          "CMYK" === M &&
            (0, mJ.jsx)("section", {
              className: GX.section,
              children: (0, mJ.jsx)(yJ, {
                color: s,
                isDisabled: !a,
                onColorChange: D,
                onRelease: b,
              }),
            }),
        ],
      }),
    }),
  });
  var N;
};
export var wJ = vJ;

export var CJ = function ({
  name: e,
  isPropertyEnabled: t,
  colorMode: n,
  setColorMode: s,
  color: i,
  setColor: o,
  isDisabled: r,
  includeAlpha: a = false,
  hideTransparentSpotColor: l = false,
  mode: c = "default",
  headingActionRight: u,
  donutHole: d,
  i18nLabelString: p,
  i18nDescriptionString: f,
  showHeader: h = true,
  onContainerClick: m,
  gradientStops: g,
  gradientState: x,
  gradientDispatch: b,
  gradientAspectRatio: y,
  gradientControlPoints: v,
  setGradientControlPoints: w,
  showGradientControls: k,
}) {
  const C = IV(),
    { t: j } = ZL(),
    S = j(p),
    _ = j(f),
    E = {
      name: e,
      includeAlpha: a,
      hideTransparentSpotColor: l,
      onContainerClick: m,
      isDisabled: r,
      onRelease: () => C("action.property.update"),
      showHeader: h,
      label: S,
      "aria-label": _,
      description: _,
      isPropertyEnabled: t,
      colorMode: n,
      setColorMode: s,
      color: i,
      setColor: o,
      gradientStops: g,
      gradientControlPoints: v,
      setGradientControlPoints: w,
      gradientAspectRatio: y,
      gradientState: x,
      gradientDispatch: b,
      showGradientControls: k,
    };
  switch (c) {
    case "none":
      return (0, kJ.jsx)(wJ, {
        hidePreviewLabel: true,
        hideChevron: true,
        mode: "none",
        ...E,
      });
    case "minimal":
      return (0, kJ.jsx)(wJ, {
        hidePreviewLabel: true,
        hideChevron: true,
        mode: "minimal",
        headingActionRight: u,
        donutHole: d,
        ...E,
      });
    case "default":
      return (0, kJ.jsx)(Pv, {
        name: e,
        label: S,
        isDisabled: r,
        children: (e) => (0, kJ.jsx)(wJ, { ...e, ...E }),
      });
    default:
      return null;
  }
};

export function AJ({ title: e, children: t }) {
  const { a11y: n } = FI();
  return (0, PJ.jsx)(Qk, {
    title: e,
    headingLevel: 2,
    headingStart: n.headingsHierarchyStart,
    children: t,
  });
}

export var VJ = {
  block: "UBQ_ColorBox-module__block--d1O8q",
  colorLabels: "UBQ_ColorBox-module__colorLabels--I4WDp",
  colorName: "UBQ_ColorBox-module__colorName--IuO5o",
  colorReference: "UBQ_ColorBox-module__colorReference--cRVjB",
  colorSpace: "UBQ_ColorBox-module__colorSpace--m4Ewv",
  noBorder: "UBQ_ColorBox-module__noBorder--nR6Te",
};

export function FJ(e, t) {
  return isSpotColor(e)
    ? e.name
    : isCMYKColor(e)
    ? BO(e)
    : isRGBAColor(e)
    ? wb(t).toUpperCase()
    : undefined;
}
export function IJ(e) {
  return isSpotColor(e)
    ? e.externalReference
    : isCMYKColor(e)
    ? "CMYK"
    : isRGBAColor(e)
    ? "RGB"
    : undefined;
}
export function HJ(e, t) {
  if (isSpotColor(e)) return t("common.spotColor");
}
export var NJ = function ({
  color: e,
  gradientStops: t,
  onClick: n,
  isDisabled: s = false,
}) {
  const i = YF(),
    { t: o } = ZL(),
    r = FI(),
    { rgba: a, isSpot: l } = (0, TJ.useMemo)(
      () => ({ rgba: PO(e, i.editor), isSpot: isSpotColor(e) }),
      [e, i.editor]
    ),
    c = (0, TJ.useMemo)(
      () =>
        t
          ? PO(
              t.map((e) => e.color),
              i.editor
            )
          : [],
      [i.editor, t]
    );
  return (0, DJ.jsx)(g_, {
    children: (0, DJ.jsxs)(c_, {
      size: "medium",
      className: VJ.block,
      children: [
        (0, DJ.jsx)(Ih.Edge, {
          children: (0, DJ.jsxs)(g_.Overlay, {
            children: [
              (0, DJ.jsxs)(Ih.Edge.TopLeft, {
                className: VJ.colorLabels,
                children: [
                  (0, DJ.jsx)("span", {
                    className: VJ.colorName,
                    children:
                      c.length > 0 ? o("property.fillType.gradient") : FJ(e, a),
                  }),
                  (0, DJ.jsx)("span", {
                    className: VJ.colorReference,
                    children: 0 === c.length ? IJ(e) : null,
                  }),
                ],
              }),
              (0, DJ.jsx)(Ih.Edge.BottomLeft, {
                children: (0, DJ.jsx)("span", {
                  className: VJ.colorSpace,
                  children: HJ(e, o),
                }),
              }),
              (0, DJ.jsx)(Ih.Edge.BottomRight, {
                children: (0, DJ.jsxs)(c_.InteractionElement, {
                  name: "edit-color",
                  onClick: n,
                  isDisabled: s,
                  children: [o("common.edit"), (0, DJ.jsx)(zq, {})],
                }),
              }),
            ],
          }),
        }),
        (0, DJ.jsx)(c_.Background.Checkered, {
          className: (0, BJ.default)({ [VJ.noBorder]: l }),
        }),
        c.length > 0
          ? (0, DJ.jsx)(c_.Background.Gradient, { gradient: vb(c) })
          : (0, DJ.jsx)(c_.Background.Color, {
              color: yb(a),
              className: (0, BJ.default)({ [VJ.noBorder]: l }),
            }),
        l &&
          (0, DJ.jsx)(c_.Background.Image, {
            url: `${r.ui.baseURL}spot-color-indicator-xl.svg`,
            size: "24px",
            repeat: false,
            position: "top right",
            className: VJ.spotColorIndicator,
          }),
      ],
    }),
  });
};
export var UJ = CJ;

export var $J = {
  libraries: "UBQ_ColorLibrary-module__libraries--V0DjZ",
  search: "UBQ_ColorLibrary-module__search--AyDuU",
  panelContent: "UBQ_ColorLibrary-module__panelContent--0-u3S",
};

export var QJ = (e) => (t) => {
  const n = t.payload?.color && AO(t.payload.color, e),
    s = n ? yb(n) : "";
  return { backgroundImage: `linear-gradient(0deg, ${s}, ${s})` };
};
export var GJ = (e) => (t) => {
  const n = t.payload?.color && AO(t.payload.color, e),
    s = n ? yb(n) : "";
  return { backgroundImage: `linear-gradient(0deg, ${s}, ${s})` };
};
export var ZJ = (e) => ({
  ...e,
  cardLabelPosition: () => "below",
  gridItemHeight: "auto",
});
export function WJ({ children: e, onColorSelect: t, isDisabled: n }) {
  const s = Nz(),
    { t: i } = ZL(),
    o = DO(),
    r = YR(),
    a = (0, zJ.useCallback)(
      (e) => {
        const t = o.getAssetSource(e);
        return {
          id: e,
          getSources: () => [t],
          canAdd: false,
          canRemove: false,
          sourceIds: [e],
          showGroupOverview: false,
          previewLength: s ? 6 : 8,
          previewBackgroundType: "cover",
          gridBackgroundType: "cover",
          gridColumns: 3,
          gridItemHeight: "square",
          cardBackgroundPreferences: [],
          promptBeforeApply: false,
          cardBorder: true,
          cardStyle: GJ(o.engine),
          cardLabel: (e) => {
            const { label: t, payload: n } = e;
            if (t) return t;
            if (n?.color) {
              if (XJ(n.color)) return n.color.name;
              if (YJ(n.color)) return BO(n.color);
              if (KJ(n.color)) return wb({ ...n.color, a: 1 }).toUpperCase();
            }
            return "";
          },
        };
      },
      [o, s]
    ),
    l = (0, zJ.useMemo)(() => {
      const e = o.engine.asset.findAllSources();
      return r.colorLibraries
        .filter(
          (t) =>
            !!e.includes(t) ||
            ("ly.img.colors.defaultPalette" === t
              ? o.log(
                  `\nError: The asset source "${t}" is unavailable. Please check the following:\n1. Ensure that "CESDK.addDefaultAssetSources" has been invoked.\n2. Confirm that "${t}" hasn't been excluded.\n3. If you don't wish to include it, remove it from the "ui.colorPalette" configuration option.\n`,
                  "Warning"
                )
              : o.log(
                  `\nError: The asset source "${t}" is unavailable. Please check the following.\n1. Add the asset source using "CESDK.engine.asset.addSource" or "CESDK.engine.asset.addLocalSource".\n2. If not needed, remove "${t}" from the "ui.colorPalette" configuration option.\n`,
                  "Warning"
                ),
            false)
        )
        .map((e) => a(e));
    }, [r.colorLibraries, a, o]),
    [c, u] = (0, zJ.useState)([]),
    d = (0, zJ.useCallback)(() => {
      u([]);
    }, []),
    p = XR(),
    [, f] = BQ("//ly.img.panel/inspector/colorLibrary", p);
  return (0, qJ.jsxs)("div", {
    className: $J.libraries,
    children: [
      l.map((e) =>
        (0, qJ.jsxs)(
          zJ.Fragment,
          {
            children: [
              (0, qJ.jsx)(Sw, {}),
              (0, qJ.jsx)(XW, {
                label: i(`libraries.${e.id}.label`),
                onEnter: () => {
                  f(true), u([e]);
                },
                onSelect: t,
                entry: {
                  ...e,
                  cardBorder: true,
                  cardStyle: QJ(o.engine),
                  cardLabel: undefined,
                },
                sources: e.getSources(),
                isDisabled: n,
              }),
            ],
          },
          e.id
        )
      ),
      e({ currentEntries: c, onClose: d }),
    ],
  });
}
export function KJ(e) {
  return (
    "sRGB" === e.colorSpace &&
    "number" == typeof e.r &&
    "number" == typeof e.g &&
    "number" == typeof e.b
  );
}
export function YJ(e) {
  return (
    "CMYK" === e.colorSpace &&
    "number" == typeof e.c &&
    "number" == typeof e.m &&
    "number" == typeof e.y &&
    "number" == typeof e.k
  );
}
export function XJ(e) {
  return (
    "string" == typeof e.name &&
    "string" == typeof e.externalReference &&
    (KJ(e.representation) || YJ(e.representation))
  );
}
export var JJ = mayBeUseMemp(function ({ setColor: e, isDisabled: t }) {
  const { t: n } = ZL(),
    s = DO(),
    i = IV(),
    o = (0, zJ.useCallback)(
      (t) => {
        switch (t.representation.colorSpace) {
          case "sRGB":
            s.engine.editor.setSpotColorRGB(
              t.name,
              t.representation.r,
              t.representation.g,
              t.representation.b
            );
            break;
          case "CMYK":
            s.engine.editor.setSpotColorCMYK(
              t.name,
              t.representation.c,
              t.representation.m,
              t.representation.y,
              t.representation.k
            );
            break;
          default:
            throw new Error(
              "Error parsing spot color, please make sure the a correct Spot color representation is provided in the asset meta data"
            );
        }
        e({ name: t.name, tint: 1, externalReference: t.externalReference }),
          i("action.property.update");
      },
      [i, s.engine.editor, e]
    ),
    r = (0, zJ.useCallback)(
      (t) => {
        switch (t.colorSpace) {
          case "sRGB":
            e({ ...t, a: 1 }), i("action.property.update");
            break;
          case "CMYK":
            e({ ...t, tint: 1 }), i("action.property.update");
            break;
          case "SpotColor":
            o(t);
            break;
          default:
            throw new Error(
              "Error parsing color, please make sure the a correct color space is provided in the asset meta data"
            );
        }
      },
      [i, e, o]
    ),
    a = (0, zJ.useCallback)(
      async (e) => {
        try {
          if (
            true !==
            (function (e) {
              switch (e.colorSpace) {
                case "sRGB":
                  if (!KJ(e))
                    throw new Error(
                      "Error parsing RGB color, please make sure the correct color properties are provided in the asset payload"
                    );
                  return true;
                case "CMYK":
                  if (!YJ(e))
                    throw new Error(
                      "Error parsing CMYK color, please make sure the correct color properties are provided in the asset payload"
                    );
                  return true;
                case "SpotColor":
                  if (!XJ(e))
                    throw new Error(
                      "Error parsing Spot color, please make sure the correct color properties are provided in the asset payload"
                    );
                  return true;
                default:
                  throw new Error(
                    "Error parsing color, please make sure the correct color space is provided in the asset payload"
                  );
              }
            })(e.payload?.color)
          )
            throw new Error(
              "Error parsing color, please make sure the a correct color space is provided in the asset meta data"
            );
          r(e.payload?.color);
        } catch (e) {
          e instanceof Error && s.log(e.message, "Error");
        }
      },
      [s, r]
    );
  return (0, qJ.jsx)(WJ, {
    onColorSelect: a,
    isDisabled: t,
    children: ({ currentEntries: e, onClose: t }) => {
      const s = e[0] ? n(`libraries.${e[0].id}.label`) : undefined,
        i = e.map(ZJ);
      return (0, qJ.jsxs)(WQ, {
        id: "//ly.img.panel/inspector/colorLibrary",
        context: "back",
        onClose: () => {
          t();
        },
        children: [
          (0, qJ.jsx)(WQ.Header, {
            children: (0, qJ.jsx)(WQ.Title, {
              children: s ?? n("component.library"),
            }),
          }),
          (0, qJ.jsx)(WQ.Content, {
            children: ({ isOpen: e }) =>
              (0, qJ.jsx)("div", {
                className: $J.panelContent,
                children: (0, qJ.jsxs)(MK, {
                  entries: i,
                  assetPanelOpen: e,
                  children: [
                    (0, qJ.jsx)(MK.Search, {
                      placeholder: n("component.library.searchPlaceholder"),
                    }),
                    (0, qJ.jsx)(MK.Content, { onSelect: a }),
                  ],
                }),
              }),
          }),
        ],
      });
    },
  });
});
export var e0 = { panelContent: "UBQ_ColorPanel-module__panelContent--feMsI" };

export function n0({ children: e, ...t }) {
  const { t: n } = ZL();
  return (0, t0.jsxs)(WQ, {
    id: "//ly.img.panel/inspector/editColor",
    context: "back",
    ...t,
    children: [
      (0, t0.jsx)(WQ.Header, {
        children: (0, t0.jsx)(WQ.Title, { children: n("common.editColor") }),
      }),
      (0, t0.jsx)(WQ.Content, {
        children: (t) =>
          (0, t0.jsx)("div", { className: e0.panelContent, children: e(t) }),
      }),
    ],
  });
}
export function s0({ isDisabled: e = false, color: t, setColor: n }) {
  const { t: s } = ZL(),
    i = YF(),
    o = s("input.colorMode"),
    r = s("input.colorMode.description"),
    a = (0, LJ.useMemo)(() => LO(t), [t]);
  return "SpotColor" === a
    ? null
    : (0, t0.jsxs)(Yk, {
        children: [
          (0, t0.jsx)(Sv, { isDisabled: e, "aria-label": o, children: o }),
          (0, t0.jsxs)(bw, {
            children: [
              (t, { isOpen: n }) => {
                const i = s(`common.${a.toLowerCase()}`);
                return (0, t0.jsx)(Ly, {
                  label: r,
                  children: (0, t0.jsxs)(CompCustomButton, {
                    name: "color-mode-select",
                    isDisabled: e,
                    ...t,
                    children: [
                      i,
                      n ? (0, t0.jsx)(EJ, {}) : (0, t0.jsx)(yQ, {}),
                    ],
                  }),
                });
              },
              () =>
                (0, t0.jsx)(bw.Options, {
                  value: a,
                  onChange: (e) => {
                    ((e) => {
                      const s = i.editor.convertColorToColorSpace(t, e);
                      n(s);
                    })(e);
                  },
                  children: ["sRGB", "CMYK"].map((e) => {
                    const t = s(`common.${e.toLowerCase()}`);
                    return (0, t0.jsx)(bw.Option, { value: e, children: t }, e);
                  }),
                }),
            ],
          }),
        ],
      });
}
export var i0 = mayBeUseMemp(function ({
  block: e,
  name: t,
  inBar: n,
  isPropertyEnabled: s,
  setIsPropertyEnabled: i,
  isDisabled: o,
  i18nLabelString: r,
  i18nDescriptionString: a,
  headerActions: l,
  donutHole: c,
  customButton: u,
  previewColor: d,
  colorMode: p,
  ...f
}) {
  const h = YF(),
    m = XR(),
    [, g] = BQ("//ly.img.panel/inspector/editColor", m);
  return (0, t0.jsxs)(t0.Fragment, {
    children: [
      (0, t0.jsx)(NJ, {
        color: f.color,
        gradientStops: f.gradientStops,
        onClick: () => g(true),
        isDisabled: o || !s,
      }),
      (0, t0.jsx)(JJ, {
        setColor: (t) => {
          if ("Gradient" === p) {
            const n = h.block.createFill("color");
            h.block.setColor(n, "fill/color/value", t), h.block.setFill(e, n);
          } else f.setColor(t);
        },
        isDisabled: o || !s,
      }),
      (0, t0.jsx)(n0, {
        children: () =>
          (0, t0.jsxs)(AJ, {
            children: [
              (0, t0.jsx)(s0, {
                color: f.color,
                setColor: f.setColor,
                isDisabled: o || !s,
              }),
              (0, t0.jsx)(UJ, {
                mode: "none",
                name: t,
                i18nLabelString: "property.color",
                i18nDescriptionString: "property.color.description",
                includeAlpha: true,
                showHeader: false,
                isDisabled: o,
                isPropertyEnabled: s,
                colorMode: p,
                ...f,
              }),
            ],
          }),
      }),
    ],
  });
});

export function a0(e) {
  const t = isCMYKColor(e),
    n = isRGBAColor(e);
  return t && (e.tint = 1), n && (e.a = 1), e;
}
export function l0(e) {
  const t = "ly.img.colors.documentColors";
  e.asset.findAllSources().includes(t) ||
    e.asset.addSource({
      id: t,
      findAssets: async ({ page: t, perPage: n }) => {
        const s = (function (e) {
          const t = e.block.findAll(),
            n = [],
            s = [],
            i = [],
            o = [];
          t.forEach((t) => {
            e.block.supportsFill(t) &&
              e.block.isValid(e.block.getFill(t)) &&
              "//ly.img.ubq/fill/color" ===
                e.block.getType(e.block.getFill(t)) &&
              e.block.isFillEnabled(t) &&
              "//ly.img.ubq/text" !== e.block.getType(t) &&
              n.push(t),
              e.block.supportsStroke(t) &&
                e.block.isStrokeEnabled(t) &&
                s.push(t),
              e.block.supportsDropShadow(t) &&
                e.block.isDropShadowEnabled(t) &&
                i.push(t),
              "//ly.img.ubq/text" === e.block.getType(t) && o.push(t);
          });
          const r = new Set();
          return (
            n.forEach((t) => {
              const n = e.block.getFill(t),
                s = a0(e.block.getColor(n, "fill/color/value"));
              r.add(JSON.stringify(s));
            }),
            s.forEach((t) => {
              const n = a0(e.block.getStrokeColor(t));
              r.add(JSON.stringify(n));
            }),
            i.forEach((t) => {
              const n = a0(e.block.getDropShadowColor(t));
              r.add(JSON.stringify(n));
            }),
            o
              .flatMap((t) => e.block.getTextColors(t))
              .forEach((e) => {
                const t = a0(e);
                r.add(JSON.stringify(t));
              }),
            Array.from(r).map((t) => {
              const n = JSON.parse(t),
                s = isCMYKColor(n);
              return {
                id: Object.values(n).toString(),
                label: FJ(n, s ? PO(n, e.editor) : n),
                payload: { color: { colorSpace: s ? "CMYK" : "sRGB", ...n } },
              };
            })
          );
        })(e);
        return {
          assets: s.slice(t * n, (t + 1) * n),
          total: s.length,
          currentPage: t,
        };
      },
    });
}
export var u0 = mayBeUseMemp(
  WithEngineComp(function ({
    block: e,
    name: t,
    inBar: n,
    isPropertyEnabled: s,
    setIsPropertyEnabled: i,
    isDisabled: o,
    i18nLabelString: r,
    i18nDescriptionString: a,
    headerActions: l,
    panelId: c,
    groupId: u,
    donutHole: d,
    customButton: p,
    previewColor: f,
    "data-cy": h,
    hidePropertyToggle: m = false,
    engine: g,
    colorMode: x,
    ...b
  }) {
    const { t: y } = ZL(),
      v = n ? xX.Fragment : Yk,
      w = n ? CX : EX,
      k = y(r),
      C = y(a);
    (0, xX.useEffect)(() => {
      l0(g);
    }, [g]);
    return (0, c0.jsxs)(v, {
      children: [
        !n && (0, c0.jsx)(Sv, { isDisabled: o, children: k }),
        (0, c0.jsx)(w, {
          label: k,
          ariaLabel: C,
          tooltip: C,
          valueLabel: y("common.edit"),
          isDisabled: o || !s,
          renderButton:
            p ??
            (({ isActive: e, ...t }) =>
              n
                ? (0, c0.jsx)(My, {
                    variant: e ? "regular" : "plain",
                    previewColor: f,
                    hidePreviewLabel: true,
                    donutHole: d,
                    isDisabled: o || !s,
                    strikeThrough: !s,
                    ...t,
                    children: k,
                  })
                : (0, c0.jsx)(Ty, {
                    variant: "regular",
                    renderChevronIcon: () => (0, c0.jsx)(zq, {}),
                    previewColor: f,
                    customPreviewLabel:
                      "Gradient" === x
                        ? y("property.gradientType.linear")
                        : undefined,
                    invertedLabel: "Gradient" === x,
                    ...t,
                  })),
          panelId: c,
          groupId: u,
          icon: (0, c0.jsx)(gX, {}),
          isPropertyEnabled: s,
          headerActions: (0, c0.jsxs)(c0.Fragment, {
            children: [
              l,
              (0, c0.jsx)(NK, {
                isEnabled: s,
                isVisible: !m,
                toggleProperty: () => {
                  i(!s);
                },
                label: y("property.strokeColor"),
              }),
            ],
          }),
          "data-cy": h,
          children: (0, c0.jsx)(E_, {
            isDisabled: !s,
            onClick: () => {
              i(true);
            },
            label: y(
              s
                ? "input.propertyToggle.disable"
                : "input.propertyToggle.enable",
              { property: k }
            ),
            children: (0, c0.jsx)(AJ, {
              children: (0, c0.jsx)(i0, {
                block: e,
                name: t,
                i18nLabelString: r,
                i18nDescriptionString: a,
                isPropertyEnabled: s,
                setIsPropertyEnabled: i,
                isDisabled: o,
                colorMode: x,
                ...b,
              }),
            }),
          }),
        }),
        !n &&
          !m &&
          (0, c0.jsx)(NK, {
            isDisabled: o,
            "data-cy": h ? `propertyToggle-${h}` : undefined,
            label: k,
            isEnabled: s,
            toggleProperty: () => {
              i(!s);
            },
          }),
      ],
    });
  })
);
export function d0(e) {
  return (0, c0.jsx)(u0, { ...e });
}
export function p0({ block: e, ...t }) {
  const n = (function (e) {
    const t = YF(),
      { isPropertyEnabled: n, color: s } = eI(t, () => ({
        isPropertyEnabled: t.block.isStrokeEnabled(e),
        color: t.block.getColor(e, "stroke/color"),
      })),
      i = (0, SJ.useCallback)((n) => t.block.setStrokeEnabled(e, n), [e, t]),
      o = (0, SJ.useCallback)(
        (n) => {
          t.block.setColor(e, "stroke/color", n);
        },
        [t, e]
      ),
      r = (0, SJ.useMemo)(() => PO(s, t.editor), [s, t.editor]);
    return {
      color: s,
      setColor: o,
      isPropertyEnabled: n,
      setIsPropertyEnabled: i,
      previewColor: r,
    };
  })(e);
  return (0, c0.jsx)(d0, { block: e, ...t, ...n });
}
export var f0 = WithEngineComp(function ({
  engine: e,
  name: t = "strokeColor",
  i18nLabelString: n = "property.strokeColor",
  i18nDescriptionString: s = "property.strokeColor.description",
  ...i
}) {
  const o = VO(),
    [r] = e.block.findAllSelected(),
    a = o.feature.isEnabled("ly.img.stroke", { engine: e });
  if (!(null != r && e.block.supportsStroke(r)) || !a) return null;
  const l = e.block.isAllowedByScope(r, EH);
  return (0, c0.jsx)(p0, {
    block: r,
    isDisabled: !l,
    "data-cy": "stroke",
    name: t,
    i18nLabelString: n,
    i18nDescriptionString: s,
    ...i,
  });
});
export var h0 = WithEngineComp(function ({
  engine: e,
  name: t = "strokeColor",
  i18nLabelString: n = "property.strokeColor",
  i18nDescriptionString: s = "property.strokeColor.description",
  ...i
}) {
  const [o] = e.block.findAllSelected(),
    r = null != o && e.block.hasStroke(o) && e.block.isStrokeEnabled(o);
  return (0, c0.jsx)(f0, {
    inBar: true,
    includeAlpha: true,
    donutHole: true,
    name: t,
    i18nLabelString: n,
    i18nDescriptionString: s,
    onContainerClick: () => {
      r || e.block.setStrokeEnabled(o, true);
    },
    ...i,
  });
});
export function m0({ block: e, ...t }) {
  const n = (function (e) {
    const t = YF(),
      { isPropertyEnabled: n, color: s } = eI(t, () => ({
        isPropertyEnabled: t.block.isDropShadowEnabled(e),
        color: t.block.getColor(e, "dropShadow/color"),
      })),
      i = (0, jJ.useCallback)(
        (n) => t.block.setDropShadowEnabled(e, n),
        [e, t]
      ),
      o = (0, jJ.useCallback)(
        (n) => {
          t.block.setColor(e, "dropShadow/color", n);
        },
        [t, e]
      ),
      r = (0, jJ.useMemo)(() => PO(s, t.editor), [s, t.editor]);
    return {
      color: s,
      setColor: o,
      isPropertyEnabled: n,
      setIsPropertyEnabled: i,
      previewColor: r,
    };
  })(e);
  return (0, c0.jsx)(d0, { block: e, ...t, ...n });
}
export var g0 = WithEngineComp(function ({ engine: e, ...t }) {
  const [n] = e.block.findAllSelected();
  if (!(null != n && e.block.hasDropShadow(n))) return null;
  const s = e.block.isAllowedByScope(n, wH);
  return (0,
  c0.jsx)(m0, { block: n, isDisabled: !s, "data-cy": "shadow-color", ...t });
});
export var x0 = WithEngineComp(function ({ engine: e, ...t }) {
  return e.block.isValid(t.block) ? (0, c0.jsx)(b0, { ...t }) : null;
});
export var b0 = WithEngineComp(function ({
  engine: e,
  property: t,
  block: n,
  ...s
}) {
  const i = e.block.getColor(n, t);
  const o = (0, xX.useMemo)(() => PO(i, e.editor), [i, e.editor]);
  return (0, c0.jsx)(d0, {
    block: n,
    name: "effect-property-color-subinspector",
    i18nLabelString: s.label,
    i18nDescriptionString: s.description,
    isPropertyEnabled: true,
    setIsPropertyEnabled: () => {},
    color: i,
    previewColor: o,
    setColor: function (s) {
      e.block.setColor(n, t, s);
    },
    hidePropertyToggle: true,
    ...s,
  });
});
(d0.Stroke = f0),
  (d0.StrokeInBar = h0),
  (d0.DropShadow = g0),
  (d0.Property = x0);
export var y0, v0;
export var w0 = d0;

export var _0 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO().feature.isEnabled("ly.img.shadow", { engine: e }),
      [s] = e.block.findAllSelected();
    return null != s && e.block.hasDropShadow(s) && n ? t({ block: s }) : null;
  })
);
export var E0 = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    block: t,
    inBar: n = false,
    deniedByScopeBehavior: s = "disable",
  }) {
    const { t: i } = ZL(),
      o = VO(),
      r = XR(),
      [a] = BQ("//ly.img.panel/inspector/shadow", r);
    function l() {
      a
        ? o.ui.closePanel("//ly.img.panel/inspector/shadow")
        : o.ui.openPanel("//ly.img.panel/inspector/shadow");
    }
    const c = e.block.isAllowedByScope(t, wH);
    if (!c && "hide" === s) return null;
    const u = e.block.isDropShadowEnabled(t),
      d = !u || !c,
      p = i("input.shadow.label"),
      f = i("input.shadow.valueLabel");
    return n
      ? (0, S0.jsx)(Ly, {
          label: i("input.shadow.description"),
          children: (0, S0.jsx)(CompCustomButton, {
            name: p,
            variant: a ? "regular" : "plain",
            icon: (0, S0.jsxs)(Gb, {
              className: (0, oX.default)(C0, { [j0]: !u }),
              children: [(0, S0.jsx)(CY, {}), !u && (0, S0.jsx)(Yb, {})],
            }),
            isActive: u,
            activeStateStyle: "pill",
            onClick: l,
            isDisabled: !c,
            "data-cy": "shadow",
            children: p,
          }),
        })
      : (0, S0.jsxs)(Yk, {
          children: [
            (0, S0.jsx)(Sv, { isDisabled: d, children: p }),
            (0, S0.jsx)(Ly, {
              label: i("input.shadow.description"),
              children: (0, S0.jsxs)(CompCustomButton, {
                name: p,
                variant: "regular",
                icon: (0, S0.jsx)(CY, {}),
                isActive: u,
                activeStateStyle: "pill",
                onClick: l,
                isDisabled: d,
                "data-cy": "shadow",
                children: [f, (0, S0.jsx)(zq, {})],
              }),
            }),
            (0, S0.jsx)(NK, {
              label: p,
              isEnabled: u,
              toggleProperty: () => {
                e.block.setDropShadowEnabled(t, !u);
              },
              isDisabled: !c,
              "data-cy": "propertyToggle-shadow",
            }),
          ],
        });
  })
);
export var L0 = WithEngineComp(function ({ engine: e, block: t }) {
  const { t: n } = ZL(),
    s = IV(),
    i = e.block.isAllowedByScope(t, wH),
    o = e.block.isDropShadowEnabled(t),
    r = e.block.getDropShadowOffsetX(t),
    a = e.block.getDropShadowOffsetY(t),
    l = e.block.getDropShadowBlurRadiusX(t),
    c = (({ x: e, y: t }) => Math.sqrt(e * e + t * t))({ x: r, y: a }),
    u = uX((180 * Math.atan2(a, r)) / Math.PI - 90, -180, 180),
    d = e.scene.getDesignUnit(),
    p = rX(d),
    f = n("input.shadow.label"),
    h = (n) => {
      undefined === n ||
        n < 0 ||
        (e.block.setDropShadowBlurRadiusX(t, n),
        e.block.setDropShadowBlurRadiusY(t, n));
    },
    m = (n) => {
      if (undefined === n || n < 0) return;
      const s = ((u + 90) / 180) * Math.PI;
      e.block.setDropShadowOffsetX(t, Math.cos(s) * n),
        e.block.setDropShadowOffsetY(t, Math.sin(s) * n);
    },
    g = () => {
      e.block.setDropShadowEnabled(t, !o);
    },
    x = (n) => {
      if (undefined === n) return;
      const s = ((n + 90) / 180) * Math.PI;
      e.block.setDropShadowOffsetX(t, Math.cos(s) * c),
        e.block.setDropShadowOffsetY(t, Math.sin(s) * c);
    },
    b = (() => {
      switch (d) {
        case "Pixel":
          return 1;
        case "Millimeter":
        default:
          return 0.1;
        case "Inch":
          return 0.01;
      }
    })();
  return (0, S0.jsxs)(S0.Fragment, {
    children: [
      (0, S0.jsx)(WQ.Header, {
        action: (0, S0.jsx)(NK, {
          label: f,
          isEnabled: o,
          isDisabled: !i,
          toggleProperty: g,
          "data-cy": "propertyToggle-shadow",
        }),
        children: (0, S0.jsx)(WQ.Title, { children: f }),
      }),
      (0, S0.jsx)(WQ.Content, {
        children: (0, S0.jsx)(E_, {
          isDisabled: !o,
          onClick: g,
          label: n(
            o ? "input.propertyToggle.disable" : "input.propertyToggle.enable",
            { property: f }
          ),
          children: (0, S0.jsxs)(Qk, {
            children: [
              (0, S0.jsx)(Yk, {
                children: (0, S0.jsx)(w0.DropShadow, {
                  panelId: "//ly.img.panel/inspector/shadow/color",
                  isDisabled: !o,
                  name: "shadow-color",
                  i18nLabelString: "property.color",
                  i18nDescriptionString: "action.shadow.color.change",
                  includeAlpha: true,
                  hidePropertyToggle: true,
                }),
              }),
              (0, S0.jsx)(Yk, { children: (0, S0.jsx)(Sw, {}) }),
              (0, S0.jsxs)(Yk, {
                children: [
                  (0, S0.jsx)(Sv, {
                    htmlFor: "shadow-angle",
                    isDisabled: !o,
                    children: n("input.shadow.angle"),
                  }),
                  (0, S0.jsx)(Ly, {
                    label: n("action.shadow.angle.change"),
                    children: (0, S0.jsx)(zv, {
                      name: "shadow-angle",
                      id: "shadow-angle",
                      "aria-label": n("input.shadow.angle.description"),
                      value: u,
                      isDisabled: !o,
                      onChange: x,
                      onRelease: (e) => {
                        undefined !== e &&
                          (x(e), s("action.shadow.angle.change"));
                      },
                      unitLabel: "",
                      min: -360,
                      max: 360,
                      step: 1,
                    }),
                  }),
                  (0, S0.jsx)(Ly, {
                    label: n("action.shadow.angle.rotate"),
                    children: (0, S0.jsx)(CompCustomButton, {
                      name: "shadow-angle-rotate",
                      "aria-label": n("action.shadow.angle.rotate"),
                      className: k0,
                      isDisabled: !o,
                      onClick: () => {
                        x(u + 45), s("action.shadow.angle.rotate");
                      },
                      children: (0, S0.jsx)(NY, {}),
                    }),
                  }),
                ],
              }),
              (0, S0.jsxs)(Yk, {
                children: [
                  (0, S0.jsx)(Sv, {
                    isDisabled: !o,
                    children: n("input.shadow.distance"),
                  }),
                  (0, S0.jsx)(Ly, {
                    label: n("action.shadow.distance.change"),
                    children: (0, S0.jsx)(zv, {
                      name: "shadow-distance",
                      id: "shadow-distance",
                      "aria-label": n("input.shadow.distance.description"),
                      value: c,
                      onChange: m,
                      onRelease: (e) => {
                        undefined !== e &&
                          (m(e), s("action.shadow.distance.change"));
                      },
                      min: 0,
                      step: b,
                      maxFractionDigits: 2,
                      unitLabel: p,
                      isDisabled: !o,
                    }),
                  }),
                ],
              }),
              (0, S0.jsxs)(Yk, {
                children: [
                  (0, S0.jsx)(Sv, {
                    isDisabled: !o,
                    children: n("input.shadow.blur"),
                  }),
                  (0, S0.jsx)(Ly, {
                    label: n("action.shadow.blur.change"),
                    children: (0, S0.jsx)(zv, {
                      name: "shadow-blur",
                      id: "shadow-blur",
                      "aria-label": n("input.shadow.blur.description"),
                      value: l,
                      onChange: h,
                      onRelease: (e) => {
                        undefined !== e &&
                          (h(e), s("action.shadow.blur.change"));
                      },
                      min: 0,
                      step: b,
                      maxFractionDigits: 2,
                      unitLabel: p,
                      isDisabled: !o,
                    }),
                  }),
                ],
              }),
            ],
          }),
        }),
      }),
    ],
  });
});
((v0 = y0 || (y0 = {})).SupportGuard = _0),
  (v0.PanelContent = L0),
  (v0.Control = function (e) {
    return (0, S0.jsx)(_0, {
      children: ({ block: t }) => (0, S0.jsx)(E0, { block: t, ...e }),
    });
  });
export var P0 = y0;

export var G0 = function ({
  isLocked: e,
  setIsLocked: t,
  isDisabled: n = false,
}) {
  const { t: s } = ZL();
  return (0, Q0.jsxs)("div", {
    className: (0, N0.default)(U0, { [z0]: !e }),
    children: [
      (0, Q0.jsx)(V0, { className: q0 }),
      (0, Q0.jsx)(Ly, {
        label: s("input.aspectLock.description"),
        children: (0, Q0.jsx)(Zp, {
          className: $0,
          "aria-label": s("input.aspectLock"),
          isDisabled: n,
          name: "toggleAspectLock",
          onClick: () => {
            t?.(!e);
          },
          "aria-pressed": e,
          "data-active": e,
          children: e ? (0, Q0.jsx)(F0, {}) : (0, Q0.jsx)(H0, {}),
        }),
      }),
      (0, Q0.jsx)(V0, { className: q0 }),
    ],
  });
};
export var Z0 = G0;

export var K0 = WithEngineComp(function ({ engine: e, block: t }) {
  const n = IV(),
    s = DO(),
    i = oD(),
    { t: o } = ZL(),
    r = rI(dH),
    a = e.block.getFrameWidth(t),
    l = e.block.getFrameHeight(t),
    c = (0, O0.useRef)({ x: a, y: l }),
    [u, d] = (0, O0.useState)(false),
    p = e.block.getContentFillMode(t),
    f = !r || "Contain" === p,
    h = (e) => {
      s.legacyApi.execute("ubq/editor/setCropAreaSize", { size: e });
    },
    m = (e, t) => {
      parseFloat(Fv(c.current[t], 1)) !== e &&
        (n("action.image.crop"), (c.current[t] = e));
      h({ x: a, y: l, [t]: e });
    },
    [g] = possibleHook3(i.scene.designUnit),
    x = rX(g);
  return (0, W0.jsxs)(Qk, {
    title: o("property.crop.size"),
    headingLevel: 3,
    children: [
      (0, W0.jsxs)(Yk, {
        children: [
          (0, W0.jsx)(Pv, {
            name: "width",
            label: o("common.width"),
            isDisabled: f,
            children: (e) =>
              (0, W0.jsx)(zv, {
                min: 0.1,
                value: a,
                unitLabel: x,
                isDisabled: f,
                onChange: (e) => {
                  if (undefined !== e)
                    if (u) {
                      h({ x: e, y: e / (a / l) });
                    } else h({ x: e, y: l });
                },
                onRelease: (e) => {
                  undefined !== e && m(e, "x");
                },
                ...e,
                "aria-label": o("property.crop.size.description", {
                  dimension: o("common.width"),
                  unit: x,
                }),
              }),
          }),
          (0, W0.jsx)(Z0, { isLocked: u, setIsLocked: d, isDisabled: f }),
        ],
      }),
      (0, W0.jsxs)(Yk, {
        children: [
          (0, W0.jsx)(Pv, {
            name: "height",
            label: o("common.height"),
            isDisabled: f,
            children: (e) =>
              (0, W0.jsx)(zv, {
                min: 0.1,
                value: l,
                unitLabel: x,
                isDisabled: f,
                onChange: (e) => {
                  if (undefined !== e)
                    if (u) {
                      h({ x: (a / l) * e, y: e });
                    } else h({ x: a, y: e });
                },
                onRelease: (e) => {
                  undefined !== e && m(e, "y");
                },
                ...e,
                "aria-label": o("property.crop.size.description", {
                  dimension: o("common.height"),
                  unit: x,
                }),
              }),
          }),
          (0, W0.jsx)(zK, {}),
        ],
      }),
    ],
  });
});

export var J0 = WithEngineComp(function ({ engine: e, block: t }) {
  const n = IV(),
    s = DO(),
    { t: i } = ZL(),
    o = rX(e.scene.getDesignUnit()),
    r = e.block.getFrameWidth(t),
    a = e.block.getFrameHeight(t),
    l = e.block.getCropTranslationX(t),
    c = e.block.getCropTranslationY(t),
    u = e.block.getContentFillMode(t),
    d = { x: l * r, y: c * a },
    p = (e) => {
      s.legacyApi.execute("ubq/editor/setAbsoluteCropTranslation", {
        value: e,
      });
    },
    f = (0, Y0.useRef)(d),
    h = (e, t) => {
      parseFloat(Fv(f.current[t], 1)) !== e &&
        (n("action.image.crop"), (f.current[t] = e)),
        p({ ...d, [t]: e });
    };
  return (0, X0.jsxs)(X0.Fragment, {
    children: [
      (0, X0.jsx)(Yk, {
        children: (0, X0.jsx)(Pv, {
          name: "xOffset",
          label: i("property.crop.offset", { axis: i("common.axis.x") }),
          isDisabled: "Contain" === u,
          children: (e) =>
            (0, X0.jsx)(zv, {
              value: d.x,
              unitLabel: o,
              onChange: (e) => {
                undefined !== e && p({ x: e, y: d.y });
              },
              onRelease: (e) => {
                undefined !== e && h(e, "x");
              },
              ...e,
              isDisabled: "Contain" === u,
              "aria-label": i("property.crop.offset.description", {
                unit: o,
                axis: i("common.axis.x"),
              }),
            }),
        }),
      }),
      (0, X0.jsx)(Yk, {
        children: (0, X0.jsx)(Pv, {
          name: "yOffset",
          label: i("property.crop.offset", { axis: i("common.axis.y") }),
          isDisabled: "Contain" === u,
          children: (e) =>
            (0, X0.jsx)(zv, {
              value: d.y,
              unitLabel: o,
              onChange: (e) => {
                undefined !== e && p({ x: d.x, y: e });
              },
              onRelease: (e) => {
                undefined !== e && h(e, "y");
              },
              ...e,
              isDisabled: "Contain" === u,
              "aria-label": i("property.crop.offset.description", {
                unit: o,
                axis: i("common.axis.y"),
              }),
            }),
        }),
      }),
    ],
  });
});

export var t1 = { straighten: true, turn: true, mirror: true };
export function n1(e) {
  const t = YF(),
    n = (0, e1.useRef)(t1),
    s = (0, e1.useRef)(1),
    { scaleRatio: i, rotation: o } = eI(t, () => ({
      scaleRatio: t.block.getCropScaleRatio(e),
      rotation: t.block.getCropRotation(e),
    }));
  (0, e1.useEffect)(() => {
    n.current.straighten &&
      n.current.turn &&
      n.current.mirror &&
      (s.current = i);
  }, [i]);
  const [r, a] = (0, e1.useState)(0),
    l = (0, e1.useMemo)(() => {
      const e = (o / Math.PI) * 180,
        t = e % 90;
      let n = e - t;
      return t > 45 && (n += 90), a(n), e;
    }, [o]),
    c = (n) => {
      const i = t.block.getContentFillMode(e),
        o = (n / 180) * Math.PI;
      t.block.setCropRotation(e, o),
        "Crop" === i && t.block.adjustCropToFillFrame(e, s.current);
    };
  return {
    cropScaleRatio: 100 * i,
    cropStraightenAngle: l - r,
    cropScaleOnChangeHandler: (n = 100) => {
      ((n) => {
        (s.current = n),
          t.block.adjustCropToFillFrame(e, n),
          t.block.setCropScaleRatio(e, n),
          t.block.adjustCropToFillFrame(e, n);
      })(n / 100);
    },
    cropStraightenOnChangeHandler: (s) => {
      if (undefined === s) return;
      let i = s;
      45 === i && (i = 44.9999),
        -45 === i && (i = -44.9999),
        (n.current.straighten = false),
        t.block.setContentFillMode(e, "Crop"),
        c(i + r);
    },
    cropStraightenOnReleaseHandler: () => {
      n.current.straighten = true;
    },
    cropTurnOnClickHandler: () => {
      const s = (r + 270) % 360;
      (n.current.turn = false),
        t.block.setContentFillMode(e, "Crop"),
        c(l - r + s),
        a(s);
    },
    cropTurnOnBlurHandler: () => {
      n.current.turn = true;
    },
    cropMirrorXOnClickHandler: () => {
      (n.current.mirror = false),
        t.block.setContentFillMode(e, "Crop"),
        t.block.flipCropHorizontal(e);
    },
    cropMirrorYOnClickHandler: () => {
      (n.current.mirror = false),
        t.block.setContentFillMode(e, "Crop"),
        t.block.flipCropVertical(e);
    },
    cropMirrorOnBlurHandler: () => {
      n.current.mirror = true;
    },
  };
}
export function i1(e) {
  const t = YF(),
    { t: n } = ZL(),
    s = rI(hH),
    [i, o] = (0, s1.useState)(() => t.editor.getEditMode());
  (0, s1.useEffect)(() => {
    let e = true;
    const n = t.editor.onStateChanged(() => {
      e && o(t.editor.getEditMode());
    });
    return () => {
      (e = false), n();
    };
  }, [t.editor]);
  const {
      contentFillMode: r,
      height: a,
      width: l,
      isFillEnabled: c,
    } = eI(t, () => ({
      isFillEnabled: t.block.supportsFill(e) && t.block.isFillEnabled(e),
      contentFillMode: t.block.getContentFillMode(e),
      width: t.block.getFrameWidth(e),
      height: t.block.getFrameHeight(e),
    })),
    u = "Crop" === r;
  return {
    hasCrop: u,
    valueLabel: u ? `${+l.toFixed(1)}  ${+a.toFixed(1)}` : n("common.select"),
    isOpen: "Crop" === i,
    openSubInspector: (0, s1.useCallback)(() => {
      t.editor.setEditMode("Crop");
    }, [t.editor]),
    closeSubInspector: (0, s1.useCallback)(() => {
      t.editor.setEditMode("Transform");
    }, [t.editor]),
    isDisabled: !c || !s,
    reset: () => {
      t.block.resetCrop(e);
    },
  };
}
export var r1 = WithEngineComp(({ block: e, engine: t }) => {
  const { t: n } = ZL(),
    s = IV(),
    i = "Contain" === t.block.getContentFillMode(e),
    {
      cropScaleRatio: o,
      cropStraightenAngle: r,
      cropScaleOnChangeHandler: a,
      cropStraightenOnChangeHandler: l,
      cropStraightenOnReleaseHandler: c,
      cropTurnOnClickHandler: u,
      cropTurnOnBlurHandler: d,
      cropMirrorXOnClickHandler: p,
      cropMirrorYOnClickHandler: f,
      cropMirrorOnBlurHandler: h,
    } = n1(e),
    { isDisabled: m } = i1(e);
  return (0, o1.jsxs)(o1.Fragment, {
    children: [
      (0, o1.jsx)(K0, { block: e }),
      (0, o1.jsxs)(Qk, {
        title: n("property.crop.transform"),
        headingLevel: 3,
        children: [
          (0, o1.jsx)(J0, { block: e }),
          (0, o1.jsx)(Yk, { children: (0, o1.jsx)(Sw, {}) }),
          (0, o1.jsx)(Yk, {
            children: (0, o1.jsx)(Pv, {
              name: "crop/scale",
              label: n("property.crop.scale"),
              isDisabled: m || i,
              children: (e) =>
                (0, o1.jsx)(zv, {
                  ...e,
                  min: 1,
                  maxFractionDigits: 2,
                  step: 1,
                  value: o,
                  unitLabel: "%",
                  id: "crop/scale",
                  onChange: a,
                  onRelease: () => s("action.image.crop"),
                  "aria-label": n("property.crop.scale.description"),
                  isDisabled: m || i,
                }),
            }),
          }),
          (0, o1.jsx)(Yk, {
            children: (0, o1.jsx)(tG, {
              name: "crop/straighten",
              label: n("property.crop.straighten"),
              value: r,
              min: -45,
              max: 45,
              step: 1,
              maxFractionDigits: 0,
              centeredZeroPosition: true,
              isDisabled: m,
              onChange: l,
              onRelease: () => {
                s("action.image.crop"), c();
              },
            }),
          }),
          (0, o1.jsxs)(Yk, {
            children: [
              (0, o1.jsx)(Sv, {
                isDisabled: m,
                children: n("action.crop.turnAndMirror"),
              }),
              (0, o1.jsx)(Ly, {
                label: n("action.crop.turn"),
                children: (0, o1.jsx)(CompCustomButton, {
                  name: "crop/turn",
                  "aria-label": n("action.crop.turn"),
                  isDisabled: m,
                  onClick: () => {
                    u(), s("action.image.crop");
                  },
                  onBlur: d,
                  children: (0, o1.jsx)(M0, {}),
                }),
              }),
              (0, o1.jsx)(Ly, {
                label: n("action.crop.mirrorX"),
                children: (0, o1.jsx)(CompCustomButton, {
                  name: "crop/mirrorX",
                  "aria-label": n("action.crop.mirrorX"),
                  isDisabled: m,
                  onClick: () => {
                    p(), s("action.image.crop");
                  },
                  onBlur: h,
                  children: (0, o1.jsx)(BY, {}),
                }),
              }),
              (0, o1.jsx)(Ly, {
                label: n("action.crop.mirrorY"),
                children: (0, o1.jsx)(CompCustomButton, {
                  name: "crop/mirrorY",
                  "aria-label": n("action.crop.mirrorY"),
                  isDisabled: m,
                  onClick: () => {
                    f(), s("action.image.crop");
                  },
                  onBlur: h,
                  children: (0, o1.jsx)(B0, {}),
                }),
              }),
            ],
          }),
        ],
      }),
    ],
  });
});
export var a1 = r1;

export var p1 = function ({ block: e }) {
  const t = DO(),
    { t: n } = ZL(),
    s = IV(),
    {
      cropStraightenAngle: i,
      cropStraightenOnChangeHandler: o,
      cropStraightenOnReleaseHandler: r,
      cropTurnOnClickHandler: a,
      cropTurnOnBlurHandler: l,
      cropMirrorXOnClickHandler: c,
      cropMirrorYOnClickHandler: u,
    } = n1(e),
    { hasCrop: d, isDisabled: p, reset: f } = i1(e);
  return (0, d1.jsxs)(d1.Fragment, {
    children: [
      (0, d1.jsx)("span", {
        className: u1,
        children: (0, d1.jsx)(CompCustomButton, {
          icon: (0, d1.jsx)(IconCheckmark, {}),
          name: "crop-done",
          "aria-label": n("action.crop.exit"),
          onClick: () => {
            t.engine.editor.setEditMode("Transform");
          },
          color: "accent",
          children: n("common.done"),
        }),
      }),
      (0, d1.jsxs)("span", {
        className: u1,
        children: [
          (0, d1.jsx)(Pv, {
            name: "crop/straighten",
            label: n("property.crop.straighten"),
            children: (e) =>
              (0, d1.jsx)(Dk, {
                ...e,
                toggleNumberInputAriaLabel: n("property.crop.straighten"),
                value: i,
                min: -45,
                max: 45,
                step: 1,
                maxFractionDigits: 0,
                centeredZeroPosition: true,
                onChange: (e) => o(Number.parseFloat(e.target.value)),
                onNumberInputChange: o,
                onRelease: () => {
                  r(), s("action.image.crop");
                },
              }),
          }),
          (0, d1.jsx)(Ly, {
            label: n("action.crop.turn"),
            children: (0, d1.jsx)(CompCustomButton, {
              name: "crop/turn",
              variant: "plain",
              "aria-label": n("action.crop.turn"),
              isDisabled: p,
              onClick: () => {
                a(), s("action.image.crop");
              },
              onBlur: l,
              children: (0, d1.jsx)(M0, {}),
            }),
          }),
          (0, d1.jsx)(Ly, {
            label: n("action.crop.mirrorX"),
            children: (0, d1.jsx)(CompCustomButton, {
              name: "crop/mirrorX",
              variant: "plain",
              "aria-label": n("action.crop.mirrorX"),
              isDisabled: p,
              onClick: () => {
                c(), s("action.image.crop");
              },
              children: (0, d1.jsx)(BY, {}),
            }),
          }),
          (0, d1.jsx)(Ly, {
            label: n("action.crop.mirrorY"),
            children: (0, d1.jsx)(CompCustomButton, {
              name: "crop/mirrorY",
              variant: "plain",
              "aria-label": n("action.crop.mirrorY"),
              isDisabled: p,
              onClick: () => {
                u(), s("action.image.crop");
              },
              children: (0, d1.jsx)(B0, {}),
            }),
          }),
        ],
      }),
      (0, d1.jsx)("span", {
        className: u1,
        children: (0, d1.jsx)(CompCustomButton, {
          icon: (0, d1.jsx)(FG, {}),
          name: "crop-reset",
          variant: "plain",
          "aria-label": n("action.crop.reset"),
          isDisabled: !d || p,
          onClick: () => {
            f(), s("action.image.crop");
          },
          children: n("common.reset"),
        }),
      }),
    ],
  });
};

export var h1 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO(),
      { blocks: s } = YR();
    if (!n.feature.isEnabled("ly.img.crop", { engine: e })) return null;
    const i = e.block.findAllSelected()[0];
    if (!i) return null;
    const o = e.block.getType(i),
      r = e.block.supportsFill(i) ? e.block.getFill(i) : undefined,
      a = null != r && e.block.isValid(r) ? e.block.getType(r) : undefined,
      l = e.block.supportsCrop(i),
      c = s[o],
      u = !!(c && "cropEnabled" in c && c.cropEnabled) && c.cropEnabled;
    return l &&
      l &&
      u &&
      ("//ly.img.ubq/fill/image" === a || "//ly.img.ubq/fill/video" === a)
      ? t({ block: i })
      : null;
  })
);
export function m1({ block: e }) {
  const { t: t } = ZL(),
    n = IV(),
    { hasCrop: s, reset: i } = i1(e);
  return (0, f1.jsxs)(f1.Fragment, {
    children: [
      (0, f1.jsx)(WQ.Header, {
        action: (0, f1.jsxs)(CompCustomButton, {
          name: "reset",
          onClick: () => {
            i(), n("action.image.crop");
          },
          "aria-label": t("common.reset"),
          "data-cy": "reset-crop-subInspector",
          variant: "plain",
          isDisabled: !s,
          children: [t("common.reset"), (0, f1.jsx)(FG, {})],
        }),
        children: (0, f1.jsx)(WQ.Title, { children: t("property.crop") }),
      }),
      (0, f1.jsx)(WQ.Content, { children: (0, f1.jsx)(a1, { block: e }) }),
    ],
  });
}
export var g1, x1;
export var b1 = mayBeUseMemp(function ({
  block: e,
  inBar: t = false,
  fillContainer: n,
  deniedByScopeBehavior: s = "disable",
}) {
  const { t: i } = ZL(),
    o = VO(),
    r = rI(hH),
    { openSubInspector: a, isDisabled: l, hasCrop: c, valueLabel: u } = i1(e),
    d = XR(),
    [p] = BQ("//ly.img.panel/inspector/crop", d);
  if (!r && "hide" === s) return null;
  const f = i("property.crop");
  return t
    ? (0, f1.jsx)(Ly, {
        label: i("property.crop.tooltip"),
        children: (0, f1.jsx)(CompCustomButton, {
          icon: (0, f1.jsx)(wY, {}),
          "data-cy": "crop",
          name: "inspectorbar-crop",
          onClick: a,
          variant: "plain",
          "aria-label": i("property.crop"),
          isDisabled: l,
          children: i("property.crop"),
        }),
      })
    : (0, f1.jsxs)(Yk, {
        children: [
          (0, f1.jsx)(Sv, { isDisabled: l, children: f }),
          (0, f1.jsx)(Ly, {
            label: i("property.crop.tooltip"),
            children: (0, f1.jsxs)(CompCustomButton, {
              name: f,
              variant: "regular",
              icon: (0, f1.jsx)(wY, {}),
              isActive: c,
              activeStateStyle: "outline",
              onClick: function () {
                p
                  ? o.ui.closePanel("//ly.img.panel/inspector/crop")
                  : o.ui.openPanel("//ly.img.panel/inspector/crop");
              },
              isDisabled: l || !r,
              "data-cy": "crop",
              children: [u, (0, f1.jsx)(zq, {})],
            }),
          }),
          !n && (0, f1.jsx)(zK, {}),
        ],
      });
});
((x1 = g1 || (g1 = {})).SupportGuard = h1),
  (x1.PanelContent = m1),
  (x1.Control = function ({
    inBar: e,
    fillContainer: t,
    deniedByScopeBehavior: n,
  }) {
    return (0, f1.jsx)(h1, {
      children: (s) =>
        (0, f1.jsx)(b1, {
          inBar: e,
          fillContainer: t,
          deniedByScopeBehavior: n,
          ...s,
        }),
    });
  }),
  (x1.InBarInspector = function () {
    return (0, f1.jsx)(h1, { children: (e) => (0, f1.jsx)(p1, { ...e }) });
  });
export var y1 = g1;

export var w1 = function (e) {
  return e
    .toLowerCase()
    .replace(/([-_][a-z])/g, (e) =>
      e.toUpperCase().replace("-", "").replace("_", "")
    );
};

export function _1({
  items: e,
  renderCollapsableContent: t,
  useBannerCards: n = false,
  backgroundType: s,
  queryActiveSelection: i,
  isDisabled: o,
}) {
  const r = n ? fk : hk;
  return (0, S1.jsx)("div", {
    className: (0, k1.default)(C1, { [j1]: n }),
    children: e.map((e, n) => {
      const a = !!i && i(e, n);
      return (0, S1.jsxs)(
        "div",
        {
          "data-id": e.id,
          children: [
            (0, S1.jsx)(r, {
              backgroundImage: e.uri,
              backgroundType: s,
              onClick: e.onClick || aV,
              "aria-label": e.ariaLabel,
              "data-cy": e["data-cy"] || e.id,
              isActive: a,
              isDisabled: o || e.isDisabled,
              children: e.label && (0, S1.jsx)(fk.Label, { children: e.label }),
            }),
            (0, S1.jsx)(
              DynamicPresenceTransition,
              { children: a && t && t(e) },
              `${e.id}-collapsable`
            ),
          ],
        },
        e.id
      );
    }),
  });
}
_1.defaultProps = { withBackground: true };
export var E1 = _1;

export var P1 = {
  effects: [
    "//ly.img.ubq/effect/pixelize",
    "//ly.img.ubq/effect/radial_pixel",
    "//ly.img.ubq/effect/cross_cut",
    "//ly.img.ubq/effect/liquid",
    "//ly.img.ubq/effect/outliner",
    "//ly.img.ubq/effect/dot_pattern",
    "//ly.img.ubq/effect/posterize",
    "//ly.img.ubq/effect/tv_glitch",
    "//ly.img.ubq/effect/half_tone",
    "//ly.img.ubq/effect/linocut",
    "//ly.img.ubq/effect/shifter",
    "//ly.img.ubq/effect/mirror",
    "//ly.img.ubq/effect/glow",
    "//ly.img.ubq/effect/vignette",
    "//ly.img.ubq/effect/tilt_shift",
    "//ly.img.ubq/effect/extrude_blur",
    "//ly.img.ubq/effect/sharpie",
    "//ly.img.ubq/effect/recolor",
    "//ly.img.ubq/effect/green_screen",
  ],
  filters: [
    "//ly.img.ubq/effect/lut_filter",
    "//ly.img.ubq/effect/duotone_filter",
  ],
  adjustments: ["//ly.img.ubq/effect/adjustments"],
};
export var A1 = ["filters", "adjustments", "effects"].reduce(
  (e, t) => (
    P1[t].forEach((n) => {
      e[n] = t;
    }),
    e
  ),
  {}
);
export var B1 = {
  "effect/pixelize/horizontalPixelSize": {
    min: 5,
    max: 50,
    step: 1,
    defaultValue: 20,
  },
  "effect/pixelize/verticalPixelSize": {
    min: 5,
    max: 50,
    step: 1,
    defaultValue: 20,
  },
  "effect/radial_pixel/radius": {
    min: 0.05,
    max: 1,
    step: 0.01,
    defaultValue: 0.1,
  },
  "effect/radial_pixel/segments": {
    min: 0.01,
    max: 1,
    step: 0.01,
    defaultValue: 0.01,
  },
  "effect/cross_cut/slices": { min: 1, max: 10, step: 1, defaultValue: 5 },
  "effect/cross_cut/offset": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0.07,
  },
  "effect/cross_cut/speedV": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0.5,
  },
  "effect/cross_cut/time": { min: 0, max: 1, step: 0.01, defaultValue: 1 },
  "effect/liquid/amount": { min: 0, max: 1, step: 0.01, defaultValue: 0.06 },
  "effect/liquid/scale": { min: 0, max: 1, step: 0.01, defaultValue: 0.62 },
  "effect/liquid/time": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "effect/outliner/amount": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "effect/outliner/passthrough": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0.5,
  },
  "effect/dot_pattern/dots": { min: 1, max: 80, step: 1, defaultValue: 30 },
  "effect/dot_pattern/size": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0.5,
  },
  "effect/dot_pattern/blur": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0.3,
  },
  "effect/posterize/levels": { min: 1, max: 15, step: 1, defaultValue: 3 },
  "effect/tv_glitch/distortion": {
    min: 0,
    max: 10,
    step: 0.1,
    defaultValue: 3,
  },
  "effect/tv_glitch/distortion2": {
    min: 0,
    max: 5,
    step: 0.05,
    defaultValue: 1,
  },
  "effect/tv_glitch/speed": { min: 0, max: 5, step: 0.05, defaultValue: 2 },
  "effect/tv_glitch/rollSpeed": {
    min: 0,
    max: 3,
    step: 0.1,
    defaultValue: 1,
  },
  "effect/half_tone/angle": { min: 0, max: 1, step: 0.01, defaultValue: 0 },
  "effect/half_tone/scale": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "effect/linocut/scale": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "effect/shifter/amount": { min: 0, max: 1, step: 0.01, defaultValue: 0.05 },
  "effect/shifter/angle": { min: 0, max: 6.3, step: 0.1, defaultValue: 0.3 },
  "effect/mirror/side": { min: 0, max: 3, step: 1, defaultValue: 1 },
  "effect/glow/size": { min: 0, max: 10, step: 0.1, defaultValue: 4 },
  "effect/glow/amount": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "effect/glow/darkness": { min: 0, max: 1, step: 0.01, defaultValue: 0.3 },
  "effect/vignette/offset": { min: 0, max: 5, step: 0.05, defaultValue: 1 },
  "effect/vignette/darkness": { min: 0, max: 1, step: 0.01, defaultValue: 1 },
  "effect/tilt_shift/amount": {
    min: 0,
    max: 0.02,
    step: 0.001,
    defaultValue: 0.016,
  },
  "effect/tilt_shift/position": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0.4,
  },
  "uniform_blur/intensity": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "effect/extrude_blur/amount": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0.2,
  },
  "effect/adjustments/brightness": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/saturation": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/contrast": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/gamma": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/clarity": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/exposure": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/shadows": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/highlights": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/blacks": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/whites": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/temperature": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/adjustments/sharpness": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/duotone_filter/intensity": {
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: 0,
  },
  "effect/lut_filter/intensity": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 1,
  },
  "effect/recolor/fromColor": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0,
    includeAlpha: false,
  },
  "effect/recolor/toColor": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0,
    includeAlpha: false,
  },
  "effect/green_screen/fromColor": {
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: 0,
    includeAlpha: false,
  },
  "blur/uniform/intensity": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "blur/linear/blurRadius": { min: 0, max: 50, step: 0.5, defaultValue: 30 },
  "blur/linear/x1": { min: 0, max: 1, step: 0.01, defaultValue: 0 },
  "blur/linear/y1": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "blur/linear/x2": { min: 0, max: 1, step: 0.01, defaultValue: 1 },
  "blur/linear/y2": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "blur/mirrored/blurRadius": { min: 0, max: 100, step: 1, defaultValue: 30 },
  "blur/mirrored/gradientSize": {
    min: 0,
    max: 100,
    step: 1,
    defaultValue: 50,
  },
  "blur/mirrored/size": { min: 0, max: 100, step: 1, defaultValue: 75 },
  "blur/mirrored/x1": { min: 0, max: 1, step: 0.01, defaultValue: 0 },
  "blur/mirrored/y1": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "blur/mirrored/x2": { min: 0, max: 1, step: 0.01, defaultValue: 1 },
  "blur/mirrored/y2": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "blur/radial/blurRadius": { min: 0, max: 100, step: 1, defaultValue: 30 },
  "blur/radial/gradientRadius": {
    min: 0,
    max: 100,
    step: 1,
    defaultValue: 50,
  },
  "blur/radial/radius": { min: 0, max: 100, step: 1, defaultValue: 75 },
  "blur/radial/x": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
  "blur/radial/y": { min: 0, max: 1, step: 0.01, defaultValue: 0.5 },
};
export var T1 = { min: 0, max: 1, step: 0.01 };
export function M1(e) {
  return B1[e] ?? T1;
}
export var O1 = new Map([
  [
    "//ly.img.ubq/effect/recolor",
    new Map(
      [
        "effect/recolor/fromColor",
        "effect/recolor/colorMatch",
        "effect/recolor/brightnessMatch",
        "effect/recolor/smoothness",
        "effect/recolor/toColor",
      ].map((e, t) => [e, t])
    ),
  ],
  [
    "//ly.img.ubq/effect/green_screen",
    new Map(
      [
        "effect/green_screen/fromColor",
        "effect/green_screen/colorMatch",
        "effect/green_screen/smoothness",
        "effect/green_screen/spill",
      ].map((e, t) => [e, t])
    ),
  ],
]);
export var R1 = new RegExp("//ly.img.ubq/effect/(.*)");
export var V1 = new RegExp("//ly.img.ubq/blur/(.*)");
export var D1 = (e) => (t) => {
  const n = t.match(e);
  return n ? n[1] : t;
};
export var F1 = D1(R1);
export var I1 = D1(V1);

export var N1 = {
  show: {
    height: "auto",
    opacity: 1,
    marginTop: "var(--ubq-margin-m)",
    overflow: "visible",
  },
  hide: { height: 0, opacity: 0, marginTop: 0, overflow: "hidden" },
};
export function U1(e, t, n) {
  return e(`property.blur.${w1(I1(t))}Blur.${n.split("/").pop()}`);
}
export var z1 = function ({ blurId: e, blurType: t }) {
  const { t: n } = ZL(),
    s = YF(),
    i = (0, L1.useMemo)(() => {
      const n = QK(t);
      return s.block.findAllProperties(e).filter((e) => e.startsWith(n));
    }, [s.block, e, t]);
  return (0, H1.jsx)(Sd.div, {
    variants: N1,
    initial: "hide",
    animate: "show",
    exit: "hide",
    children: i.map((s) =>
      (0, H1.jsx)(
        Yk,
        {
          "data-cy": "slider-input-row",
          children: (0, H1.jsx)(rG, {
            label: U1(n, t, s),
            property: s,
            block: e,
            centeredZeroPosition: false,
            ...M1(s),
          }),
        },
        s
      )
    ),
  });
};

export function q1(e, t) {
  return e(`property.blur.${w1(I1(t))}Blur`);
}
export var Q1, G1;
export var Z1 = function ({
  blurId: e,
  setBlur: t,
  removeBlur: n,
  blurType: s,
}) {
  const { t: i } = ZL(),
    o = YF(),
    r = FI(),
    a = (0, v1.useRef)(null),
    l = ov(t),
    c = ov(n),
    u = oD(),
    [d] = possibleHook3(u.assetSourceIdsChannel),
    { data: p } = GF(
      ["asset-sources", "ly.img.blur"],
      () => o.asset.findAssets("ly.img.blur", { page: 0, perPage: 1e3 }),
      { enabled: d.includes("ly.img.blur") }
    ),
    f = (0, v1.useMemo)(
      () =>
        p?.assets
          .filter((e) => e.meta?.blurType)
          .map((e) => {
            const t = e.meta?.blurType;
            return {
              id: t,
              "data-cy": `blur-${t}`,
              label: q1(i, t),
              uri: `${r.ui.baseURL}blur/${I1(t)}.jpeg`,
              onClick: () => {
                if (s === t) c();
                else {
                  const e = o.block.createBlur(t);
                  l(e);
                }
              },
            };
          }) ?? [],
      [s, r.ui.baseURL, p?.assets, o.block, c, l, i]
    );
  return (0, $1.jsx)("div", {
    ref: a,
    children: (0, $1.jsx)(E1, {
      useBannerCards: true,
      items: f,
      renderCollapsableContent: ({ id: t }) =>
        e ? (0, $1.jsx)(z1, { blurId: e, blurType: t }) : null,
      queryActiveSelection: ({ id: e }) => e === s,
    }),
  });
};

export var t2 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO().feature.isEnabled("ly.img.blur", { engine: e }),
      { blocks: s } = YR(),
      [i] = e.block.findAllSelected();
    if (null == i) return null;
    const o = e.block.getType(i),
      r = e.block.hasBlur(i),
      a = s[o];
    return !(!a || !("blurEnabled" in a)) && a.blurEnabled && r && n
      ? t({ block: i })
      : null;
  })
);
export var n2 = WithEngineComp(function ({ engine: e, block: t }) {
  const { t: n } = ZL(),
    s = IV(),
    i = e.block.isAllowedByScope(t, vH),
    o =
      e.block.isValid(t) && e.block.hasBlur(t) ? e.block.getBlur(t) : undefined,
    r = null != o && e.block.isValid(o),
    a = !!r && e.block.isBlurEnabled(t),
    l = r ? e.block.getType(o) : undefined,
    c = l ? q1(n, l) : n("common.select"),
    u = () => {
      o && e.block.destroy(o);
    };
  return (0, e2.jsxs)(e2.Fragment, {
    children: [
      (0, e2.jsx)(WQ.Header, {
        action:
          null != t
            ? (0, e2.jsxs)(e2.Fragment, {
                children: [
                  (0, e2.jsxs)(CompCustomButton, {
                    name: "reset",
                    onClick: () => {
                      u(), s("action.property.reset");
                    },
                    "aria-label": n("common.reset"),
                    "data-cy": "reset-blur-subInspector",
                    variant: "plain",
                    isDisabled: !r || !i,
                    children: [n("common.reset"), (0, e2.jsx)(FG, {})],
                  }),
                  (0, e2.jsx)(NK, {
                    label: c,
                    isEnabled: a,
                    toggleProperty: () => {
                      r && e.block.setBlurEnabled(t, !a);
                    },
                    isDisabled: !i || !r,
                    "data-cy": "propertyToggle-blur",
                  }),
                ],
              })
            : null,
        children: (0, e2.jsx)(WQ.Title, { children: n("input.blur") }),
      }),
      (0, e2.jsx)(WQ.Content, {
        children: (0, e2.jsx)("div", {
          className: Y1,
          "data-cy": "subInspector_scroll_content_wrapper",
          children: (0, e2.jsx)(Z1, {
            blurId: o,
            blurType: l,
            setBlur: (n) => {
              e.block.setBlur(t, n), s("action.image.blur");
            },
            removeBlur: u,
          }),
        }),
      }),
    ],
  });
});
export var s2 = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    block: t,
    inBar: n = false,
    deniedByScopeBehavior: s = "disable",
  }) {
    const { t: i } = ZL(),
      o = VO(),
      r = XR(),
      [a] = BQ("//ly.img.panel/inspector/blur", r);
    function l() {
      a
        ? o.ui.closePanel("//ly.img.panel/inspector/blur")
        : o.ui.openPanel("//ly.img.panel/inspector/blur");
    }
    const c = e.block.isAllowedByScope(t, vH);
    if (!c && "hide" === s) return null;
    const u = e.block.getBlur(t),
      d = e.block.isValid(u),
      p = !!d && e.block.isBlurEnabled(t),
      f = d ? e.block.getType(u) : undefined,
      h = f ? q1(i, f) : i("common.select"),
      m = (!!d && !p) || !c,
      g = i("input.blur");
    return n
      ? (0, e2.jsx)(Ly, {
          label: i("input.blur.tooltip"),
          children: (0, e2.jsx)(CompCustomButton, {
            name: g,
            variant: a ? "regular" : "plain",
            icon: (0, e2.jsxs)(Gb, {
              className: (0, W1.default)(X1, { [J1]: d && !p }),
              children: [(0, e2.jsx)(yY, {}), d && !p && (0, e2.jsx)(Yb, {})],
            }),
            isActive: d,
            activeStateStyle: "pill",
            onClick: l,
            isDisabled: !c,
            "data-cy": "blur",
            children: g,
          }),
        })
      : (0, e2.jsxs)(Yk, {
          children: [
            (0, e2.jsx)(Sv, { isDisabled: m, children: g }),
            (0, e2.jsx)(Ly, {
              label: i("input.blur.tooltip"),
              children: (0, e2.jsxs)(CompCustomButton, {
                name: g,
                variant: "regular",
                icon: (0, e2.jsx)(yY, {}),
                isActive: d,
                activeStateStyle: "pill",
                onClick: l,
                isDisabled: m,
                "data-cy": "blur",
                children: [h, (0, e2.jsx)(zq, {})],
              }),
            }),
            d
              ? (0, e2.jsx)(NK, {
                  label: h,
                  isEnabled: p,
                  toggleProperty: () => {
                    d && e.block.setBlurEnabled(t, !p);
                  },
                  isDisabled: !c || !d,
                  "data-cy": "propertyToggle-blur",
                })
              : (0, e2.jsx)(zK, {}),
          ],
        });
  })
);
((G1 = Q1 || (Q1 = {})).SupportGuard = t2),
  (G1.PanelContent = n2),
  (G1.Control = function (e) {
    return (0, e2.jsx)(t2, {
      children: ({ block: t }) => (0, e2.jsx)(s2, { block: t, ...e }),
    });
  });
export var i2 = Q1;

export var l2 = [
  "effect/adjustments/brightness",
  "effect/adjustments/saturation",
  "effect/adjustments/contrast",
  "effect/adjustments/gamma",
];
export var c2 = [
  "effect/adjustments/clarity",
  "effect/adjustments/exposure",
  "effect/adjustments/shadows",
  "effect/adjustments/highlights",
  "effect/adjustments/blacks",
  "effect/adjustments/whites",
  "effect/adjustments/temperature",
  "effect/adjustments/sharpness",
];
export var u2 = l2.concat(c2);
export function d2(e, t) {
  return e(`property.adjustments.${t.split("/").pop()}`);
}
export var p2 = function ({ effectId: e }) {
  const { t: t } = ZL();
  return (0, a2.jsxs)(a2.Fragment, {
    children: [
      (0, a2.jsx)(AJ, {
        title: t("input.adjustments.basic"),
        children: l2.map((n) =>
          (0, a2.jsx)(
            Yk,
            {
              "data-cy": "slider-input-row",
              children: (0, a2.jsx)(rG, {
                label: d2(t, n),
                block: e,
                property: n,
                ...M1(n),
              }),
            },
            n
          )
        ),
      }),
      (0, a2.jsx)(AJ, {
        title: t("input.adjustments.refinements"),
        children: c2.map((n) =>
          (0, a2.jsx)(
            Yk,
            {
              "data-cy": "slider-input-row",
              children: (0, a2.jsx)(rG, {
                label: d2(t, n),
                block: e,
                property: n,
                ...M1(n),
              }),
            },
            n
          )
        ),
      }),
    ],
  });
};

export var h2 = class _Effect {
  constructor(e, t, n, s, i, o, r) {
    (this.id = e),
      (this.slotIndex = t),
      (this.effectStackIndex = n),
      (this.effectGroup = s),
      (this.effectId = i),
      (this.effectType = o),
      (this.isPlaceholder = r);
  }
  static Slot(e, t, n, s, i) {
    return new _Effect(s.toString(), e, t, n, s, i, false);
  }
  static Placeholder(e, t, n, s) {
    return new _Effect(
      s?.toString() ?? Math.random().toString(36).substring(2, 9),
      e,
      t,
      n,
      undefined,
      undefined,
      true
    );
  }
};
export function m2(e) {
  const t = YF(),
    n = IV(),
    s = (0, f2.useRef)([]),
    i = eI(t, () => t.block.getEffects(e)),
    o = (0, f2.useMemo)(() => {
      const e = (function (e, t) {
        const n = { filters: [], adjustments: [], effects: [] };
        return (
          t.forEach((t, s) => {
            const i = e.block.getType(t),
              o = A1[i];
            if (!o) return;
            const r = h2.Slot(n[o].length, s, o, t, i);
            n[o].push(r);
          }),
          n
        );
      })(t, i);
      return (
        (s.current = s.current.filter(
          (e) => i[e.effectStackIndex]?.toString() !== e.id
        )),
        s.current.length &&
          s.current.forEach((t) => {
            e[t.effectGroup] = [
              ...e[t.effectGroup].slice(0, t.slotIndex),
              t,
              ...e[t.effectGroup]
                .slice(t.slotIndex)
                .map((e) => ({ ...e, slotIndex: e.slotIndex + 1 })),
            ];
          }),
        {
          filters:
            e.filters.length > 0
              ? e.filters
              : [h2.Placeholder(0, i.length, "filters")],
          adjustments:
            e.adjustments.length > 0
              ? e.adjustments
              : [h2.Placeholder(0, i.length, "adjustments")],
          effects:
            e.effects.length > 0
              ? e.effects
              : [h2.Placeholder(0, i.length, "effects")],
        }
      );
    }, [t, i, s]),
    r = (0, f2.useCallback)(
      (r, a) => {
        if (a.isPlaceholder) {
          s.current = s.current.filter((e) => e.id !== a.id);
          let n = Math.min(a.effectStackIndex, i.length);
          for (const e of o[a.effectGroup].slice(a.slotIndex))
            if (!e.isPlaceholder) {
              n = e.effectStackIndex;
              break;
            }
          t.block.insertEffect(e, r, n);
        } else
          t.block.removeEffect(e, a.effectStackIndex),
            t.block.insertEffect(e, r, a.effectStackIndex);
        "effects" === a.effectGroup && n("action.effect.add"),
          "filters" === a.effectGroup && n("action.filter.add");
      },
      [t.block, e, o, i.length, n]
    ),
    a = (0, f2.useCallback)(
      (i) => {
        if (i.isPlaceholder) return;
        if (o[i.effectGroup].length > 1) {
          const e = h2.Placeholder(
            i.slotIndex,
            i.effectStackIndex,
            i.effectGroup,
            i.effectId
          );
          s.current = [...s.current, e].sort(
            (e, t) => e.slotIndex - t.slotIndex
          );
        }
        t.block.removeEffect(e, i.effectStackIndex),
          "effects" === i.effectGroup && n("action.effect.remove"),
          "filters" === i.effectGroup && n("action.filter.remove");
      },
      [t.block, e, o, n]
    );
  return {
    filters: o.filters,
    adjustments: o.adjustments,
    effects: o.effects,
    insertEffect: r,
    removeEffect: a,
  };
}
export var g2, x2;

export var y2 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO().feature.isEnabled("ly.img.adjustment", { engine: e }),
      { blocks: s } = YR(),
      [i] = e.block.findAllSelected();
    if (null == i) return null;
    const o = e.block.getType(i),
      r = e.block.hasEffects(i),
      a = s[o];
    return !(!a || !("adjustmentsEnabled" in a)) &&
      a.adjustmentsEnabled &&
      r &&
      n
      ? t({ block: i })
      : null;
  })
);
export var v2 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, block: t, effectId: n }) {
    const { t: s } = ZL(),
      i = IV(),
      o = DO(),
      { adjustments: r, insertEffect: a, removeEffect: l } = m2(t),
      c = e.block.isAllowedByScope(t, xH),
      u = e.block.isAllowedByScope(t, yH),
      d = r.find((e) => e.effectId === n) ?? r[0],
      p = XR(),
      [f] = BQ("//ly.img.panel/inspector/adjustments", p);
    (0, r2.useEffect)(() => {
      if (f && null != d && null == d?.effectId) {
        const t = e.block.createEffect("//ly.img.ubq/effect/adjustments");
        a(t, d);
      } else if (!f && null != d?.effectId) {
        u2.some((t) => 0 !== e.block.getFloat(d.effectId, t)) || l(d);
      }
    }, [d, e.block, a, f, l]);
    const [h, m] = (0, r2.useState)(false),
      [g, x] = (0, r2.useState)(() => C2(s, e, n)),
      b = (0, r2.useCallback)(() => {
        const t =
          null != d?.effectId &&
          e.block.isValid(d.effectId) &&
          u2.some((t) => 0 !== e.block.getFloat(d.effectId, t));
        m(t);
      }, [d?.effectId, e.block]),
      y = (0, r2.useCallback)(() => {
        const t = C2(s, e, n);
        x(t);
      }, [n, e, s]);
    HV("action.property.update", () => {
      b(), y();
    }),
      HV("action.property.reset", () => {
        b(), y();
      }),
      (0, r2.useEffect)(
        () => (
          b(),
          o.getHistoryStateEmitter().addGlobalListener((e) => {
            e.some(({ event: e }) => "undo" === e || "redo" === e) &&
              (b(), y());
          })
        ),
        [o, b, y]
      );
    const v = null != d?.effectId && e.block.isValid(d.effectId),
      w = v && e.block.isEffectEnabled(d.effectId);
    return (0, b2.jsxs)(b2.Fragment, {
      children: [
        (0, b2.jsx)(WQ.Header, {
          action:
            null != t
              ? (0, b2.jsxs)(b2.Fragment, {
                  children: [
                    (0, b2.jsxs)(CompCustomButton, {
                      name: "reset",
                      onClick: () => {
                        d?.effectId &&
                          (u2.forEach((t) => {
                            e.block.setFloat(d.effectId, t, 0);
                          }),
                          i("action.property.reset"));
                      },
                      "aria-label": s("common.reset"),
                      "data-cy": "reset-adjustments-subInspector",
                      variant: "plain",
                      isDisabled: !h || !c || !u,
                      children: [s("common.reset"), (0, b2.jsx)(FG, {})],
                    }),
                    (0, b2.jsx)(NK, {
                      label: g,
                      isEnabled: w,
                      toggleProperty: () => {
                        v && e.block.setEffectEnabled(d.effectId, !w);
                      },
                      isDisabled: !c || !u || !h,
                      "data-cy": "propertyToggle-adjustments",
                    }),
                  ],
                })
              : null,
          children: (0, b2.jsx)(WQ.Title, {
            children: s("input.adjustments"),
          }),
        }),
        (0, b2.jsx)(WQ.Content, {
          children: v ? (0, b2.jsx)(p2, { effectId: d.effectId }) : null,
        }),
      ],
    });
  })
);
export var w2 = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    effectId: t,
    block: n,
    inBar: s = false,
    deniedByScopeBehavior: i = "disable",
  }) {
    const { t: o } = ZL(),
      r = VO(),
      a = DO(),
      l = XR(),
      [c] = BQ("//ly.img.panel/inspector/adjustments", l);
    function u() {
      c
        ? r.ui.closePanel("//ly.img.panel/inspector/adjustments")
        : r.ui.openPanel("//ly.img.panel/inspector/adjustments", {
            payload: { effectId: t },
          });
    }
    const d = e.block.isAllowedByScope(n, xH),
      p = e.block.isAllowedByScope(n, yH),
      [f, h] = (0, r2.useState)(false),
      [m, g] = (0, r2.useState)(() => C2(o, e, t)),
      x = (0, r2.useCallback)(() => {
        const n =
          null != t &&
          e.block.isValid(t) &&
          u2.some((n) => 0 !== e.block.getFloat(t, n));
        h(n);
      }, [t, e.block]),
      b = (0, r2.useCallback)(() => {
        g(C2(o, e, t));
      }, [t, e, o]);
    if (
      (HV("action.property.update", () => {
        x(), b();
      }),
      HV("action.property.reset", () => {
        x(), b();
      }),
      (0, r2.useEffect)(
        () => (
          g(C2(o, e, t)),
          x(),
          a.getHistoryStateEmitter().addGlobalListener((e) => {
            e.some(({ event: e }) => "undo" === e || "redo" === e) &&
              (x(), b());
          })
        ),
        [t, e, a, o, x, b]
      ),
      !((d && p) || "hide" !== i))
    )
      return null;
    const y = null != t && e.block.isValid(t),
      v = y && e.block.isEffectEnabled(t),
      w = (!!t && !v) || !d || !p,
      k = o("input.adjustments");
    return s
      ? (0, b2.jsx)(Ly, {
          label: o("input.adjustments.tooltip"),
          children: (0, b2.jsx)(CompCustomButton, {
            name: k,
            variant: c ? "regular" : "plain",
            icon: (0, b2.jsxs)(Gb, {
              className: (0, o2.default)(X1, { [J1]: y && !v }),
              children: [(0, b2.jsx)(mY, {}), y && !v && (0, b2.jsx)(Yb, {})],
            }),
            isActive: f,
            activeStateStyle: "pill",
            onClick: u,
            isDisabled: !d || !p,
            "data-cy": "adjustments",
            children: k,
          }),
        })
      : (0, b2.jsxs)(Yk, {
          children: [
            (0, b2.jsx)(Sv, { isDisabled: w, children: k }),
            (0, b2.jsx)(Ly, {
              label: o("input.adjustments.tooltip"),
              children: (0, b2.jsxs)(CompCustomButton, {
                name: k,
                variant: "regular",
                icon: (0, b2.jsx)(mY, {}),
                isActive: y,
                activeStateStyle: "pill",
                onClick: u,
                isDisabled: w,
                "data-cy": "adjustments",
                children: [m, (0, b2.jsx)(zq, {})],
              }),
            }),
            null != t
              ? (0, b2.jsx)(NK, {
                  label: m,
                  isEnabled: v,
                  toggleProperty: () => {
                    y && e.block.setEffectEnabled(t, !v);
                  },
                  isDisabled: !d || !p || !f,
                  "data-cy": "propertyToggle-adjustments",
                })
              : (0, b2.jsx)(zK, {}),
          ],
        });
  })
);
export function k2({ block: e, ...t }) {
  const { adjustments: n } = m2(e);
  return (0, b2.jsx)(b2.Fragment, {
    children: n.map((n) =>
      (0, b2.jsx)(w2, { effectId: n.effectId, block: e, ...t }, n.slotIndex)
    ),
  });
}
export function C2(e, t, n) {
  if (null == n || !t.block.isValid(n)) return e("common.select");
  const s = u2.filter((e) => 0 !== t.block.getFloat(n, e));
  switch (s.length) {
    case 0:
      return e("common.select");
    case 1:
      return d2(e, s[0]);
    default:
      return e("common.mixed");
  }
}
((x2 = g2 || (g2 = {})).SupportGuard = y2),
  (x2.PanelContent = v2),
  (x2.ControlStack = function (e) {
    return (0, b2.jsx)(y2, {
      children: ({ block: t }) => (0, b2.jsx)(k2, { block: t, ...e }),
    });
  });
export var j2 = g2;

export var E2 = (e, t = ".") =>
  e
    .split(t)
    .reduce(
      (e, t) => (0 === e.length ? [t] : (e.push(`${e[e.length - 1]}.${t}`), e)),
      []
    )
    .reverse();
export var L2 = ({ i18nKey: e, selectedElementType: t }) => {
  const n = E2(t.replace(/^\/\/ly\.img\.[^/]+\//, ""), "/").map(
    (t) => `component.inspector.${t}.${e}.label`
  );
  return (
    n.push(`component.inspector.${e}.label`), n.push(`${e}.label`), n.push(e), n
  );
};
export var P2 = (e, { title: t, i18nKey: n }, s) =>
  t ||
  (n
    ? e(L2({ i18nKey: n, selectedElementType: s }), { defaultValue: null })
    : undefined);

export var B2 = {
  show: {
    height: "auto",
    opacity: 1,
    marginTop: "var(--ubq-margin-m)",
    overflow: "visible",
  },
  hide: { height: 0, opacity: 0, marginTop: 0, overflow: "hidden" },
};
export var T2 = function ({ effectId: e, property: t }) {
  const { t: n } = ZL();
  return (0, A2.jsx)(Sd.div, {
    variants: B2,
    initial: "hide",
    animate: "show",
    exit: "hide",
    children: (0, A2.jsx)(Yk, {
      "data-cy": "slider-input-row",
      children: (0, A2.jsx)(rG, {
        label: n("property.duoToneFilterIntensity"),
        block: e,
        property: t,
        centeredZeroPosition: false,
        ...M1(t),
      }),
    }),
  });
};

export function O2({
  insertEffect: e,
  removeEffect: t,
  currentDuotoneFilter: n,
  assets: s,
}) {
  const { t: i } = ZL(),
    o = YF(),
    r = (0, _2.useMemo)(
      () =>
        s.map((s) => {
          const r = s.meta ? s.meta.thumbUri : "",
            a = o.editor.getAbsoluteURI(r);
          return {
            id: `${s.context.sourceId}.${s.id}`,
            "data-cy": `filter-${s.id}`,
            label: V2(i, s.id),
            uri: a,
            onClick() {
              if (s.id === n?.asset.id) t();
              else {
                const t = o.block.createEffect(
                    "//ly.img.ubq/effect/duotone_filter"
                  ),
                  n = kb(s.meta?.darkColor);
                o.block.setColorRGBA(
                  t,
                  "effect/duotone_filter/darkColor",
                  n.r,
                  n.g,
                  n.b,
                  n.a
                );
                const i = kb(s.meta?.lightColor);
                o.block.setColorRGBA(
                  t,
                  "effect/duotone_filter/lightColor",
                  i.r,
                  i.g,
                  i.b,
                  i.a
                ),
                  e(t);
              }
            },
          };
        }),
      [o.block, o.editor, s, n?.asset.id, e, t, i]
    );
  return (0, M2.jsx)(E1, {
    useBannerCards: true,
    items: r,
    renderCollapsableContent: () =>
      n?.effectId
        ? (0, M2.jsx)(T2, {
            effectId: n.effectId,
            property: "effect/duotone_filter/intensity",
          })
        : null,
    queryActiveSelection: ({ id: e }) =>
      e === `${n?.asset.context.sourceId}.${n?.asset.id}`,
  });
}
export function R2({
  insertEffect: e,
  removeEffect: t,
  currentLutFilter: n,
  assets: s,
}) {
  const { t: i } = ZL(),
    o = YF(),
    r = (0, _2.useMemo)(
      () =>
        s.map((s) => {
          const r = s.meta ? s.meta.thumbUri : "",
            a = o.editor.getAbsoluteURI(r);
          return {
            id: `${s.context.sourceId}.${s.id}`,
            "data-cy": `filter-${s.id}`,
            label: V2(i, s.id),
            uri: a,
            onClick() {
              if (s.id === n?.asset.id) t();
              else {
                const t = o.block.createEffect(
                  "//ly.img.ubq/effect/lut_filter"
                );
                o.block.setString(
                  t,
                  "effect/lut_filter/lutFileURI",
                  s.meta?.uri
                ),
                  o.block.setInt(
                    t,
                    "effect/lut_filter/horizontalTileCount",
                    parseInt(s.meta?.horizontalTileCount, 10)
                  ),
                  o.block.setInt(
                    t,
                    "effect/lut_filter/verticalTileCount",
                    parseInt(s.meta?.verticalTileCount, 10)
                  ),
                  e(t);
              }
            },
          };
        }),
      [o.block, o.editor, s, n?.asset.id, e, t, i]
    );
  return (0, M2.jsx)(E1, {
    useBannerCards: true,
    items: r,
    renderCollapsableContent: () =>
      n?.effectId
        ? (0, M2.jsx)(T2, {
            effectId: n.effectId,
            property: "effect/lut_filter/intensity",
          })
        : null,
    queryActiveSelection: ({ id: e }) =>
      e === `${n?.asset.context.sourceId}.${n?.asset.id}`,
  });
}
export function V2(e, t) {
  return e(
    `property.${(function (e) {
      const t = e.slice(e.lastIndexOf(".") + 1),
        [n, s] = t.split("/");
      return `${n}Filter.${s}`;
    })(t)}`
  );
}
export var D2 = function ({
  filter: e,
  duotoneAssets: t,
  lutAssets: n,
  insertEffect: s,
  removeEffect: i,
}) {
  const o = (0, _2.useRef)(!!e),
    r = (0, _2.useRef)(null),
    a = ov(s),
    l = ov(i),
    c = "//ly.img.ubq/effect/duotone_filter" === e?.effectType ? e : undefined,
    u = "//ly.img.ubq/effect/lut_filter" === e?.effectType ? e : undefined;
  return (
    (0, _2.useEffect)(() => {
      if (!e?.effectId || !r.current || !o.current) return;
      const t = r.current.querySelector(
          `[data-id="${e.asset.context.sourceId}.${e.asset.id}"]`
        ),
        n = t?.closest('[data-cy="subInspector_scroll_container"]');
      t &&
        n &&
        ((n.scrollTop = t.offsetTop - t.scrollHeight), (o.current = false));
    }, [e?.asset.context.sourceId, e?.asset.id, e?.effectId]),
    (0, M2.jsxs)("div", {
      ref: r,
      children: [
        (0, M2.jsx)(O2, {
          currentDuotoneFilter: c,
          assets: t,
          insertEffect: a,
          removeEffect: l,
        }),
        (0, M2.jsx)(R2, {
          currentLutFilter: u,
          assets: n,
          insertEffect: a,
          removeEffect: l,
        }),
      ],
    })
  );
};

export var H2, N2;
export var U2 = function () {
  const e = YF(),
    [t, n] = (0, I2.useState)(() => e.asset.findAllSources());
  return (
    (0, I2.useEffect)(() => {
      function t() {
        n(e.asset.findAllSources());
      }
      const s = e.asset.onAssetSourceAdded(t),
        i = e.asset.onAssetSourceRemoved(t);
      return () => {
        s(), i();
      };
    }, [e.asset]),
    t
  );
};

export var $2 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO().feature.isEnabled("ly.img.filter", { engine: e }),
      { blocks: s } = YR(),
      [i] = e.block.findAllSelected();
    if (null == i) return null;
    const o = e.block.getType(i),
      r = e.block.hasEffects(i),
      a = s[o];
    return !(!a || !("filtersEnabled" in a)) && a.filtersEnabled && r && n
      ? t({ block: i })
      : null;
  })
);
export var q2 = WithEngineComp(function ({ engine: e, effectId: t, block: n }) {
  const { t: s } = ZL(),
    i = IV(),
    { filters: o, insertEffect: r, removeEffect: a } = m2(n),
    l = o.find((e) => e.effectId === t) ?? o[0],
    c = e.block.isAllowedByScope(n, bH),
    u = e.block.isAllowedByScope(n, yH),
    {
      duotoneAssetQuery: d,
      lutAssetQuery: p,
      currentFilter: f,
    } = G2(l?.effectId),
    h = f?.asset.id ? V2(s, f.asset.id) : s("common.select"),
    m = !!l?.effectId && e.block.isEffectEnabled(l.effectId);
  return (0, z2.jsxs)(z2.Fragment, {
    children: [
      (0, z2.jsx)(WQ.Header, {
        action:
          null != n
            ? (0, z2.jsxs)(z2.Fragment, {
                children: [
                  (0, z2.jsxs)(CompCustomButton, {
                    name: "reset",
                    onClick: () => {
                      l && (a(l), i("action.property.reset"));
                    },
                    "aria-label": s("common.reset"),
                    "data-cy": "reset-filter-subInspector",
                    variant: "plain",
                    isDisabled: null == l?.effectId || !c || !u,
                    children: [s("common.reset"), (0, z2.jsx)(FG, {})],
                  }),
                  (0, z2.jsx)(NK, {
                    label: h,
                    isEnabled: m,
                    toggleProperty: () => {
                      l?.effectId && e.block.setEffectEnabled(l.effectId, !m);
                    },
                    isDisabled: null == l?.effectId || !c || !u,
                    "data-cy": "propertyToggle-filter",
                  }),
                ],
              })
            : null,
        children: (0, z2.jsx)(WQ.Title, { children: s("input.filter") }),
      }),
      (0, z2.jsx)(WQ.Content, {
        children: (0, z2.jsx)("div", {
          className: Y1,
          "data-cy": "subInspector_scroll_content_wrapper",
          children:
            d.isSuccess && p.isSuccess
              ? (0, z2.jsx)(D2, {
                  filter: f,
                  duotoneAssets: d.data.assets,
                  lutAssets: p.data.assets,
                  insertEffect: (e) => {
                    l && r(e, l);
                  },
                  removeEffect: () => {
                    l && a(l);
                  },
                })
              : (0, z2.jsx)("div", {
                  className: K1,
                  children: (0, z2.jsx)(Hh, {}),
                }),
        }),
      }),
    ],
  });
});
export var Q2 = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    effectId: t,
    block: n,
    inBar: s = false,
    deniedByScopeBehavior: i = "disable",
  }) {
    const { t: o } = ZL(),
      r = VO(),
      { currentFilter: a } = G2(t),
      l = null != t && e.block.isValid(t),
      c = a?.asset.id ? V2(o, a.asset.id) : o("common.select"),
      u = null != t && e.block.isEffectEnabled(t),
      d = XR(),
      [p] = BQ("//ly.img.panel/inspector/filters", d);
    function f() {
      p
        ? r.ui.closePanel("//ly.img.panel/inspector/filters")
        : r.ui.openPanel("//ly.img.panel/inspector/filters", {
            payload: { effectId: t },
          });
    }
    const h = e.block.isAllowedByScope(n, bH),
      m = e.block.isAllowedByScope(n, yH);
    if (!((h && m) || "hide" !== i)) return null;
    const g = (!!t && !u) || !h || !m,
      x = o("input.filter");
    return s
      ? (0, z2.jsx)(Ly, {
          label: o("input.filter.tooltip"),
          children: (0, z2.jsx)(CompCustomButton, {
            name: x,
            variant: p ? "regular" : "plain",
            icon: (0, z2.jsxs)(Gb, {
              className: (0, F2.default)(X1, { [J1]: l && !u }),
              children: [(0, z2.jsx)(PY, {}), l && !u && (0, z2.jsx)(Yb, {})],
            }),
            isActive: l,
            activeStateStyle: "pill",
            onClick: f,
            isDisabled: !h || !m,
            "data-cy": "filter",
            children: x,
          }),
        })
      : (0, z2.jsxs)(Yk, {
          children: [
            (0, z2.jsx)(Sv, { isDisabled: g, children: x }),
            (0, z2.jsx)(Ly, {
              label: o("input.filter.tooltip"),
              children: (0, z2.jsxs)(CompCustomButton, {
                name: x,
                variant: "regular",
                icon: (0, z2.jsx)(PY, {}),
                isActive: l,
                activeStateStyle: "pill",
                onClick: f,
                isDisabled: g,
                "data-cy": "filter",
                children: [c, (0, z2.jsx)(zq, {})],
              }),
            }),
            null != t
              ? (0, z2.jsx)(NK, {
                  label: c,
                  isEnabled: u,
                  toggleProperty: () => {
                    e.block.setEffectEnabled(t, !u);
                  },
                  isDisabled: null == t || !h || !m,
                  "data-cy": "propertyToggle-filter",
                })
              : (0, z2.jsx)(zK, {}),
          ],
        });
  })
);
export function G2(e) {
  const t = YF(),
    n = U2(),
    s = GF(
      ["asset-sources", "ly.img.filter.duotone"],
      () =>
        t.asset.findAssets("ly.img.filter.duotone", { page: 0, perPage: 1e3 }),
      { enabled: n.includes("ly.img.filter.duotone") }
    ),
    i = GF(
      ["asset-sources", "ly.img.filter.lut"],
      () => t.asset.findAssets("ly.img.filter.lut", { page: 0, perPage: 1e3 }),
      { enabled: n.includes("ly.img.filter.lut") }
    ),
    o = (0, S2.useMemo)(() => {
      if (!e) return;
      const n = t.block.getType(e);
      if ("//ly.img.ubq/effect/duotone_filter" === n) {
        const i = _O(
            t.block.getColorRGBA(e, "effect/duotone_filter/lightColor")
          ),
          o = _O(t.block.getColorRGBA(e, "effect/duotone_filter/darkColor")),
          r = s?.data?.assets.find((e) => {
            const t = kb(e.meta?.lightColor),
              n = kb(e.meta?.darkColor);
            return EO(t, i) && EO(n, o);
          });
        return r && { effectId: e, effectType: n, asset: r };
      }
      if ("//ly.img.ubq/effect/lut_filter" === n) {
        const s = t.block.getString(e, "effect/lut_filter/lutFileURI"),
          o = t.block.getInt(e, "effect/lut_filter/horizontalTileCount"),
          r = t.block.getInt(e, "effect/lut_filter/verticalTileCount"),
          a = i?.data?.assets.find(
            (e) =>
              e.meta?.uri === s &&
              parseInt(e.meta?.horizontalTileCount, 10) === o &&
              parseInt(e.meta?.verticalTileCount, 10) === r
          );
        return a && { effectId: e, effectType: n, asset: a };
      }
    }, [t.block, s, e, i]);
  return { duotoneAssetQuery: s, lutAssetQuery: i, currentFilter: o };
}
export function Z2({ block: e, ...t }) {
  const { filters: n } = m2(e);
  return (0, z2.jsx)(z2.Fragment, {
    children: n.map((n) =>
      (0, z2.jsx)(Q2, { effectId: n.effectId, block: e, ...t }, n.slotIndex)
    ),
  });
}
((N2 = H2 || (H2 = {})).SupportGuard = $2),
  (N2.PanelContent = q2),
  (N2.ControlStack = function (e) {
    return (0, z2.jsx)($2, {
      children: ({ block: t }) => (0, z2.jsx)(Z2, { block: t, ...e }),
    });
  });
export var W2 = H2;

export var J2 = {
  show: {
    height: "auto",
    opacity: 1,
    marginTop: "var(--ubq-margin-m)",
    overflow: "visible",
  },
  hide: { height: 0, opacity: 0, marginTop: 0, overflow: "hidden" },
};
export var e5 = function ({ effectId: e, effectType: t }) {
  const { t: n } = ZL(),
    s = YF(),
    i = (0, Y2.useMemo)(() => {
      const n = QK(t),
        i = s.block.findAllProperties(e).filter((e) => e.startsWith(n));
      return (function (e, t) {
        if (!O1.has(e)) return t;
        const n = O1.get(e);
        return t.sort(
          (e, t) =>
            (n.has(e) ? n.get(e) : 1 / 0) - (n.has(t) ? n.get(t) : 1 / 0)
        );
      })(t, i);
    }, [s, e, t]);
  return (0, X2.jsx)(Sd.div, {
    variants: J2,
    initial: "hide",
    animate: "show",
    exit: "hide",
    children: i.map((i) => {
      const o = s.block.getPropertyType(i),
        r = M1(i),
        [a, l] = (function (e, t, n) {
          const s = w1(F1(t)),
            i = n.split("/").pop(),
            o = `property.effect.${s}.${i}`,
            r = `${o}.description`;
          return [e(o), e(r)];
        })(n, t, i);
      return "Color" === o
        ? (0, X2.jsx)(
            w0.Property,
            {
              panelId: `//ly.img.panel/inspector/editColor/${i}`,
              label: a,
              description: l,
              property: i,
              block: e,
              ...r,
            },
            i
          )
        : (0, X2.jsx)(
            Yk,
            {
              "data-cy": "slider-input-row",
              children: (0, X2.jsx)(rG, {
                label: a,
                property: i,
                block: e,
                centeredZeroPosition: false,
                ...r,
              }),
            },
            i
          );
    }),
  });
};

export function n5(e, t) {
  return e(`property.effect.${w1(F1(t))}`);
}
export var s5, i5;
export var o5 = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    effectId: t,
    insertEffect: n,
    removeEffect: s,
  }) {
    const { t: i } = ZL(),
      o = FI(),
      r = (0, K2.useRef)(null),
      a = (0, K2.useRef)(!!t),
      l = ov(n),
      c = ov(s),
      u = U2(),
      d = t && e.block.isValid(t) ? e.block.getType(t) : undefined,
      { data: p } = GF(
        ["asset-sources", "ly.img.effect"],
        () => e.asset.findAssets("ly.img.effect", { page: 0, perPage: 1e3 }),
        { enabled: u.includes("ly.img.effect") }
      ),
      f = (0, K2.useMemo)(
        () =>
          p?.assets
            .filter((e) => e.meta?.effectType)
            .map((t) => {
              const n = t.meta?.effectType;
              return {
                id: n,
                "data-cy": `effect-${n}`,
                label: n5(i, n),
                uri: `${o.ui.baseURL}effects/${F1(n)}.jpeg`,
                onClick: () => {
                  if (d === n) c();
                  else {
                    const t = e.block.createEffect(n);
                    l(t);
                  }
                },
              };
            }) ?? [],
        [o.ui.baseURL, d, p?.assets, e.block, l, c, i]
      );
    return (
      (0, K2.useEffect)(() => {
        if (!t || !r.current || !a.current) return;
        const n = e.block.getType(t),
          s = r.current.querySelector(`[data-id="${n}`),
          i = s?.closest('[data-cy="subInspector_scroll_container"]');
        s &&
          i &&
          ((i.scrollTop = s.offsetTop - s.scrollHeight), (a.current = false));
      }, [e.block, t]),
      (0, t5.jsx)("div", {
        ref: r,
        children: (0, t5.jsx)(E1, {
          useBannerCards: true,
          items: f,
          renderCollapsableContent: ({ id: e }) =>
            null == t ? null : (0, t5.jsx)(e5, { effectId: t, effectType: e }),
          queryActiveSelection: ({ id: e }) => e === d,
        }),
      })
    );
  })
);

export var l5 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO().feature.isEnabled("ly.img.effect", { engine: e }),
      { blocks: s } = YR(),
      [i] = e.block.findAllSelected();
    if (null == i) return null;
    const o = e.block.getType(i),
      r = e.block.hasEffects(i),
      a = s[o];
    return !(!a || !("effectsEnabled" in a)) && a.effectsEnabled && r && n
      ? t({ block: i })
      : null;
  })
);
export var c5 = WithEngineComp(function ({ engine: e, block: t, effectId: n }) {
  const { t: s } = ZL(),
    i = IV(),
    { effects: o, insertEffect: r, removeEffect: a } = m2(t),
    l = e.block.isAllowedByScope(t, yH),
    c = o.find((e) => e.effectId === n) ?? o[0],
    u = c?.effectId ? n5(s, e.block.getType(c.effectId)) : s("common.select"),
    d = !!c?.effectId && e.block.isEffectEnabled(c.effectId);
  return (0, a5.jsxs)(a5.Fragment, {
    children: [
      (0, a5.jsx)(WQ.Header, {
        action:
          null != t
            ? (0, a5.jsxs)(a5.Fragment, {
                children: [
                  (0, a5.jsxs)(CompCustomButton, {
                    name: "reset",
                    onClick: () => {
                      c && (a(c), i("action.property.reset"));
                    },
                    "aria-label": s("common.reset"),
                    "data-cy": "reset-effect-subInspector",
                    variant: "plain",
                    isDisabled: null == c?.effectId || !l,
                    children: [s("common.reset"), (0, a5.jsx)(FG, {})],
                  }),
                  (0, a5.jsx)(NK, {
                    label: u,
                    isEnabled: d,
                    toggleProperty: () => {
                      c?.effectId && e.block.setEffectEnabled(c.effectId, !d);
                    },
                    isDisabled: null == c?.effectId || !l,
                    "data-cy": "propertyToggle-effect",
                  }),
                ],
              })
            : null,
        children: (0, a5.jsx)(WQ.Title, { children: s("input.effect") }),
      }),
      (0, a5.jsx)(WQ.Content, {
        children: (0, a5.jsx)("div", {
          className: Y1,
          "data-cy": "subInspector_scroll_content_wrapper",
          children: (0, a5.jsx)(o5, {
            effectId: c?.effectId,
            insertEffect: (e) => {
              c && r(e, c);
            },
            removeEffect: () => {
              c && a(c);
            },
          }),
        }),
      }),
    ],
  });
});
export var u5 = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    effectId: t,
    block: n,
    inBar: s = false,
    deniedByScopeBehavior: i = "disable",
  }) {
    const { t: o } = ZL(),
      r = VO(),
      a = null != t && e.block.isValid(t),
      l = t ? n5(o, e.block.getType(t)) : o("common.select"),
      c = null != t && e.block.isEffectEnabled(t),
      u = XR(),
      [d] = BQ("//ly.img.panel/inspector/effects", u);
    function p() {
      d
        ? r.ui.closePanel("//ly.img.panel/inspector/effects")
        : r.ui.openPanel("//ly.img.panel/inspector/effects", {
            payload: { effectId: t },
          });
    }
    const f = e.block.isAllowedByScope(n, yH);
    if (!f && "hide" === i) return null;
    const h = (!!t && !c) || !f,
      m = o("input.effect");
    return s
      ? (0, a5.jsx)(Ly, {
          label: o("input.effect.tooltip"),
          children: (0, a5.jsx)(CompCustomButton, {
            name: m,
            variant: d ? "regular" : "plain",
            icon: (0, a5.jsxs)(Gb, {
              className: (0, r5.default)(X1, { [J1]: a && !c }),
              children: [(0, a5.jsx)(EY, {}), a && !c && (0, a5.jsx)(Yb, {})],
            }),
            isActive: a,
            activeStateStyle: "pill",
            onClick: p,
            disabled: !f,
            "data-cy": "effect",
            children: m,
          }),
        })
      : (0, a5.jsxs)(Yk, {
          children: [
            (0, a5.jsx)(Sv, { isDisabled: h, children: m }),
            (0, a5.jsx)(Ly, {
              label: o("input.effect.tooltip"),
              children: (0, a5.jsxs)(CompCustomButton, {
                name: m,
                variant: "regular",
                icon: (0, a5.jsx)(EY, {}),
                isActive: a,
                activeStateStyle: "pill",
                onClick: p,
                isDisabled: h,
                "data-cy": "effect",
                children: [l, (0, a5.jsx)(zq, {})],
              }),
            }),
            null != t
              ? (0, a5.jsx)(NK, {
                  label: l,
                  isEnabled: c,
                  toggleProperty: () => {
                    e.block.setEffectEnabled(t, !c);
                  },
                  isDisabled: null == t || !f,
                  "data-cy": "propertyToggle-effect",
                })
              : (0, a5.jsx)(zK, {}),
          ],
        });
  })
);
export function d5({ block: e, ...t }) {
  const { effects: n } = m2(e);
  return (0, a5.jsx)(a5.Fragment, {
    children: n.map((n) =>
      (0, a5.jsx)(u5, { effectId: n.effectId, block: e, ...t }, n.slotIndex)
    ),
  });
}
((i5 = s5 || (s5 = {})).SupportGuard = l5),
  (i5.PanelContent = c5),
  (i5.ControlStack = function (e) {
    return (0, a5.jsx)(l5, {
      children: ({ block: t }) => (0, a5.jsx)(d5, { block: t, ...e }),
    });
  });
export var p5 = s5;

export var m5 = i0;

export var v5 = function (e) {
  const t = YF(),
    {
      trimLength: n,
      trimOffset: s,
      totalDuration: i,
    } = eI(t, () => {
      const n = t.block.unstable_isAVResourceLoaded(e);
      return {
        totalDuration: n ? t.block.getAVResourceTotalDuration(e) : 0,
        trimLength: n ? t.block.getTrimLength(e) : 0,
        trimOffset: n ? t.block.getTrimOffset(e) : 0,
      };
    }),
    o = eI(t, () => t.block.getPlaybackTime(e)),
    r = s + o,
    a = (0, y5.useCallback)(
      (n) => {
        t.block.unstable_isAVResourceLoaded(e) &&
          (t.block.setTrimLength(e, n), t.block.setPlaybackTime(e, n));
      },
      [e, t.block]
    ),
    l = (0, y5.useCallback)(
      (n) => {
        t.block.unstable_isAVResourceLoaded(e) &&
          (t.block.setTrimOffset(e, n), t.block.setPlaybackTime(e, 0));
      },
      [e, t.block]
    ),
    c = (0, y5.useCallback)(
      (i) => {
        const o = i - s,
          r = Math.max(0, Math.min(n, o));
        t.block.setPlaybackTime(e, r);
      },
      [e, t.block, n, s]
    );
  return {
    totalDuration: i,
    trimLength: n,
    setTrimLength: a,
    trimOffset: s,
    setTrimOffset: l,
    seekerOffset: r,
    setSeekerOffset: c,
  };
};

export var j5 =
  "UBQ_TrimSubInspector-module__containerTrimModeInterface--YVMh4";

export function A5(e, t) {
  return e(t.join("."));
}
export var B5 = function ({ block: e, selectedBlock: t, blockType: n }) {
  const s = YF(),
    { t: i } = ZL(),
    o = IV(),
    {
      trimLength: r,
      setTrimLength: a,
      trimOffset: l,
      setTrimOffset: c,
      totalDuration: u,
    } = v5(e),
    d = u?.toFixed(2);
  function p() {
    o("action.property.update");
  }
  const f = u - l;
  return (0, P5.jsxs)(Qk, {
    title: A5(i, ["component", n, "properties"]),
    children: [
      (0, P5.jsxs)(Yk, {
        children: [
          (0, P5.jsx)(Sv, { children: A5(i, ["component", n, "source"]) }),
          (0, P5.jsx)(Sv, { children: d }),
        ],
      }),
      (0, P5.jsxs)(Yk, {
        children: [
          (0, P5.jsx)(Pv, {
            name: `${n}-duration`,
            label: i("input.duration"),
            children: (e) =>
              (0, P5.jsx)(zv, {
                ...e,
                "data-cy": "trimDuration",
                value: r,
                min: 0.1,
                max: f,
                step: 0.1,
                onChange: (e) => {
                  if (null == e) return;
                  const n = wk(e, 0.1, f);
                  a(n), null != t && s.block.setDuration(t, n);
                },
                onRelease: p,
                "aria-label": A5(i, ["input", n, "duration.description"]),
                tooltipLabel: i("input.duration"),
                unitLabel: "s",
              }),
          }),
          (0, P5.jsx)(Ly, {
            label: A5(i, ["input", n, "duration.reset"]),
            children: (0, P5.jsx)(CompCustomButton, {
              name: `${n}-duration-reset`,
              className: k5,
              variant: "plain",
              "aria-label": A5(i, ["input", n, "duration.reset"]),
              onClick: () => {
                c(0),
                  a(u),
                  null != t && s.block.setDuration(t, u),
                  o("action.property.update");
              },
              children: (0, P5.jsx)(FG, {}),
            }),
          }),
        ],
      }),
      (0, P5.jsx)(Yk, { children: (0, P5.jsx)(Sw, {}) }),
      (0, P5.jsxs)(Yk, {
        children: [
          (0, P5.jsx)(Pv, {
            name: `${n}-trim-start`,
            label: i("input.time.start"),
            children: (e) =>
              (0, P5.jsx)(zv, {
                ...e,
                "data-cy": "trimStart",
                value: l,
                min: 0,
                max: Fv(u, 1),
                step: 0.1,
                onChange: (e) => {
                  if (undefined !== e) {
                    const n = wk(e, 0, l + r - 0.1),
                      i = wk(r - (n - l), 0.1, u - n);
                    a(i), c(n), null != t && s.block.setDuration(t, i);
                  }
                },
                onRelease: p,
                tooltipLabel: i("input.time.start"),
                unitLabel: "s",
              }),
          }),
          (0, P5.jsx)(zK, {}),
        ],
      }),
      (0, P5.jsxs)(Yk, {
        children: [
          (0, P5.jsx)(Pv, {
            name: `${n}-trim-end`,
            label: i("input.time.end"),
            children: (e) =>
              (0, P5.jsx)(zv, {
                ...e,
                "data-cy": "trimEnd",
                value: l + r,
                min: 0,
                max: Fv(u, 1),
                step: 0.1,
                onChange: (e) => {
                  if (undefined !== e) {
                    const n = wk(e, l + 0.1, u),
                      i = n - l,
                      o = Math.min(l, n);
                    a(i), c(o), null != t && s.block.setDuration(t, i);
                  }
                },
                onRelease: p,
                tooltipLabel: i("input.time.end"),
                unitLabel: "s",
              }),
          }),
          (0, P5.jsx)(zK, {}),
        ],
      }),
    ],
  });
};

export var M5 = function (e) {
  const t = YF(),
    { isLoaded: n, trimTarget: s } = eI(t, () => {
      const n = t.block.getType(e);
      let s =
        "//ly.img.ubq/audio" === n || "//ly.img.ubq/fill/video" === n
          ? e
          : undefined;
      if (!s && t.block.supportsFill(e)) {
        const n = t.block.getFill(e);
        null != n &&
          t.block.isValid(n) &&
          "//ly.img.ubq/fill/video" === t.block.getType(n) &&
          (s = n);
      }
      return {
        isLoaded: null != s && t.block.unstable_isAVResourceLoaded(s),
        trimTarget: s,
      };
    }),
    i = eI(t, () => (n && null != s ? t.block.getTrimLength(s) : 0)),
    o = eI(t, () => "Trim" === t.editor.getEditMode()),
    r = (0, T5.useCallback)(
      (e) => {
        t.editor.setEditMode(e ? "Trim" : "Transform");
      },
      [t.editor]
    );
  return {
    avResourceLoaded: n,
    isOpen: o,
    setOpen: r,
    valueLabel: `${xS(i, true).timeString}`,
  };
};

export var R5 = function ({ block: e, selectedBlock: t, i18nBlockType: n }) {
  const { t: s } = ZL(),
    i = YF(),
    o = IV(),
    r = FI(),
    { setOpen: a } = M5(e);
  (0, b5.useEffect)(
    () => (
      i.block.setSoloPlaybackEnabled(e, true),
      () => {
        i.block.isValid(e) && i.block.setSoloPlaybackEnabled(e, false);
      }
    ),
    [e, i.block]
  ),
    (0, b5.useEffect)(
      () => () => {
        "Trim" === i.editor.getEditMode() && i.editor.setEditMode("Transform");
      },
      [i.editor]
    );
  const {
      totalDuration: l,
      trimLength: c,
      setTrimLength: u,
      trimOffset: d,
      setTrimOffset: p,
      seekerOffset: f,
      setSeekerOffset: h,
    } = v5(e),
    m = eI(i, () => {
      const e = i.scene.getCurrentPage(),
        n = e ? i.block.getDuration(e) : 0;
      if (null == t || 0 === n) return 0;
      const s = i.block.getTimeOffset(t),
        o = i.block.getDuration(t);
      return Math.max(0, s + o - n);
    }),
    g = eI(i, () => i.block.isPlaying(e)),
    x = (0, b5.useCallback)(
      (t) => {
        i.block.setPlaying(e, t);
      },
      [e, i.block]
    ),
    b = (0, b5.useCallback)(() => {
      x(false), a(false), o("action.property.update");
    }, [o, a, x]),
    [y, v] = (0, b5.useState)(""),
    w = (function () {
      const [e, t] = (0, KS.useState)(window.devicePixelRatio);
      return (
        (0, KS.useEffect)(() => {
          const n = () => {
              t(window.devicePixelRatio);
            },
            s = matchMedia(`(resolution: ${e}dppx)`);
          return (
            s.addEventListener("change", n),
            () => {
              s.removeEventListener("change", n);
            }
          );
        }, [e]),
        e
      );
    })(),
    k = Math.ceil(24 * w);
  (0, b5.useEffect)(() => {
    if ("video" !== n) return aV;
    let t,
      s = true;
    return (
      i.block
        .getVideoFillThumbnailAtlas(e, 8, 8, k)
        .then((e) => {
          (t = URL.createObjectURL(e)), s && v(t);
        })
        .catch(() => {}),
      () => {
        (s = false), t && URL.revokeObjectURL(t);
      }
    );
  }, [k, e, n, i.block]);
  const C = (0, b5.useRef)(false),
    j = l - d;
  return (0, O5.jsxs)("span", {
    className: (0, w5.default)(C5, j5),
    children: [
      (0, O5.jsx)(Ly, {
        label: A5(s, ["component", n, "trim.play.description"]),
        children: (0, O5.jsx)(CompCustomButton, {
          name: "trimPlay",
          "aria-label": A5(s, ["component", n, "trim.play"]),
          className: S5,
          variant: "plain",
          onClick: () => {
            x(!g);
          },
          children: g ? (0, O5.jsx)(rZ, {}) : (0, O5.jsx)(lZ, {}),
        }),
      }),
      (0, O5.jsx)("div", {
        className: _5,
        children: (0, O5.jsx)(Ly, {
          label: A5(s, ["component", n, "trim.duration.description"]),
          children: (0, O5.jsx)(zv, {
            name: "trimDuration",
            "data-cy": "inBarTrimDuration",
            "aria-label": A5(s, ["component", n, "trim.duration"]),
            maxFractionDigits: 1,
            value: c,
            min: 0.1,
            max: j,
            onChange: (e) => {
              if (null == e) return;
              const n = wk(e, 0.1, j);
              u(n), t && i.block.setDuration(t, n);
            },
            onRelease: () => {
              o("action.property.update");
            },
            unitLabel: "s",
            dynamicWidth: true,
          }),
        }),
      }),
      (0, O5.jsx)("div", {
        className: E5,
        children: (0, O5.jsx)(BS, {
          mediaDuration: l,
          offset: f,
          setOffset: h,
          min: d,
          max: d + c,
          onStart: (e) => {
            e.stopPropagation(),
              g ? (x(false), (C.current = true)) : (C.current = false);
          },
          onStop: (e) => {
            e.stopPropagation(), C.current && x(true);
          },
          children: (0, O5.jsx)(fS, {
            mediaDuration: l,
            trimOffset: d,
            setTrimOffset: (e) => {
              g && x(false);
              const t = "function" == typeof e ? e() : e;
              p(t);
            },
            trimLength: c,
            setTrimLength: (e) => {
              g && x(false);
              const n = "function" == typeof e ? e() : e;
              u(n), t && i.block.setDuration(t, n);
            },
            onUpdateTrimProperties: () => {
              o("action.property.update");
            },
            postContainedDuration: m,
            renderBackground: () => {
              switch (n) {
                case "video":
                  return "" !== y
                    ? (0, O5.jsx)(Gj.Background.Atlas, {
                        atlas: y,
                        atlasRows: 8,
                        atlasColumns: 8,
                      })
                    : null;
                case "audio":
                  return (0, O5.jsx)(Gj.Background.MaskedSvg, {
                    frame: `${r.ui.baseURL}audio-wave.svg`,
                  });
                default:
                  return null;
              }
            },
          }),
        }),
      }),
      (0, O5.jsx)(CompCustomButton, {
        color: "accent",
        name: "trimConfirmation",
        className: L5,
        onClick: b,
        children: s("common.done"),
      }),
    ],
  });
};

export var D5 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO(),
      s = rI(SH);
    if (!n.feature.isEnabled("ly.img.trim", { engine: e })) return null;
    const i = e.block.findAllSelected()[0];
    if (!i) return null;
    const o = e.block.getType(i),
      r = e.block.supportsFill(i) ? e.block.getFill(i) : undefined,
      a = null != r && e.block.isValid(r) ? e.block.getType(r) : undefined,
      l = null != r && e.block.isFillEnabled(i),
      c = "//ly.img.ubq/fill/video" === a ? r : i,
      u = "//ly.img.ubq/fill/video" === a ? "video" : QK(o);
    return e.block.supportsTrim(c)
      ? t({
          block: c,
          selectedBlock: i,
          i18nBlockType: u,
          isDisabled: !s || (null != r && !l),
        })
      : null;
  })
);
export function F5({ block: e, i18nBlockType: t, selectedBlock: n }) {
  const { t: s } = ZL();
  return (0, V5.jsxs)(V5.Fragment, {
    children: [
      (0, V5.jsx)(WQ.Header, {
        children: (0, V5.jsx)(WQ.Title, { children: s("common.trim") }),
      }),
      (0, V5.jsx)(WQ.Content, {
        children: (0, V5.jsx)(B5, { block: e, selectedBlock: n, blockType: t }),
      }),
    ],
  });
}
export var I5, H5;
export var N5 = mayBeUseMemp(function ({
  block: e,
  i18nBlockType: t,
  isDisabled: n,
  inBar: s = false,
  deniedByScopeBehavior: i = "disable",
}) {
  const { t: o } = ZL(),
    r = VO(),
    { avResourceLoaded: a, valueLabel: l, isOpen: c, setOpen: u } = M5(e),
    d = rI(SH),
    p = XR(),
    [f] = BQ("//ly.img.panel/inspector/trim", p);
  if (!d && "hide" === i) return null;
  const h = o("common.trim"),
    m = A5(o, ["component", t, "trim.description"]);
  return s
    ? (0, V5.jsx)(Ly, {
        label: m,
        children: (0, V5.jsx)(CompCustomButton, {
          icon: (0, V5.jsx)(x5, {}),
          "data-cy": "trim",
          name: "inspectorbar-trim",
          onClick: () => {
            u(!c);
          },
          variant: "plain",
          "aria-label": m,
          isDisabled: !a || n,
          children: h,
        }),
      })
    : (0, V5.jsxs)(Yk, {
        children: [
          (0, V5.jsx)(Sv, { isDisabled: !a || n, children: h }),
          (0, V5.jsx)(Ly, {
            label: m,
            children: (0, V5.jsxs)(CompCustomButton, {
              name: h,
              variant: "regular",
              icon: (0, V5.jsx)(x5, {}),
              activeStateStyle: "outline",
              onClick: function () {
                f
                  ? r.ui.closePanel("//ly.img.panel/inspector/trim")
                  : r.ui.openPanel("//ly.img.panel/inspector/trim");
              },
              isDisabled: n || !d || !a,
              "data-cy": "trim",
              children: [l, (0, V5.jsx)(zq, {})],
            }),
          }),
          (0, V5.jsx)(zK, {}),
        ],
      });
});
((H5 = I5 || (I5 = {})).SupportGuard = D5),
  (H5.PanelContent = F5),
  (H5.Control = function ({ inBar: e, deniedByScopeBehavior: t }) {
    return (0, V5.jsx)(D5, {
      children: (n) =>
        (0, V5.jsx)(N5, { inBar: e, deniedByScopeBehavior: t, ...n }),
    });
  }),
  (H5.InBarInspector = function () {
    return (0, V5.jsx)(D5, { children: (e) => (0, V5.jsx)(R5, { ...e }) });
  });
export var U5 = I5;

export var W5 = WithEngineComp(function ({
  block: e,
  isDisabled: t,
  engine: n,
}) {
  const { t: s } = ZL(),
    i = IV(),
    o = n.block.getBool(e, "playback/muted"),
    r = n.block.getFloat(e, "playback/volume");
  return (0, Z5.jsxs)(Yk, {
    children: [
      (0, Z5.jsx)(tG, {
        name: "playback/volume",
        label: s("property.volume"),
        min: 0,
        max: 1,
        value: r,
        onChange: (t) => {
          n.block.setFloat(e, "playback/volume", t);
        },
        onRelease: () => {
          i("action.property.update");
        },
        centeredZeroPosition: false,
        isDisabled: o || t,
      }),
      (0, Z5.jsx)(NK, {
        toggleProperty: () => {
          return (t = !o), void n.block.setBool(e, "playback/muted", t);
          var t;
        },
        label: s("input.audio.mute"),
        isEnabled: o,
        isDisabled: t,
        enabledIcon: Q5,
        disabledIcon: $5,
        "data-cy": "propertyToggle-volume",
      }),
    ],
  });
});

export function Y5({ deniedByScopeBehavior: e }) {
  return (0, K5.jsx)(X5, {
    children: (t) => (0, K5.jsx)(J5, { deniedByScopeBehavior: e, ...t }),
  });
}
Y5.InBar = function ({ deniedByScopeBehavior: e }) {
  return (0, K5.jsx)(X5, {
    children: (t) => (0, K5.jsx)(e4, { deniedByScopeBehavior: e, ...t }),
  });
};
export var X5 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    if (!VO().feature.isEnabled("ly.img.volume", { engine: e })) return null;
    const [n] = e.block.findAllSelected();
    if (!n || "//ly.img.ubq/page" === e.block.getType(n)) return null;
    const s = e.block.isAllowedByScope(n, SH),
      i = e.block.supportsFill(n),
      o = i ? e.block.getFill(n) : undefined,
      r =
        undefined !== o && e.block.isValid(o) ? e.block.getType(o) : undefined,
      a = i && e.block.isFillEnabled(n);
    if (undefined !== o && "//ly.img.ubq/fill/video" === r)
      return t({
        selectedBlock: n,
        block: o,
        isDisabled: !s || (null != o && !a),
      });
    const l = e.block.findAllProperties(n);
    return l.includes("playback/volume") && l.includes("playback/muted")
      ? t({ selectedBlock: n, block: n, isDisabled: !s || (null != o && !a) })
      : null;
  })
);
export var J5 = WithEngineComp(function ({
  engine: e,
  block: t,
  selectedBlock: n,
  isDisabled: s,
  deniedByScopeBehavior: i,
}) {
  const o = e.block.isAllowedByScope(n, SH);
  return o || "hide" !== i
    ? (0, K5.jsx)(W5, { block: t, isDisabled: s || !o })
    : null;
});
export var e4 = WithEngineComp(function ({
  engine: e,
  isDisabled: t,
  selectedBlock: n,
  block: s,
  deniedByScopeBehavior: i = "disable",
}) {
  const { t: o } = ZL(),
    r = e.block.isAllowedByScope(n, SH);
  if (!r && "hide" === i) return null;
  const a = e.block.getBool(s, "playback/muted");
  return (0, K5.jsxs)(Cx, {
    placement: "bottom",
    children: [
      (e) =>
        (0, K5.jsx)(CompCustomButton, {
          icon: a ? (0, K5.jsx)(Q5, {}) : (0, K5.jsx)($5, {}),
          name: "volume",
          ...e,
          variant: "plain",
          isDisabled: t || !r,
          children: o("property.volume"),
        }),
      () =>
        (0, K5.jsx)("div", {
          className: G5,
          children: (0, K5.jsx)(W5, { block: s }),
        }),
    ],
  });
});
export var t4 = Y5;

export var s4 = { r: 0, g: 0, b: 0, a: 0 };
export function i4(e) {
  const { t: t } = ZL(),
    n = YF(),
    {
      isPropertyEnabled: s,
      fill: i,
      fillType: o,
      colorMode: r,
      color: a,
      gradientStops: l,
      gradientControlPoints: c,
    } = eI(n, () => {
      const t = n.block.isFillEnabled(e),
        s = n.block.getFill(e),
        i = n.block.isValid(s) ? n.block.getType(s) : undefined,
        o =
          "//ly.img.ubq/fill/gradient/linear" === i ||
          "//ly.img.ubq/fill/gradient/radial" === i ||
          "//ly.img.ubq/fill/gradient/conical" === i;
      return {
        isPropertyEnabled: t,
        fill: s,
        fillType: i,
        colorMode: o ? "Gradient" : "Solid",
        color:
          "//ly.img.ubq/fill/color" === i
            ? n.block.getColor(s, "fill/color/value")
            : s4,
        gradientStops: o
          ? n.block.getGradientColorStops(s, "fill/gradient/colors")
          : undefined,
        gradientControlPoints: {
          start: {
            x: o ? n.block.getFloat(s, "fill/gradient/linear/startPointX") : 0,
            y: o ? n.block.getFloat(s, "fill/gradient/linear/startPointY") : 0,
          },
          center: { x: 0, y: 0 },
          end: {
            x: o ? n.block.getFloat(s, "fill/gradient/linear/endPointX") : 1,
            y: o ? n.block.getFloat(s, "fill/gradient/linear/endPointY") : 1,
          },
        },
      };
    }),
    u = (0, n4.useCallback)(
      (t) => {
        if (t === r || null == e) return;
        const s =
          "Gradient" === t
            ? n.block.createFill("gradient/linear")
            : n.block.createFill("color");
        n.block.setFill(e, s);
      },
      [e, r, n.block]
    ),
    d = (0, n4.useCallback)((t) => n.block.setFillEnabled(e, t), [e, n]),
    p = (0, n4.useCallback)(
      (e) => {
        n.block.setColor(i, "fill/color/value", e);
      },
      [n, i]
    ),
    f = (0, n4.useCallback)(
      (e) => n.block.setGradientColorStops(i, "fill/gradient/colors", e),
      [n, i]
    ),
    [h, m] = pJ({
      gradientStops: l,
      setGradientStops: f,
      initialState: {
        activeStopIndex: 0,
        dragTarget: oJ,
        internalGradientStops: aX(l ?? []),
      },
    }),
    { activeStopIndex: g } = h;
  (0, n4.useEffect)(() => {
    "Gradient" === r && 0 !== g && m(lJ(0));
  }, [o]);
  const x = (0, n4.useCallback)(
      (e) => {
        if (!l || !f) return;
        const t = l.slice();
        (t[g] = { ...t[g], color: e }), f(t);
      },
      [g, l, f]
    ),
    b = (0, n4.useCallback)(
      (e) => {
        null != i &&
          "Gradient" === r &&
          (n.block.setFloat(i, "fill/gradient/linear/startPointX", e.start.x),
          n.block.setFloat(i, "fill/gradient/linear/startPointY", e.start.y),
          n.block.setFloat(i, "fill/gradient/linear/endPointX", e.end.x),
          n.block.setFloat(i, "fill/gradient/linear/endPointY", e.end.y));
      },
      [n.block, i, r]
    ),
    [y, v] = (0, n4.useMemo)(
      () => ("Gradient" === r && l ? [l[g].color, x] : [a, p]),
      [g, a, l, r, p, x]
    ),
    w = n.block.getFrameWidth(e) / n.block.getFrameHeight(e),
    { customPreviewLabel: k, previewColor: C } = (0, n4.useMemo)(
      () => ({
        customPreviewLabel:
          "Gradient" === r ? t("property.gradientType.linear") : undefined,
        previewColor: l
          ? vb(
              PO(
                l.map((e) => e.color),
                n.editor
              )
            )
          : PO(a, n.editor),
      }),
      [a, n.editor, l, r, t]
    );
  return {
    colorMode: r,
    setColorMode: u,
    color: y,
    setColor: v,
    isPropertyEnabled: s,
    setIsPropertyEnabled: d,
    customPreviewLabel: k,
    previewColor: C,
    gradientState: h,
    gradientDispatch: m,
    gradientStops: l,
    setGradientStops: f,
    gradientAspectRatio: w,
    gradientControlPoints: c,
    setGradientControlPoints: b,
    showGradientControls: true,
  };
}
export var o4 = "UBQ_FillInspectorControls-module__contentBox--KoUDx";

export var a4 = mayBeUseMemp(
  WithEngineComp(({ engine: e, fillBlock: t, isDisabled: n = false }) => {
    const s = VO(),
      { t: i } = ZL(),
      o = XR(),
      [, r] = BQ("//ly.img.panel/assetLibrary.replace", o),
      a = Nz(),
      l = e.block.getString(t, "fill/image/imageFileURI"),
      c = e.block.getString(t, "fill/image/previewFileURI"),
      u = e.block.getSourceSet(t, "fill/image/sourceSet"),
      d = (0, h5.useMemo)(() => {
        if (0 === u.length) return c || l;
        const e = a ? 0.95 * window.innerWidth : 256;
        return (function (e, t) {
          return e.reduce((e, n) =>
            Math.abs(n.width - t) < Math.abs(e.width - t) ? n : e
          );
        })(u, e).uri;
      }, [l, c, a, u]),
      p = i("common.replace"),
      f = s.feature.isEnabled("ly.img.replace", { engine: e });
    return (0, r4.jsxs)(AJ, {
      children: [
        (0, r4.jsx)(E_, {
          label: p,
          isDisabled: n,
          children: (0, r4.jsx)(g_, {
            children: (0, r4.jsxs)(c_, {
              className: o4,
              children: [
                f &&
                  (0, r4.jsx)(Ih.Edge, {
                    children: (0, r4.jsx)(g_.Overlay, {
                      children: (0, r4.jsx)(Ih.Edge.BottomRight, {
                        children: (0, r4.jsx)(c_.InteractionElement, {
                          name: "replace-image",
                          icon: (0, r4.jsx)(IY, {}),
                          onClick: () => r(true),
                          "aria-label": i("action.image.replace"),
                          children: p,
                        }),
                      }),
                    }),
                  }),
                (0, r4.jsx)(c_.Background.Image, { url: d, checkered: true }),
              ],
            }),
          }),
        }),
        (0, r4.jsx)(y1.Control, { fillContainer: true }),
      ],
    });
  })
);
export var l4 = mayBeUseMemp(
  WithEngineComp(({ engine: e, fillBlock: t, isDisabled: n = false }) => {
    const s = VO(),
      { t: i } = ZL(),
      o = XR(),
      [, r] = BQ("//ly.img.panel/assetLibrary.replace", o),
      a = e.block.getString(t, "fill/video/fileURI"),
      [l, c] = (0, h5.useState)("");
    (0, h5.useEffect)(() => {
      let n = true;
      return (
        a &&
          e.block
            .getVideoFillThumbnail(t, 200)
            .then((e) => {
              n && c(URL.createObjectURL(e));
            })
            .catch(() => {}),
        () => {
          n = false;
        }
      );
    }, [e, a, t]);
    const u = i("common.replace"),
      d = s.feature.isEnabled("ly.img.replace", { engine: e });
    return (0, r4.jsxs)(r4.Fragment, {
      children: [
        (0, r4.jsxs)(AJ, {
          children: [
            (0, r4.jsx)(E_, {
              label: u,
              isDisabled: n,
              children: (0, r4.jsx)(g_, {
                children: (0, r4.jsxs)(c_, {
                  size: "medium",
                  className: o4,
                  children: [
                    d &&
                      (0, r4.jsx)(Ih.Edge, {
                        children: (0, r4.jsx)(g_.Overlay, {
                          children: (0, r4.jsx)(Ih.Edge.BottomRight, {
                            children: (0, r4.jsx)(c_.InteractionElement, {
                              name: "replace-video",
                              icon: (0, r4.jsx)(IY, {}),
                              onClick: () => r(true),
                              "aria-label": i("action.video.replace"),
                              children: u,
                            }),
                          }),
                        }),
                      }),
                    (0, r4.jsx)(c_.Background.Image, {
                      url: l,
                      checkered: true,
                    }),
                  ],
                }),
              }),
            }),
            (0, r4.jsx)(y1.Control, {}),
            (0, r4.jsx)(U5.Control, {}),
          ],
        }),
        (0, r4.jsx)(AJ, { children: (0, r4.jsx)(t4, {}) }),
      ],
    });
  })
);
export function c4({ block: e, isDisabled: t }) {
  const n = i4(e);
  return (0, r4.jsx)(AJ, {
    children: (0, r4.jsx)(m5, {
      block: e,
      name: "fillColor",
      i18nLabelString: "property.fill",
      i18nDescriptionString: "property.fill.description",
      isDisabled: t,
      "data-cy": "fill",
      ...n,
    }),
  });
}
export var u4, d4;
export var p4 = WithEngineComp(function ({ block: e, engine: t }) {
  const n = t.block.isAllowedByScope(e, SH),
    s = t.block.isFillEnabled(e),
    i = t.block.getFill(e);
  if (!t.block.isValid(i)) return null;
  const o = !n || !s;
  switch (t.block.getType(i)) {
    case "//ly.img.ubq/fill/image":
      return (0, r4.jsx)(a4, { fillBlock: i, isDisabled: o });
    case "//ly.img.ubq/fill/video":
      return (0, r4.jsx)(l4, { fillBlock: i, isDisabled: o });
    case "//ly.img.ubq/fill/gradient/linear":
    case "//ly.img.ubq/fill/gradient/radial":
    case "//ly.img.ubq/fill/gradient/conical":
    case "//ly.img.ubq/fill/color":
      return (0, r4.jsx)(c4, { block: e, isDisabled: o });
    default:
      return null;
  }
});

export var x4 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = VO(),
      [s] = e.block.findAllSelected();
    if (null == s) return null;
    const i = e.block.supportsFill(s) && e.block.isValid(e.block.getFill(s)),
      o = n.feature.isEnabled("ly.img.fill", { engine: e });
    return i && o && "//ly.img.ubq/text" !== e.block.getType(s)
      ? t({ block: s })
      : null;
  })
);
export var b4 = WithEngineComp(function ({ engine: e, block: t }) {
  const { t: n } = ZL(),
    s = IV(),
    i = e.block.isAllowedByScope(t, SH),
    o = e.block.isAllowedByScope(t, _H),
    r = e.block.isAllowedByScope(t, hH),
    a = e.scene.getMode(),
    l = e.block.isFillEnabled(t),
    c = e.block.getFill(t),
    u = e.block.isValid(c) ? e.block.getType(c) : undefined,
    d = (0, f5.useMemo)(
      () =>
        "//ly.img.ubq/fill/image" === u || "//ly.img.ubq/fill/video" === u
          ? !l || (!r && !i)
          : !l || !i,
      [i, r, u, l]
    ),
    { icon: p, label: f } = (0, f5.useMemo)(() => {
      switch (u) {
        case "//ly.img.ubq/fill/image":
          return {
            icon: (0, g4.jsx)(IconPhoto, {}),
            label: n("component.contentFill.image"),
          };
        case "//ly.img.ubq/fill/video":
          return {
            icon: (0, g4.jsx)(IconPlayOutline, {}),
            label: n("component.contentFill.video"),
          };
        case "//ly.img.ubq/fill/gradient/conical":
        case "//ly.img.ubq/fill/gradient/linear":
        case "//ly.img.ubq/fill/gradient/radial":
        case "//ly.img.ubq/fill/color":
          return {
            icon: (0, g4.jsx)(gX, {}),
            label: n("component.contentFill.color"),
          };
        default:
          return { icon: undefined, label: "" };
      }
    }, [u, n]);
  return (0, g4.jsxs)(g4.Fragment, {
    children: [
      (0, g4.jsx)(WQ.Header, {
        action: (0, g4.jsxs)(g4.Fragment, {
          children: [
            (0, g4.jsxs)(Cx, {
              children: [
                (e, { isOpen: t }) =>
                  (0, g4.jsx)(Ly, {
                    label: n("component.contentFill.options.description"),
                    children: (0, g4.jsxs)(CompCustomButton, {
                      variant: "plain",
                      name: "change-fill-type",
                      icon: p,
                      ...e,
                      isDisabled: d || !o,
                      children: [
                        f,
                        t
                          ? (0, g4.jsx)(IconChevronDown, {})
                          : (0, g4.jsx)(IconChevronUp, {}),
                      ],
                    }),
                  }),
                ({ closePopover: i }) =>
                  (0, g4.jsxs)(yC.Container, {
                    "aria-label": n("component.contentFill.options"),
                    children: [
                      "Video" === a &&
                        (0, g4.jsx)(yC.Item, {
                          children: (0, g4.jsx)(CompCustomButton, {
                            variant: "plain",
                            icon: (0, g4.jsx)(IconPlayOutline, {}),
                            name: "video-fill",
                            onClick: () => {
                              "//ly.img.ubq/fill/video" !== u &&
                                e.block.isValid(c) &&
                                (e.block.setFill(
                                  t,
                                  e.block.createFill("video")
                                ),
                                e.block.setKind(t, "video"),
                                e.block.destroy(c),
                                s("action.fillType.change")),
                                i();
                            },
                            children: n("component.contentFill.video"),
                          }),
                        }),
                      (0, g4.jsx)(yC.Item, {
                        children: (0, g4.jsx)(CompCustomButton, {
                          variant: "plain",
                          icon: (0, g4.jsx)(IconPhoto, {}),
                          name: "image-fill",
                          onClick: () => {
                            "//ly.img.ubq/fill/image" !== u &&
                              e.block.isValid(c) &&
                              (e.block.setFill(t, e.block.createFill("image")),
                              e.block.setKind(t, "image"),
                              e.block.destroy(c),
                              s("action.fillType.change")),
                              i();
                          },
                          children: n("component.contentFill.image"),
                        }),
                      }),
                      (0, g4.jsx)(yC.Item, {
                        children: (0, g4.jsx)(CompCustomButton, {
                          variant: "plain",
                          icon: (0, g4.jsx)(gX, {}),
                          name: "color-fill",
                          onClick: () => {
                            if (
                              "//ly.img.ubq/fill/color" !== u &&
                              "//ly.img.ubq/fill/gradient/conical" !== u &&
                              "//ly.img.ubq/fill/gradient/linear" !== u &&
                              "//ly.img.ubq/fill/gradient/radial" !== u &&
                              e.block.isValid(c)
                            ) {
                              switch (
                                (e.block.setFill(
                                  t,
                                  e.block.createFill("color")
                                ),
                                e.block.getType(t))
                              ) {
                                case "//ly.img.ubq/page":
                                  e.block.setKind(t, "page");
                                  break;
                                case "//ly.img.ubq/graphic":
                                  e.block.setKind(t, "shape");
                                  break;
                                default:
                                  e.block.setKind(t, "");
                              }
                              e.block.destroy(c), s("action.fillType.change");
                            }
                            i();
                          },
                          children: n("component.contentFill.color"),
                        }),
                      }),
                    ],
                  }),
              ],
            }),
            (0, g4.jsx)(NK, {
              isEnabled: l,
              toggleProperty: () => {
                e.block.setFillEnabled(t, !l);
              },
              label: n("property.fill"),
              isDisabled: !i,
              "data-cy": "propertyToggle-fill",
            }),
          ],
        }),
        children: (0, g4.jsx)(WQ.Title, {
          children: n("component.contentFill"),
        }),
      }),
      (0, g4.jsx)(WQ.Content, {
        children: (0, g4.jsx)(E_, {
          isDisabled: !l,
          onClick: () => e.block.setFillEnabled(t, true),
          label: n(
            l ? "input.propertyToggle.disable" : "input.propertyToggle.enable",
            { property: f }
          ),
          children: (0, g4.jsx)(p4, { block: t }),
        }),
      }),
    ],
  });
});
export var y4 = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    block: t,
    inBar: n = false,
    deniedByScopeBehavior: s = "disable",
  }) {
    const { t: i } = ZL(),
      o = VO(),
      r = XR(),
      [a] = BQ("//ly.img.panel/inspector/fill", r),
      l = (0, f5.useCallback)(() => {
        a
          ? o.ui.closePanel("//ly.img.panel/inspector/fill")
          : o.ui.openPanel("//ly.img.panel/inspector/fill");
      }, [o.ui, a]),
      c = e.block.isAllowedByScope(t, SH),
      u = e.block.isAllowedByScope(t, hH),
      d = e.block.isFillEnabled(t),
      p = e.block.getFill(t),
      f = e.block.isValid(p) ? e.block.getType(p) : undefined,
      h =
        "//ly.img.ubq/fill/gradient/linear" === f ||
        "//ly.img.ubq/fill/gradient/radial" === f ||
        "//ly.img.ubq/fill/gradient/conical" === f,
      m = (0, f5.useMemo)(
        () =>
          "//ly.img.ubq/fill/image" === f || "//ly.img.ubq/fill/video" === f
            ? !d || (!u && !c)
            : !d || !c,
        [c, u, f, d]
      ),
      g =
        "//ly.img.ubq/fill/color" === f
          ? e.block.getColor(p, "fill/color/value")
          : undefined,
      x = h
        ? e.block.getGradientColorStops(p, "fill/gradient/colors")
        : undefined,
      b = i("component.contentFill"),
      {
        icon: y,
        valueLabel: v,
        button: w,
      } = (0, f5.useMemo)(() => {
        switch (f) {
          case "//ly.img.ubq/fill/image":
            return {
              icon: (0, g4.jsx)(IconPhoto, {}),
              valueLabel: i("component.contentFill.image"),
            };
          case "//ly.img.ubq/fill/video":
            return {
              icon: (0, g4.jsx)(IconPlayOutline, {}),
              valueLabel: i("component.contentFill.video"),
            };
          case "//ly.img.ubq/fill/gradient/conical":
          case "//ly.img.ubq/fill/gradient/linear":
          case "//ly.img.ubq/fill/gradient/radial":
          case "//ly.img.ubq/fill/color": {
            let t = "";
            return (
              g && (t = PO(g, e.editor)),
              x &&
                (t = vb(
                  PO(
                    x.map((e) => e.color),
                    e.editor
                  )
                )),
              {
                icon: (0, g4.jsx)(gX, {}),
                valueLabel: i("component.contentFill.color"),
                button: n
                  ? (0, g4.jsx)(My, {
                      name: b,
                      "data-cy": "fill",
                      variant: a ? "regular" : "plain",
                      previewColor: t,
                      strikeThrough: !d,
                      hidePreviewLabel: true,
                      onClick: l,
                      children: i("component.contentFill.color"),
                    })
                  : (0, g4.jsx)(Ty, {
                      name: b,
                      "data-cy": "fill",
                      variant: "regular",
                      renderChevronIcon: () => (0, g4.jsx)(zq, {}),
                      previewColor: t,
                      customPreviewLabel: h
                        ? i("property.gradientType.linear")
                        : undefined,
                      invertedLabel: h,
                      isDisabled: m,
                      onClick: l,
                    }),
              }
            );
          }
          default:
            return { icon: undefined, label: "" };
        }
      }, [e.editor, g, f, x, n, m, d, h, a, b, i, l]);
    return c || u || "hide" !== s
      ? n
        ? (0, g4.jsx)(Ly, {
            label: b,
            children:
              w ??
              (0, g4.jsx)(CompCustomButton, {
                name: b,
                variant: a ? "regular" : "plain",
                icon: (0, g4.jsxs)(Gb, {
                  className: (0, f4.default)(h4, { [m4]: !d }),
                  children: [y, !d && (0, g4.jsx)(Yb, {})],
                }),
                onClick: l,
                disabled: !c && !u,
                "data-cy": "fill",
                children: v,
              }),
          })
        : (0, g4.jsxs)(Yk, {
            children: [
              (0, g4.jsx)(Sv, { isDisabled: m, children: v }),
              (0, g4.jsx)(Ly, {
                label: i("input.effect.tooltip"),
                children:
                  w ??
                  (0, g4.jsxs)(CompCustomButton, {
                    name: b,
                    variant: "regular",
                    icon: y,
                    onClick: l,
                    isDisabled: m,
                    "data-cy": "fill",
                    children: [v, (0, g4.jsx)(zq, {})],
                  }),
              }),
              (0, g4.jsx)(NK, {
                isEnabled: d,
                toggleProperty: () => {
                  e.block.setFillEnabled(t, !d);
                },
                label: i("property.fill"),
                isDisabled: !c,
                "data-cy": "propertyToggle-fill",
              }),
            ],
          })
      : null;
  })
);
((d4 = u4 || (u4 = {})).SupportGuard = x4),
  (d4.PanelContent = b4),
  (d4.Control = function (e) {
    return (0, g4.jsx)(x4, {
      children: ({ block: t }) => (0, g4.jsx)(y4, { block: t, ...e }),
    });
  });
export var v4 = u4;

export var k4 = class extends UIComponentBuilder {
  constructor(e, t, n, s) {
    super("InspectorBarBuilder", e, t, n, s);
  }
};

export var _4 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, className: t }) {
    const { t: n } = ZL(),
      s = XR(),
      i = e.editor.getEditMode(),
      [o, r] = s.getInspectorBarOrder({ editMode: i });
    return (0, S4.jsx)("div", {
      className: (0, w4.default)(C4, t),
      role: "region",
      "aria-label": n("component.inspectorBar"),
      children: (0, S4.jsx)("div", {
        className: j4,
        children: o.map((t, i) => {
          const o = t.id,
            a = `${r}.${o}.${i}`,
            l = s.registeredComponents[o];
          if (null == l) return null;
          if ("react" === l.type) {
            const e = l.component;
            return (0, S4.jsx)(e, {}, a);
          }
          const c = { componentId: o };
          return (0, S4.jsx)(
            qz,
            {
              builderRenderFunction: l.render,
              createBuilder: (t) => new k4(t, n, c, e),
            },
            a
          );
        }),
      }),
    });
  })
);

export var A4 = class extends UIComponentBuilder {
  constructor(e, t, n, s) {
    super("NavigationBarBuilder", e, t, n, s);
  }
  Heading = (e, { content: t }) => {
    const n = this.translator(t, { defaultValue: t });
    this._push({
      id: e,
      type: "Heading",
      focusable: false,
      node: (0, P4.jsx)(HI, { level: 1, className: L4, children: n }),
    });
  };
};

export var R4 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = XR(),
      s = Nz(),
      i = e.editor.getEditMode(),
      [o, r] = n.getNavigationBarOrder({ editMode: i });
    return (0, O4.jsx)("div", {
      className: B4,
      "data-cy": "navigation-bar",
      children: (0, O4.jsx)("div", {
        className: (0, E4.default)(T4, { [M4]: s }),
        children: o.map((s, i) => {
          const o = s.id,
            a = `${r}.${o}.${i}`,
            l = n.registeredComponents[o];
          if (null == l) return null;
          if ("react" === l.type) {
            const e = l.component;
            return (0, O4.jsx)(e, {}, a);
          }
          const c = { componentId: o };
          return (0, O4.jsx)(
            qz,
            {
              payload: s,
              builderRenderFunction: l.render,
              createBuilder: (n) => new A4(n, t, c, e),
            },
            a
          );
        }),
      }),
    });
  })
);

export var F4 = { short: 2e3, medium: 6e3, long: 12e3, infinite: undefined };
export var I4 = /^(?:(?<action>undo|redo)\.)?(?<key>.*)/;
export var H4 = mayBeUseMemp(function () {
  const e = DO(),
    t = VO(),
    n = XR(),
    { t: s } = ZL();
  (0, V4.useEffect)(
    () =>
      e.addNotificationHandler((e) => {
        !(function (e, t, n) {
          const { i18n: s } = t,
            [, i, o] = s.match(I4),
            r = [];
          "undo" === i && r.push(n("notification.undo"));
          "redo" === i && r.push(n("notification.redo"));
          const a = n([`${o}.description`, o], { defaultValue: "" });
          a && r.push(a);
          if (0 === r.length) return null;
          const l = r.join(": ");
          e.ui.showNotification({ message: l, duration: "short" });
        })(t, e, s);
      }),
    [t, e, s]
  );
  const i = (e) => {
    n.removeNotification(e.id), e.onDismiss?.();
  };
  return (0, D4.jsx)(jv.Container, {
    children: n.notifications.map((e) => {
      const t = (function (e) {
          if (null == e) return F4.medium;
          if ("string" == typeof e)
            return Object.keys(F4).includes(e) ? F4[e] : F4.medium;
          return e;
        })(e.duration),
        n = s(e.message, { defaultValue: e.message });
      return (0, D4.jsx)(
        jv.Item,
        {
          "data-cy": "notification",
          name: e.id,
          type: "loading" === e.type ? "info" : e.type,
          loading: "loading" === e.type,
          timeoutAction: () => {
            i(e);
          },
          timeoutDelay: t,
          onClick: () => {
            i(e);
          },
          action: e.action
            ? {
                label: s(e.action?.label, { defaultValue: e.action?.label }),
                onClick: () => {
                  e.action?.onClick({ id: e.id });
                },
              }
            : undefined,
          ariaLabelCloseButton: s("common.close"),
          children: n,
        },
        e.id
      );
    }),
  });
});

export var U4 = WithEngineComp(function ({
  children: e,
  engine: t,
  condition: n,
}) {
  return ("function" == typeof n ? n(t) : n)
    ? (0, N4.jsx)(N4.Fragment, { children: e })
    : null;
});

export var storageUnits = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
export var q4 = (e) => e.toLocaleString("en");

export var Z4 = (e, t) => {
  let n = "";
  if (t) {
    n = `${((e) => {
      let t = e;
      if (!Number.isFinite(t))
        throw new TypeError(`Expected a finite number, got ${typeof t}: ${t}`);
      if (0 === t) return " 0 B";
      if (t < 1) return `${q4(t)} B`;
      const n = Math.min(Math.floor(Math.log10(t) / 3), storageUnits.length - 1);
      return (t = Number((t / 1e3 ** n).toPrecision(3))), `${q4(t)} ${storageUnits[n]}`;
    })(t.reduce((e, t) => e + t.size, 0))}`;
  }
  return (0, G4.jsxs)(G4.Fragment, {
    children: [
      (0, G4.jsx)(HI, { level: 1, children: e }),
      (0, G4.jsx)("p", { children: n }),
    ],
  });
};
export var W4 = function () {
  const { t: e } = ZL(),
    {
      upload: t,
      uploadProgress: n,
      uploadError: s,
    } = (0, qI.useContext)(UploadContext),
    i = useSetUploadContext(),
    o = () => {
      i.setUpload(undefined),
        i.setUploadError(undefined),
        i.setUploadProgress(undefined);
    },
    r = (0, z4.useMemo)(() => {
      if (!t) return "";
      switch (true) {
        case t.every((e) => e.type.startsWith("image")):
          return e("input.uploadImage");
        case t.every((e) => e.type.startsWith("video")):
          return e("input.uploadVideo");
        case t.every((e) => e.type.startsWith("audio")):
          return e("input.uploadAudio");
        default:
          return e("input.uploadFiles");
      }
    }, [t, e]);
  if (s) {
    const t = e("common.back"),
      n = e("error.upload"),
      i = e("error.upload.description");
    return (0, G4.jsx)(Yw, {
      show: true,
      onClose: o,
      type: "error",
      "aria-label": i,
      clickOutsideToClose: false,
      footer: (0, G4.jsx)(Yw.Footer, {
        children: (0, G4.jsx)(CompCustomButton, {
          name: "upload-error-button-close",
          onClick: o,
          "aria-label": t,
          children: t,
        }),
      }),
      children: (0, G4.jsxs)("div", {
        className: Q4,
        children: [
          (0, G4.jsx)(HI, { level: 1, children: n }),
          (0, G4.jsx)("p", { children: i }),
          (0, G4.jsx)("p", { children: s }),
        ],
      }),
    });
  }
  return (0, G4.jsx)(Yw, {
    type: "loading",
    progress: n ?? "indeterminate",
    show: !!t,
    "aria-label": r,
    clickOutsideToClose: false,
    "data-cy": "uploadingFile",
    children: (0, G4.jsx)("div", { className: Q4, children: Z4(r, t) }),
  });
};
export var K4 = W4;

export var f3 = function (e, t, n, s) {
  const i = t.scene.getMode();
  let o = (0, p3.default)(
    ((e) => {
      if (1 !== e.selectedBlocks.length) return [];
      const [t] = e.selectedBlocks;
      return "//ly.img.ubq/fill/image" === t.fillType
        ? [ImageLibraryConfig.id]
        : "//ly.img.ubq/fill/video" === t.fillType
        ? [VideoLibraryConfig.id]
        : "//ly.img.ubq/audio" === t.blockType
        ? [AudioLibraryConfig.id]
        : [];
    })(s)
  );
  o = o.filter((t) => {
    const n = e.ui.getAssetLibraryEntry(t);
    return null != n && (null == n.sceneMode || n.sceneMode === i);
  });
  let r = o;
  return (
    null != n.replaceAssetLibraryEntries &&
      (r = n.replaceAssetLibraryEntries({
        selectedBlocks: s.selectedBlocks,
        defaultEntryIds: o,
      })),
    r.map((t) => e.ui.getAssetLibraryEntry(t)).filter(GK)
  );
};
export var h3 = function () {
  const e = VO(),
    t = XR(),
    [n, s] = eI(e.engine, (n) => {
      const s = n.block
        .findAllSelected()
        .map((e) => {
          if (!n.block.isValid(e)) return;
          const t = n.block.supportsFill(e) ? n.block.getFill(e) : undefined,
            s =
              null != t && n.block.isValid(t) ? n.block.getType(t) : undefined;
          return { id: e, blockType: n.block.getType(e), fillType: s };
        })
        .filter(GK);
      return [f3(e, n, t, { selectedBlocks: s }), n.asset.findAllSources()];
    });
  return ZK(n, e.engine, s);
};

export var g3 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, children: t }) {
    const n = XR(),
      [s, i] = BQ("//ly.img.panel/assetLibrary.replace", n),
      [o] = BQ("//ly.img.panel/assetLibrary", n),
      r = rI(SH),
      a = h3(),
      l = null != a && a.length > 0,
      c = oI("ui/replaceAssetOnSelect"),
      u = e.block.findAllSelected(),
      d = (0, d3.useMemo)(
        () =>
          u.some((t) => {
            const n = e.block.hasFill(t) ? e.block.getFill(t) : undefined,
              s =
                e.block.hasPlaceholderBehavior(t) &&
                e.block.isPlaceholderBehaviorEnabled(t),
              i =
                undefined !== n &&
                e.block.isValid(n) &&
                e.block.hasPlaceholderBehavior(n) &&
                e.block.isPlaceholderBehaviorEnabled(n);
            return (
              e.block.isValid(t) && e.block.isPlaceholderEnabled(t) && (s || i)
            );
          }),
        [e.block, u]
      ),
      p = ov((t) => {
        const n = t && c && l && !o;
        n && i(true);
        const s = e.block.onClicked((e) => {
          n && !o && u.includes(e) && i(true);
        });
        return () => {
          i(false), s();
        };
      });
    return (
      (0, d3.useEffect)(() => p(r && d), [r, d, p]),
      (0, m3.jsx)(m3.Fragment, {
        children: t({
          canReplace: r && l,
          replaceAssetLibraryPanelOpen: s,
          setReplaceAssetLibraryPanelOpen: i,
        }),
      })
    );
  })
);
export var x3 = {
  audioTitle: "UBQ_Clip-module__audioTitle--WdlTU",
  ghost: "UBQ_Clip-module__ghost--tCq5-",
};

export var j3 = WithEngineComp(function ({
  engine: e,
  block: t,
  height: n,
  timeBegin: s,
  timeEnd: i,
  pixelRatio: o,
  action: r,
}) {
  const a = (0, b3.useRef)(null),
    [l, c] = P3(),
    [u, d] = (0, b3.useState)(true),
    p = (0, b3.useCallback)((e, t, n, s) => {
      (e.fillStyle = "hsla(338, 64%, 51%, 1)"), e.fillRect(t, 0, n, s);
    }, []),
    f = ov(() => {
      const s = a.current;
      if (!e.block.isValid(t) || !s) return;
      if ("//ly.img.ubq/graphic" !== e.block.getType(t)) return;
      const i = e.block.getDuration(t),
        r = e.block.getFrameWidth(t),
        u = e.block.getFrameHeight(t),
        f = Math.floor(r / (u / n)),
        h = i * o,
        m = Math.ceil(h / f),
        g = s.getContext("2d"),
        x = document.createElement("canvas"),
        b = x.getContext("2d");
      (x.width = m * f),
        (x.height = n),
        c(),
        l(() =>
          e.block.generateVideoThumbnailSequence(t, n, 0, i, m, (e, t) => {
            const i = e * f;
            t instanceof Error
              ? b && p(b, i, f, n)
              : (b?.putImageData(t, i, 0),
                e === m - 1 &&
                  ((s.width = x.width),
                  (s.height = x.height),
                  g?.drawImage(x, 0, 0),
                  d(false)));
          })
        );
    });
  (0, b3.useEffect)(() => {
    d(true), f();
  }, [f, o, n]);
  const h = (0, b3.useRef)(s),
    m = (0, b3.useRef)(i);
  (0, b3.useEffect)(() => {
    ("start-trimming" !== r && "idle" !== r) ||
      ((h.current = s), (m.current = i));
    const e = s !== h.current || i !== m.current;
    "trimming" === r && e && d(true);
  }, [r, s, i]),
    (0, b3.useEffect)(() => e.editor.onHistoryUpdated(f), [e.editor, f]);
  const g = (h.current, (h.current - s) * o);
  return (0, C3.jsxs)(C3.Fragment, {
    children: [
      (0, C3.jsx)(L3, { isLoading: u }),
      (0, C3.jsx)("canvas", {
        className: y3,
        ref: a,
        style: { left: "trimming" === r || u ? g : 0 },
      }),
    ],
  });
});
export var S3 = WithEngineComp(function ({
  engine: e,
  block: t,
  height: n,
  pixelRatio: s,
}) {
  const i = (0, b3.useRef)(null),
    [o, r] = P3(),
    [a, l] = (0, b3.useState)(true),
    c = (0, b3.useCallback)((e, t, n, s) => {
      const o = e.getContext("2d");
      if (!o || !i.current) return;
      (o.fillStyle = "hsla(338, 64%, 51%, 1)"), o.fillRect(t, 0, n, s);
      const r = e.toDataURL();
      (i.current.style.backgroundImage = `url(${r})`),
        (i.current.style.backgroundSize = `${n}px ${s}px`);
    }, []),
    u = ov(() => {
      if (!e.block.isValid(t)) return;
      const a = e.block.getType(t);
      if ("//ly.img.ubq/text" !== a && "//ly.img.ubq/graphic" !== a) return;
      const u = document.createElement("canvas"),
        d = u.getContext("2d"),
        p = e.block.getFrameWidth(t),
        f = e.block.getFrameHeight(t),
        h = Math.floor(p / (f / n));
      (u.width = h),
        (u.height = n),
        r(),
        o(() =>
          e.block.generateVideoThumbnailSequence(t, n, 0, h / s, 1, (e, t) => {
            const s = e * h;
            if (t instanceof Error) return void c(u, s, h, n);
            if (!i.current) return;
            d?.putImageData(t, s, 0);
            const o = u.toDataURL();
            (i.current.style.backgroundImage = `url(${o})`),
              (i.current.style.backgroundSize = `${h}px ${n}px`),
              l(false);
          })
        );
    });
  return (
    (0, b3.useEffect)(() => {
      l(true), u();
    }, [u, n]),
    (0, b3.useEffect)(() => e.editor.onHistoryUpdated(u), [e.editor, u]),
    (0, C3.jsxs)(C3.Fragment, {
      children: [
        (0, C3.jsx)(L3, { isLoading: a }),
        (0, C3.jsx)("span", { className: v3, ref: i }),
      ],
    })
  );
});
export function _3() {
  const e = `${FI().ui.baseURL}audio-wave.svg`;
  return (0, C3.jsx)("span", {
    className: w3,
    style: { maskImage: `url(${e})`, WebkitMaskImage: `url(${e})` },
  });
}
export var E3 = {
  idle: { x: "-100%", opacity: 0 },
  loading: {
    opacity: 1,
    x: ["-100%", "100%"],
    transition: { duration: 1.8, repeat: 1 / 0, repeatDelay: 0.3, ease: Ur },
  },
};
export function L3({ isLoading: e }) {
  return (0, C3.jsx)(Sd.span, {
    className: k3,
    variants: E3,
    initial: "idle",
    animate: e ? "loading" : "idle",
  });
}
export function P3() {
  const e = (0, b3.useRef)([]),
    t = (0, b3.useCallback)((t) => {
      let n = false;
      const s = t();
      return (
        e.current.push(() => {
          n || ((n = true), s());
        }),
        s
      );
    }, []),
    n = (0, b3.useCallback)(() => {
      e.current.forEach((e) => e()), (e.current = []);
    }, []);
  return (0, b3.useEffect)(() => () => n(), [n]), [t, n];
}
export var B3 = WithEngineComp(function ({
  engine: e,
  block: t,
  maxDuration: n,
  trimOffset: s,
  clipType: i = "foreGround",
  ...o
}) {
  if (!e.block.isValid(t)) return null;
  const r = e.block.getType(t);
  let a = false,
    l = false;
  switch (
    (null != s &&
      null != n &&
      ((a = 0 === s), (l = fO(o.timeEnd, o.timeBegin + (n - s), 1e-4))),
    r)
  ) {
    case "//ly.img.ubq/graphic":
    case "//ly.img.ubq/text":
      return (0, A3.jsx)(T3, {
        block: t,
        limitReachedLeft: a,
        limitReachedRight: l,
        maxDuration: n,
        trimOffset: s,
        clipType: i,
        ...o,
      });
    case "//ly.img.ubq/audio":
      return (0, A3.jsx)(M3, {
        block: t,
        limitReachedLeft: a,
        limitReachedRight: l,
        maxDuration: n,
        trimOffset: s,
        clipType: i,
        ...o,
      });
    default:
      return null;
  }
});
export var T3 = WithEngineComp(function ({
  engine: e,
  clips: t,
  block: n,
  moveRef: s,
  trimLeftRef: i,
  trimRightRef: o,
  pixelRatio: r,
  timeBegin: a,
  timeEnd: l,
  limitReachedLeft: c,
  limitReachedRight: u,
  clipType: d,
  height: p,
  action: f,
}) {
  const { t: h } = ZL(),
    m = e.block.isAllowedByScope(n, BH),
    g = l - a,
    x = e.block.supportsFill(n) ? e.block.getFill(n) : undefined,
    b =
      null != x &&
      e.block.isValid(x) &&
      "//ly.img.ubq/fill/video" === e.block.getType(x),
    y = !!b && e.block.isMuted(x),
    v = e.block.supportsAnimation(n),
    w = v ? e.block.getInAnimation(n) : undefined,
    k = v ? e.block.getOutAnimation(n) : undefined,
    C = v ? e.block.getLoopAnimation(n) : undefined,
    j = null != w && e.block.isValid(w),
    S = null != k && e.block.isValid(k),
    _ = null != C && e.block.isValid(C),
    E = j || S || _,
    { timeString: L } = xS(g, true);
  return (0, A3.jsxs)(TE, {
    id: `clip-${n}`,
    className: x3.block,
    isSelected: e.block.isSelected(n),
    moveRef: m ? s : undefined,
    onPointerDown: (t) => {
      if (!m) return;
      const s = e.block.isSelected(n),
        i = e.block.findAllSelected().length > 1;
      t.shiftKey ? e.block.setSelected(n, !s) : (s && !i) || e.block.select(n);
    },
    children: [
      m &&
        (0, A3.jsx)(TE.TrimHandles, {
          show: "both",
          trimLeftRef: i,
          trimRightRef: o,
          limitReachedLeft: c,
          limitReachedRight: u,
        }),
      (0, A3.jsxs)(TE.Meta, {
        children: [
          (0, A3.jsx)(TE.MetaLabel, { show: "selected", children: L }),
          E && (0, A3.jsx)(TE.MetaIcon, { children: (0, A3.jsx)(hG, {}) }),
          y && (0, A3.jsx)(TE.MetaIcon, { children: (0, A3.jsx)(Q5, {}) }),
          (() => {
            const t = e.block.getType(n),
              s = null != x && e.block.isValid(x) ? e.block.getType(x) : null,
              i = e.block.hasShape(n) ? e.block.getShape(n) : null,
              o = null != i && e.block.isValid(i) ? e.block.getType(i) : null;
            switch (true) {
              case "//ly.img.ubq/text" === t:
                return (0, A3.jsx)(TE.MetaIcon, {
                  children: (0, A3.jsx)(IconFontT, {}),
                });
              case "//ly.img.ubq/fill/video" === s:
                return (0, A3.jsx)(TE.MetaIcon, {
                  children: (0, A3.jsx)(IconPlayOutline, {}),
                });
              case "//ly.img.ubq/fill/image" === s &&
                "sticker" === e.block.getKind(n):
                return (0, A3.jsx)(TE.MetaIcon, {
                  children: (0, A3.jsx)(IconSticker, {}),
                });
              case "//ly.img.ubq/fill/image" === s:
                return (0, A3.jsx)(TE.MetaIcon, {
                  children: (0, A3.jsx)(IconPhoto, {}),
                });
              case null != o:
                return (0, A3.jsxs)(A3.Fragment, {
                  children: [
                    (0, A3.jsx)(TE.MetaIcon, {
                      children: (0, A3.jsx)(IconShapes, {}),
                    }),
                    (0, A3.jsx)(TE.MetaLabel, { children: V3(h, o) }),
                  ],
                });
              default:
                return null;
            }
          })(),
        ],
      }),
      (0, A3.jsx)(TE.Atlas, {
        children: b
          ? (0, A3.jsx)(j3, {
              block: n,
              height: p,
              pixelRatio: r,
              timeBegin: a,
              timeEnd: l,
              action: f,
            })
          : (0, A3.jsx)(S3, {
              block: n,
              height: p,
              pixelRatio: r,
              timeBegin: a,
              timeEnd: l,
              action: f,
            }),
      }),
      (0, A3.jsx)(O3, { clips: t, block: n, clipType: d }),
    ],
  });
});
export var M3 = WithEngineComp(function ({
  engine: e,
  clips: t,
  block: n,
  moveRef: s,
  trimLeftRef: i,
  trimRightRef: o,
  timeBegin: r,
  timeEnd: a,
  limitReachedLeft: l,
  limitReachedRight: c,
  clipType: u,
}) {
  const d = e.block.isAllowedByScope(n, BH),
    p = a - r,
    f = e.block.isMuted(n),
    { timeString: h } = xS(p, true),
    m = e.block.getName(n),
    g = e.block.getString(n, "audio/fileURI"),
    x = (0, u3.useMemo)(
      () =>
        m ||
        (function (e) {
          const [t] = e.match(D3) ?? [];
          return t;
        })(g),
      [m, g]
    );
  return (0, A3.jsxs)(TE, {
    id: `clip-${n}`,
    isSelected: e.block.isSelected(n),
    moveRef: d ? s : undefined,
    onPointerDown: (t) => {
      if (!d) return;
      const s = e.block.isSelected(n),
        i = e.block.findAllSelected().length > 1;
      t.shiftKey ? e.block.setSelected(n, !s) : (s && !i) || e.block.select(n);
    },
    children: [
      d &&
        (0, A3.jsx)(TE.TrimHandles, {
          show: "both",
          trimLeftRef: i,
          trimRightRef: o,
          limitReachedLeft: l,
          limitReachedRight: c,
        }),
      (0, A3.jsxs)(TE.Meta, {
        children: [
          (0, A3.jsx)(TE.MetaLabel, { show: "selected", children: h }),
          f && (0, A3.jsx)(TE.MetaIcon, { children: (0, A3.jsx)(Q5, {}) }),
          (0, A3.jsx)(TE.MetaIcon, { children: (0, A3.jsx)(IconMusic, {}) }),
          (0, A3.jsxs)(TE.MetaLabel, {
            children: [
              (0, A3.jsx)("span", { children: "Title" }),
              (0, A3.jsx)("span", { children: "  " }),
              (0, A3.jsx)("span", { className: x3.audioTitle, children: x }),
            ],
          }),
        ],
      }),
      (0, A3.jsx)(TE.Atlas, { children: (0, A3.jsx)(_3, {}) }),
      (0, A3.jsx)(O3, { clips: t, block: n, clipType: u }),
    ],
  });
});
export var O3 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, block: t, clips: n, clipType: s }) {
    const i = VO(),
      o = DO(),
      { focusSelectedElement: r } = xI(),
      { getScope: a } = useShortcutScope(),
      { t: l } = ZL(),
      c = IV(),
      u = i.feature.isEnabled("ly.img.duplicate", { engine: e }),
      d = e.block.isAllowedByScope(t, AH),
      p = i.feature.isEnabled("ly.img.delete", { engine: e }),
      f = e.block.isAllowedByScope(t, PH),
      h = i.feature.isEnabled("ly.img.replace", { engine: e }),
      m = e.block.isAllowedByScope(t, SH),
      g = i.feature.isEnabled("ly.img.placeholder", { engine: e }),
      x = oI("ui/placeholder"),
      b = e.block.getType(t),
      y = e.block.supportsFill(t) ? e.block.getFill(t) : undefined,
      v = null != y && e.block.isValid(y) ? e.block.getType(y) : undefined,
      w = "sticker" === e.block.getKind(t),
      k =
        "//ly.img.ubq/graphic" === b &&
        ("//ly.img.ubq/fill/image" === v || "//ly.img.ubq/fill/video" === v) &&
        !w,
      C = e.block.hasPlaybackControl(t),
      j = null != y && e.block.hasPlaybackControl(y),
      S = (C && e.block.isMuted(t)) || (j && e.block.isMuted(y)),
      _ = e.block.hasTrim(t),
      E = null != y && e.block.hasTrim(y),
      L = n.indexOf(t),
      P = 0 === L,
      A = L === n.length - 1,
      B = (!u || !d) && (!p || !f) && (!h || !m) && (!g || !x) && P && A;
    return (0, A3.jsx)(g3, {
      children: ({
        replaceAssetLibraryPanelOpen: n,
        setReplaceAssetLibraryPanelOpen: i,
        canReplace: b,
      }) =>
        (0, A3.jsx)(TE.ContextMenu, {
          name: "clip-options",
          show: "hover",
          onPointerUp: (e) => {
            e.stopPropagation();
            const t = new PointerEvent("pointerup", {
              clientX: e.clientX,
              clientY: e.clientY,
            });
            window.dispatchEvent(t);
          },
          isDisabled: B,
          closeOnWheel: true,
          returnFocus: a(AI)?.element,
          children: ({ closePopover: a }) =>
            (0, A3.jsxs)(A3.Fragment, {
              children: [
                "background" === s
                  ? (0, A3.jsxs)(A3.Fragment, {
                      children: [
                        (0, A3.jsx)(TE.ContextMenuItem, {
                          children: (0, A3.jsx)(CompCustomButton, {
                            name: "move-clip-left",
                            variant: "plain",
                            icon: (0, A3.jsx)(t3, {}),
                            onPointerUp: (e) => e.stopPropagation(),
                            onClick: () => {
                              const n = $V(e, t);
                              if (null == n) return;
                              const s = e.block.getChildren(n).indexOf(t);
                              e.block.insertChild(n, t, s - 1),
                                c("action.property.update"),
                                a();
                            },
                            isDisabled: P,
                            children: l("action.arrange.moveLeft"),
                          }),
                        }),
                        (0, A3.jsx)(TE.ContextMenuItem, {
                          children: (0, A3.jsx)(CompCustomButton, {
                            name: "move-clip-right",
                            variant: "plain",
                            icon: (0, A3.jsx)(OW, {}),
                            onPointerUp: (e) => e.stopPropagation(),
                            onClick: () => {
                              const n = $V(e, t);
                              if (null == n) return;
                              const s = e.block.getChildren(n).indexOf(t);
                              e.block.insertChild(n, t, s + 1),
                                c("action.property.update"),
                                a();
                            },
                            isDisabled: A,
                            children: l("action.arrange.moveRight"),
                          }),
                        }),
                      ],
                    })
                  : (0, A3.jsxs)(A3.Fragment, {
                      children: [
                        (0, A3.jsx)(TE.ContextMenuItem, {
                          children: (0, A3.jsx)(CompCustomButton, {
                            name: "bring-clip-forward",
                            variant: "plain",
                            icon: (0, A3.jsx)(a3, {}),
                            onPointerUp: (e) => e.stopPropagation(),
                            onClick: () => {
                              const n = e.scene.getCurrentPage();
                              if (!n) return;
                              const s = e.block.getChildren(n).indexOf(t);
                              e.block.insertChild(n, t, s + 1),
                                c("action.property.update"),
                                a();
                            },
                            isDisabled: P,
                            children: l("action.arrange.bringForward"),
                          }),
                        }),
                        (0, A3.jsx)(TE.ContextMenuItem, {
                          children: (0, A3.jsx)(CompCustomButton, {
                            name: "send-clip-backward",
                            variant: "plain",
                            icon: (0, A3.jsx)(c3, {}),
                            onPointerUp: (e) => e.stopPropagation(),
                            onClick: () => {
                              const n = e.scene.getCurrentPage();
                              if (!n) return;
                              const s = e.block.getChildren(n).indexOf(t);
                              e.block.insertChild(n, t, s - 1),
                                c("action.property.update"),
                                a();
                            },
                            isDisabled: A,
                            children: l("action.arrange.sendBackward"),
                          }),
                        }),
                      ],
                    }),
                "background" === s
                  ? (0, A3.jsxs)(A3.Fragment, {
                      children: [
                        (0, A3.jsx)(Sw, {}),
                        (0, A3.jsx)(TE.ContextMenuItem, {
                          children: (0, A3.jsx)(CompCustomButton, {
                            name: "set-as-overlay",
                            variant: "plain",
                            icon: (0, A3.jsx)(o3, {}),
                            onPointerUp: (e) => e.stopPropagation(),
                            onClick: () => {
                              const n = e.scene.getCurrentPage();
                              null != n &&
                                (e.block.appendChild(n, t),
                                e.block.setTimeOffset(
                                  t,
                                  e.block.getPlaybackTime(n)
                                ),
                                c("action.property.update"),
                                a());
                            },
                            children: l("action.setAsOverlay"),
                          }),
                        }),
                      ],
                    })
                  : null,
                "foreGround" === s && k
                  ? (0, A3.jsxs)(A3.Fragment, {
                      children: [
                        (0, A3.jsx)(Sw, {}),
                        (0, A3.jsx)(TE.ContextMenuItem, {
                          children: (0, A3.jsx)(CompCustomButton, {
                            name: "set-as-clip",
                            variant: "plain",
                            icon: (0, A3.jsx)(s3, {}),
                            onPointerUp: (e) => e.stopPropagation(),
                            onClick: () => {
                              const n = e.scene.getCurrentPage();
                              if (null == n) return;
                              const s = UV(e, n) ?? zV(e, n);
                              e.block.fillParent(t),
                                e.block.appendChild(s, t),
                                c("action.property.update"),
                                a();
                            },
                            children: l("action.setAsClip"),
                          }),
                        }),
                      ],
                    })
                  : null,
                C || j ? (0, A3.jsx)(Sw, {}) : null,
                C || j
                  ? (0, A3.jsx)(TE.ContextMenuItem, {
                      children: (0, A3.jsx)(CompCustomButton, {
                        name: "mute-clip-volume",
                        variant: "plain",
                        icon: S ? (0, A3.jsx)(Q5, {}) : (0, A3.jsx)($5, {}),
                        onPointerUp: (e) => e.stopPropagation(),
                        onClick: () => {
                          C
                            ? e.block.setMuted(t, !S)
                            : j && e.block.setMuted(y, !S),
                            a();
                        },
                        children: l(S ? "action.unmute" : "action.mute"),
                      }),
                    })
                  : null,
                _ || E
                  ? (0, A3.jsx)(TE.ContextMenuItem, {
                      children: (0, A3.jsx)(CompCustomButton, {
                        name: "trim-clip",
                        variant: "plain",
                        icon: (0, A3.jsx)(x5, {}),
                        onPointerUp: (e) => e.stopPropagation(),
                        onClick: () => {
                          e.editor.setEditMode("Trim"), a();
                        },
                        children: l("common.trim"),
                      }),
                    })
                  : null,
                (0, A3.jsx)(Sw, {}),
                h &&
                  b &&
                  !w &&
                  (0, A3.jsx)(TE.ContextMenuItem, {
                    children: (0, A3.jsx)(CompCustomButton, {
                      name: "replace-clip",
                      variant: "plain",
                      icon: (0, A3.jsx)(IY, {}),
                      onPointerUp: (e) => e.stopPropagation(),
                      onClick: () => {
                        e.editor.setEditMode("Transform"), a(), i(true);
                      },
                      disabled: n || !m,
                      children: l("common.replace"),
                    }),
                  }),
                g &&
                  (0, A3.jsx)(TE.ContextMenuItem, {
                    children: (0, A3.jsx)(iX.Button, {
                      variant: "plain",
                      isDisabled: !x,
                      children: l("component.placeholder.create"),
                    }),
                  }),
                u &&
                  (0, A3.jsx)(TE.ContextMenuItem, {
                    children: (0, A3.jsx)(CompCustomButton, {
                      name: "duplicate-clip",
                      variant: "plain",
                      icon: (0, A3.jsx)(SY, {}),
                      onPointerUp: (e) => e.stopPropagation(),
                      onClick: () => {
                        const n = e.block.duplicate(t);
                        "background" !== s && o.addOffsetToDesignElement(n),
                          e.block.select(n),
                          r(),
                          c("action.block.duplicate"),
                          a();
                      },
                      disabled: !d,
                      children: l("action.block.duplicate"),
                    }),
                  }),
                p &&
                  (0, A3.jsx)(TE.ContextMenuItem, {
                    children: (0, A3.jsx)(CompCustomButton, {
                      name: "delete-clip",
                      variant: "plain",
                      icon: (0, A3.jsx)(vZ, {}),
                      onPointerUp: (e) => e.stopPropagation(),
                      onClick: () => {
                        e.block.destroy(t), c("action.block.delete"), a();
                      },
                      disabled: !f,
                      children: l("common.delete"),
                    }),
                  }),
              ],
            }),
        }),
    });
  })
);
export function R3() {
  return (0, A3.jsx)("span", { className: x3.ghost });
}
export function V3(e, t) {
  return e(`block.${t.replace("//ly.img.ubq/shape/", "")}`);
}
export var D3 = new RegExp("[^/]*$");
export var F3 = B3;
export function I3() {
  const e = E$("--ubq-scale-base", (e) => C$(e, 4));
  return {
    scaleBase: e,
    marginBase: E$("--ubq-margin-base", (e) => C$(e, 4)),
    basePixelRatio: 10 * e,
    minZoomLevel: 0.25,
    maxZoomLevel: 30,
    clipMinDuration: 0.1,
    zeroPointOffset: 10 * e,
    clipHeight: 8 * e,
    audioClipHeight: 6 * e,
  };
}
export var N3 = function ({
  className: e,
  pixelRatio: t,
  totalDuration: n,
  clipMinDuration: s = 0,
  snapTimes: i,
}) {
  const o = I3(),
    r = YF(),
    a = IV(),
    { tracks: l, clips: c } = eI(r, () => {
      const e = r.scene.getCurrentPage(),
        t = e
          ? r.block
              .getChildren(e)
              .filter((e) => "//ly.img.ubq/audio" === r.block.getType(e))
          : [],
        n = [];
      for (const e of t.reverse()) {
        const t = r.block.unstable_isAVResourceLoaded(e);
        n.push({
          id: e,
          elements: [
            {
              id: e,
              start: r.block.getTimeOffset(e),
              duration: r.block.getDuration(e),
              ...(t && {
                maxDuration: r.block.getAVResourceTotalDuration(e),
                trimOffset: r.block.getTrimOffset(e),
              }),
            },
          ],
        });
      }
      return { tracks: n, clips: t };
    }),
    [u, d] = (0, J4.useState)(null);
  return (
    (0, J4.useEffect)(() => {
      d(null);
    }, [l]),
    (0, H3.jsx)("div", {
      className: e,
      style: { width: n ? n * t : 0 },
      children: (0, H3.jsx)(X_, {
        pxPerSec: t,
        elementHeight: o.audioClipHeight,
        minElementDuration: s,
        tracks: u ?? l,
        onChange: (e) => {
          const t = r.scene.getCurrentPage();
          if (null == t) return;
          d(e);
          const n = e.concat().reverse();
          for (const [e, s] of n.entries()) {
            const n = s.elements[0];
            r.block.insertChild(t, n.id, e),
              r.block.setTimeOffset(n.id, n.start),
              r.block.setDuration(n.id, n.duration);
            r.block.unstable_isAVResourceLoaded(n.id) &&
              null != n.trimOffset &&
              (r.block.setTrimOffset(n.id, n.trimOffset),
              r.block.setTrimLength(n.id, n.duration));
          }
          a("action.property.update");
        },
        renderGhost: R3,
        snapTimes: i,
        onActionChange: (e) => {
          if ("start-moving" === e || "start-trimming" === e) {
            const e = r.scene.getCurrentPage();
            null != e && r.block.isPlaying(e) && r.block.setPlaying(e, false);
          }
        },
        renderContent: ({
          element: e,
          timeBegin: t,
          timeEnd: n,
          pxPerSec: s,
          height: i,
          moveRef: o,
          trimLeftRef: r,
          trimRightRef: a,
          action: l,
        }) =>
          (0, H3.jsx)(F3, {
            clips: c,
            block: e.id,
            pixelRatio: s,
            timeBegin: t,
            timeEnd: n,
            height: i,
            moveRef: o,
            trimLeftRef: r,
            trimRightRef: a,
            maxDuration: e.maxDuration,
            trimOffset: e.trimOffset,
            action: l,
          }),
      }),
    })
  );
};

export var q3 = function ({
  scrollContainerRef: e,
  zeroPointOffset: t,
  onDrag: n,
  onDragStart: s,
  pixelRatio: i,
  totalDuration: o,
}) {
  const r = YF(),
    {
      currentPage: a,
      playbackTime: l,
      isPlaying: c,
    } = eI(r, () => {
      const e = r.scene.getCurrentPage();
      return {
        currentPage: e,
        playbackTime: e ? r.block.getPlaybackTime(e) : 0,
        isPlaying: !!e && r.block.isPlaying(e),
      };
    });
  return (
    (0, U3.useEffect)(() => {
      const n = e.current;
      if (!n || !c || null == a) return;
      const s = (n.clientWidth - t) / i,
        o = s + n.scrollLeft / i;
      l > o - 0.08 * s && (n.scrollLeft = l * i),
        l < n.scrollLeft / i && (n.scrollLeft = l * i);
    }, [a, c, i, l, e, t]),
    (0, $3.jsx)(IE, {
      className: z3,
      pixelRatio: i,
      totalDuration: o,
      zeroPointOffset: t,
      playbackTime: l,
      onDragStart: s,
      onDrag: n,
    })
  );
};

export var G3 = function ({
  className: e,
  pixelRatio: t,
  totalDuration: n,
  clipMinDuration: s = 0,
  snapTimes: i,
}) {
  const o = I3(),
    r = YF(),
    a = IV(),
    { tracks: l, clips: c } = eI(r, () => {
      const e = r.scene.getCurrentPage(),
        t = null != e ? UV(r, e) : undefined,
        n = null != t ? r.block.getChildren(t) : [];
      if (null == t || 0 === n.length) return { tracks: [], clips: [] };
      const s = { id: t, elements: [] };
      for (const e of n) {
        const t = r.block.getFill(e),
          n =
            "//ly.img.ubq/fill/video" ===
              (r.block.isValid(t) ? r.block.getType(t) : undefined) &&
            r.block.unstable_isAVResourceLoaded(t);
        s.elements.push({
          id: e,
          start: r.block.getTimeOffset(e),
          duration: r.block.getDuration(e),
          ...(n && {
            maxDuration: r.block.getAVResourceTotalDuration(t),
            trimOffset: r.block.getTrimOffset(t),
          }),
        });
      }
      return { tracks: [s], clips: n };
    });
  return 0 === l.length
    ? null
    : (0, Q3.jsx)("div", {
        className: e,
        style: { width: n ? n * t : 0 },
        children: (0, Q3.jsx)(X_, {
          pxPerSec: t,
          elementHeight: o.clipHeight,
          minElementDuration: s,
          tracks: l,
          packed: true,
          onChange: (e) => {
            const t = r.scene.getCurrentPage(),
              n = null != t ? UV(r, t) : undefined;
            if (null == n) return;
            const s = e[0];
            for (const [e, t] of s.elements.entries()) {
              r.block.insertChild(n, t.id, e),
                r.block.setTimeOffset(t.id, t.start),
                r.block.setDuration(t.id, t.duration);
              const s = r.block.getFill(t.id);
              r.block.isValid(s) &&
                r.block.hasTrim(s) &&
                r.block.unstable_isAVResourceLoaded(s) &&
                null != t.trimOffset &&
                (r.block.setTrimOffset(s, t.trimOffset),
                r.block.setTrimLength(s, t.duration));
            }
            a("action.property.update");
          },
          renderGhost: R3,
          snapTimes: i,
          onActionChange: (e) => {
            if ("start-moving" === e || "start-trimming" === e) {
              const e = r.scene.getCurrentPage();
              null != e && r.block.isPlaying(e) && r.block.setPlaying(e, false);
            }
          },
          renderContent: ({
            element: e,
            timeBegin: t,
            timeEnd: n,
            pxPerSec: s,
            height: i,
            moveRef: o,
            trimLeftRef: r,
            trimRightRef: a,
            action: l,
          }) =>
            (0, Q3.jsx)(F3, {
              clips: c,
              block: e.id,
              pixelRatio: s,
              timeBegin: t,
              timeEnd: n,
              height: i,
              moveRef: o,
              trimLeftRef: r,
              trimRightRef: a,
              maxDuration: e.maxDuration,
              trimOffset: e.trimOffset,
              clipType: "background",
              action: l,
            }),
        }),
      });
};

export var K3 = function ({
  className: e,
  pixelRatio: t,
  totalDuration: n,
  clipMinDuration: s = 0,
  snapTimes: i,
}) {
  const o = I3(),
    r = YF(),
    a = IV(),
    { tracks: l, clips: c } = eI(r, () => {
      const e = r.scene.getCurrentPage(),
        t = e
          ? r.block.getChildren(e).filter((e) => {
              const t = r.block.getType(e);
              return "//ly.img.ubq/graphic" === t || "//ly.img.ubq/text" === t;
            })
          : [],
        n = [];
      for (const e of t.reverse()) {
        const t = r.block.getFill(e),
          s =
            "//ly.img.ubq/fill/video" ===
              (r.block.isValid(t) ? r.block.getType(t) : undefined) &&
            r.block.unstable_isAVResourceLoaded(t);
        n.push({
          id: e,
          elements: [
            {
              id: e,
              start: r.block.getTimeOffset(e),
              duration: r.block.getDuration(e),
              ...(s && {
                maxDuration: r.block.getAVResourceTotalDuration(t),
                trimOffset: r.block.getTrimOffset(t),
              }),
            },
          ],
        });
      }
      return { tracks: n, clips: t };
    }),
    [u, d] = (0, Z3.useState)(null);
  return (
    (0, Z3.useEffect)(() => {
      d(null);
    }, [l]),
    (0, W3.jsx)("div", {
      className: e,
      style: { width: n ? n * t : 0 },
      children: (0, W3.jsx)(X_, {
        pxPerSec: t,
        elementHeight: o.clipHeight,
        minElementDuration: s,
        tracks: u || l,
        onChange: (e) => {
          d(e);
          const t = r.scene.getCurrentPage();
          if (null == t) return;
          const n = e.concat().reverse();
          for (const [e, s] of n.entries()) {
            const n = s.elements[0];
            r.block.insertChild(t, n.id, e),
              r.block.setTimeOffset(n.id, n.start),
              r.block.setDuration(n.id, n.duration);
            const i = r.block.getFill(n.id);
            r.block.isValid(i) &&
              r.block.hasTrim(i) &&
              r.block.unstable_isAVResourceLoaded(i) &&
              null != n.trimOffset &&
              (r.block.setTrimOffset(i, n.trimOffset),
              r.block.setTrimLength(i, n.duration));
          }
          a("action.property.update");
        },
        renderGhost: R3,
        snapTimes: i,
        onActionChange: (e) => {
          if ("start-moving" === e || "start-trimming" === e) {
            const e = r.scene.getCurrentPage();
            null != e && r.block.isPlaying(e) && r.block.setPlaying(e, false);
          }
        },
        renderContent: ({
          element: e,
          timeBegin: t,
          timeEnd: n,
          pxPerSec: s,
          height: i,
          moveRef: o,
          trimLeftRef: r,
          trimRightRef: a,
          action: l,
        }) =>
          (0, W3.jsx)(F3, {
            clips: c,
            block: e.id,
            pixelRatio: s,
            timeBegin: t,
            timeEnd: n,
            height: i,
            moveRef: o,
            trimLeftRef: r,
            trimRightRef: a,
            maxDuration: e.maxDuration,
            trimOffset: e.trimOffset,
            action: l,
          }),
      }),
    })
  );
};
export var c7 = {
  block: "UBQ_VideoTimelineControls-module__block--51LSm",
  group: "UBQ_VideoTimelineControls-module__group--O98jr",
  playbackControls: "UBQ_VideoTimelineControls-module__playbackControls--tTdue",
  playbackInfo: "UBQ_VideoTimelineControls-module__playbackInfo--qBo24",
  zoomControls: "UBQ_VideoTimelineControls-module__zoomControls--sMM4p",
  expandButton: "UBQ_VideoTimelineControls-module__expandButton--MRale",
};

export var d7 = WithEngineComp(function ({ engine: e, page: t }) {
  const n = i4(t);
  return e.block.isValid(e.block.getFill(t))
    ? (0, u7.jsx)(w0, {
        block: t,
        name: "background-color",
        panelId: "//ly.img.panel/inspector/background/color",
        i18nLabelString: "property.backgroundColor",
        i18nDescriptionString: "property.backgroundColor.description",
        inBar: true,
        ...n,
      })
    : null;
});
export var p7 = WithEngineComp(function ({ engine: e, page: t }) {
  const n = I3(),
    { t: s } = ZL(),
    i = IV(),
    o = e.block.findAllSelected()[0],
    r = null != o ? e.block.getType(o) : undefined,
    a =
      "//ly.img.ubq/graphic" === r ||
      "//ly.img.ubq/text" === r ||
      "//ly.img.ubq/audio" === r,
    l = null != o && e.block.hasTrim(o),
    c = l && e.block.unstable_isAVResourceLoaded(o),
    u = null != o && e.block.hasFill(o) ? e.block.getFill(o) : undefined,
    d = null != u && e.block.isValid(u) && e.block.hasTrim(u),
    p = d && e.block.unstable_isAVResourceLoaded(u),
    f = a ? e.block.getTimeOffset(o) : 0,
    h = a ? e.block.getDuration(o) : 0,
    m = e.block.getPlaybackTime(t),
    g = m > f + n.clipMinDuration && m < f + h - n.clipMinDuration;
  return (0, u7.jsx)(Ly, {
    label: s("action.splitClip.description"),
    children: (0, u7.jsx)(CompCustomButton, {
      name: "split-clip",
      variant: "plain",
      icon: (0, u7.jsx)(i7, {}),
      onClick: async function () {
        if (!g || !o) return;
        const n = $V(e, o) ?? t,
          s = e.block.getPlaybackTime(t),
          r = e.block.getChildren(n).indexOf(o);
        if (-1 === r) return;
        const a = s - f,
          c = e.block.duplicate(o);
        if (
          (e.block.setTimeOffset(c, s),
          e.block.setDuration(c, h - a),
          e.block.setDuration(o, a),
          e.block.insertChild(n, c, r + 1),
          e.block.select(c),
          l)
        ) {
          e.block.setTrimLength(o, a);
          const t = e.block.getTrimOffset(o);
          e.block.setTrimOffset(c, t + a), e.block.setTrimLength(c, h - a);
        }
        if (d) {
          e.block.setTrimLength(u, a);
          const t = e.block.getTrimOffset(u);
          e.block.setTrimOffset(e.block.getFill(c), t + a),
            e.block.setTrimLength(e.block.getFill(c), h - a);
        }
        i("action.splitClip");
      },
      disabled: !g || (l && !c) || (d && !p),
      children: s("action.splitClip"),
    }),
  });
});
export var f7 = WithEngineComp(function ({ engine: e, page: t }) {
  const n = e.block.getDuration(t),
    s = xS(e.block.getPlaybackTime(t), true),
    i = xS(n, true);
  return (0,
  u7.jsxs)("span", { className: c7.playbackInfo, children: [(0, u7.jsx)("time", { dateTime: s.periodString, "data-cy": "timelinePlaybackInfo-playbackTime", children: s.timeString }), (0, u7.jsx)("span", { children: " / " }), (0, u7.jsx)("time", { dateTime: i.periodString, "data-cy": "timelinePlaybackInfo-totalDuration", children: i.timeString })] });
});
export var h7 = WithEngineComp(function ({ engine: e, page: t }) {
  const { t: n } = ZL(),
    s = e.block.isPlaying(t),
    i = e.block.getDuration(t),
    o = (0, l7.useCallback)(() => {
      s ||
        e.block.isLooping(t) ||
        e.block.getPlaybackTime(t) !== e.block.getDuration(t) ||
        e.block.setPlaybackTime(t, 0),
        e.block.setPlaying(t, !s);
    }, [e, s, t]);
  return (
    (function (e, t) {
      const n = ov(t),
        { registerShortcut: s, unregisterShortcut: i } = useShortcutScope();
      (0, bI.useEffect)(() => {
        const t = s(e, n);
        return () => {
          i(e, t);
        };
      }, [s, e, n, i]);
    })(BI, (e, t) => {
      const n = t instanceof HTMLInputElement,
        s = t instanceof HTMLTextAreaElement,
        r = t instanceof HTMLElement && t.isContentEditable,
        a = t instanceof HTMLButtonElement,
        l = a && "-1" === t.getAttribute("data-ubq-canvas-layer-id"),
        c = n || s || r || (a && !l);
      " " === e.key && i > 0 && !c && o();
    }),
    (0, l7.useEffect)(
      () =>
        e.editor.onHistoryUpdated(() => {
          s && e.block.setPlaying(t, false);
        }),
      [e.block, e.editor, s, t]
    ),
    (0, u7.jsx)(Ly, {
      label: n(
        s
          ? "component.timeline.pause.description"
          : "component.timeline.play.description"
      ),
      children: (0, u7.jsx)(VS, {
        name: "play-button",
        "data-cy": "timelinePlayButton",
        size: "small",
        "aria-label": n(
          s
            ? "component.timeline.pause.description"
            : "component.timeline.play.description"
        ),
        onClick: o,
        disabled: 0 === i,
        children: s ? (0, u7.jsx)(rZ, {}) : (0, u7.jsx)(lZ, {}),
      }),
    })
  );
});
export var m7 = WithEngineComp(function ({ engine: e, page: t }) {
  const { t: n } = ZL(),
    s = e.block.isLooping(t);
  return (0, u7.jsx)(Ly, {
    label: n(s ? "action.loop.disable" : "action.loop.enable"),
    children: (0, u7.jsx)(CompCustomButton, {
      name: "loop-toggle",
      variant: "plain",
      icon: s ? (0, u7.jsx)(e7, {}) : (0, u7.jsx)(n7, {}),
      "aria-label": n(s ? "action.loop.disable" : "action.loop.enable"),
      isActive: s,
      activeStateStyle: "none",
      onClick: () => {
        e.block.setLooping(t, !s);
      },
    }),
  });
});
export var x7 = WithEngineComp(function TimelineZoomingWrapper({
  engine: e,
  isExpanded: t,
  toggleExpanded: n,
  zoomIn: s,
  zoomOut: i,
  zoomToFit: o,
}) {
  const { t: r } = ZL(),
    a = e.scene.getCurrentPage();
  return (0, u7.jsxs)("div", {
    className: c7.block,
    children: [
      (0, u7.jsx)("div", {
        className: (0, a7.default)(c7.group, c7.left),
        children:
          null != a &&
          (0, u7.jsxs)(u7.Fragment, {
            children: [
              (0, u7.jsx)(d7, { page: a }),
              (0, u7.jsx)(p7, { page: a }),
            ],
          }),
      }),
      (0, u7.jsx)("div", {
        className: (0, a7.default)(c7.group, c7.playbackControls),
        children:
          null != a &&
          (0, u7.jsxs)(u7.Fragment, {
            children: [
              (0, u7.jsx)(f7, { page: a }),
              (0, u7.jsx)(h7, { page: a }),
              (0, u7.jsx)(m7, { page: a }),
            ],
          }),
      }),
      (0, u7.jsxs)("div", {
        className: (0, a7.default)(c7.group, c7.right),
        children: [
          t &&
            (0, u7.jsx)(TimelineZooming, {
              zoomIn: s,
              zoomOut: i,
              zoomToFit: o,
            }),
          (0, u7.jsx)(Ly, {
            label: r(
              t ? "component.timeline.collapse" : "component.timeline.expand"
            ),
            children: (0, u7.jsxs)(CompCustomButton, {
              className: c7.expandButton,
              name: "expand-timeline",
              "aria-label": r(
                t ? "component.timeline.collapse" : "component.timeline.expand"
              ),
              variant: t ? "plain" : "regular",
              icon: t ? undefined : (0, u7.jsx)(r7, {}),
              onClick: n,
              children: [
                t ? null : r("component.timeline.label"),
                t ? (0, u7.jsx)(yQ, {}) : (0, u7.jsx)(EJ, {}),
              ],
            }),
          }),
        ],
      }),
    ],
  });
});

export var S7 = mayBeUseMemp(function ({ scrollContainerRef: e }) {
  const t = (0, y7.useRef)(null),
    { t: n } = ZL(),
    s = VO(),
    i = s.engine,
    { backgroundTrackLibraryEntries: o } = XR(),
    [r, a] = (0, y7.useState)(false);
  return (
    (0, y7.useEffect)(() => {
      if (!t.current) return;
      const n = new IntersectionObserver(
        ([e]) => {
          a(!e.isIntersecting);
        },
        { root: e.current, threshold: 0.95 }
      );
      return (
        n.observe(t.current),
        () => {
          n.disconnect();
        }
      );
    }, [e]),
    (0, y7.useEffect)(
      () =>
        i.asset.unstable_registerApplyAssetMiddleware(async (e, t, n) => {
          const r = await n(e, t);
          if (
            null != r &&
            s.ui.isPanelOpen("//ly.img.panel/assetLibrary", {
              payload: { entries: o },
            }) &&
            o.some((t) => s.ui.getAssetLibraryEntry(t)?.sourceIds.includes(e))
          ) {
            const e = i.scene.getCurrentPage();
            if (!e) return;
            const t = UV(i, e) ?? zV(i, e);
            i.block.fillParent(r), i.block.appendChild(t, r);
          }
          return r;
        }),
      [o, s.ui, i, i.asset]
    ),
    0 === o.length
      ? null
      : (0, j7.jsxs)(j7.Fragment, {
          children: [
            (0, j7.jsxs)("div", {
              id: "add-clip-button-sentinel",
              className: C7,
              "aria-hidden": true,
              ref: t,
              children: [(0, j7.jsx)(HZ, {}), n("action.clip.add")],
            }),
            (0, j7.jsx)(Sd.div, {
              className: v7,
              variants: {
                initial: { width: "100%" },
                sticky: { width: "calc(var(--ubq-scale-base) * 8)" },
              },
              initial: r ? "sticky" : "initial",
              animate: r ? "sticky" : "initial",
              transition: { duration: 0.3, ease: [0.2, 0, 0, 1] },
              children: (0, j7.jsx)(Ly, {
                label: n("action.backgroundClip.add"),
                children: (0, j7.jsxs)(CompCustomButton, {
                  className: (0, b7.default)(w7, { [k7]: r }),
                  variant: "plain",
                  color: "accent",
                  centered: true,
                  name: "add-background-clips",
                  onPointerUp: (e) => {
                    e.stopPropagation();
                    const t = new PointerEvent("pointerup", {
                      clientX: e.clientX,
                      clientY: e.clientY,
                    });
                    window.dispatchEvent(t);
                  },
                  onClick: () => {
                    s.ui.openPanel("//ly.img.panel/assetLibrary", {
                      payload: { entries: o },
                    });
                  },
                  children: [
                    (0, j7.jsx)(HZ, {}),
                    (0, j7.jsx)(Sd.span, {
                      initial: { opacity: r ? 0 : 1 },
                      animate: { opacity: r ? 0 : 1 },
                      children: n("action.clip.add"),
                    }),
                  ],
                }),
              }),
            }),
          ],
        })
  );
});
export var _7 = {
  block: "UBQ_VideoTimeline-module__block--7jS2p",
  resizeHandle: "UBQ_VideoTimeline-module__resizeHandle--BwFFh",
  expandable: "UBQ_VideoTimeline-module__expandable--qztys",
  scrollContainer: "UBQ_VideoTimeline-module__scrollContainer--ZSu2E",
  timelineWrapper: "UBQ_VideoTimeline-module__timelineWrapper--3GAM9",
  foregroundTracks: "UBQ_VideoTimeline-module__foregroundTracks--NrHt-",
  backgroundTracks: "UBQ_VideoTimeline-module__backgroundTracks--KH3zZ",
  timeRuler: "UBQ_VideoTimeline-module__timeRuler--jUJdX",
};

export function L7({
  className: e,
  children: t,
  isExpanded: n,
  setExpanded: s,
  header: i,
}) {
  const { t: o } = ZL(),
    r = No(componentContriller),
    a = (0, X4.useRef)(null),
    l = iL("embedViewport"),
    c = (0, X4.useRef)(0.3 * l.height),
    u = 0.8 * l.height,
    d = No(() => new Qd("auto")),
    p = zd(n ? c.current : 0);
  return (
    (0, X4.useEffect)(() => {
      pp(p, n ? c.current : 0, { duration: 0.1 });
    }, [p, n]),
    (0, E7.jsxs)(PI, {
      className: (0, Y4.default)(_7.expandable, e),
      scope: AI,
      label: o("editor.scope.videoTimeline"),
      children: [
        (0, E7.jsx)(Sd.div, {
          drag: "y",
          dragSnapToOrigin: true,
          onDragStart: () => {
            a.current?.setAttribute("data-resizing", "true");
          },
          onDrag: (e, { offset: t }) => {
            const n = wk(0, c.current - t.y, u);
            p.set(n);
          },
          onDragEnd: (e, { offset: t }) => {
            if (0 === p.get()) s?.(false);
            else {
              const e = wk(0, c.current - t.y, u);
              (c.current = e), p.set(e);
            }
            a.current?.setAttribute("data-resizing", "false");
          },
          dragMomentum: false,
          dragControls: r,
        }),
        (0, E7.jsx)("div", {
          role: "button",
          "aria-label": o("action.resize"),
          "aria-disabled": !n,
          className: _7.resizeHandle,
          onPointerDown: (e) => {
            n && r.start(e);
          },
          ref: a,
        }),
        i,
        (0, E7.jsx)(Sd.div, {
          custom: n,
          style: { willChange: d, height: p },
          children: t,
        }),
      ],
    })
  );
}
export var P7 = mayBeUseMemp(function ({ className: e }) {
  const t = DO(),
    n = YF(),
    s = (0, X4.useRef)(null),
    i = I3(),
    { requestFocusForDesignElementId: o } = KR(),
    [r, a] = (0, X4.useState)(1),
    [l, c] = (0, X4.useState)(true),
    u = i.basePixelRatio * r,
    { backgroundTrackLibraryEntries: d, assetLibraryEntries: p } = XR();
  (0, X4.useEffect)(
    () =>
      n.asset.unstable_registerApplyAssetMiddleware(async (e, t, s) => {
        const i = await s(e, t),
          o = null != i && n.block.supportsDuration(i),
          r = null != i && null != n.block.getParent(i);
        return (
          o &&
            r &&
            "Video" === n.scene.getMode() &&
            (function (e, t, n, s) {
              const i = e.scene.getCurrentPage();
              if (null == i) return;
              const o =
                null != t && e.block.supportsFill(t)
                  ? e.block.getFill(t)
                  : undefined;
              e.block.isPlaying(i) && e.block.setPlaying(i, false);
              const r = e.block.getDuration(i),
                a = e.block.getPlaybackTime(i),
                l = r - a,
                c = e.block.supportsTrim(t),
                u = null != o && e.block.supportsTrim(o),
                d = Math.min(1, r),
                p = Math.min(l, e.block.getDuration(t)),
                f = Math.max(d, p);
              if (r > 0)
                e.block.setTimeOffset(t, f > l ? a - (f - l) : a),
                  e.block.setDuration(t, f);
              else if (n) {
                const n = UV(e, i) ?? zV(e, i);
                e.block.fillParent(t), e.block.appendChild(n, t);
              }
              if (c || u) {
                const n = u ? o : t;
                e.block.forceLoadAVResource(n).then(() => {
                  e.block.setTrimLength(n, e.block.getDuration(t));
                });
              }
              "//ly.img.ubq/audio" === e.block.getType(t) &&
                (NV(t, e), s && e.block.setName(t, s));
            })(
              n,
              i,
              d.some((t) => {
                const n = p[t];
                return n?.sourceIds.includes(e);
              }),
              t.label
            ),
          i
        );
      }),
    [p, d, n]
  ),
    (0, X4.useEffect)(
      () =>
        n.asset.unstable_registerApplyAssetToBlockMiddleware(
          async (e, t, s, i) => {
            if ((await i(e, t, s), "Video" === n.scene.getMode())) {
              const e = t.meta?.duration
                ? parseFloat(t.meta.duration)
                : undefined;
              !(function (e, t, n) {
                const s = e.block.supportsFill(t)
                  ? e.block.getFill(t)
                  : undefined;
                let i = e.block.getDuration(t);
                null != n && n < i && (e.block.setDuration(t, n), (i = n)),
                  e.block.supportsTrim(t)
                    ? e.block.forceLoadAVResource(t).then(() => {
                        e.block.setTrimOffset(t, 0),
                          e.block.setTrimLength(t, i);
                      })
                    : null != s &&
                      e.block.supportsTrim(s) &&
                      e.block.forceLoadAVResource(s).then(() => {
                        e.block.setTrimOffset(s, 0),
                          e.block.setTrimLength(s, i);
                      });
              })(n, s, e);
            }
            "//ly.img.ubq/audio" === n.block.getType(s) &&
              t.label &&
              n.block.setName(s, t.label);
          }
        ),
      [n]
    );
  const {
      currentPage: f,
      pageChildren: h,
      isPlaying: m,
      backgroundTotalDuration: g,
      foregroundTotalDuration: x,
      totalDuration: b,
    } = eI(n, () => {
      const e = n.scene.getCurrentPage(),
        t = null != e ? n.block.getChildren(e) : undefined,
        s = null != e ? UV(n, e) : undefined,
        i = s && n.block.getDuration(s),
        o = t?.reduce((e, t) => {
          const s = n.block.getTimeOffset(t) + n.block.getDuration(t);
          return Math.max(e, s);
        }, 0);
      return {
        currentPage: e,
        pageChildren: t,
        backgroundTotalDuration: i,
        foregroundTotalDuration: o,
        totalDuration: null != e ? n.block.getDuration(e) : 0,
        isPlaying: !!e && n.block.isPlaying(e),
      };
    }),
    y = (0, X4.useMemo)(
      () =>
        h
          ?.filter((e) => {
            const t = n.block.getType(e);
            return (
              "//ly.img.ubq/audio" === t ||
              "//ly.img.ubq/graphic" === t ||
              "//ly.img.ubq/text" === t ||
              "//ly.img.ubq/track" === t
            );
          })
          .flatMap((e) =>
            "//ly.img.ubq/track" === n.block.getType(e)
              ? n.block.getChildren(e)
              : e
          )
          .flatMap((e) => {
            const t = n.block.getTimeOffset(e);
            return [t, t + n.block.getDuration(e)];
          }) ?? [],
      [n.block, h]
    ),
    v = (0, X4.useMemo)(() => {
      const e = n.scene.getCurrentPage(),
        t = e ? n.block.getPlaybackTime(e) : 0;
      return Array.from(new Set([0, b, t, ...y]));
    }, [y, n.block, n.scene, b]),
    w = (0, X4.useCallback)(() => {
      if (!f) return;
      const e = g || x || 0;
      n.block.setDuration(f, e),
        n.block.getPlaybackTime(f) > e && n.block.setPlaybackTime(f, e);
    }, [g, f, n.block, x]);
  function k() {
    s.current?.scrollTo({ top: 0, left: 0 });
  }
  (0, X4.useEffect)(
    () => (
      w(),
      t.getHistoryStateEmitter().addGlobalListener((e) => {
        e.some(({ event: e }) => "undo" === e || "redo" === e) && w();
      })
    ),
    [t, w]
  ),
    HV("action.scene.load", k),
    HV("action.scene.new", k),
    (0, X4.useEffect)(() => {
      const e = s.current,
        t = e?.querySelector(`#clip-${o}`);
      t &&
        e &&
        (function (e, t, n) {
          const s = n?.top ?? 0,
            i = n?.right ?? 0,
            o = n?.bottom ?? 0,
            r = n?.left ?? 0,
            a = e.getBoundingClientRect(),
            l = t.getBoundingClientRect(),
            c = a.top - l.top + t.scrollTop,
            u = a.bottom - l.top + t.scrollTop,
            d = a.left - l.left + t.scrollLeft,
            p = a.right - l.left + t.scrollLeft,
            f = c < t.scrollTop + s,
            h = u > t.scrollTop + t.clientHeight - o,
            m = d < t.scrollLeft + r,
            g = p > t.scrollLeft + t.clientWidth - i;
          f
            ? (t.scrollTop = c - s)
            : h && (t.scrollTop = u - t.clientHeight + o),
            m || (!m && g && a.width > l.width)
              ? (t.scrollLeft = d - r)
              : g && (t.scrollLeft = p - t.clientWidth + i);
        })(t, e, { top: 28, bottom: 70, left: 24, right: 24 });
    }, [n.block, o]);
  const C = (0, X4.useCallback)(() => {
      a((e) => {
        const t = 1.25 * e;
        return Math.min(t, i.maxZoomLevel);
      });
    }, [i.maxZoomLevel]),
    j = (0, X4.useCallback)(() => {
      a((e) => {
        const t = e / 1.25;
        return Math.max(t, i.minZoomLevel);
      });
    }, [i.minZoomLevel]),
    S = (0, X4.useCallback)(() => {
      const e = s.current,
        t = null !== f ? n.block.getDuration(f) : 0;
      if (!e || 0 === t) return;
      let o = i.zeroPointOffset + 4 * i.marginBase;
      if (g) {
        o +=
          (e.querySelector("#add-clip-button-sentinel")?.clientWidth ?? 0) +
          3 * i.marginBase;
      }
      const r = (e.clientWidth - o) / i.basePixelRatio;
      a(r / t);
    }, [g, i.basePixelRatio, i.marginBase, i.zeroPointOffset, f, n.block]),
    _ = (0, X4.useCallback)(() => {
      c((e) => !e);
    }, []),
    E = (0, X4.useCallback)(() => {
      null != f &&
        (m && n.block.setPlaying(f, false), n.block.setPlaying(f, false));
    }, [f, n, m]),
    L = (0, X4.useCallback)(
      (e) => {
        if (null == f) return;
        if ((n.block.setPlaybackTime(f, e), !s.current)) return;
        const t = i.zeroPointOffset / u,
          o = s.current.clientWidth / u,
          r = s.current.scrollLeft / u,
          a = o + r;
        if (e > a - t - 0.1) {
          const n = Math.abs(e - a + t);
          s.current.scrollLeft += 3 + 10 * n;
        }
        if (e < r - t + 0.05) {
          const n = Math.abs(r - t - e);
          s.current.scrollLeft -= 3 + 10 * n;
        }
      },
      [i.zeroPointOffset, f, n.block, u]
    );
  return (0, E7.jsx)(L7, {
    className: (0, Y4.default)(_7.block, e),
    isExpanded: l,
    setExpanded: c,
    header: (0, E7.jsx)(x7, {
      isExpanded: l,
      toggleExpanded: _,
      zoomIn: C,
      zoomOut: j,
      zoomToFit: S,
    }),
    children: (0, E7.jsx)("div", {
      id: "timeline-scroll-container",
      className: _7.scrollContainer,
      ref: s,
      children: (0, E7.jsxs)("div", {
        className: _7.timelineWrapper,
        onPointerUp: (e) => {
          const t = e.currentTarget.getBoundingClientRect(),
            s = (e.clientX - t.left - i.zeroPointOffset) / u;
          !f ||
            s < 0 ||
            s > b ||
            (n.block.setPlaying(f, false), n.block.setPlaybackTime(f, s));
        },
        children: [
          (0, E7.jsx)(cE, {
            className: _7.timeRuler,
            pixelRatio: u,
            zeroPointOffset: i.zeroPointOffset,
            totalDuration: b,
            baseTickSpacing: 7.5 * i.scaleBase,
            baseSecondSpacing: 50 * i.scaleBase,
          }),
          (0, E7.jsxs)("div", {
            className: _7.foregroundTracks,
            style: { marginLeft: i.zeroPointOffset },
            children: [
              (0, E7.jsx)(K3, {
                pixelRatio: u,
                totalDuration: x,
                clipMinDuration: i.clipMinDuration,
                snapTimes: v,
              }),
              (0, E7.jsx)(N3, {
                pixelRatio: u,
                totalDuration: x,
                clipMinDuration: i.clipMinDuration,
                snapTimes: v,
              }),
            ],
          }),
          (0, E7.jsxs)("div", {
            className: _7.backgroundTracks,
            style: { paddingLeft: i.zeroPointOffset },
            children: [
              (0, E7.jsx)(G3, {
                className: _7.backgroundTrack,
                pixelRatio: u,
                totalDuration: g,
                clipMinDuration: i.clipMinDuration,
                snapTimes: v,
              }),
              (0, E7.jsx)(S7, { scrollContainerRef: s }),
            ],
          }),
          (0, E7.jsx)(q3, {
            onDragStart: E,
            onDrag: L,
            pixelRatio: u,
            totalDuration: b,
            scrollContainerRef: s,
            zeroPointOffset: i.zeroPointOffset,
          }),
          (0, E7.jsx)(hE, {
            pixelRatio: u,
            zeroPointOffset: i.zeroPointOffset,
            totalDuration: b,
          }),
        ],
      }),
    }),
  });
});
export var A7 = function (e) {
  const t = XR().getPanelState(e);
  return t?.payload ?? {};
};

export var T7 = mayBeUseMemp(function ({ block: e }) {
  const t = A7("//ly.img.panel/inspector/adjustments"),
    n = NQ("//ly.img.panel/inspector"),
    s = UQ("//ly.img.panel/inspector"),
    i = Nz(),
    o = "number" == typeof t.effectId ? t.effectId : undefined;
  return (0,
  B7.jsx)(WQ, { id: "//ly.img.panel/inspector/adjustments", group: "subInspector", "data-cy": "adjustments-subinspector-panel", floating: n, panelPosition: i ? "left" : s, children: (0, B7.jsx)(j2.PanelContent, { effectId: o, block: e }) });
});

export var O7 = mayBeUseMemp(function () {
  const e = "//ly.img.panel/inspector/animation",
    t = NQ(e),
    n = UQ(e),
    s = Nz();
  return (0,
  M7.jsx)(WQ, { id: e, group: "subInspector", delayRenderAfterAnimation: false, "data-cy": "asset-library-panel", fullHeight: true, focusTrapActive: false, floating: t, panelPosition: s ? "left" : n, children: (0, M7.jsx)(oY.PanelContent, {}) });
});

export var F7 = function ({ error: e, onClose: t }) {
  const { t: n } = ZL();
  return (0, D7.jsx)(Yw, {
    show: null !== e,
    onClose: t,
    type: "error",
    "aria-label": e?.description || "",
    footer: (0, D7.jsx)(Yw.Footer, {
      children: (0, D7.jsx)(CompCustomButton, {
        name: "applyAsset-error-close",
        onClick: t,
        children: n("common.back"),
      }),
    }),
    children: (0, D7.jsxs)("div", {
      className: V7,
      children: [
        (0, D7.jsx)(HI, { level: 1, children: e?.heading }),
        (0, D7.jsx)("p", { children: e?.description }),
      ],
    }),
  });
};

export var N7 = function ({
  panelId: e,
  group: t,
  position: n,
  title: s,
  onClose: i,
  children: o,
  ...r
}) {
  const { t: a } = ZL();
  return (0, H7.jsxs)(WQ, {
    id: e,
    group: t,
    delayRenderAfterAnimation: false,
    "data-cy": "asset-library-panel",
    onClose: i,
    fullHeight: true,
    focusTrapActive: false,
    ...r,
    children: [
      (0, H7.jsx)(WQ.Header, {
        children: (0, H7.jsx)(WQ.Title, {
          children: s ?? a("component.library"),
        }),
      }),
      (0, H7.jsx)(WQ.Content, {
        children: (e) => (0, H7.jsx)("div", { className: I7, children: o(e) }),
      }),
    ],
  });
};

export function z7(e) {
  const t = YF(),
    [n, s] = (0, U7.useState)([]),
    { uploadHandler: i } = XI(n);
  return [
    (0, U7.useCallback)(
      (n, o) => {
        const { sourceId: r, group: a } = o || {};
        s(r ? t.asset.getSupportedMimeTypes(r) : []),
          i()(
            n.map((t) => ({
              file: t,
              addToAssetSource: r ? { sourceId: r, group: a } : undefined,
              applyAssetAfterUpload:
                "//ly.img.panel/assetLibrary.replace" === e,
              applyAssetTarget:
                "//ly.img.panel/assetLibrary.replace" === e
                  ? "replace"
                  : "insert",
            }))
          );
      },
      [e, t.asset, i]
    ),
  ];
}
export var q7 = mayBeUseMemp(function () {
  const e = DO(),
    { engine: t } = e,
    { t: n } = ZL(),
    { focusSelectedElement: s, focusSelectedElementOrDocument: i } = xI(),
    o = "//ly.img.panel/assetLibrary",
    [r] = z7(o),
    { assetLibraryEntries: a } = XR(),
    { assetLibraryPanelInsertAutoClose: l, assetLibraryPanelEnabled: c } = YR(),
    { title: u, entries: d = [] } = A7(o),
    p = d
      .map((e) => {
        const n = a[e];
        if (n) return XK(n, t, t.asset.findAllSources());
      })
      .filter((e) => null != e),
    [f, h] = (0, R7.useState)(null),
    m = NQ(o),
    g = UQ(o),
    x = Nz();
  if (!c) return null;
  let b = null != u ? n(u) : undefined;
  return (
    null == b && 1 === p.length && (b = bG(n, { entry: p[0] })),
    (0, $7.jsxs)($7.Fragment, {
      children: [
        (0, $7.jsx)(N7, {
          title: b,
          panelId: o,
          group: "assetLibrary",
          onClose: () => {
            i();
          },
          floating: m,
          position: x ? "left" : g,
          children: ({ isOpen: i, setIsOpen: o }) =>
            (0, $7.jsxs)(MK, {
              entries: p,
              assetPanelOpen: i,
              children: [
                (0, $7.jsx)(MK.Search, {
                  placeholder: n("component.library.searchPlaceholder"),
                }),
                (0, $7.jsx)(MK.Content, {
                  onSelect: async (i) => {
                    const r = i.context.sourceId;
                    try {
                      await t.asset.apply(r, i);
                    } catch (t) {
                      t instanceof Error && e.log(t.message, "Error"),
                        h({
                          heading: n("error.applyAsset"),
                          description: n("error.applyAsset.description"),
                        });
                    }
                    await t.reactor.nextReaction, l() && o(false), s();
                  },
                  onUpload: r,
                }),
              ],
            }),
        }),
        (0, $7.jsx)(F7, {
          error: f,
          onClose: () => {
            h(null);
          },
        }),
      ],
    })
  );
});

export var G7 = mayBeUseMemp(
  WithEngineComp(function ({ block: e }) {
    const t = NQ("//ly.img.panel/inspector"),
      n = UQ("//ly.img.panel/inspector"),
      s = Nz();
    return (0,
    Q7.jsx)(WQ, { id: "//ly.img.panel/inspector/blur", group: "subInspector", "data-cy": "blur-subinspector-panel", floating: t, panelPosition: s ? "left" : n, children: (0, Q7.jsx)(i2.PanelContent, { block: e }) });
  })
);

export var K7 = mayBeUseMemp(function ({ block: e }) {
  const t = YF(),
    n = VO(),
    s = NQ("//ly.img.panel/inspector"),
    i = UQ("//ly.img.panel/inspector"),
    o = Nz(),
    r = XR(),
    [a] = BQ("//ly.img.panel/inspector/crop", r),
    l = "advanced" === r.viewStyle,
    { isOpen: c } = i1(e);
  return (
    (0, Z7.useEffect)(() => {
      a && "Crop" !== t.editor.getEditMode() && t.editor.setEditMode("Crop"),
        a ||
          "Crop" !== t.editor.getEditMode() ||
          t.editor.setEditMode("Transform");
    }, [t.editor, a]),
    (0, Z7.useEffect)(() => {
      c &&
        !n.ui.isPanelOpen("//ly.img.panel/inspector/crop") &&
        l &&
        n.ui.openPanel("//ly.img.panel/inspector/crop"),
        !c &&
          n.ui.isPanelOpen("//ly.img.panel/inspector/crop") &&
          n.ui.closePanel("//ly.img.panel/inspector/crop");
    }, [n.ui, l, c]),
    (0, W7.jsx)(WQ, {
      id: "//ly.img.panel/inspector/crop",
      "data-cy": "crop-subinspector-panel",
      floating: s,
      panelPosition: o ? "left" : i,
      children: (0, W7.jsx)(y1.PanelContent, { block: e }),
    })
  );
});

export var X7 = function (e, t) {
  const n = document.createElement("link");
  return (
    n.setAttribute("rel", "stylesheet"),
    n.setAttribute("href", `${t}stylesheets/${e}`),
    n
  );
};

export var n9 = function ({ error: e }) {
  const { t: t } = ZL();
  return (0, t9.jsxs)("div", {
    className: J7,
    children: [
      (0, t9.jsx)(Rw, {}),
      (0, t9.jsx)(HI, {
        level: 2,
        className: e9,
        children: e?.toString() || t("error.generic"),
      }),
    ],
  });
};

export var i9 = mayBeUseMemp(function ({ customPanel: e }) {
  const { t: t } = ZL(),
    n = (0, Y7.useRef)(),
    s = FI(),
    i = t(`panel.${e.id}`),
    o = s.ui.baseURL,
    r = !s.ui.stylesheets?.disableShadowDOM,
    a = !s.ui.stylesheets?.disableTagInsertion;
  return (0, s9.jsxs)(
    WQ,
    {
      id: e.id,
      children: [
        (0, s9.jsx)(WQ.Header, {
          children: (0, s9.jsx)(WQ.Title, { children: i }),
        }),
        (0, s9.jsx)(WQ.Content, {
          children: (0, s9.jsx)(oj, {
            fallback: (e) => (0, s9.jsx)(n9, { error: e }),
            children: (0, s9.jsx)("div", {
              ref: (t) => {
                if (null != t) {
                  let s = t;
                  rm &&
                    r &&
                    (s = (function (e, t) {
                      const n = e.attachShadow({ mode: "open" }),
                        s = e.getRootNode();
                      if (s instanceof ShadowRoot) {
                        const e = (function (e) {
                          for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            if (n.href?.endsWith("cesdk.css")) return n;
                          }
                          return;
                        })(s.styleSheets);
                        null == e
                          ? t.enableTagInsertion &&
                            n.appendChild(X7("cesdk.css", t.baseURL ?? ""))
                          : (function (e, t) {
                              if ("adoptedStyleSheets" in e) {
                                const n = new CSSStyleSheet();
                                Array.from(t.cssRules)
                                  .map((e) => e.cssText)
                                  .forEach((e, t) => n.insertRule(e, t)),
                                  (e.adoptedStyleSheets = [n]);
                              } else {
                                const n = document.createElement("style");
                                (n.textContent = Array.from(t.cssRules)
                                  .map((e) => e.cssText)
                                  .join("\n")),
                                  e.appendChild(n);
                              }
                            })(n, e);
                        const i = document.createElement("div");
                        return n.appendChild(i), i;
                      }
                      return e;
                    })(t, { baseURL: o, enableTagInsertion: a })),
                    (n.current = e.onMount(s));
                } else null != n.current && n.current();
              },
            }),
          }),
        }),
      ],
    },
    e.id
  );
});
export var o9 = mayBeUseMemp(function () {
  const e = XR();
  return (0,
  s9.jsx)(s9.Fragment, { children: e.customPanels.map((e) => (0, s9.jsx)(i9, { customPanel: e }, e.id)) });
});

export var a9 = mayBeUseMemp(function ({ block: e }) {
  const t = A7("//ly.img.panel/inspector/effects"),
    n = NQ("//ly.img.panel/inspector"),
    s = UQ("//ly.img.panel/inspector"),
    i = Nz(),
    o = "number" == typeof t.effectId ? t.effectId : undefined;
  return (0,
  r9.jsx)(WQ, { id: "//ly.img.panel/inspector/effects", group: "subInspector", "data-cy": "effects-subinspector-panel", floating: n, panelPosition: i ? "left" : s, children: (0, r9.jsx)(p5.PanelContent, { block: e, effectId: o }) });
});

export var u9 = mayBeUseMemp(function ({ block: e }) {
  const t = YF(),
    n = NQ("//ly.img.panel/inspector"),
    s = UQ("//ly.img.panel/inspector"),
    i = Nz();
  return (
    (0, l9.useEffect)(() => {
      l0(t);
    }, [t]),
    (0, c9.jsx)(WQ, {
      id: "//ly.img.panel/inspector/fill",
      group: "subInspector",
      "data-cy": "fill-subinspector-panel",
      floating: n,
      panelPosition: i ? "left" : s,
      children: (0, c9.jsx)(v4.PanelContent, { block: e }),
    })
  );
});

export var p9 = mayBeUseMemp(function ({ block: e }) {
  const t = A7("//ly.img.panel/inspector/filters"),
    n = NQ("//ly.img.panel/inspector"),
    s = UQ("//ly.img.panel/inspector"),
    i = Nz(),
    o = "number" == typeof t.effectId ? t.effectId : undefined;
  return (0,
  d9.jsx)(WQ, { id: "//ly.img.panel/inspector/filters", group: "subInspector", "data-cy": "filters-subinspector-panel", floating: n, panelPosition: i ? "left" : s, children: (0, d9.jsx)(W2.PanelContent, { effectId: o, block: e }) });
});

export var x9 = {};
defineGetter(x9, {
  AudioDesignBlock: () => e8,
  CutoutDesignBlock: () => S8,
  DesignDesignBlock: () => _ee,
  GroupDesignBlock: () => Oee,
  PageDesignBlock: () => Vee,
  SceneDesignBlock: () => kte,
  TextDesignBlock: () => Mne,
});

export function v9({ definitionElement: { children: e }, context: t }) {
  return (0, y9.jsx)("div", {
    className: b9,
    children: (0, y9.jsx)(Z6, { context: t, definition: e }),
  });
}
export var k9 = mayBeUseMemp(function ({ definitionElement: e, context: t }) {
  const { t: n } = ZL(),
    { a11y: s } = FI(),
    { i18nString: i } = e,
    { selectedDesignElement: o } = uD(),
    r = i ? n(i) : P2(n, e, o?.type ?? "//ly.img.ubq/scene");
  return (0,
  w9.jsx)(Qk, { title: r, headingLevel: 2, headingStart: s.headingsHierarchyStart, headingAreaRight: e.headingAreaRight, children: (0, w9.jsx)(Z6, { context: t, definition: e.children }) });
});
export var C9 = k9;

export var S9 = mayBeUseMemp(function ({ definitionElement: e, context: t }) {
  return (0,
  j9.jsx)(Yk, { children: (0, j9.jsx)(Z6, { context: t, definition: e.children }) });
});

export var E9 = mayBeUseMemp(function ({ definitionElement: e }) {
  const { t: t } = ZL(),
    { isDisabled: n, i18nKey: s } = e;
  return (0, _9.jsx)(Sv, { isDisabled: !!n && n(), children: t(`${s}`) });
});
export var L9 = E9;

export var B9 = function ({ isDisabled: e }) {
  const t = IV(),
    { t: n } = ZL(),
    s = O$(),
    [i, o] = possibleHook3(s?.rotation, 0);
  let r = ((i / Math.PI) * 180) % 360;
  r > 180 ? (r -= 360) : r <= -180 && (r += 360);
  const a = n("common.rotation.inUnit");
  return (0, A9.jsx)(zv, {
    unitLabel: "",
    id: "transform-rotation",
    name: "transform-rotation",
    "aria-label": a,
    tooltipLabel: a,
    value: r,
    onChange: (e) => {
      if (null != e) {
        const t = (e / 180) * Math.PI;
        o(t);
      }
    },
    onRelease: (e) => {
      null != e && t("action.block.rotate");
    },
    isDisabled: e,
    maxFractionDigits: 0,
  });
};

export var M9 = mayBeUseMemp(function ({
  context: e,
  definitionElement: { disableFlip: t, children: n },
}) {
  const { t: s } = ZL(),
    i = VO(),
    o = IV(),
    r = O$(),
    [a, l] = possibleHook3(r?.flipHorizontal, false),
    [c, u] = possibleHook3(r?.flipVertical, false),
    [d] = possibleHook3(r?.isTransformLocked, false),
    [p, f, h, m] = rI([uH, fH, pH, dH]),
    g = d || !p,
    x = d || t || !f,
    b = d || !h,
    y = d || !m,
    { blocksTransformEnabled: v } = YR();
  return r
    ? (0, T9.jsxs)(T9.Fragment, {
        children: [
          (0, T9.jsxs)(Yk, {
            children: [
              (0, T9.jsx)(Sv, {
                isDisabled: b && x,
                children: s("common.rotateAndFlip"),
              }),
              (0, T9.jsx)(B9, { isDisabled: b }),
              (0, T9.jsxs)("div", {
                className: P9,
                children: [
                  (0, T9.jsx)(Ly, {
                    label: s("property.flip.x"),
                    children: (0, T9.jsx)(CompCustomButton, {
                      name: "flipX",
                      "aria-label": s("property.flip.x"),
                      disabled: x,
                      "data-cy": "flipX",
                      onClick: () => {
                        l(!a), o("action.property.update");
                      },
                      isActive: a,
                      children: (0, T9.jsx)(BY, {}),
                    }),
                  }),
                  (0, T9.jsx)(Ly, {
                    label: s("property.flip.y"),
                    children: (0, T9.jsx)(CompCustomButton, {
                      name: "flipY",
                      "aria-label": s("property.flip.y"),
                      disabled: x,
                      "data-cy": "flipY",
                      onClick: () => {
                        u(!c), o("action.property.update");
                      },
                      isActive: c,
                      children: (0, T9.jsx)(B0, {}),
                    }),
                  }),
                ],
              }),
            ],
          }),
          (0, T9.jsx)(Z6, { definition: n, context: e }),
          v &&
            (0, T9.jsxs)(T9.Fragment, {
              children: [
                (0, T9.jsx)(Yk, { children: (0, T9.jsx)(Sw, {}) }),
                (0, T9.jsxs)(Yk, {
                  children: [
                    (0, T9.jsx)(Sv, {
                      isDisabled: g && y,
                      children: s("common.transform"),
                    }),
                    (0, T9.jsx)(Ly, {
                      label: s("input.transform.description"),
                      children: (0, T9.jsxs)(CompCustomButton, {
                        name: "transform-inspector",
                        variant: "regular",
                        onClick: () => {
                          i.ui.openPanel("//ly.img.panel/inspector/transform");
                        },
                        isDisabled: g && y,
                        "data-cy": "transform",
                        children: [s("input.transform"), (0, T9.jsx)(zq, {})],
                      }),
                    }),
                  ],
                }),
              ],
            }),
        ],
      })
    : null;
});
export var O9 = M9;

export function V9({ tooltip: e, onClick: t, i18nKey: n, ...s }) {
  const { t: i } = ZL();
  if (e) {
    const e = s["aria-label"] || i(n);
    return (0, R9.jsx)(Ly, {
      label: e,
      "data-cy": `${s["data-cy"]}-tooltip`,
      children: (0, R9.jsx)(CompCustomButton, {
        ...s,
        "aria-label": e,
        onClick: t,
      }),
    });
  }
  return (0, R9.jsx)(CompCustomButton, { ...s, onClick: t });
}
export function D9({ name: e, actionName: t, actionMethod: n, ...s }) {
  const i = DO();
  return (0, R9.jsx)(V9, {
    ...s,
    name: e,
    onClick: () => {
      if (n) n(i);
      else {
        const n = t || e;
        if (!(n in i) || "function" != typeof i[n])
          throw new Error(`Method ${n} not found on EngineFacade`);
        i[n]();
      }
    },
  });
}
export var I9 = mayBeUseMemp(function ({ definitionElement: e, context: t }) {
  const { t: n } = ZL(),
    s = rI(e.scope),
    { i18nString: i } = e,
    o = i
      ? n(i)
      : e.ariaLabel || n(e.i18nKey || e.name, { defaultValue: null });
  let r = {};
  return (
    e.buttonProps &&
      (r =
        "function" == typeof e.buttonProps ? e.buttonProps(t) : e.buttonProps),
    (0, F9.jsx)(D9, {
      i18nKey: e.i18nKey ?? "",
      tooltip: e.tooltip,
      name: e.name,
      "aria-label": o,
      actionName: e.actionName,
      actionMethod: e.actionMethod,
      "data-cy": e.dataCy,
      ...r,
      isDisabled: e.isDisabled || r.isDisabled || !s,
      children: e.icon,
    })
  );
});
export var N9 = (e) => (0, H9.isValidElementType)(e);

export var z9 = function ({
  definitionElement: { children: e, name: t },
  context: n,
}) {
  return (0, U9.jsx)(CompLayout1, {
    children: (0, U9.jsx)(Z6, {
      context: n,
      definition: e.map((e) => (N9(e) ? e : { ...e, i18nGroupPrefix: t })),
    }),
  });
};
export var x6 = function () {
  const { t: e } = ZL(),
    t = YF(),
    n = IV(),
    { blocks: s, selectedDesignElement: i } = uD(),
    o = s.map((e) => e.id),
    r = t.block.isAlignable(o),
    a = t.block.isDistributable(o),
    l = rI(uH),
    c = oI("ui/fixLayers"),
    u = 1 === s?.length,
    d = s?.length > 2,
    [p, f] = possibleHook3(u ? s[0].alwaysOnTop : undefined, false),
    [h, m] = possibleHook3(u ? s[0].alwaysOnBottom : undefined, false),
    g = !l || !r,
    x = !l || !u,
    b = !l || !a || !d,
    y = !c || !u,
    v = !c || !u,
    w = (t) => ({
      name: t,
      "data-cy": t,
      variant: "plain",
      scope: uH,
      label: e(`action.${t}`),
      i18nKey: `action.${t}`,
    }),
    k = (t) => ({
      ...w(t),
      tooltip: true,
      "aria-label": e(`action.${t}.description`),
      isDisabled: g,
    }),
    C = (e) => {
      const { label: t, ...n } = w(e);
      return { ...n, isDisabled: x, children: t };
    },
    j = (e) => {
      const { label: t, ...n } = w(e);
      return { ...n, isDisabled: b, children: t };
    };
  function S() {
    i && (t.block.bringForward(i.id), n("action.arrange.bringForward"));
  }
  function _() {
    i && (t.block.bringToFront(i.id), n("action.arrange.toFront"));
  }
  function E() {
    i && (t.block.sendBackward(i.id), n("action.arrange.sendBackward"));
  }
  function L() {
    i && (t.block.sendToBack(i.id), n("action.arrange.toBack"));
  }
  return (0, g6.jsxs)(Yk, {
    className: h6,
    children: [
      (0, g6.jsxs)("span", {
        className: m6,
        children: [
          (0, g6.jsx)(V9, {
            ...k("align.left"),
            icon: (0, g6.jsx)(s6, {}),
            onClick: () => {
              t.block.alignHorizontally(o, "Left"), n("action.align.left");
            },
          }),
          (0, g6.jsx)(V9, {
            ...k("align.horizontalCenter"),
            icon: (0, g6.jsx)(t6, {}),
            onClick: () => {
              t.block.alignHorizontally(o, "Center"),
                n("action.align.horizontalCenter");
            },
          }),
          (0, g6.jsx)(V9, {
            ...k("align.right"),
            icon: (0, g6.jsx)(o6, {}),
            onClick: () => {
              t.block.alignHorizontally(o, "Right"), n("action.align.right");
            },
          }),
        ],
      }),
      (0, g6.jsxs)("span", {
        className: m6,
        children: [
          (0, g6.jsx)(V9, {
            ...k("align.top"),
            icon: (0, g6.jsx)(a6, {}),
            onClick: () => {
              t.block.alignVertically(o, "Top"), n("action.align.top");
            },
          }),
          (0, g6.jsx)(V9, {
            ...k("align.verticalCenter"),
            icon: (0, g6.jsx)(c6, {}),
            onClick: () => {
              t.block.alignVertically(o, "Center"),
                n("action.align.verticalCenter");
            },
          }),
          (0, g6.jsx)(V9, {
            ...k("align.bottom"),
            icon: (0, g6.jsx)(W9, {}),
            onClick: () => {
              t.block.alignVertically(o, "Bottom"), n("action.align.bottom");
            },
          }),
        ],
      }),
      (0, g6.jsx)("span", {
        className: m6,
        children: (0, g6.jsxs)(Cx, {
          children: [
            (t) =>
              (0, g6.jsx)(Ly, {
                label: e("action.position"),
                children: (0, g6.jsx)(CompCustomButton, {
                  name: "action.position",
                  "aria-label": e("action.position"),
                  variant: "plain",
                  isDisabled: x && b && y && v,
                  "data-cy": "action.position",
                  ...t,
                  children: (0, g6.jsx)(d6, {}),
                }),
              }),
            () =>
              (0, g6.jsxs)(yC.Container, {
                children: [
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      ...j("distribute.vertically"),
                      icon: (0, g6.jsx)(J9, {}),
                      onClick: () => {
                        t.block.distributeVertically(o),
                          n("action.distribute.vertically");
                      },
                    }),
                  }),
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      ...j("distribute.horizontally"),
                      icon: (0, g6.jsx)(Y9, {}),
                      onClick: () => {
                        t.block.distributeHorizontally(o),
                          n("action.distribute.horizontally");
                      },
                    }),
                  }),
                  (0, g6.jsx)(Sw, {}),
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      ...C("arrange.toFront"),
                      icon: (0, g6.jsx)(q9, {}),
                      onClick: _,
                    }),
                  }),
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      ...C("arrange.bringForward"),
                      icon: (0, g6.jsx)(a3, {}),
                      onClick: S,
                    }),
                  }),
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      ...C("arrange.sendBackward"),
                      icon: (0, g6.jsx)(c3, {}),
                      onClick: E,
                    }),
                  }),
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      ...C("arrange.toBack"),
                      icon: (0, g6.jsx)(f6, {}),
                      onClick: L,
                    }),
                  }),
                  (0, g6.jsx)(Sw, {}),
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      name: "toggle-always_on_top",
                      icon: p
                        ? (0, g6.jsx)(IconCheckmark, {})
                        : (0, g6.jsx)(G9, {}),
                      i18nKey: "input.alwaysOnTop",
                      variant: "plain",
                      isDisabled: y || !l,
                      onClick: () => {
                        f(!p);
                      },
                      children: e("input.alwaysOnTop"),
                    }),
                  }),
                  (0, g6.jsx)(yC.Item, {
                    children: (0, g6.jsx)(V9, {
                      name: "toggle-always_on_bottom",
                      icon: h
                        ? (0, g6.jsx)(IconCheckmark, {})
                        : (0, g6.jsx)(G9, {}),
                      i18nKey: "input.alwaysOnBottom",
                      variant: "plain",
                      isDisabled: v || !l,
                      onClick: () => {
                        m(!h);
                      },
                      children: e("input.alwaysOnBottom"),
                    }),
                  }),
                ],
              }),
          ],
        }),
      }),
    ],
  });
};

export var y6 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    [n] = e.block.findAllSelected();
  if (!n || !e.block.hasOpacity(n)) return null;
  const s = e.block.isAllowedByScope(n, mH);
  return (0,
  b6.jsx)(rG, { block: n, label: t("common.opacity"), property: "opacity", min: 0, max: 1, step: 0.01, isDisabled: !s, centeredZeroPosition: false });
});

export var _6 = [
  ["PassThrough", "Normal"],
  ["Darken", "Multiply", "ColorBurn"],
  ["Lighten", "Screen", "ColorDodge"],
  ["Overlay", "SoftLight", "HardLight"],
  ["Difference", "Exclusion"],
  ["Hue", "Saturation", "Color", "Luminosity"],
];
export var E6 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = ((e) => ({
      PassThrough: e("property.blendMode.PassThrough"),
      Normal: e("property.blendMode.Normal"),
      Darken: e("property.blendMode.Darken"),
      Multiply: e("property.blendMode.Multiply"),
      ColorBurn: e("property.blendMode.ColorBurn"),
      Lighten: e("property.blendMode.Lighten"),
      Screen: e("property.blendMode.Screen"),
      ColorDodge: e("property.blendMode.ColorDodge"),
      Overlay: e("property.blendMode.Overlay"),
      SoftLight: e("property.blendMode.SoftLight"),
      HardLight: e("property.blendMode.HardLight"),
      Difference: e("property.blendMode.Difference"),
      Exclusion: e("property.blendMode.Exclusion"),
      Hue: e("property.blendMode.Hue"),
      Saturation: e("property.blendMode.Saturation"),
      Color: e("property.blendMode.Color"),
      Luminosity: e("property.blendMode.Luminosity"),
    }))(t),
    s = IV(),
    i = Nz(),
    o = e.block.findAllSelected();
  if (1 !== o.length) return null;
  const [r] = o;
  if (!e.block.hasBlendMode(r)) return null;
  const a = e.block.isAllowedByScope(r, gH),
    l = e.block.getBlendMode(r) ?? "Normal";
  return (0, S6.jsxs)(S6.Fragment, {
    children: [
      (0, S6.jsx)(Sv, { isDisabled: !a, children: t("property.blendMode") }),
      (0, S6.jsxs)(bw, {
        children: [
          (e, { isOpen: s }) =>
            (0, S6.jsx)(Ly, {
              label: t("property.blendMode.tooltip"),
              children: (0, S6.jsxs)(CompCustomButton, {
                name: "BlendModeSelect",
                isDisabled: !a,
                ...e,
                "aria-label": t("property.blendMode.description", {
                  mode: n[l],
                }),
                children: [
                  n[l],
                  s
                    ? (0, S6.jsx)(IconChevronDown, {})
                    : (0, S6.jsx)(IconChevronUp, {}),
                ],
              }),
            }),
          () =>
            (0, S6.jsx)(bw.Options, {
              className: (0, v6.default)(k6, { [C6]: i }),
              value: l,
              onChange: (t) => {
                e.block.setBlendMode(r, t), s("action.property.update");
              },
              children: _6.map((e, t) =>
                (0, S6.jsxs)(
                  w6.Fragment,
                  {
                    children: [
                      t > 0 && (0, S6.jsx)(Sw, {}),
                      e.map((e) => {
                        const t = n[e];
                        return (0, S6.jsx)(
                          bw.Option,
                          { value: e, className: j6, children: t },
                          e
                        );
                      }),
                    ],
                  },
                  t
                )
              ),
            }),
        ],
      }),
    ],
  });
});

export var P6 = function ({ definitionElement: e, context: t }) {
  const { component: n, disableFlip: s, keepRatio: i } = e;
  return (0, L6.jsx)(Z6, {
    context: t,
    definition: [
      {
        type: "section",
        i18nKey: "layer",
        i18nString: "input.layer",
        children: [
          {
            type: "component",
            show: ({ facade: { cesdk: e, engine: t } }) =>
              e?.feature.isEnabled("ly.img.position", { engine: t }) ?? false,
            component: x6,
          },
          {
            type: "inspectorSectionRow",
            show: ({ facade: { cesdk: e, engine: t } }) =>
              e?.feature.isEnabled("ly.img.position", { engine: t }) ?? false,
            children: [{ type: "separator" }],
          },
          {
            type: "transform",
            component: n,
            disableFlip: s,
            keepRatio: i,
            children: [
              {
                type: "inspectorSectionRow",
                show: ({ configurationStore: e }) => e.blocksOpacityEnabled,
                children: [y6],
              },
              { type: "inspectorSectionRow", children: [E6] },
            ],
          },
        ],
      },
    ],
  });
};

export var B6 = function ({ definitionElement: e, ...t }) {
  const { component: n, ...s } = e;
  return (0, A6.jsx)(n, { ...t, ...s });
};
export var T6 = mayBeUseMemp(({ definitionElement: e, context: t }) => {
  const { render: n } = e;
  return n(t);
});

export var O6 = function ({
  definitionElement: {
    min: e,
    max: t,
    step: n,
    i18nString: s,
    i18nPropertyKey: i,
    property: o,
    snapOffset: r,
    centeredZeroPosition: a,
  },
}) {
  const l = O$(),
    { t: c } = ZL();
  if (null == l) return null;
  const u = c([
    `${s}`,
    `property.${i}`,
    `property.${i}.label`,
    "common.property",
    `${i}`,
  ]);
  return (0, M6.jsx)(rG, {
    block: l.id,
    min: e,
    max: t,
    step: n,
    property: o,
    label: u,
    snapOffset: r,
    centeredZeroPosition: a,
  });
};
export var R6 = O6;

export function D6() {
  const { t: e } = ZL(),
    t = O$(),
    [n, s] = possibleHook3(t?.includedInExport, false);
  return (0, V6.jsx)(
    nb,
    {
      name: "exportable",
      checked: n,
      onChange: s,
      label: e("input.showInExport"),
      icon: (0, V6.jsx)(DK, {}),
    },
    "exportable"
  );
}
export var F6 = function () {
  return O$() ? (0, V6.jsx)(D6, {}) : null;
};

export var H6 = function ({ context: e }) {
  return oI("ui/manageExportable")
    ? (0, I6.jsx)(Z6, {
        context: e,
        definition: [
          {
            type: "section",
            i18nKey: "export",
            i18nString: "input.export",
            children: [
              { type: "customRender", render: () => (0, I6.jsx)(F6, {}) },
            ],
          },
        ],
      })
    : null;
};

export var U6 = ({ definitionElement: e, context: t }) => {
  const { t: n } = ZL(),
    { i18nString: s } = e,
    i = t.facade.engine.block.findAllSelected()[0],
    o = i ? t.facade.engine.block.getType(i) : "//ly.img.ubq/scene",
    r = s ? n(s) : P2(n, e, o);
  let a = e.valueLabel && e.valueLabel(t);
  const l = null != a;
  l ||
    (a = ((e, { i18nKey: t }, n) =>
      t
        ? e(L2({ i18nKey: `${t}.value`, selectedElementType: n }), {
            defaultValue: e("common.select"),
          })
        : undefined)(n, e, o));
  return {
    label: r,
    valueLabel: a,
    hasValue: l,
    tooltip: (e.tooltip && n(e.tooltip)) ?? r,
  };
};
export var z6 = () => {
  const e = JE(),
    t = ax();
  ((e) => {
    const t = (0, FV.useRef)(e);
    t.current = e;
    const n = DO().getHistoryStateEmitter();
    (0, FV.useEffect)(() => {
      let e = true;
      const s = () => {
        e && t.current();
      };
      return (
        n.addGlobalListener(s),
        () => {
          n.removeGlobalListener(s), (e = false);
        }
      );
    }, [n]);
  })(() => {
    window.requestAnimationFrame(() => {
      t.current && e();
    });
  });
};
export var $6 = mayBeUseMemp(
  ({
    definitionElement: e,
    context: t,
    forceUpdate: n,
    isPropertyEnabled: s = true,
    commonValues: { label: i, hasValue: o, valueLabel: r, tooltip: a },
    subInspectorComponent: l,
    toggleOpen: c,
    isDisabled: u,
    panelId: d,
  }) => {
    let p = false;
    undefined !== e.active ? (p = e.active) : e.valueLabel && (p = o);
    const f = !!e.isDisabled && e.isDisabled(t),
      h = l;
    return (0, N6.jsx)(h, {
      panelId: d ?? e.panelId ?? "//ly.img.panel/inspector/subInspector",
      groupId: "subInspector",
      "data-cy": e.dataCy,
      label: i || "",
      valueLabel: r,
      tooltip: a ?? i,
      active: p,
      isDisabled: u || !s || f,
      isPropertyEnabled: s,
      onClose: n,
      onOpenStateChanged: c,
      icon: e.icon,
      children: (0, N6.jsx)(Z6, { context: t, definition: e.children }),
    });
  }
);
export var q6 = function ({ definitionElement: e, context: t, ...n }) {
  const s = U6({ definitionElement: e, context: t, ...n }),
    { label: i, hasValue: o } = s,
    r = JE(),
    a = undefined === e.hasPropertyGap || e.hasPropertyGap;
  z6();
  const l = e.propertyToggle ? e.propertyToggle(t) : null,
    c = null === (u = l) || u.isEnabled;
  var u;
  const d = !!e.isDisabled && e.isDisabled(t);
  return (0, N6.jsxs)(Yk, {
    children: [
      (0, N6.jsx)(Sv, { isDisabled: !c || d, children: i }),
      (0, N6.jsx)($6, {
        definitionElement: e,
        context: t,
        forceUpdate: r,
        isPropertyEnabled: c,
        commonValues: s,
        subInspectorComponent: EX,
        ...n,
      }),
      l && o
        ? (0, N6.jsx)(NK, {
            label: i || "",
            isEnabled: l.isEnabled,
            toggleProperty: l.toggle,
            "data-cy": l.dataCy,
            isDisabled: d,
          })
        : a && (0, N6.jsx)(zK, {}),
    ],
  });
};

export var Z6 = mayBeUseMemp(({ definition: e, context: t }) => {
  if (!e) return null;
  const { inspectorProps: n } = t;
  return (0, Q6.jsx)(Q6.Fragment, {
    children: e.map((e, s) => {
      const i = s,
        o = { key: i, ...n, context: t };
      if (N9(e))
        return (0, G6.createElement)(B6, {
          ...o,
          key: i,
          definitionElement: { type: "component", component: e },
        });
      if (null != e.show) {
        let n = true;
        if (((n = "function" == typeof e.show ? e.show(t) : e.show), !n))
          return null;
      }
      switch (e.type) {
        case "common":
          return (0, Q6.jsx)(P6, { ...o, definitionElement: e });
        case "transform":
          return (0, Q6.jsx)(O9, { ...o, definitionElement: e });
        case "scope":
          return (0, Q6.jsx)(H6, { ...o, definitionElement: e });
        case "section":
          return (0, Q6.jsx)(C9, { ...o, definitionElement: e });
        case "inspectorSectionRow":
          return (0, Q6.jsx)(S9, { ...o, definitionElement: e });
        case "label":
          return (0, Q6.jsx)(L9, { ...o, definitionElement: e });
        case "subInspector":
          return (0, Q6.jsx)(q6, { ...o, definitionElement: e });
        case "horizontalGroup":
          return (0, Q6.jsx)(v9, { ...o, definitionElement: e });
        case "button":
          return (0, Q6.jsx)(I9, { ...o, definitionElement: e });
        case "buttonContainer":
          return (0, Q6.jsx)(z9, { ...o, definitionElement: e });
        case "component":
          return (0, Q6.jsx)(B6, { ...o, definitionElement: e });
        case "customRender":
          return (0, Q6.jsx)(T6, { ...o, definitionElement: e });
        case "property":
          return (0, Q6.jsx)(R6, { ...o, definitionElement: e });
        case "separator":
          return (0, Q6.jsx)(Sw, { ...o });
        default:
          return QO(e);
      }
    }),
  });
});
export var W6 = (e, t) =>
  mayBeUseMemp(function (n) {
    const s = DO(),
      i = KR(),
      o = YR(),
      r = FI(),
      { t: a } = ZL(),
      { selectedDesignElement: l } = uD(),
      c = {
        inspectorProps: n,
        facade: s,
        engineStore: i,
        configurationStore: o,
        configuration: r,
        designBlockDefinition: t,
        t: a,
      };
    return (0, Q6.jsx)(Z6, { context: c, definition: e }, l?.id);
  });
export var K6 = (e, t, n) => {
  let s;
  return (
    (s = n?.inspector
      ? Array.isArray(n.inspector)
        ? W6(n.inspector, n)
        : n.inspector
      : W6([{ type: "common", component: t }, { type: "scope" }], n)),
    { designBlockType: e, propsComponent: t, inspector: s }
  );
};
export var Y6 = (e) => {
  const t = K6(e.designBlockType, e.propsComponent, e),
    { inspector: n, ...s } = e;
  return { ...t, ...s };
};

export var J6 = {
  designBlockType: "//ly.img.ubq/audio",
  propsComponent: "ubq/designblocks/Audio",
  inspector: [
    {
      type: "component",
      component: function () {
        const { t: e } = ZL();
        return (0, X6.jsxs)(Qk, {
          title: e("component.audio.properties"),
          children: [
            (0, X6.jsx)(U5.Control, {}),
            (0, X6.jsx)(Yk, { children: (0, X6.jsx)(Sw, {}) }),
            (0, X6.jsx)(t4, {}),
          ],
        });
      },
    },
  ],
};
export var e8 = Y6(J6);
export var i8 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = IV(),
    s = t("input.cutoutOffset"),
    i = e.block.findAllSelected();
  if (1 !== i.length) return null;
  const o = i[0],
    r = rX(e.scene.getDesignUnit()),
    a = e.block.getFloat(o, "cutout/offset");
  return (0, s8.jsx)(Pv, {
    name: "cutoutOffsetValue",
    label: s,
    children: (t) =>
      (0, s8.jsx)(zv, {
        ...t,
        value: a,
        onChange: (t) => {
          e.block.setFloat(o, "cutout/offset", t ?? 0),
            n("action.cutoutOffset.change");
        },
        unitLabel: r,
      }),
  });
});
export var o8 = i8;

export var a8 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = t("input.cutoutOffset");
    return VO().feature.isEnabled("ly.img.cutout", { engine: e })
      ? (0, r8.jsxs)(Cx, {
          children: [
            (e) =>
              (0, r8.jsx)(Ly, {
                label: n,
                children: (0, r8.jsx)(CompCustomButton, {
                  name: "cutoutOffsetButton",
                  variant: "plain",
                  icon: (0, r8.jsx)(n8, {}),
                  ...e,
                  children: n,
                }),
              }),
            () => (0, r8.jsx)(Kk, { children: (0, r8.jsx)(o8, {}) }),
          ],
        })
      : null;
  })
);
export var l8 = a8;

export var m8 = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, inBar: t = false, ...n }) {
    const { t: s } = ZL(),
      i = IV(),
      o = VO().feature.isEnabled("ly.img.cutout", { engine: e }),
      [r] = e.block.findAllSelected();
    if (null == r || !o) return null;
    const a = e.block.getEnum(r, "cutout/type"),
      l = [
        {
          name: "solid",
          label: s("input.cutoutType.solid"),
          icon: (0, h8.jsx)(p8, {}),
          value: "Solid",
        },
        {
          name: "dashed",
          label: s("input.cutoutType.dashed"),
          icon: (0, h8.jsx)(u8, {}),
          value: "Dashed",
        },
      ],
      c = l.filter((e) => e.name === a?.toLowerCase())[0],
      u = s("input.cutoutType");
    return (0, h8.jsxs)(bw, {
      children: [
        (e, { isOpen: s }) =>
          (0, h8.jsx)(Ly, {
            label: u,
            children: (0, h8.jsxs)(CompCustomButton, {
              name: "cutoutTypeMenu",
              "aria-label": u,
              icon: c.icon,
              value: c.label,
              ...n,
              variant: t ? "plain" : n.variant,
              ...e,
              children: [
                c.label,
                s
                  ? (0, h8.jsx)(IconChevronDown, {})
                  : (0, h8.jsx)(IconChevronUp, {}),
              ],
            }),
          }),
        () =>
          (0, h8.jsx)(bw.Options, {
            value: a,
            onChange: (t) => {
              e.block.setEnum(r, "cutout/type", t),
                i("action.cutoutType.change");
            },
            children: l.map(({ name: e, label: t, icon: n, value: s }) =>
              (0, h8.jsx)(
                bw.Option,
                {
                  value: s,
                  children: (0, h8.jsxs)("div", {
                    className: f8,
                    children: [n, (0, h8.jsx)("span", { children: t })],
                  }),
                },
                e
              )
            ),
          }),
      ],
    });
  })
);
export var g8 = m8;

export var y8 = function () {
  const { t: e } = ZL(),
    t = e("input.cutoutSmoothing"),
    n = IV(),
    s = oD(),
    [i] = possibleHook3(s.scene.designUnit),
    [o] = possibleHook3(s.scene.dpi),
    r = O$(),
    [a, l] = possibleHook3(r?.cutoutSmoothing, 0),
    [c, u] = (0, x8.useMemo)(() => {
      const e = (function (e, t) {
        return (
          (100 *
            ("Pixel" === e
              ? 1
              : "Inch" === e
              ? t
              : "Millimeter" === e
              ? t / 25.4
              : 0)) /
          200
        );
      })(i, o);
      return [e, 1 / e];
    }, [i, o]);
  return (0, b8.jsx)(tG, {
    name: "cutoutSmoothingValue",
    label: t,
    min: 0,
    max: 100,
    maxFractionDigits: 0,
    centeredZeroPosition: false,
    value: a * c,
    onChange: (e) => {
      l(e * u);
    },
    onRelease: () => {
      n("action.cutoutSmoothing.change");
    },
  });
};
export var v8 = y8;
export var w8 = () => [
  {
    type: "scope",
    presets: [
      BH,
      hH,
      mH,
      gH,
      "layer/visibility",
      "layer/clipping",
      xH,
      yH,
      vH,
      wH,
      SH,
      EH,
      LH,
      uH,
      dH,
      fH,
      pH,
      PH,
      AH,
    ],
  },
];

export var C8 = "ubq/designblocks/Cutout";
export var j8 = {
  designBlockType: "//ly.img.ubq/cutout",
  propsComponent: C8,
  inspector: [
    { type: "common", component: C8 },
    {
      type: "section",
      i18nString: "component.cutout",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.cutout", { engine: t }) ?? false,
      children: [
        {
          type: "inspectorSectionRow",
          children: [
            {
              type: "customRender",
              render: () => {
                const { t: e } = ZL();
                return (0, k8.jsx)(Pv, {
                  name: "inspectorCutoutType",
                  label: e("input.cutoutType"),
                  children: (e) => (0, k8.jsx)(g8, { ...e }),
                });
              },
            },
          ],
        },
        { type: "inspectorSectionRow", children: [o8] },
        { type: "inspectorSectionRow", children: [v8] },
      ],
    },
    ...w8(),
  ],
};
export var S8 = Y6(j8);

export var E8 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = IV(),
    [s] = e.block.findAllSelected();
  if (!s) return null;
  if (!e.block.supportsShape(s)) return null;
  const i = e.block.getShape(s);
  if (!e.block.isValid(i)) return null;
  const o = e.block.getType(i),
    r = "//ly.img.ubq/shape/rect" === o,
    a = "//ly.img.ubq/shape/polygon" === o,
    l = a ? e.block.getInt(i, "shape/polygon/sides") : 4;
  if (!r && !a) return null;
  const c = e.block.isAllowedByScope(s, LH),
    u = e.block.getWidth(s),
    d = e.block.getHeight(s),
    p = a
      ? Math.floor((Math.min(u, d) / l / 2) * Math.PI)
      : Math.floor(Math.min(u, d) / 2);
  return (0, _8.jsx)(Yk, {
    children: (0, _8.jsx)(tG, {
      name: "rounded-corners",
      value: (() => {
        if (a) return e.block.getFloat(i, "shape/polygon/cornerRadius");
        if (r) {
          const t = e.block.getFloat(i, "shape/rect/cornerRadiusTL"),
            n = e.block.getFloat(i, "shape/rect/cornerRadiusTR"),
            s = e.block.getFloat(i, "shape/rect/cornerRadiusBL"),
            o = e.block.getFloat(i, "shape/rect/cornerRadiusBR");
          return Math.max(t, n, s, o);
        }
        return 0;
      })(),
      onChange: (t) => {
        var n;
        a && ((n = t), e.block.setFloat(i, "shape/polygon/cornerRadius", n)),
          r &&
            (function (t) {
              e.block.setFloat(i, "shape/rect/cornerRadiusTL", t),
                e.block.setFloat(i, "shape/rect/cornerRadiusTR", t),
                e.block.setFloat(i, "shape/rect/cornerRadiusBL", t),
                e.block.setFloat(i, "shape/rect/cornerRadiusBR", t);
            })(t);
      },
      onRelease: () => {
        n("action.property.update");
      },
      label: t("property.cornerRadius"),
      min: 0,
      max: p,
      step: 1,
      centeredZeroPosition: false,
      disabled: !c,
    }),
  });
});

export var P8 = "shape/star/innerDiameter";
export var A8 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = e.block.findAllSelected()[0];
  if (!n) return null;
  const s = e.block.getShape(n);
  if (!(e.block.isValid(s) && e.block.findAllProperties(s).includes(P8)))
    return null;
  const i = e.block.isAllowedByScope(n, LH);
  return (0,
  L8.jsx)(Yk, { children: (0, L8.jsx)(rG, { block: s, property: P8, label: t("property.innerDiameter"), min: 0.1, max: 1, centeredZeroPosition: false, disabled: !i }) });
});

export var T8 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = IV(),
    s = e.block.findAllSelected()[0];
  if (!s) return null;
  const i = e.block.getShape(s);
  if (!(e.block.isValid(i) && "//ly.img.ubq/shape/line" === e.block.getType(i)))
    return null;
  const o = e.block.isAllowedByScope(s, LH),
    r = e.block.getFrameHeight(s);
  return (0, B8.jsx)(Yk, {
    children: (0, B8.jsx)(tG, {
      name: "lineWidth",
      label: t("property.lineWidth"),
      value: r,
      onChange: (t) => {
        e.block.setHeight(s, t);
      },
      min: 0.1,
      max: 30,
      isDisabled: !o,
      centeredZeroPosition: false,
      onRelease: () => {
        n("action.property.update");
      },
    }),
  });
});

export var O8 = "shape/star/points";
export var R8 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = e.block.findAllSelected()[0];
  if (!n) return null;
  const s = e.block.getShape(n);
  if (!(e.block.isValid(s) && e.block.findAllProperties(s).includes(O8)))
    return null;
  const i = e.block.isAllowedByScope(n, LH);
  return (0,
  M8.jsx)(Yk, { children: (0, M8.jsx)(rG, { block: s, property: O8, label: t("property.points"), min: 3, max: 12, step: 1, centeredZeroPosition: false, disabled: !i }) });
});

export var D8 = "shape/polygon/sides";
export var F8 = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = e.block.findAllSelected()[0];
  if (!n) return null;
  const s = e.block.getShape(n);
  if (!(e.block.isValid(s) && e.block.findAllProperties(s).includes(D8)))
    return null;
  const i = e.block.isAllowedByScope(n, LH);
  return (0,
  V8.jsx)(Yk, { children: (0, V8.jsx)(rG, { block: s, property: D8, label: t("property.sides"), min: 3, max: 12, step: 1, centeredZeroPosition: false, disabled: !i }) });
});
export var Y8 = {
  popoverContent: "UBQ_StrokeProperties-module__popoverContent--79gSa",
};
export var X8 = () => {
  const e = YF(),
    t = O$(),
    [n] = possibleHook3(t?.hasStroke, false),
    [s] = possibleHook3(n && t?.isStrokeEnabled, false),
    [i] = possibleHook3(n && t?.Color("stroke/color")),
    o = i && PO(i, e.editor);
  return !!(o && s && o.a > 0);
};

export var eee = ["Inner", "Center", "Outer"];
export var tee = {
  Center: (0, J8.jsx)(Q8, {}),
  Inner: (0, J8.jsx)(Z8, {}),
  Outer: (0, J8.jsx)(K8, {}),
};
export var nee = ["Miter", "Bevel", "Round"];
export var see = {
  Bevel: (0, J8.jsx)(H8, {}),
  Miter: (0, J8.jsx)(U8, {}),
  Round: (0, J8.jsx)($8, {}),
};
export function iee({ disablePositionControls: e = false }) {
  const { t: t } = ZL(),
    n = IV(),
    s = O$(),
    [i] = possibleHook3(s?.hasStroke),
    [o, r] = possibleHook3(i && s?.strokePosition),
    [a, l] = possibleHook3(i && s?.strokeCornerGeometry),
    c = {
      Center: t("property.strokePosition.center"),
      Inner: t("property.strokePosition.inner"),
      Outer: t("property.strokePosition.outer"),
    },
    u = {
      Bevel: t("property.strokeCornerGeometry.bevel"),
      Miter: t("property.strokeCornerGeometry.miter"),
      Round: t("property.strokeCornerGeometry.round"),
    };
  return (0, J8.jsxs)(J8.Fragment, {
    children: [
      (0, J8.jsx)(Yk, {
        children: (0, J8.jsxs)(bw, {
          children: [
            (n, { isOpen: s }) =>
              (0, J8.jsx)(Pv, {
                name: "StrokePositionSelect",
                label: t("property.strokePosition"),
                isDisabled: e,
                children: (i) =>
                  (0, J8.jsx)(Ly, {
                    label: t("property.strokePosition.description"),
                    children: (0, J8.jsxs)(CompCustomButton, {
                      isDisabled: e,
                      ...i,
                      ...n,
                      icon: o && tee[o],
                      children: [
                        o && c[o],
                        s ? (0, J8.jsx)(EJ, {}) : (0, J8.jsx)(yQ, {}),
                      ],
                    }),
                  }),
              }),
            () =>
              (0, J8.jsx)(bw.Options, {
                className: Y8.options,
                value: o,
                onChange: (e) => {
                  e && (r(e), n("action.property.update"));
                },
                children: eee.map((e) =>
                  (0, J8.jsx)(
                    bw.Option,
                    {
                      value: e,
                      className: Y8.option,
                      icon: tee[e],
                      "data-cy": e,
                      children: o && c[e],
                    },
                    e
                  )
                ),
              }),
          ],
        }),
      }),
      (0, J8.jsx)(Yk, {
        children: (0, J8.jsxs)(bw, {
          children: [
            (e, { isOpen: n }) =>
              (0, J8.jsx)(Pv, {
                name: "StrokeCornerGeometrySelect",
                label: t("property.strokeCornerGeometry"),
                children: (s) =>
                  (0, J8.jsx)(Ly, {
                    label: t("property.strokeCornerGeometry.description"),
                    children: (0, J8.jsxs)(CompCustomButton, {
                      ...e,
                      ...s,
                      icon: a && see[a],
                      children: [
                        a && u[a],
                        n ? (0, J8.jsx)(EJ, {}) : (0, J8.jsx)(yQ, {}),
                      ],
                    }),
                  }),
              }),
            () =>
              (0, J8.jsx)(bw.Options, {
                className: Y8.options,
                value: a,
                onChange: (e) => {
                  e && (l(e), n("action.property.update"));
                },
                children: nee.map((e) =>
                  (0, J8.jsx)(
                    bw.Option,
                    {
                      value: e,
                      className: Y8.option,
                      icon: see[e],
                      "data-cy": e,
                      children: u[e],
                    },
                    e
                  )
                ),
              }),
          ],
        }),
      }),
    ],
  });
}
export function oee({
  isDisabled: e = false,
  disablePositionControls: t = false,
}) {
  const { t: n } = ZL(),
    s = rI(EH),
    i = X8(),
    o = n("property.strokePositionAndCornerGeometry.description");
  return i
    ? (0, J8.jsxs)(Cx, {
        children: [
          (t) =>
            (0, J8.jsx)(Ly, {
              label: o,
              children: (0, J8.jsx)(CompCustomButton, {
                name: "stroke-properties",
                "aria-label": o,
                variant: "plain",
                isDisabled: !s || !i || e,
                ...t,
                children: (0, J8.jsxs)(Gb, {
                  children: [(0, J8.jsx)(CC, {}), (0, J8.jsx)(wC, {})],
                }),
              }),
            }),
          () =>
            (0, J8.jsx)("div", {
              className: Y8.popoverContent,
              children: (0, J8.jsx)(iee, { disablePositionControls: t }),
            }),
        ],
      })
    : null;
}
export function ree({ children: e }) {
  const { t: t } = ZL(),
    n = rI(EH);
  return (0, J8.jsxs)(Yk, {
    children: [
      (0, J8.jsx)(Sv, { isDisabled: !n, children: t("common.advanced") }),
      (0, J8.jsx)(EX, {
        panelId: "//ly.img.panel/inspector/stroke/properties",
        groupId: "subInspector",
        label: t("common.advanced"),
        valueLabel: t("property.strokePositionAndCornerGeometry"),
        ariaLabel: t("property.strokePositionAndCornerGeometry.description"),
        tooltip: t("property.strokePositionAndCornerGeometry.description"),
        isDisabled: !n,
        "data-cy": "stroke-properties-subInspector",
        children: (0, J8.jsx)(Qk, { children: e }),
      }),
      (0, J8.jsx)(zK, {}),
    ],
  });
}
export function aee() {
  return (0, J8.jsx)(ree, { children: (0, J8.jsx)(iee, {}) });
}
export function lee() {
  return (0, J8.jsx)(ree, {
    children: (0, J8.jsx)(iee, { disablePositionControls: true }),
  });
}

export var pee = {
  button: "UBQ_StrokeStyleSelect-module__button--NBL3i",
  option: "UBQ_StrokeStyleSelect-module__option--CpdmR",
};

export var hee = [
  "Solid",
  "Dashed",
  "DashedRound",
  "LongDashed",
  "LongDashedRound",
  "Dotted",
];
export var mee = (e) => ({
  Dashed: {
    name: "Dashed",
    label: e("property.strokeStyle.dashed"),
    icon: (0, fee.jsx)(uee, {}),
  },
  DashedRound: {
    name: "DashedRound",
    label: e("property.strokeStyle.dashedRound"),
    icon: (0, fee.jsx)(uee, {}),
  },
  Dotted: {
    name: "Dotted",
    label: e("property.strokeStyle.dotted"),
    icon: (0, fee.jsx)(u8, {}),
  },
  LongDashed: {
    name: "LongDashed",
    label: e("property.strokeStyle.longDashed"),
    icon: (0, fee.jsx)(uee, {}),
  },
  LongDashedRound: {
    name: "LongDashedRound",
    label: e("property.strokeStyle.longDashedRound"),
    icon: (0, fee.jsx)(uee, {}),
  },
  Solid: {
    name: "Solid",
    label: e("property.strokeStyle.solid"),
    icon: (0, fee.jsx)(p8, {}),
  },
});
export function gee({ plain: e = false, isDisabled: t = false }) {
  const { t: n, i18n: s } = ZL(),
    i = IV(),
    o = (0, dee.useMemo)(() => mee(n), [s.language]),
    r = O$(),
    [a] = possibleHook3(r?.hasStroke, false),
    [l, c] = possibleHook3(a && r?.strokeStyle, "Solid"),
    u = n("property.strokeStyle.description");
  return (0, fee.jsxs)(bw, {
    children: [
      (n, { isOpen: s }) =>
        (0, fee.jsx)(Ly, {
          label: u,
          children: (0, fee.jsxs)(CompCustomButton, {
            name: "select-stroke-style",
            "aria-label": u,
            variant: e ? "plain" : undefined,
            className: pee.button,
            isDisabled: t,
            icon: o[l].icon,
            ...n,
            children: [
              o[l].label,
              s
                ? (0, fee.jsx)(IconChevronDown, {})
                : (0, fee.jsx)(IconChevronUp, {}),
            ],
          }),
        }),
      () =>
        (0, fee.jsx)(bw.Options, {
          value: l,
          onChange: (e) => {
            c(e), i("action.strokeStyle.change");
          },
          children: hee.map((e) => {
            const { name: t, icon: n, label: s } = o[e];
            return (0, fee.jsx)(
              bw.Option,
              { value: t, className: pee.option, icon: n, children: s },
              t
            );
          }),
        }),
    ],
  });
}
export function xee() {
  const { t: e } = ZL(),
    t = rI(EH);
  return (0, fee.jsxs)(Yk, {
    children: [
      (0, fee.jsx)(Sv, { isDisabled: !t, children: e("property.strokeStyle") }),
      (0, fee.jsx)(gee, { isDisabled: !t }),
      (0, fee.jsx)(zK, {}),
    ],
  });
}
export var bee = function ({ isDisabled: e }) {
  const t = rI(EH),
    n = X8();
  return n
    ? (0, fee.jsx)(gee, { plain: true, isDisabled: !t || !n || e })
    : null;
};

export function vee({ isDisabled: e }) {
  const { t: t } = ZL(),
    n = O$(),
    [s, i] = possibleHook3(n?.strokeWidth, 0),
    o = t("property.strokeWidth.description"),
    r = oD(),
    [a] = possibleHook3(r.scene.designUnit),
    l = rX(a),
    c = IV(),
    u = (() => {
      switch (a) {
        case "Pixel":
          return 1;
        case "Millimeter":
        default:
          return 0.1;
        case "Inch":
          return 0.01;
      }
    })();
  return (0, yee.jsxs)(yee.Fragment, {
    children: [
      (0, yee.jsx)(Sv, { isDisabled: e, children: t("property.strokeWidth") }),
      (0, yee.jsx)(Ly, {
        label: o,
        children: (0, yee.jsx)(zv, {
          name: "strokeWidthInput",
          "aria-label": o,
          value: s,
          onChange: (e) => {
            undefined !== e && i(e);
          },
          onRelease: (e) => {
            undefined !== e && (i(e), c("action.property.update"));
          },
          min: 0,
          maxFractionDigits: 2,
          step: u,
          unitLabel: l,
          isDisabled: e,
        }),
      }),
    ],
  });
}
export var wee = {
  DefaultUI: function () {
    return (0, yee.jsx)(vee, { isDisabled: false });
  },
  AdvancedUI: function () {
    const e = rI(EH);
    return (0, yee.jsx)(vee, { isDisabled: !e });
  },
};

export var Cee = (e) => [
  {
    type: "customRender",
    show: X8,
    render: () =>
      (0, kee.jsxs)(Yk, {
        children: [(0, kee.jsx)(wee.AdvancedUI, {}), (0, kee.jsx)(zK, {})],
      }),
  },
  { type: "component", show: X8, component: xee },
  { type: "component", show: X8, component: e?.forText ? lee : aee },
];

export var See = "ubq/designblocks/DesignBlockProps";
export var _ee = Y6({
  designBlockType: "//ly.img.ubq/graphic",
  propsComponent: See,
  inspector: [
    { type: "common", component: See },
    {
      type: "section",
      i18nKey: "shape",
      i18nString: "input.shape",
      show: ({ facade: { cesdk: e, engine: t } }) => {
        const n = t.block.findAllSelected()[0];
        if (null == n) return false;
        if ("sticker" === t.block.getKind(n)) return false;
        const s = t.block.hasShape(n) ? t.block.getShape(n) : undefined,
          i = null != s && t.block.isValid(s) ? t.block.getType(s) : undefined;
        if (!s) return false;
        const o = t.block.findAllProperties(s);
        return (
          (o.includes("shape/polygon/sides") ||
            o.includes("shape/star/points") ||
            o.includes("shape/star/innerDiameter") ||
            "//ly.img.ubq/shape/line" === i ||
            "//ly.img.ubq/shape/rect" === i) &&
          (e?.feature.isEnabled("ly.img.shape.options", { engine: t }) ?? false)
        );
      },
      children: [R8, A8, F8, T8, E8],
    },
    {
      type: "section",
      i18nString: "component.contentFill",
      show: ({ facade: { cesdk: e, engine: t } }) => {
        const n = t.block.findAllSelected()[0];
        return (
          null != n &&
          "sticker" !== t.block.getKind(n) &&
          (e?.feature.isEnabled("ly.img.fill", { engine: t }) ?? false)
        );
      },
      children: [() => (0, jee.jsx)(v4.Control, {})],
    },
    {
      type: "section",
      i18nKey: "stroke",
      i18nString: "input.stroke",
      show: ({ facade: { cesdk: e, engine: t } }) => {
        const n = t.block.findAllSelected()[0];
        if (null == n) return false;
        const s = t.block.hasShape(n) ? t.block.getShape(n) : undefined;
        return (
          "//ly.img.ubq/shape/line" !==
            (null != s && t.block.isValid(s)
              ? t.block.getType(s)
              : undefined) &&
          "sticker" !== t.block.getKind(n) &&
          (e?.feature.isEnabled("ly.img.stroke", { engine: t }) ?? false)
        );
      },
      children: [
        {
          type: "customRender",
          render: () =>
            (0, jee.jsx)(w0.Stroke, {
              panelId: "//ly.img.panel/inspector/stroke/color",
              groupId: "subInspector",
              includeAlpha: true,
              name: "strokeColor",
              i18nLabelString: "property.strokeColor",
              i18nDescriptionString: "property.strokeColor.description",
              donutHole: true,
            }),
        },
        ...Cee(),
      ],
    },
    {
      type: "section",
      i18nKey: "animations",
      i18nString: "input.animations",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.animations", { engine: t }) ?? false,
      children: [
        { type: "component", component: () => (0, jee.jsx)(oY.Control, {}) },
      ],
    },
    {
      type: "section",
      i18nKey: "appearance",
      i18nString: "input.appearance",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        [
          "ly.img.adjustment",
          "ly.img.filter",
          "ly.img.effect",
          "ly.img.blur",
          "ly.img.shadow",
        ].some((n) => e?.feature.isEnabled(n, { engine: t }) ?? false),
      children: [
        {
          type: "component",
          show: ({ facade: { engine: e } }) => {
            const t = e.block.findAllSelected()[0];
            return null != t && "sticker" !== e.block.getKind(t);
          },
          component: () => (0, jee.jsx)(j2.ControlStack, {}),
        },
        {
          type: "component",
          show: ({ facade: { engine: e } }) => {
            const t = e.block.findAllSelected()[0];
            return null != t && "sticker" !== e.block.getKind(t);
          },
          component: () => (0, jee.jsx)(W2.ControlStack, {}),
        },
        {
          type: "component",
          show: ({ facade: { engine: e } }) => {
            const t = e.block.findAllSelected()[0];
            return null != t && "sticker" !== e.block.getKind(t);
          },
          component: () => (0, jee.jsx)(p5.ControlStack, {}),
        },
        {
          type: "component",
          show: ({ facade: { engine: e } }) => {
            const t = e.block.findAllSelected()[0];
            return null != t && "sticker" !== e.block.getKind(t);
          },
          component: () => (0, jee.jsx)(i2.Control, {}),
        },
        {
          type: "inspectorSectionRow",
          show: ({ facade: { engine: e } }) => {
            const t = e.block.findAllSelected()[0];
            return null != t && "sticker" !== e.block.getKind(t);
          },
          children: [{ type: "separator" }],
        },
        { type: "customRender", render: () => (0, jee.jsx)(P0.Control, {}) },
      ],
    },
    ...w8(),
  ],
});
export var Aee = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    isDisabled: t,
    className: n,
    asCanvasAction: s = false,
    variant: i = "plain",
    name: o = "ungroup",
    centered: r,
  }) {
    const a = oI("ui/group"),
      l = IV(),
      [c] = e.block.findAllSelected(),
      u = DO(),
      { t: d } = ZL(),
      p = d("action.ungroup"),
      f = VO().feature.isEnabled("ly.img.group", { engine: e });
    return null != c && "//ly.img.ubq/group" === e.block.getType(c) && a && f
      ? (0, Pee.jsx)(CompCustomButton, {
          className: n,
          icon: (0, Pee.jsx)(Lee, {}),
          name: o,
          "aria-label": p,
          isDisabled: t,
          variant: i,
          onClick: () => {
            const t = e.block.getChildren(c);
            if (
              (e.block.ungroup(c),
              t.forEach((t) => {
                e.block.setSelected(t, true);
              }),
              t.length > 0)
            ) {
              const [n] = t;
              !(function t(n) {
                const s = e.block.getParent(n);
                s &&
                  ("//ly.img.ubq/page" === e.block.getType(s)
                    ? u.scrollToPage(s)
                    : t(s));
              })(n);
            }
            l("action.ungroup");
          },
          "data-ubq-action": s ? RH : undefined,
          centered: r,
          children: p,
        })
      : null;
  })
);
export var Bee = Aee;

export var Mee = "ubq/designblocks/Group";
export var Oee = Y6({
  designBlockType: "//ly.img.ubq/group",
  propsComponent: Mee,
  inspector: [
    { type: "common", component: Mee },
    {
      type: "section",
      i18nKey: "selection",
      i18nString: "input.selection",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.group", { engine: t }) ?? false,
      children: [
        {
          type: "inspectorSectionRow",
          children: [
            {
              type: "customRender",
              render: () =>
                (0, Tee.jsx)(Bee, { variant: "regular", centered: true }),
            },
          ],
        },
      ],
    },
    ...w8(),
  ],
});

export var Vee = Y6({
  designBlockType: "//ly.img.ubq/page",
  propsComponent: "ubq/designblocks/Page",
  inspector: [
    {
      type: "section",
      i18nString: "component.contentFill",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.fill", { engine: t }) ?? false,
      children: [() => (0, Ree.jsx)(v4.Control, {})],
    },
    {
      type: "section",
      i18nKey: "stroke",
      i18nString: "input.stroke",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.stroke", { engine: t }) ?? false,
      children: [
        {
          type: "customRender",
          render: () =>
            (0, Ree.jsx)(w0.Stroke, {
              panelId: "//ly.img.panel/inspector/stroke/color",
              groupId: "subInspector",
              includeAlpha: true,
              name: "strokeColor",
              i18nLabelString: "property.strokeColor",
              i18nDescriptionString: "property.strokeColor.description",
              donutHole: true,
            }),
        },
        ...Cee(),
      ],
    },
    {
      type: "section",
      i18nKey: "appearance",
      i18nString: "input.appearance",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        [
          "ly.img.adjustment",
          "ly.img.filter",
          "ly.img.effect",
          "ly.img.blur",
          "ly.img.shadow",
        ].some((n) => e?.feature.isEnabled(n, { engine: t }) ?? false),
      children: [
        () => (0, Ree.jsx)(j2.ControlStack, {}),
        () => (0, Ree.jsx)(W2.ControlStack, {}),
        () => (0, Ree.jsx)(p5.ControlStack, {}),
        () => (0, Ree.jsx)(i2.Control, {}),
      ],
    },
    {
      type: "scope",
      show: ({ facade: e }) => "Video" !== e.engine.scene.getMode(),
    },
  ],
});
export var Dee = (e) => {
  const t = oD(),
    [n] = possibleHook3(t.scene.designUnit),
    s = GO(BleedMarginConfig, n),
    i = rX(n),
    o = (e) => `${(Math.round(100 * e) / 100).toString()} ${i}`;
  let r;
  return {
    options: s.dropdownOptions.map((t) => {
      const n = { label: o(t), value: t };
      return e.left === n.value && (r = n), n;
    }),
    selectedOption: r,
  };
};

export var Iee = function () {
  const e = DO(),
    t = oD(),
    n = IV(),
    { t: s } = ZL(),
    i = e.getPageManager(),
    [o, r] = possibleHook3(i.channels.bleedMargin),
    [a, l] = possibleHook3(i.channels.bleedMarginEnabled),
    [c] = possibleHook3(t.scene.designUnit),
    u = rX(c),
    { selectedOption: d, options: p } = Dee(o),
    f = (e, t) => {
      null != e &&
        (r(
          e < 0
            ? { left: 0, top: 0, right: 0, bottom: 0 }
            : { left: e, top: e, right: e, bottom: e }
        ),
        t && n("action.property.update"));
    },
    h = s("property.bleedMargin"),
    m = s("input.bleedMargin.select");
  return (0, Fee.jsx)(NK, {
    isEnabled: a,
    label: h,
    toggleProperty: (e) => {
      const t = "boolean" == typeof e ? e : e(a);
      l(t), i.setBleedMarginEnabled(t);
    },
    "data-cy": "togglePropertyBleedMargin",
    children: (0, Fee.jsx)(Pv, {
      name: "margin",
      isDisabled: !a,
      label: h,
      children: (e) =>
        (0, Fee.jsx)(Aw, {
          min: 0,
          value: o?.left,
          onChange: f,
          onRelease: (e) => {
            f(e, true);
          },
          isDisabled: !a,
          options: p,
          selectedOption: d,
          unitLabel: u,
          ...e,
          "aria-label": m,
        }),
    }),
  });
};
export var Hee = Iee;

export var $ee = function () {
  const { t: e } = ZL(),
    t = DO().getPageManager(),
    [n, s] = (0, Nee.useState)(t.getClipContent()),
    i = (e) => () => {
      t.setClipContent(e), s(e);
    };
  return (0, zee.jsxs)(zee.Fragment, {
    children: [
      (0, zee.jsx)(Sv, { children: e("input.clipContent") }),
      (0, zee.jsxs)(CompButtonGroup, {
        children: [
          (0, zee.jsx)(CompCustomButton, {
            name: "enableClipContent",
            isActive: n,
            onClick: i(true),
            className: Uee,
            "aria-label": e("input.clipContent.on.description"),
            children: e("common.on"),
          }),
          (0, zee.jsx)(CompCustomButton, {
            name: "disableClipContent",
            isActive: !n,
            onClick: i(false),
            className: Uee,
            "aria-label": e("input.clipContent.off.description"),
            children: e("common.off"),
          }),
        ],
      }),
      (0, zee.jsx)(zK, {}),
    ],
  });
};
export var qee = $ee;
export function Gee(e) {
  return { ...e, width: e.height, height: e.width };
}
export function Zee(e, t) {
  const n = (function (e, t = 1) {
    const n = 10 ** t;
    return {
      ...e,
      width: Math.round(e.width * n) / n,
      height: Math.round(e.height * n) / n,
    };
  })(t);
  let s;
  return (
    Object.entries(e).some(([e, t]) => {
      const i = { unit: t.unit, width: t.width, height: t.height },
        o = Gee(i);
      return (0, Qee.default)(i, n)
        ? ((s = { id: e, preset: t }), true)
        : !(!(0, Qee.default)(o, n) || t.fixedOrientation) &&
            ((s = { id: e, preset: Gee(t) }), true);
    }),
    undefined !== s ? s : { id: "custom", preset: t }
  );
}
export var Kee = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = DO(),
    n = IV(),
    s = oD(),
    [i] = possibleHook3(t.settings.pageFormats),
    [o] = possibleHook3(s.scene.pageDimensions),
    [r] = possibleHook3(s.scene.designUnit),
    [a] = possibleHook3(s.scene.dpi),
    [l, c] = possibleHook3(s.scene.aspectRatioLock),
    u = { unit: r, width: o.width, height: o.height },
    d = ({ width: e, height: n }) => {
      let s = 1;
      switch (r) {
        case "Millimeter":
          s = (1 / a) * 25.4;
          break;
        case "Inch":
          s = 1 / a;
      }
      const o = {
        ...u,
        width: wk(e ?? u.width, s, Number.MAX_SAFE_INTEGER),
        height: wk(n ?? u.height, s, Number.MAX_SAFE_INTEGER),
      };
      if (l) {
        const t = (c = u).width / c.height;
        let i, r, a, l;
        t < 1
          ? ((i = s),
            (r = s / t),
            (a = Number.MAX_SAFE_INTEGER * t),
            (l = Number.MAX_SAFE_INTEGER))
          : ((i = s * t),
            (r = s),
            (a = Number.MAX_SAFE_INTEGER),
            (l = Number.MAX_SAFE_INTEGER / t)),
          (o.width = wk(e ?? n * t, i, a)),
          (o.height = wk(n ?? e / t, r, l));
      }
      var c;
      t.updatePageFormat(Zee(i, o));
    },
    p = () => {
      n("action.page.changeFormat", { resyncCameraFromSnapshot: true });
    },
    f = (t) =>
      e("x" === t ? "common.width.inUnit" : "common.height.inUnit", {
        unit: r,
      });
  return (0, Wee.jsxs)(Wee.Fragment, {
    children: [
      (0, Wee.jsxs)(Yk, {
        children: [
          (0, Wee.jsx)(Sv, {
            htmlFor: "pages-width",
            children: e("common.width"),
          }),
          (0, Wee.jsx)(zv, {
            id: "pages-width",
            name: "pages-width",
            value: o.width,
            onChange: (e) => {
              undefined !== e && d({ width: e, height: undefined });
            },
            unitLabel: rX(r),
            onRelease: p,
            "aria-label": f("x"),
            tooltipLabel: f("x"),
            min: 0,
            max: Number.MAX_SAFE_INTEGER,
          }),
          (0, Wee.jsx)(Z0, { isLocked: l, setIsLocked: c }),
        ],
      }),
      (0, Wee.jsxs)(Yk, {
        children: [
          (0, Wee.jsx)(Sv, {
            htmlFor: "pages-height",
            children: e("common.height"),
          }),
          (0, Wee.jsx)(zv, {
            id: "pages-height",
            name: "pages-height",
            value: o.height,
            onChange: (e) => {
              undefined !== e && d({ width: undefined, height: e });
            },
            unitLabel: rX(r),
            onRelease: p,
            "aria-label": f("y"),
            tooltipLabel: f("y"),
            min: 0,
            max: Number.MAX_SAFE_INTEGER,
          }),
          (0, Wee.jsx)(zK, {}),
        ],
      }),
    ],
  });
});
export var Yee = Kee;

export var ete = WithEngineComp(function ({ engine: e }) {
  const t = IV(),
    { t: n } = ZL(),
    s = e.scene.get();
  if (null === s) return null;
  const i = e.block.getFloat(s, "scene/dpi"),
    o = ResolutionOptions.dropdownOptions.map((e) => ({
      value: e,
      label: `${e} dpi`,
    })),
    r = o.find((e) => e.value === i),
    a = n("common.resolution"),
    l = n("input.resolution.select", { which: a }),
    c = e.scene.getDesignUnit(),
    u = e.block.getFloat(s, "scene/pageDimensions/width"),
    d = e.block.getFloat(s, "scene/pageDimensions/height"),
    p =
      "Millimeter" === c
        ? wk(Math.ceil(1 / (Math.min(u, d) / 25.4)), 1, Number.MAX_SAFE_INTEGER)
        : "Inch" === c
        ? wk(Math.ceil(1 / Math.min(u, d)), 1, Number.MAX_SAFE_INTEGER)
        : 1;
  return (0, Jee.jsxs)(Jee.Fragment, {
    children: [
      (0, Jee.jsx)(Sv, { htmlFor: "pages-dpi", children: a }),
      (0, Jee.jsx)(Aw, {
        id: "pages-dpi",
        name: "dpi",
        value: i,
        min: p,
        step: 1,
        selectedOption: r,
        options: o,
        onChange: (t) => {
          undefined !== t &&
            e.block.setFloat(s, "scene/dpi", wk(t, p, Number.MAX_SAFE_INTEGER));
        },
        onRelease: () => {
          t("action.property.update");
        },
        unitLabel: "dpi",
        "aria-label": l,
      }),
      (0, Jee.jsx)(zK, {}),
    ],
  });
});
export var cte = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = DO(),
    [n] = possibleHook3(t.settings.pageFormats),
    s = IV(),
    i = () => {
      s("action.page.changeFormat", { resyncCameraFromSnapshot: true });
    },
    o = oD(),
    [r] = possibleHook3(o.scene.designUnit),
    [a] = possibleHook3(o.scene.pageFormatId),
    [l] = possibleHook3(o.scene.pageDimensions),
    c = (function ({ width: e, height: t }) {
      return e === t ? 2 : e > t ? 1 : 0;
    })(l),
    u = (0, ote.useRef)(1);
  2 !== c && (u.current = c);
  const d = !n[a]?.fixedOrientation,
    p = (e) => {
      const s = n[e];
      t.updatePageFormat({ id: e, preset: s }), i();
    };
  return (0, lte.jsxs)(lte.Fragment, {
    children: [
      (0, lte.jsx)(Sv, { children: e("input.preset") }),
      (0, lte.jsxs)(bw, {
        children: [
          (t, { isOpen: n }) =>
            (0, lte.jsx)(Ly, {
              label: e("input.preset.tooltip"),
              children: (0, lte.jsxs)(CompCustomButton, {
                name: "FormatSelect",
                "data-cy": "FormatSelect",
                "aria-label": e(["input.preset.description", "input.preset"]),
                ...t,
                children: [
                  e(`preset.document.${a}`, { defaultValue: a }),
                  n
                    ? (0, lte.jsx)(IconChevronDown, {})
                    : (0, lte.jsx)(IconChevronUp, {}),
                ],
              }),
            }),
          () =>
            (0, lte.jsx)(bw.Options, {
              value: a,
              onChange: p,
              children: Object.keys(n).map((t) =>
                (0, lte.jsx)(
                  bw.Option,
                  {
                    value: t,
                    "data-value": t,
                    children: (0, lte.jsx)("span", {
                      className: ate,
                      children: e(`preset.document.${t}`, {
                        defaultValue: t,
                      }),
                    }),
                  },
                  t
                )
              ),
            }),
        ],
      }),
      (0, lte.jsx)(Ly, {
        label: e("property.orientation.flip"),
        children: (0, lte.jsx)(CompCustomButton, {
          variant: "plain",
          "aria-label": e("property.orientation.description", {
            orientation: e(
              1 === c
                ? "property.orientation.portrait"
                : "property.orientation.landscape"
            ),
          }),
          name: "toggleOrientation",
          className: rte,
          onClick: () => {
            const e = Zee(n, { unit: r, width: l.height, height: l.width });
            t.updatePageFormat(e), i();
          },
          disabled: !d || 2 === c,
          children:
            1 === u.current ? (0, lte.jsx)(nte, {}) : (0, lte.jsx)(ite, {}),
        }),
      }),
    ],
  });
});
export var gte = function () {
  const e = DO(),
    { t: t } = ZL(),
    n = IV(),
    s = oD(),
    [i] = possibleHook3(s.scene.layout);
  return (0, mte.jsxs)(Yk, {
    children: [
      (0, mte.jsx)(Sv, { children: t("property.layout") }),
      (0, mte.jsxs)(CompButtonGroup, {
        children: [
          (0, mte.jsx)(Ly, {
            label: t("property.layout.horizontal"),
            children: (0, mte.jsx)(CompCustomButton, {
              name: "horizontalLayout",
              "aria-label": t("property.layout.horizontal"),
              isActive: "HorizontalStack" === i,
              onClick: () => {
                e.legacyApi
                  .changeSceneLayout(e.getScene(), "HorizontalStack", 35, true)
                  .then(() => {
                    n("property.layout.horizontal");
                  });
              },
              children: (0, mte.jsx)(pte, {}),
            }),
          }),
          (0, mte.jsx)(Ly, {
            label: t("property.layout.vertical"),
            children: (0, mte.jsx)(CompCustomButton, {
              name: "verticalLayout",
              "aria-label": t("property.layout.vertical"),
              isActive: "VerticalStack" === i,
              onClick: () => {
                e.legacyApi
                  .changeSceneLayout(e.getScene(), "VerticalStack", 35, true)
                  .then(() => {
                    n("property.layout.vertical");
                  });
              },
              children: (0, mte.jsx)(hte, {}),
            }),
          }),
        ],
      }),
    ],
  });
};
export var xte = gte;

export var yte = WithEngineComp(function ({ engine: e }) {
  const t = IV(),
    { t: n } = ZL(),
    s = e.scene.get();
  if (null === s || "Pixel" !== e.scene.getDesignUnit()) return null;
  const i = e.block.getFloat(s, "scene/pixelScaleFactor"),
    o = PlaybackSpeedOptions.dropdownOptions.map((e) => ({
      value: e,
      label: `${e} x`,
    })),
    r = o.find((e) => e.value === i),
    a = n("common.pixelScale"),
    l = n("input.resolution.select", { which: a });
  return (0, bte.jsxs)(bte.Fragment, {
    children: [
      (0, bte.jsx)(Sv, { htmlFor: "pages-pixel-scale", children: a }),
      (0, bte.jsx)(Aw, {
        id: "pages-pixel-scale",
        name: "pixelscale",
        value: i,
        min: 0.1,
        step: 0.1,
        selectedOption: r,
        options: o,
        onChange: (t) => {
          t && e.block.setFloat(s, "scene/pixelScaleFactor", t);
        },
        onRelease: () => {
          t("action.property.update");
        },
        unitLabel: "x",
        "aria-label": l,
      }),
      (0, bte.jsx)(zK, {}),
    ],
  });
});

export var wte = {
  designBlockType: "//ly.img.ubq/scene",
  propsComponent: "ubq/designblocks/SceneProps",
  inspector: [
    {
      type: "section",
      i18nKey: "input.canvas",
      show: ({ facade: e }) => {
        const t = e.engine.scene.getMode(),
          n = e.engine.block.getEnum(e.engine.scene.get(), "scene/layout");
        return "Video" !== t && "Free" !== n;
      },
      children: [{ type: "inspectorSectionRow", children: [xte] }],
    },
    {
      type: "section",
      i18nKey: "pages",
      i18nString: "input.pages",
      show: (e) => e.configurationStore.blocks["//ly.img.ubq/page"].format,
      children: [
        {
          show: ({ configuration: e }) => !e.featureFlags?.differentPageFormats,
          type: "inspectorSectionRow",
          children: [ute],
        },
        {
          type: "inspectorSectionRow",
          show: ({ configuration: e }) => !e.featureFlags?.differentPageFormats,
          children: [{ type: "separator" }],
        },
        {
          type: "customRender",
          show: ({ configuration: e }) => !e.featureFlags?.differentPageFormats,
          render: () => (0, vte.jsx)(Yee, {}),
        },
        {
          type: "inspectorSectionRow",
          show: ({ configuration: e }) => !e.featureFlags?.differentPageFormats,
          children: [{ type: "separator" }],
        },
        {
          type: "inspectorSectionRow",
          show: ({ facade: e }) => "Video" !== e.engine.scene.getMode(),
          children: [
            function () {
              const e = DO(),
                t = IV(),
                [n] = possibleHook3(e.settings.pageFormats),
                { t: s } = ZL(),
                i = oD(),
                [o, r] = possibleHook3(i.scene.designUnit),
                a = (s) => {
                  r(s);
                  const i = { ...e.getPageDimensions(), unit: s },
                    o = Zee(n, i);
                  e.updatePageFormat(o),
                    t("action.page.changeFormat", {
                      resyncCameraFromSnapshot: true,
                    });
                },
                l = (e) => {
                  switch (e) {
                    case "Inch":
                      return s("common.inch");
                    case "Millimeter":
                      return s("common.millimeter");
                    case "Pixel":
                      return s("common.pixel");
                    default:
                      return e;
                  }
                },
                c = ["Inch", "Millimeter", "Pixel"];
              return (0, Xee.jsxs)(Xee.Fragment, {
                children: [
                  (0, Xee.jsx)(Sv, { children: s("common.unit") }),
                  (0, Xee.jsxs)(bw, {
                    children: [
                      (e, { isOpen: t }) =>
                        (0, Xee.jsx)(Ly, {
                          label: s("input.unit.tooltip"),
                          children: (0, Xee.jsxs)(CompCustomButton, {
                            name: "DesignUnitSelect",
                            "aria-label": s("common.unit.description"),
                            ...e,
                            children: [
                              l(o),
                              t
                                ? (0, Xee.jsx)(IconChevronDown, {})
                                : (0, Xee.jsx)(IconChevronUp, {}),
                            ],
                          }),
                        }),
                      () =>
                        (0, Xee.jsx)(bw.Options, {
                          value: o,
                          onChange: a,
                          children: c.map((e) =>
                            (0, Xee.jsx)(
                              bw.Option,
                              { value: e, children: l(e) },
                              e
                            )
                          ),
                        }),
                    ],
                  }),
                  (0, Xee.jsx)(zK, {}),
                ],
              });
            },
          ],
        },
        {
          type: "inspectorSectionRow",
          show: ({ facade: e }) => "Video" !== e.engine.scene.getMode(),
          children: [yte],
        },
        {
          type: "inspectorSectionRow",
          show: ({ facade: e }) => "Video" !== e.engine.scene.getMode(),
          children: [ete],
        },
        {
          type: "inspectorSectionRow",
          show: ({ facade: e, configuration: t }) =>
            "Video" !== e.engine.scene.getMode() &&
            !t.featureFlags?.differentPageFormats,
          children: [{ type: "separator" }],
        },
        {
          type: "inspectorSectionRow",
          show: ({ facade: e, configuration: t }) =>
            "Video" !== e.engine.scene.getMode() &&
            !t.featureFlags?.differentPageFormats,
          children: [Hee],
        },
        {
          type: "inspectorSectionRow",
          show: ({ facade: e, configuration: t }) =>
            "Video" !== e.engine.scene.getMode() &&
            !t.featureFlags?.differentPageFormats,
          children: [{ type: "separator" }],
        },
        { type: "inspectorSectionRow", children: [qee] },
      ],
    },
  ],
};
export var kte = Y6(wte);

export var Bte = WithEngineComp(function ({ engine: e, children: t }) {
  const n = VO(),
    [s] = e.block.findAllSelected(),
    i = null != s && "//ly.img.ubq/text" === e.block.getType(s),
    o =
      null != s &&
      e.block.supportsFill(s) &&
      e.block.isValid(e.block.getFill(s)),
    r = n.feature.isEnabled("ly.img.fill", { engine: e });
  return i && o && r ? t({ block: s }) : null;
});
export function Tte(e) {
  const { shouldNotRender: t, ...n } = (function ({
    block: e,
    isDisabled: t,
    inBar: n,
    deniedByScopeBehavior: s = "disable",
  }) {
    const i = YF(),
      o = rI(SH),
      { isPropertyEnabled: r, allTextColors: a } = eI(i, () => ({
        isPropertyEnabled: i.block.isFillEnabled(e),
        allTextColors: i.block.getTextColors(e),
      })),
      l = (0, Pte.useCallback)(
        (t) => {
          i.block.setFillEnabled(e, t);
        },
        [e, i]
      ),
      c = (0, Pte.useCallback)(
        (t) => {
          i.block.setTextColor(e, t);
        },
        [e, i]
      ),
      u = (0, Pte.useMemo)(() => PO(a, i.editor), [a, i.editor]),
      d = a[0];
    return {
      block: e,
      isPropertyEnabled: r,
      setIsPropertyEnabled: l,
      name: "color",
      color: d,
      setColor: c,
      previewColor: u,
      isDisabled: t || !o,
      includeAlpha: true,
      i18nLabelString: "property.fill",
      i18nDescriptionString: "property.fill.description",
      panelId: "//ly.img.panel/inspector/fill/color",
      "data-cy": "fill",
      inBar: n,
      shouldNotRender: !o && "hide" === s,
    };
  })(e);
  return t ? null : (0, Ate.jsx)(w0, { ...n });
}
export function Mte(e) {
  return (0, Ate.jsx)(Bte, {
    children: (t) => (0, Ate.jsx)(Tte, { ...t, ...e }),
  });
}
Mte.InBar = function (e) {
  return (0, Ate.jsx)(Bte, {
    children: (t) => (0, Ate.jsx)(Tte, { ...t, ...e, inBar: true }),
  });
};
export var Ote = Mte;

export function Dte(e) {
  return null != e ? Math.round(100 * e) / 100 : e;
}
export var Fte = (e) => {
  const { t: t } = ZL(),
    n = FontSizeOptions,
    s = (0, Vte.useMemo)(
      () => ({
        label: t("typography.autoSize"),
        value: "auto",
        separate: true,
      }),
      [t]
    ),
    i = (e) => `${e.toString()} pt`,
    o = "number" == typeof e ? Dte(e) : e,
    [r, a] = (0, Vte.useMemo)(() => {
      let e;
      o === s.value && (e = s);
      const t = n.dropdownOptions.map((t) => {
        const n = Dte(t),
          s = { label: i(n), value: t };
        return o === n && (e = s), s;
      });
      return [[s, ...t], e];
    }, [s, n.dropdownOptions, o]);
  return { options: r, selectedOption: a };
};

export var zte = WithEngineComp(function ({
  engine: e,
  block: t,
  isDisabled: n,
  inBar: s = false,
  className: i,
  deniedByScopeBehavior: o = "disable",
  ...r
}) {
  const a = VO(),
    l = DO(),
    c = IV(),
    { t: u } = ZL(),
    d = rI(jH),
    p = e.block.getFloat(t, "text/fontSize"),
    f = (n) => e.block.setFloat(t, "text/fontSize", n),
    h = e.block.getBool(t, "text/automaticFontSizeEnabled"),
    m = (n) => e.block.setBool(t, "text/automaticFontSizeEnabled", n),
    { options: g, selectedOption: x } = Fte(h ? "auto" : p),
    b = (n) => {
      const s = ((e, t) => (n) => {
        undefined !== n &&
          (e(n < 0.1 ? 0.1 : n), t && c("action.property.update"));
      })(f, n);
      return (i) => {
        "number" == typeof i
          ? (h &&
              (l.setTextFrameHeightAuto(t),
              n || a.ui.showNotification("action.text.autoHeight.automatic"),
              m(false)),
            s(i))
          : "auto" === i &&
            (l.setTextFrameSizingFixed(t),
            m(true),
            ((n) => {
              e.block.setFloat(t, "text/minAutomaticFontSize", n);
            })(Dte(0.5 * p)),
            ((n) => {
              e.block.setFloat(t, "text/maxAutomaticFontSize", n);
            })(p),
            n
              ? c("action.property.update")
              : a.ui.showNotification("action.text.fixedFrame.automatic"));
      };
    };
  return d || "hide" !== o
    ? (0, Ute.jsx)(Pv, {
        className: Ite,
        isDisabled: !d,
        name: "fontSize",
        label: u("typography.size"),
        children: (e) =>
          (0, Ute.jsx)(Pw, {
            min: 0.1,
            value: h ? "auto" : Dte(p),
            onChange: b(),
            onRelease: b(true),
            selectedOption: x,
            options: g,
            isDisabled: !d || n,
            unitLabel: "pt",
            "aria-label": u("input.fontSize.select"),
            "data-cy": "fontSizeSelect",
            className: (0, Rte.default)(i, { [Nte]: s }),
            ...r,
            ...e,
            children: h
              ? (0, Ute.jsx)("div", {
                  className: (0, Rte.default)(Fy, Hte),
                  children: (0, Ute.jsx)("span", {
                    children: u("typography.autoSize.abbreviation"),
                  }),
                })
              : null,
          }),
      })
    : null;
});
export var $te = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, ...t }) {
    const n = VO(),
      [s] = e.block.findAllSelected(),
      i = n.feature.isEnabled("ly.img.text.fontSize", { engine: e });
    return null != s && "//ly.img.ubq/text" === e.block.getType(s) && i
      ? (0, Ute.jsx)(zte, { block: s, ...t })
      : null;
  })
);

export var Gte = function () {
  const e = IV(),
    { t: t } = ZL(),
    n = O$(),
    s = rI(jH),
    [i] = possibleHook3(n?.automaticFontSizeEnabled, false),
    [o, r] = possibleHook3(n?.minAutomaticFontSize, 0),
    [a, l] = possibleHook3(n?.maxAutomaticFontSize, 0),
    c = (e) => {
      e < a && r(e);
    },
    u = (e) => {
      e > o && l(e);
    },
    d = 0.1,
    p = (t, n) => (s) => {
      undefined !== s && (t(s < d ? d : s), n && e("action.property.update"));
    };
  return i
    ? (0, Qte.jsxs)(Yk, {
        children: [
          (0, Qte.jsx)(Sv, {
            isDisabled: !s,
            children: t("typography.sizeRange"),
          }),
          (0, Qte.jsxs)(CompLayout1, {
            className: qte,
            children: [
              (0, Qte.jsx)(Ly, {
                label: t("input.fontSize.selectMin"),
                children: (0, Qte.jsx)(zv, {
                  name: "minAutomaticFontSize",
                  value: o,
                  min: d,
                  max: a,
                  maxFractionDigits: 1,
                  onChange: p(c),
                  onRelease: p(c, true),
                  unitLabel: "pt",
                  "aria-label": t("input.fontSize.selectMin"),
                  isDisabled: !s,
                }),
              }),
              (0, Qte.jsx)(Ly, {
                label: t("input.fontSize.selectMax"),
                children: (0, Qte.jsx)(zv, {
                  name: "maxAutomaticFontSize",
                  value: a,
                  min: Math.max(d, o),
                  maxFractionDigits: 1,
                  onChange: p(u),
                  onRelease: p(u, true),
                  unitLabel: "pt",
                  "aria-label": t("input.fontSize.selectMax"),
                  isDisabled: !s,
                }),
              }),
            ],
          }),
        ],
      })
    : null;
};

export var Yte = (e, t) => (e ? e.subFamily : t("typography.weight.400"));

export var Jte = function ({ font: e }) {
  const { t: t } = ZL();
  return (0, Xte.jsx)("div", { className: Kte, children: Yte(e, t) });
};

export function tne(e) {
  if (!e) return 400;
  switch (e) {
    case "thin":
      return 100;
    case "extraLight":
      return 200;
    case "light":
      return 300;
    case "normal":
    default:
      return 400;
    case "medium":
      return 500;
    case "semiBold":
      return 600;
    case "bold":
      return 700;
    case "extraBold":
      return 800;
    case "heavy":
      return 900;
  }
}
export function nne(e) {
  return e.sort((e, t) => tne(e.weight) - tne(t.weight));
}
export var sne = function ({ selectedFont: e }) {
  const t = YF(),
    n = O$(),
    s = IV(),
    { t: i } = ZL(),
    o = rI(jH);
  return (0, ene.jsxs)(bw.Async, {
    fetchValues: async () => {
      if (!n || !t.block.isValid(n.id)) return [];
      const e = t.block.getTypeface(n.id);
      return [
        ...nne(e.fonts.filter((e) => "italic" !== e.style)),
        ...nne(e.fonts.filter((e) => "italic" === e.style)),
      ];
    },
    children: [
      (t, { isOpen: n }) => {
        const s = i("input.fontSelect", { font: e?.style ?? "Regular" });
        return (0, ene.jsx)(Ly, {
          label: s,
          children: (0, ene.jsxs)(CompCustomButton, {
            name: "FontSelect",
            "data-cy": "FontSelect",
            "aria-label": s,
            isDisabled: !e || !o,
            ...t,
            children: [
              Yte(e, i),
              n
                ? (0, ene.jsx)(IconChevronDown, {})
                : (0, ene.jsx)(IconChevronUp, {}),
            ],
          }),
        });
      },
      ({ values: i }) =>
        (0, ene.jsx)(bw.Options, {
          value: e,
          onChange: (e) => {
            if (!e) return;
            if (!n || !t.block.isValid(n.id)) return;
            const i = t.block.getTypeface(n.id);
            t.block.setFont(n.id, e.uri, i), s("action.property.update");
          },
          children: (() => {
            let e = false;
            return i.map((t) => {
              const n = !e && "italic" === t.style;
              return (
                n && (e = true),
                (0, ene.jsxs)(
                  Zte.Fragment,
                  {
                    children: [
                      n && (0, ene.jsx)("hr", { className: Wte }),
                      (0, ene.jsx)(
                        bw.Option,
                        {
                          value: t,
                          "data-value": t.uri,
                          children: (0, ene.jsx)(Jte, { font: t }),
                        },
                        t.uri
                      ),
                    ],
                  },
                  t.uri
                )
              );
            });
          })(),
        }),
    ],
  });
};
export var ine = sne;
export var une = { bold: (0, cne.jsx)(rne, {}), italic: (0, cne.jsx)(lne, {}) };
export var dne = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    type: t,
    buttonProps: n,
    deniedByScopeBehavior: s = "disable",
  }) {
    const { t: i } = ZL(),
      o = VO(),
      r = rI(jH),
      a = o.feature.isEnabled("ly.img.text.fontStyle", { engine: e }),
      [l] = e.block.findAllSelected();
    if (
      null == l ||
      "//ly.img.ubq/text" !== e.block.getType(l) ||
      !a ||
      (!r && "hide" === s)
    )
      return null;
    const c = e.block.getTextFontStyles(l),
      u = e.block.getTextFontWeights(l),
      d = e.block.canToggleBoldFont(l),
      p = e.block.canToggleItalicFont(l),
      f = une[t],
      h = undefined !== u && "bold" === u[0],
      m = undefined !== c && "italic" === c[0],
      g = (!d && "bold" === t) || (!p && "italic" === t);
    let x = false,
      b = t;
    switch (t) {
      case "bold":
        (x = h), (b = i("typography.bold"));
        break;
      case "italic":
        (x = m), (b = i("typography.italic"));
        break;
      default:
        (x = false), (b = t);
    }
    const y = i("input.fontStyle.toggle", { style: b });
    return (0, cne.jsx)(Ly, {
      label: y,
      children: (0, cne.jsx)(CompCustomButton, {
        "aria-label": b,
        name: `font-style-toggle-${t}`,
        onClick: () => {
          "bold" === t
            ? e.block.toggleBoldFont(l)
            : "italic" === t && e.block.toggleItalicFont(l);
        },
        isActive: x,
        isDisabled: n?.isDisabled || !r || g,
        variant: n?.variant,
        children: f,
      }),
    });
  })
);
export var pne = dne;

export var hne = (e) => {
  const t = YF(),
    n = eI(t, (t) => {
      if (null != e)
        try {
          return t.block.getTypeface(e);
        } catch {
          return;
        }
    }),
    s = eI(t, (t) => {
      if (null != e)
        try {
          return t.block.getString(e, "text/fontFileUri");
        } catch {
          return;
        }
    }),
    i = (0, fne.useMemo)(() => {
      if (n) for (const e of n.fonts) if (e.uri === s) return e;
    }, [n, s]);
  return n ? { typeface: n, font: i } : undefined;
};

export var bne = {};
export var yne = async ({ fontFamily: e, fontFileUri: t }) => {
  if (!bne[e]) {
    if (FontFace) {
      const n = new FontFace(e, `url(${t})`);
      await n.load(), document.fonts.add(n);
    } else {
      const n = document.createElement("style");
      n.appendChild(
        document.createTextNode(
          `\n        @font-face {\n          font-family: "${e}";\n          src: url("${t}");\n        }\n        `
        )
      ),
        document.head.appendChild(n);
    }
    bne[e] = true;
  }
};
export var vne = {
  block: "UBQ_TypefaceSelectItem-module__block--pzqad",
  text: "UBQ_TypefaceSelectItem-module__text--B3knY",
};

export var kne = function ({ typeface: e, font: t, label: n }) {
  const s = (0, xne.useRef)(null),
    i = UE(s),
    [o, r] = (0, xne.useState)(0);
  (0, xne.useEffect)(() => {
    let n = true;
    return (
      i &&
        0 === o &&
        (r(1),
        yne({ fontFamily: e.name, fontFileUri: t.uri })
          .then(() => {
            n && r(2);
          })
          .catch(() => {
            n && r(0);
          })),
      () => {
        n = false;
      }
    );
  }, [e.name, t.uri, i]);
  const a = 2 === o ? { fontFamily: `"${e.name}"` } : {};
  return (0, wne.jsx)(bw.Option, {
    value: { typeface: e, font: t },
    "data-value": e.name,
    isLoading: 1 === o,
    className: vne.option,
    children: (0, wne.jsx)("div", {
      ref: s,
      className: (0, gne.default)(vne.block),
      children: (0, wne.jsx)("div", {
        className: vne.text,
        style: a,
        children: n || e.name,
      }),
    }),
  });
};

export var jne = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    buttonVariant: t,
    showIcon: n,
    isDisabled: s,
    deniedByScopeBehavior: i = "disable",
  }) {
    const o = FI(),
      r = IV(),
      { t: a } = ZL(),
      l = rI(jH),
      c = VO().feature.isEnabled("ly.img.text.typeface", { engine: e }),
      [u] = e.block.findAllSelected(),
      d = hne(u);
    if (
      null == u ||
      "//ly.img.ubq/text" !== e.block.getType(u) ||
      !c ||
      (!l && "hide" === i)
    )
      return null;
    const p = d?.font,
      f = d?.typeface;
    return (0, Cne.jsxs)(bw.Async, {
      className: mne,
      fetchValues: async () => {
        const t = (
            await Promise.all(
              (o.ui.typefaceLibraries ?? []).map(async (t) =>
                (
                  await e.asset.findAssets(t, { page: 0, perPage: 1e3 })
                ).assets.filter(
                  (e) =>
                    e.payload?.typeface && e.payload.typeface.fonts.length > 0
                )
              )
            )
          ).flat(),
          n = [];
        for (const e of t) {
          const t = e.payload.typeface;
          let s = t.fonts[0];
          for (const e of t.fonts)
            if (
              (undefined === e.weight || "normal" === e.weight) &&
              ((s = e), undefined === e.style || "normal" === e.style)
            )
              break;
          n.push({ typeface: t, font: s });
        }
        return n.sort((e, t) => e.typeface.name.localeCompare(t.typeface.name));
      },
      children: [
        (e, { isOpen: i }) =>
          (0, Cne.jsx)(Ly, {
            label: a("input.typefaceSelect.tooltip"),
            children: (0, Cne.jsxs)(CompCustomButton, {
              icon: n ? (0, Cne.jsx)(WY, {}) : undefined,
              name: "TypefaceSelect",
              "data-cy": "TypefaceSelect",
              "aria-label": a("input.typefaceSelect.description", {
                fontFamily: f?.name,
              }),
              isDisabled: !l || s,
              ...e,
              variant: t,
              children: [
                f ? f.name : a("input.fontSelect.fallback"),
                i
                  ? (0, Cne.jsx)(IconChevronDown, {})
                  : (0, Cne.jsx)(IconChevronUp, {}),
              ],
            }),
          }),
        ({ values: t }) =>
          (0, Cne.jsx)(bw.Options, {
            value: { typeface: f, font: p },
            onChange: (t) => {
              t.font &&
                t.typeface &&
                u &&
                (e.block.setTypeface(u, t.font.uri, t.typeface),
                r("action.property.update"));
            },
            children: t.map((e) =>
              (0, Cne.jsx)(
                kne,
                { typeface: e.typeface, font: e.font },
                e.typeface.name
              )
            ),
          }),
      ],
    });
  })
);
export var Sne = jne;

export var Lne = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, block: t }) {
    const { t: n } = ZL(),
      s = VO(),
      i = s.feature.isEnabled("ly.img.text.typeface", { engine: e }),
      o = s.feature.isEnabled("ly.img.text.fontSize", { engine: e }),
      r = s.feature.isEnabled("ly.img.text.fontStyle", { engine: e }),
      a = e.block.isAllowedByScope(t, jH),
      l = hne(t);
    return (0,
    Ene.jsxs)(Ene.Fragment, { children: [i && (0, Ene.jsxs)(Yk, { children: [(0, Ene.jsx)(Sv, { isDisabled: !a, children: n("typography.typeface") }), (0, Ene.jsx)(Sne, {})] }), r && (0, Ene.jsxs)(Yk, { children: [(0, Ene.jsx)(Sv, { isDisabled: !a, children: n("typography.style") }), (0, Ene.jsx)(ine, { selectedFont: l?.font }), (0, Ene.jsxs)("div", { className: _ne, children: [(0, Ene.jsx)(pne, { type: "bold" }), (0, Ene.jsx)(pne, { type: "italic" })] })] }), o && (0, Ene.jsxs)(Ene.Fragment, { children: [(0, Ene.jsx)(Yk, { children: (0, Ene.jsx)($te, {}) }), (0, Ene.jsx)(Gte, {})] })] });
  })
);
export var Pne = WithEngineComp(function ({ engine: e }) {
  const [t] = e.block.findAllSelected();
  return null == t || "//ly.img.ubq/text" !== e.block.getType(t)
    ? null
    : (0, Ene.jsx)(Lne, { block: t });
});

export var Bne = "ubq/designblocks/Text";
export function Tne(e, t) {
  const n = O$(),
    [s] = possibleHook3(n?.horizontalTextAlignment),
    [i] = possibleHook3(n?.verticalTextAlignment);
  return {
    component: Bne,
    isActive: ("horizontal" === e && s === t) || ("vertical" === e && i === t),
  };
}
export var Mne = Y6({
  designBlockType: "//ly.img.ubq/text",
  propsComponent: Bne,
  inspector: [
    { type: "common", component: Bne },
    {
      type: "section",
      i18nKey: "character",
      i18nString: "input.character",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        [
          "ly.img.text.typeface",
          "ly.img.text.fontSize",
          "ly.img.text.fontStyle",
          "ly.img.text.alignment",
          "ly.img.text.advanced",
        ].some((n) => e?.feature.isEnabled(n, { engine: t }) ?? false),
      children: [
        Pne,
        {
          type: "inspectorSectionRow",
          show: ({ facade: { engine: e, cesdk: t } }) =>
            t?.feature.isEnabled("ly.img.text.alignment", { engine: e }) ??
            false,
          children: [
            {
              type: "label",
              i18nKey: "property.textAlignment.horizontal",
              isDisabled: () => !rI(jH),
            },
            {
              type: "buttonContainer",
              name: "horizontalAlignment",
              children: [
                {
                  type: "button",
                  component: Bne,
                  name: "alignTextLeft",
                  buttonProps: () => Tne("horizontal", "Left"),
                  icon: (0, Ane.jsx)(_te, {}),
                  scope: jH,
                  tooltip: true,
                  i18nKey: "property.textAlignment.horizontal.left",
                  actionMethod: ({ engine: e }) => {
                    const t = e.block.findAllSelected()[0];
                    t && e.block.setEnum(t, "text/horizontalAlignment", "Left");
                  },
                },
                {
                  type: "button",
                  component: Bne,
                  name: "alignTextHorizontalCenter",
                  buttonProps: () => Tne("horizontal", "Center"),
                  icon: (0, Ane.jsx)(jte, {}),
                  scope: jH,
                  tooltip: true,
                  i18nKey: "property.textAlignment.horizontal.center",
                  actionMethod: ({ engine: e }) => {
                    const t = e.block.findAllSelected()[0];
                    t &&
                      e.block.setEnum(t, "text/horizontalAlignment", "Center");
                  },
                },
                {
                  type: "button",
                  component: Bne,
                  name: "alignTextRight",
                  buttonProps: () => Tne("horizontal", "Right"),
                  icon: (0, Ane.jsx)(Lte, {}),
                  scope: jH,
                  tooltip: true,
                  i18nKey: "property.textAlignment.horizontal.right",
                  actionMethod: ({ engine: e }) => {
                    const t = e.block.findAllSelected()[0];
                    t &&
                      e.block.setEnum(t, "text/horizontalAlignment", "Right");
                  },
                },
              ],
            },
          ],
        },
        {
          type: "inspectorSectionRow",
          show: ({
            configurationStore: e,
            facade: { cesdk: t, engine: n },
          }) => {
            const s = e.blocks["//ly.img.ubq/text"].advancedEnabled,
              i =
                t?.feature.isEnabled("ly.img.text.advanced", { engine: n }) ??
                false,
              o = [
                "ly.img.text.typeface",
                "ly.img.text.fontSize",
                "ly.img.text.fontStyle",
                "ly.img.text.alignment",
              ].some((e) => t?.feature.isEnabled(e, { engine: n }) ?? false);
            return s && i && o;
          },
          children: [{ type: "separator" }],
        },
        {
          type: "inspectorSectionRow",
          show: ({ configurationStore: e, facade: { cesdk: t, engine: n } }) =>
            e.blocks["//ly.img.ubq/text"].advancedEnabled &&
            (t?.feature.isEnabled("ly.img.text.advanced", { engine: n }) ??
              false),
          children: [
            {
              type: "customRender",
              render: () => (0, Ane.jsx)(pG.Control, {}),
            },
          ],
        },
      ],
    },
    {
      type: "section",
      i18nString: "component.contentFill",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.fill", { engine: t }) ?? false,
      children: [
        {
          type: "customRender",
          show: ({ configurationStore: e }) =>
            e.blocks["//ly.img.ubq/text"].colorEnabled,
          render: () => (0, Ane.jsx)(Ote, {}),
        },
      ],
    },
    {
      type: "section",
      i18nKey: "stroke",
      i18nString: "input.stroke",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.stroke", { engine: t }) ?? false,
      children: [
        {
          type: "customRender",
          render: () =>
            (0, Ane.jsx)(w0.Stroke, {
              panelId: "//ly.img.panel/inspector/stroke/color",
              groupId: "subInspector",
              includeAlpha: true,
              name: "strokeColor",
              i18nLabelString: "property.strokeColor",
              i18nDescriptionString: "property.strokeColor.description",
              donutHole: true,
            }),
        },
        ...Cee({ forText: true }),
      ],
    },
    {
      type: "section",
      i18nKey: "animations",
      i18nString: "input.animations",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        e?.feature.isEnabled("ly.img.animations", { engine: t }) ?? false,
      children: [
        { type: "component", component: () => (0, Ane.jsx)(oY.Control, {}) },
      ],
    },
    {
      type: "section",
      i18nKey: "appearance",
      i18nString: "input.appearance",
      show: ({ facade: { cesdk: e, engine: t } }) =>
        [
          "ly.img.adjustment",
          "ly.img.filter",
          "ly.img.effect",
          "ly.img.blur",
          "ly.img.shadow",
        ].some((n) => e?.feature.isEnabled(n, { engine: t }) ?? false),
      children: [
        () => (0, Ane.jsx)(j2.ControlStack, {}),
        () => (0, Ane.jsx)(W2.ControlStack, {}),
        () => (0, Ane.jsx)(p5.ControlStack, {}),
        () => (0, Ane.jsx)(i2.Control, {}),
        { type: "customRender", render: () => (0, Ane.jsx)(P0.Control, {}) },
      ],
    },
    { type: "scope" },
  ],
});
export var One = Object.values(x9).reduce(
  (e, t) => ((e[t.designBlockType] = t), e),
  {}
);

export var Vne = mayBeUseMemp(function ({ blockType: e }) {
  const t = One[e];
  return t ? (0, Rne.jsx)(t.inspector, {}) : null;
});
export var Dne = {
  container: "UBQ_WelcomeInspector-module__container--1g3cE",
  "white-label-logo": "UBQ_WelcomeInspector-module__white-label-logo--YuI6e",
  sectionblock: "UBQ_WelcomeInspector-module__sectionblock--gnll2",
  paragraphs: "UBQ_WelcomeInspector-module__paragraphs--6xS5e",
};

export var Ine = function () {
  return (0, Fne.jsx)(Qk, {
    className: Dne.sectionblock,
    classNameContent: Dne.sectioncontent,
    children: (0, Fne.jsx)("div", {
      className: Dne.container,
      children: (0, Fne.jsx)("div", {
        className: Dne.paragraphs,
        children: (0, Fne.jsx)(qL, { i18nKey: "component.welcome.text" }),
      }),
    }),
  });
};
export function Jne(e, t, n) {
  const { ids: s, parentId: i } = (function (e, t) {
    if (0 === e.length) return { ids: [] };
    let n = (function (e, t) {
      const n = {};
      return e.map((e) => {
        const s = t.block.getParent(e) || undefined;
        let i = -1;
        if (null != s) {
          null == n[s] && (n[s] = t.block.getChildren(s));
          i = (n[s] ?? []).findIndex((t) => t === e);
        }
        return { id: e, childIndex: i, parentId: s };
      });
    })(e, t);
    const s = (function (e) {
      return (function (e) {
        return e
          .sort(
            (t, n) =>
              e.filter((e) => e === t).length - e.filter((e) => e === n).length
          )
          .pop();
      })(e.map(({ parentId: e }) => e).filter(Boolean));
    })(n);
    if (null == s) return { ids: [] };
    return (
      (n = n.filter((e) => null != e.parentId && e.parentId === s)),
      (n = (0, Yne.default)(n, "childIndex")),
      { ids: n.map((e) => e.id), parentId: s }
    );
  })(e, n);
  if (0 === s.length || null == i)
    throw new Error(
      `Invalid selected ids for boolean operation ${t}: ${s.join(",")}`
    );
  const o = n.block.createCutoutFromOperation(s, t);
  return s.forEach((e) => n.block.destroy(e)), n.block.appendChild(i, o), o;
}
export function ese() {
  const { t: e } = ZL(),
    t = YF(),
    n = eI(t, (e) => e.block.findAllSelected()),
    s = IV(),
    [i, o] = (0, Xne.useState)(0),
    r = t.block.isCombinable(n),
    a = n.every((e) => "//ly.img.ubq/cutout" === t.block.getType(e)),
    l = a || r;
  return {
    operations: [
      {
        operation: "Union",
        label: e("input.booleanoperations.union"),
        icon: Kne,
      },
      {
        operation: "Difference",
        label: e("input.booleanoperations.subtract"),
        icon: Zne,
      },
      {
        operation: "Intersection",
        label: e("input.booleanoperations.intersect"),
        icon: Qne,
      },
      {
        operation: "XOR",
        label: e("input.booleanoperations.exclude"),
        icon: $ne,
      },
    ],
    showBooleanOperations: l,
    clickHandler: (e, i = { selectAfter: false }) => {
      let r;
      if (a) r = Jne(n, e, t);
      else
        try {
          r = t.block.combine(n, e);
        } catch (e) {
          const t = e.message;
          if (t.includes("Result is an empty shape.")) o(1);
          else if (t.includes("Union has no visible effect.")) o(2);
          else {
            if (!t.includes("Difference has no visible effect.")) throw e;
            o(3);
          }
          return;
        }
      i.selectAfter && undefined !== r && t.block.setSelected(r, true),
        s("input.booleanoperations");
    },
    error: i,
    dismissError: () => o(0),
  };
}
export var nse = (e, t) => {
  switch (t) {
    case 1:
      return {
        header: e("error.booleanOperation.emptyShape"),
        description: e("error.booleanOperation.emptyShape.description"),
      };
    case 2:
      return {
        header: e("error.booleanOperation.effectlessUnion"),
        description: e("error.booleanOperation.effectlessUnion.description"),
      };
    default:
      return {
        header: e("error.booleanOperation.effectlessDifference"),
        description: e(
          "error.booleanOperation.effectlessDifference.description"
        ),
      };
  }
};
export function sse({ error: e, dismissError: t }) {
  const { t: n } = ZL(),
    { header: s, description: i } = nse(n, e),
    o = 0 !== e;
  return (0, tse.jsx)(hx, {
    children: (0, tse.jsxs)(Yw, {
      show: o,
      "aria-label": "error description",
      type: "warning",
      className: Une.dialog,
      onClose: t,
      footer: (0, tse.jsx)(Yw.Footer, {
        children: (0, tse.jsx)(CompCustomButton, {
          name: "boolean-operations-error-close",
          onClick: t,
          children: n("common.close"),
        }),
      }),
      children: [
        (0, tse.jsx)(HI, { level: 1, className: Une.heading, children: s }),
        (0, tse.jsx)("p", { children: i }),
      ],
    }),
  });
}
export var ose = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = VO(),
      { a11y: s } = FI(),
      {
        operations: i,
        showBooleanOperations: o,
        clickHandler: r,
        error: a,
        dismissError: l,
      } = ese(),
      c = n.feature.isEnabled("ly.img.combine", { engine: e });
    return o && c
      ? (0, ise.jsxs)(ise.Fragment, {
          children: [
            (0, ise.jsx)(Qk, {
              title: t("input.booleanoperations"),
              headingLevel: 2,
              headingStart: s.headingsHierarchyStart,
              children: (0, ise.jsx)(Yk, {
                children: i.map(({ operation: e, label: t, icon: n }) =>
                  (0, ise.jsx)(
                    Ly,
                    {
                      label: t,
                      children: (0, ise.jsx)(CompCustomButton, {
                        name: e,
                        icon: (0, ise.jsx)(n, {}),
                        onClick: () => {
                          r(e);
                        },
                      }),
                    },
                    e
                  )
                ),
              }),
            }),
            (0, ise.jsx)(sse, { error: a, dismissError: l }),
          ],
        })
      : null;
  })
);

export var cse = mayBeUseMemp(function ({
  isDisabled: e,
  asCanvasAction: t,
  className: n,
  variant: s = "plain",
  name: i = "group",
  centered: o,
}) {
  const r = YF(),
    { hasMultiSelection: a, selectedDesignElementsIds: l } = uD(),
    { focusElement: c } = xI(),
    u = oI("ui/group"),
    d = r.block.isGroupable(l),
    { t: p } = ZL(),
    f = p("action.group"),
    h = IV(),
    m = VO().feature.isEnabled("ly.img.group", { engine: r });
  return a && u && d && m
    ? (0, lse.jsx)(CompCustomButton, {
        className: n,
        icon: (0, lse.jsx)(ase, {}),
        name: i,
        "aria-label": f,
        isDisabled: e,
        variant: s,
        centered: o,
        onClick: () => {
          const e = r.block.group(l);
          c(e), h("action.group");
        },
        "data-ubq-action": t ? RH : undefined,
        children: f,
      })
    : null;
});
export var use = cse;

export var pse = mayBeUseMemp(function () {
  const e = YF(),
    t = VO(),
    { t: n } = ZL(),
    s = "Design" === e.scene.getMode(),
    i = t.feature.isEnabled("ly.img.group", { engine: e }),
    o = t.feature.isEnabled("ly.img.position", { engine: e });
  return (0,
  dse.jsxs)("div", { className: MH, children: [o && (0, dse.jsx)(Qk, { title: n("input.layer"), children: (0, dse.jsx)(x6, {}) }), (0, dse.jsx)(ose, {}), s && i && (0, dse.jsx)(Qk, { title: n("input.selection"), children: (0, dse.jsx)(Yk, { children: (0, dse.jsx)(use, { variant: "regular", centered: true }) }) }), (0, dse.jsxs)("div", { className: OH, children: [(0, dse.jsx)(Nne, {}), (0, dse.jsx)("p", { children: n("input.multiSelection.notice") })] })] });
});

export var hse = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = KR(),
      { viewStyle: n } = YR(),
      s = (() => {
        const e = (0, TO.useContext)(OO);
        if (null == e || null == e.container)
          throw new Error("Context with editor container not initialized");
        return e.container;
      })(),
      i = (0, g9.useRef)(null),
      o = e.block.findAllSelected(),
      r = 0 === o.length ? e.scene.get() : o[0],
      a = 0 === o.length,
      l = o.length > 1;
    Xy(
      ["esc"],
      () => {
        r && DH(t, s, r);
      },
      { elementRef: i }
    );
    const c = oI("ui/inspectScene");
    return null == r || (!c && a && "default" === n)
      ? null
      : !c && a
      ? (0, fse.jsx)("div", {
          className: MH,
          ref: i,
          children: (0, fse.jsx)(Ine, {}),
        })
      : l
      ? (0, fse.jsx)(pse, {})
      : (0, fse.jsx)("div", {
          className: MH,
          ref: i,
          children: (0, fse.jsx)(Vne, { blockType: e.block.getType(r) }, r),
        });
  })
);

export var bse = function ({
  name: e,
  setName: t,
  onClose: n,
  "aria-labelledby": s,
}) {
  const [i, o] = (0, mse.useState)(e),
    r = (0, mse.useRef)(null);
  return (
    Xy(
      ["esc"],
      () => {
        n();
      },
      { elementRef: r }
    ),
    Xy(
      ["enter"],
      (e) => {
        e.preventDefault(), t(i), n();
      },
      { elementRef: r }
    ),
    (0, xse.jsx)(dm, {
      focusTrapOptions: { escapeDeactivates: false },
      children: (0, xse.jsx)("span", {
        className: gse,
        children: (0, xse.jsx)(ClickOutsideContextProvider, {
          onClickOutside: (e) => {
            e.isOutside(r.current) && n();
          },
          children: (0, xse.jsx)(Zy, {
            ref: r,
            name: "rename-design-element-input",
            value: i,
            onChange: o,
            placeholder: e,
            "aria-labelledby": s,
          }),
        }),
      }),
    })
  );
};
export var yse = {
  renameButton: "UBQ_InspectorPanel-module__renameButton---BwuO",
};
export var wse = "ubq-headline_label";
export function kse({ name: e, setMode: t }) {
  const { t: n } = ZL();
  return (0, vse.jsx)(Ly, {
    label: n("input.rename", { designElementName: e }),
    children: (0, vse.jsx)(CompCustomButton, {
      className: yse.renameButton,
      name: "rename-design-element",
      onClick: () => {
        t("edit");
      },
      "aria-label": n("input.rename", { designElementName: e }),
      "data-cy": "rename-design-element",
      variant: "plain",
      children: (0, vse.jsx)(h9, {}),
    }),
  });
}
export var Cse = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, ...t }) {
    const n = VO(),
      { t: s } = ZL(),
      [i] = KF(),
      o = IV(),
      { focusDocument: r } = xI(),
      a = oI("editor/inspect"),
      l = oI("ui/placeholder"),
      c = n.feature.isEnabled("ly.img.placeholder", { engine: e }),
      u = l && c,
      d = oI("ui/inspectScene"),
      [p, f] = (0, m9.useState)("display"),
      { inspectorEnabled: h, viewStyle: m } = YR();
    if (!h || !a) return null;
    if (null == e.scene.get()) return null;
    const g = e.block.findAllSelected(),
      x = 0 === g.length,
      b = 1 === g.length;
    let y = "",
      v = true;
    if (
      (0 === g.length && ((y = d ? s("block.scene") : ""), (v = false)),
      g.length > 1 &&
        ((y = s("input.multiSelection.title", { count: g.length })),
        (v = false)),
      b)
    ) {
      const [t] = g;
      if (((y = e.block.getName(t)), "" === y)) {
        switch (e.block.getType(t)) {
          case "//ly.img.ubq/page":
            y = s("block.page");
            break;
          case "//ly.img.ubq/group":
            y = s("block.group");
            break;
          case "//ly.img.ubq/audio":
            y = s("block.audio");
            break;
          case "//ly.img.ubq/text":
            y = s("block.text");
            break;
          case "//ly.img.ubq/cutout":
            y = s("block.cutout");
            break;
          case "//ly.img.ubq/graphic":
            y = s("block.graphic");
            break;
          default:
            y = "";
        }
      }
    }
    const w = g.map((t) => e.block.getType(t)),
      k = !!b && e.block.isPlaceholderEnabled(g[0]),
      C = `${i}_${g.join("_")}`;
    return (0, vse.jsxs)(WQ, {
      id: "//ly.img.panel/inspector",
      group: "inspector",
      show: "advanced" === m || undefined,
      closable: "default" === m || !x,
      focusTrapActive: false,
      onClose: () => {
        x ||
          "advanced" !== m ||
          (e.block
            .findAllSelected()
            .forEach((t) => e.block.setSelected(t, false)),
          r());
      },
      children: [
        (0, vse.jsx)(WQ.Header, {
          action:
            b &&
            u &&
            KY.includes(w[0]) &&
            (0, vse.jsx)(iX.Button, {
              tooltip: k ? s("component.placeholder.settings") : undefined,
              children: !k && s("component.placeholder.create"),
            }),
          overlay:
            "edit" === p &&
            (0, vse.jsx)(bse, {
              name: y,
              setName: (t) => {
                if (b) {
                  const [n] = g;
                  e.block.setName(n, t), o("action.block.rename");
                }
              },
              onClose: () => {
                f("display");
              },
              "aria-labelledby": wse,
            }),
          children: (0, vse.jsx)(WQ.Title, {
            action: v && (0, vse.jsx)(kse, { name: y, setMode: f }),
            children: (0, vse.jsx)("span", {
              id: wse,
              onDoubleClick: () => {
                f("edit");
              },
              children: y,
            }),
          }),
        }),
        (0, vse.jsx)(WQ.Content, {
          children: (0, vse.jsx)(hse, { ...t }, C),
        }),
      ],
    });
  })
);
export var Lse = function ({ value: e, onChange: t, ...n }) {
  const [s, i] = (0, _se.useState)(e),
    o = (0, _se.useCallback)(
      (e) => {
        i(e), t?.(e);
      },
      [t]
    );
  return (
    (0, _se.useEffect)(() => {
      i(e);
    }, [e]),
    (0, Ese.jsx)(Rv, { value: s, onChange: o, ...n })
  );
};
export var Bse = function ({ value: e, onChange: t, ...n }) {
  const [s, i] = (0, Pse.useState)(e),
    o = (0, Pse.useCallback)(
      (e) => {
        i(e), t?.(e);
      },
      [t]
    );
  return (
    (0, Pse.useEffect)(() => {
      i(e);
    }, [e]),
    (0, Ase.jsx)(Zy, { value: s, onChange: o, ...n })
  );
};
export var Tse = {
  block: "UBQ_PanelBuilder-module__block--T3ctJ",
  dropdownContent: "UBQ_PanelBuilder-module__dropdownContent--0Brv4",
  textParagraph: "UBQ_PanelBuilder-module__textParagraph--YANJ7",
  alignCenter: "UBQ_PanelBuilder-module__alignCenter--k6Qmn",
  alignRight: "UBQ_PanelBuilder-module__alignRight--qMRvG",
};
export var Ose = function ({
  children: e,
  inputLabelPosition: t,
  inputLabel: n,
  isDisabled: s,
  withoutSectionElements: i,
  withSectionBlock: o,
}) {
  return i
    ? (0, Mse.jsx)(Mse.Fragment, { children: e })
    : null == n
    ? o
      ? (0, Mse.jsx)(tC, { children: e })
      : (0, Mse.jsx)(Yk, { children: e })
    : "top" === t
    ? (0, Mse.jsxs)(tC, {
        children: [(0, Mse.jsx)(Sv, { isDisabled: s, children: n }), e],
      })
    : (0, Mse.jsxs)(Yk, {
        children: [(0, Mse.jsx)(Sv, { isDisabled: s, children: n }), e],
      });
};
export var Vse = class extends UIComponentBuilder {
  constructor(e, t, n, s) {
    super("PanelBuilder", e, t, n, s);
  }
  Section = (e, { title: t, children: n }) => {
    const s = this._translateLabel(t),
      i = this._pushChildren("Section", n);
    this._push({
      id: e,
      type: "Section",
      focusable: false,
      node: (0, Rse.jsx)(Qk, {
        title: s,
        children: Sse.default.createElement(
          Sse.default.Fragment,
          null,
          ...i.map(({ node: e }) => e)
        ),
      }),
    });
  };
  Button = (
    e,
    { label: t, inputLabel: n, tooltip: s, onClick: i, icon: o, ...r }
  ) => {
    const a = this._translateLabel(t),
      l = this._translateLabel(n),
      c = this._translateLabel(s),
      u = "ButtonGroup" === this._currentNesting;
    this._push({
      id: e,
      type: "Button",
      focusable: !r.isDisabled,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: l,
        inputLabelPosition: r.inputLabelPosition,
        isDisabled: r.isDisabled,
        withoutSectionElements: u,
        children: (0, Rse.jsx)(CompTooltip, {
          showTooltip: null != c,
          label: c ?? "",
          children: (0, Rse.jsx)(CompCustomButton, {
            "aria-label": a,
            name: `${this.name}-Button-${e}`,
            onClick: i,
            centered: true,
            variant: r.variant ?? "regular",
            color: r.color,
            size: r.size,
            isActive: r.isActive,
            isSelected: r.isSelected,
            isDisabled: r.isDisabled,
            isLoading: r.isLoading,
            loadingProgress: r.loadingProgress,
            icon:
              null != o
                ? (0, Rse.jsx)(f$, { iconSize: "normal", customIcon: o })
                : undefined,
            children: a,
          }),
        }),
      }),
    });
  };
  ButtonGroup = (e, { children: t, inputLabel: n, ...s }) => {
    const i = this._translateLabel(n),
      o = this._pushChildren("ButtonGroup", t).filter(
        (e) => !!["Button", "Dropdown", "Select"].includes(e.type)
      ),
      r = !o.some(({ focusable: e }) => e);
    this._push({
      id: e,
      type: "ButtonGroup",
      focusable: r,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: i,
        inputLabelPosition: s.inputLabelPosition,
        children: (0, Rse.jsx)(CompButtonGroup, {
          children: o.map(({ id: e, node: t }) =>
            (0, Rse.jsx)(Sse.Fragment, { children: t }, e)
          ),
        }),
      }),
    });
  };
  Checkbox = (e, { inputLabel: t, icon: n, ...s }) => {
    const i = this._translateLabel(t);
    this._push({
      id: e,
      type: "Checkbox",
      focusable: !s.isDisabled,
      node: (0, Rse.jsx)(Yk, {
        children: (0, Rse.jsx)(nb, {
          label: i ?? "",
          name: `${this.name}-Checkbox-${e}`,
          labelPosition: s.inputLabelPosition,
          checked: s.value,
          isDisabled: s.isDisabled,
          onChange: s.setValue,
          icon:
            null != n
              ? (0, Rse.jsx)(f$, { iconSize: "normal", customIcon: n })
              : undefined,
        }),
      }),
    });
  };
  Dropdown = (
    e,
    { label: t, inputLabel: n, tooltip: s, icon: i, children: o, ...r }
  ) => {
    const a = this._translateLabel(t),
      l = this._translateLabel(n),
      c = this._translateLabel(s),
      u = "ButtonGroup" === this._currentNesting;
    let d = () => {};
    const p = {
        close: () => {
          d();
        },
      },
      f = this._pushChildren("Dropdown", o ? () => o(p) : undefined),
      h = !f.some(({ focusable: e }) => e);
    this._push({
      id: e,
      type: "Dropdown",
      focusable: !r.isDisabled,
      node: (0, Rse.jsxs)(Cx, {
        placement: "bottom",
        disableFocusTrap: h,
        children: [
          (t, { isOpen: n }) =>
            (0, Rse.jsx)(Ose, {
              inputLabel: l,
              inputLabelPosition: r.inputLabelPosition,
              isDisabled: r.isDisabled,
              withoutSectionElements: u,
              children: (0, Rse.jsx)(CompTooltip, {
                showTooltip: null != c,
                label: c ?? "",
                children: (0, Rse.jsxs)(CompCustomButton, {
                  name: `${this.name}-Dropdown-${e}`,
                  variant: r.variant ?? "regular",
                  color: r.color,
                  size: r.size,
                  isLoading: r.isLoading,
                  loadingProgress: r.loadingProgress,
                  ...t,
                  className: Tse.block,
                  isDisabled: 0 === f.length || r.isDisabled,
                  icon:
                    null != i
                      ? (0, Rse.jsx)(f$, {
                          iconSize: "normal",
                          customIcon: i,
                        })
                      : undefined,
                  children: [
                    a,
                    n
                      ? (0, Rse.jsx)(IconChevronDown, {})
                      : (0, Rse.jsx)(IconChevronUp, {}),
                  ],
                }),
              }),
            }),
          ({ closePopover: t }) => (
            (d = t),
            (0, Rse.jsx)("ul", {
              className: Tse.dropdownContent,
              children: f.map(({ id: t, node: n, type: s }) =>
                "Separator" === s
                  ? (0, Rse.jsx)(Sse.Fragment, { children: n }, e)
                  : (0, Rse.jsx)("li", { children: n }, t)
              ),
            })
          ),
        ],
      }),
    });
  };
  MediaPreview = (e, { size: t, preview: n, action: s }) => {
    let i, o;
    if (s) {
      const { label: t, onClick: n, icon: o, ...r } = s,
        a = this._translateLabel(t);
      i = (0, Rse.jsx)(Ih.Edge.BottomRight, {
        children: (0, Rse.jsx)(c_.InteractionElement, {
          name: `media-preview-action-${e}`,
          icon:
            null != s.icon
              ? (0, Rse.jsx)(f$, { iconSize: "normal", customIcon: o })
              : undefined,
          onClick: s.onClick,
          ...r,
          children: a,
        }),
      });
    }
    n &&
      ("image" === n.type
        ? (o = (0, Rse.jsx)(c_.Background.Image, {
            url: n.uri,
            checkered: true,
          }))
        : "color" === n.type &&
          (o = (0, Rse.jsx)(c_.Background.Color, { color: n.color }))),
      this._push({
        id: e,
        type: "MediaPreview",
        focusable: null != s && !s.isDisabled,
        node: (0, Rse.jsx)(tC, {
          children: (0, Rse.jsx)(g_, {
            children: (0, Rse.jsxs)(c_, {
              size: t,
              children: [
                (0, Rse.jsx)(Ih.Edge, {
                  children: (0, Rse.jsx)(g_.Overlay, { children: i }),
                }),
                o,
              ],
            }),
          }),
        }),
      });
  };
  TextArea = (e, { inputLabel: t, isDisabled: n, value: s, setValue: i }) => {
    const o = this._translateLabel(t);
    this._push({
      id: e,
      type: "TextArea",
      focusable: !n,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: o,
        inputLabelPosition: "top",
        isDisabled: n,
        withSectionBlock: true,
        children: (0, Rse.jsx)(Lse, {
          disabled: n,
          value: s,
          onChange: i,
          id: e,
          name: `${this.name}-TextArea-${e}`,
        }),
      }),
    });
  };
  TextInput = (
    e,
    {
      inputLabel: t,
      inputLabelPosition: n,
      isDisabled: s,
      value: i,
      setValue: o,
    }
  ) => {
    const r = this._translateLabel(t);
    this._push({
      id: e,
      type: "TextInput",
      focusable: !s,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: r,
        inputLabelPosition: n,
        isDisabled: s,
        children: (0, Rse.jsx)(Bse, {
          id: e,
          name: `${this.name}-TextInput-${e}`,
          disabled: s,
          value: i,
          onChange: o,
        }),
      }),
    });
  };
  Slider = (
    e,
    {
      inputLabel: t,
      inputLabelPosition: n,
      isDisabled: s,
      value: i,
      setValue: o,
      min: r,
      max: a,
      step: l,
      centered: c = false,
    }
  ) => {
    const u = this._translateLabel(t);
    this._push({
      id: e,
      type: "Slider",
      focusable: !s,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: u,
        inputLabelPosition: n,
        isDisabled: s,
        children: (0, Rse.jsx)(JQ, {
          id: e,
          name: `${this.name}-Slider-${e}`,
          label: u ?? "",
          disabled: s,
          value: i,
          min: r,
          max: a,
          step: l,
          centeredZeroPosition: c,
          onChange: o,
        }),
      }),
    });
  };
  NumberInput = (
    e,
    {
      inputLabel: t,
      inputLabelPosition: n,
      isDisabled: s,
      value: i,
      setValue: o,
      min: r,
      max: a,
      step: l,
    }
  ) => {
    const c = this._translateLabel(t);
    this._push({
      id: e,
      type: "NumberInput",
      focusable: !s,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: c,
        inputLabelPosition: n,
        isDisabled: s,
        children: (0, Rse.jsx)(zv, {
          name: `${this.name}-NumberInput-${e}`,
          disabled: s,
          value: i,
          onChange: o,
          min: r,
          max: a,
          step: l,
        }),
      }),
    });
  };
  ColorInput = (
    e,
    {
      label: t,
      inputLabel: n,
      inputLabelPosition: s,
      isDisabled: i,
      value: o,
      setValue: r,
    }
  ) => {
    const a = this._translateLabel(t),
      l = this._translateLabel(n);
    this._push({
      id: e,
      type: "ColorInput",
      focusable: !i,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: l,
        inputLabelPosition: s,
        isDisabled: i,
        children: (0, Rse.jsx)(wJ, {
          name: `${this.name}-ColorInput-${e}`,
          mode: "default",
          isDisabled: i,
          label: a ?? "",
          showHeader: null != a,
          "aria-label": a ?? "",
          color: o,
          setColor: r,
        }),
      }),
    });
  };
  Library = (e, { entries: t, searchable: n, onSelect: s }) => {
    this._push({
      id: e,
      type: "Library",
      focusable: true,
      node: (0, Rse.jsx)("div", {
        children: (0, Rse.jsxs)(MK, {
          entries: ZK(t, this.engine),
          assetPanelOpen: false,
          children: [
            n && (0, Rse.jsx)(MK.Search, {}),
            (0, Rse.jsx)(MK.Content, {
              onSelect: async (e) => {
                s
                  ? await s(e)
                  : await this.engine.asset.apply(e.context.sourceId, e);
              },
            }),
          ],
        }),
      }),
    });
  };
  Select = (
    e,
    {
      inputLabel: t,
      tooltip: n,
      value: s,
      setValue: i,
      values: o,
      isDisabled: r,
      isLoading: a,
      loadingProgress: l,
      inputLabelPosition: c,
    }
  ) => {
    const u = this._translateLabel(t),
      d = this._translateLabel(n),
      p = "ButtonGroup" === this._currentNesting;
    this._push({
      id: e,
      type: "Select",
      focusable: !r,
      node: (0, Rse.jsx)(Ose, {
        inputLabel: u,
        inputLabelPosition: c,
        isDisabled: r,
        withoutSectionElements: p,
        children: (0, Rse.jsxs)(bw, {
          children: [
            (t, { isOpen: n }) =>
              (0, Rse.jsx)(CompTooltip, {
                showTooltip: null != d,
                label: d ?? "",
                children: (0, Rse.jsxs)(CompCustomButton, {
                  name: `${this.name}-Select-${e}`,
                  isDisabled: r,
                  isLoading: a,
                  loadingProgress: l,
                  icon:
                    null != s.icon
                      ? (0, Rse.jsx)(f$, {
                          iconSize: "normal",
                          customIcon: s.icon,
                        })
                      : undefined,
                  ...t,
                  children: [
                    this._translateLabel(s.label),
                    n
                      ? (0, Rse.jsx)(IconChevronDown, {})
                      : (0, Rse.jsx)(IconChevronUp, {}),
                  ],
                }),
              }),
            () =>
              (0, Rse.jsx)(bw.Options, {
                value: s,
                onChange: (e) => {
                  i(e);
                },
                children: o.map((e) =>
                  (0, Rse.jsx)(
                    bw.Option,
                    {
                      value: e,
                      icon:
                        null != e.icon
                          ? (0, Rse.jsx)(f$, {
                              iconSize: "normal",
                              customIcon: e.icon,
                            })
                          : undefined,
                      children: this._translateLabel(e.label),
                    },
                    e.id
                  )
                ),
              }),
          ],
        }),
      }),
    });
  };
  Heading = (e, { content: t }) => {
    const n = this.translator(t, { defaultValue: t });
    let s = 0;
    this.nestingStack.forEach((e) => {
      "Section" === e && s++;
    });
    const i = Math.min(1 + s, 6);
    this._push({
      id: e,
      type: "Heading",
      focusable: false,
      node: (0, Rse.jsx)(HI, {
        level: i,
        className: Tse.heading,
        children: n,
      }),
    });
  };
  Text = (e, { content: t, align: n }) => {
    const s = this.translator(t, { defaultValue: t });
    this._push({
      id: e,
      type: "Text",
      focusable: false,
      node: (0, Rse.jsx)("p", {
        className: (0, jse.default)(Tse.textParagraph, {
          [Tse.alignLeft]: "left" === n,
          [Tse.alignCenter]: "center" === n,
          [Tse.alignRight]: "right" === n,
        }),
        children: s,
      }),
    });
  };
};
export var Fse = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = XR();
    return (0, Dse.jsx)(Dse.Fragment, {
      children: Object.entries(n.registeredPanels).map(([n, s]) => {
        if ("react" === s.type) {
          const e = s.component;
          return (0, Dse.jsx)(e, {}, n);
        }
        const i = t(`panel.${n}`);
        return (0, Dse.jsxs)(
          WQ,
          {
            id: n,
            focusTrapActive: false,
            children: [
              (0, Dse.jsx)(WQ.Header, {
                children: (0, Dse.jsx)(WQ.Title, { children: i }),
              }),
              (0, Dse.jsx)(WQ.Content, {
                children: (0, Dse.jsx)(oj, {
                  fallback: (e) => (0, Dse.jsx)(n9, { error: e }),
                  children: (0, Dse.jsx)(qz, {
                    builderRenderFunction: s.render,
                    createBuilder: (s) => new Vse(s, t, { componentId: n }, e),
                  }),
                }),
              }),
            ],
          },
          n
        );
      }),
    });
  })
);
export var Nse = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = DO(),
      n = IV(),
      { t: s } = ZL(),
      { assetLibraryPanelReplaceAutoClose: i } = YR(),
      { focusElement: o, focusSelectedElementOrDocument: r } = xI(),
      a = h3(),
      l = oI("ui/placeholder"),
      c = VO(),
      u = "//ly.img.panel/assetLibrary.replace",
      [d] = z7(u);
    HV("action.video.replace", () => {
      i() && c.ui.closePanel(u);
    }),
      HV("action.audio.replace", () => {
        i() && c.ui.closePanel(u);
      }),
      HV("action.image.replace", () => {
        i() && c.ui.closePanel(u);
      });
    const [p, f] = (0, Ise.useState)(null),
      h = e.block.findAllSelected()[0],
      m = null != h ? e.block.getType(h) : undefined,
      g = null != h && e.block.hasFill(h) ? e.block.getFill(h) : undefined,
      x = null != g && e.block.isValid(g) ? e.block.getType(g) : undefined;
    if (null == h) return null;
    let b;
    switch (true) {
      case "//ly.img.ubq/fill/video" === x:
        b = s("action.video.replace");
        break;
      case "//ly.img.ubq/audio" === m:
        b = s("action.audio.replace");
        break;
      case "//ly.img.ubq/fill/image" === x:
        b = s("action.image.replace");
        break;
      default:
        b = s("common.replace");
    }
    return (0, Hse.jsxs)(Hse.Fragment, {
      children: [
        (0, Hse.jsx)(N7, {
          panelId: u,
          group: "assetLibrary",
          title: b,
          onClose: () => {
            r();
          },
          children: ({ isOpen: r, setIsOpen: c }) =>
            (0, Hse.jsxs)(MK, {
              entries: a,
              assetPanelOpen: r,
              children: [
                (0, Hse.jsx)(MK.Search, {
                  placeholder: s("component.library.searchPlaceholder"),
                }),
                (0, Hse.jsx)(MK.Content, {
                  onSelect: async (r) => {
                    if (!h) return;
                    let a;
                    switch (true) {
                      case "//ly.img.ubq/fill/video" === x:
                        a = "action.video.replace";
                        break;
                      case "//ly.img.ubq/audio" === m:
                        a = "action.audio.replace";
                        break;
                      case "//ly.img.ubq/fill/image" === x:
                        (a = "action.image.replace"),
                          undefined === r.meta?.blockType &&
                            (r.meta = {
                              ...r.meta,
                              blockType: "//ly.img.ubq/graphic",
                              fillType: "//ly.img.ubq/fill/image",
                            });
                    }
                    if (r.meta?.uri) {
                      (u = h), i() && (c(false), o(u));
                      const n = r.context.sourceId;
                      try {
                        await e.asset.applyToBlock(n, r, h),
                          l || e.block.setPlaceholderEnabled(h, false);
                      } catch (e) {
                        e instanceof Error && t.log(e.message, "Error"),
                          f({
                            heading: s("error.replaceAsset"),
                            description: s("error.replaceAsset.description"),
                          });
                      }
                    }
                    var u;
                    a && n(a);
                  },
                  includeTypes: ["ly.img.image"],
                  onUpload: d,
                }),
              ],
            }),
        }),
        (0, Hse.jsx)(F7, {
          error: p,
          onClose: () => {
            f(null);
          },
        }),
      ],
    });
  })
);
export function zse(e) {
  return null == e
    ? { show: false }
    : "boolean" == typeof e
    ? { show: e }
    : { ...e, show: null == e.show || e.show };
}
export var $se = function (e, t) {
  const n = zse(t.ui.elements?.panels?.inspector);
  e.ui.setPanelFloating(
    "//ly.img.panel/inspector",
    n.floating ?? InspectorPanelConfig.floating
  ),
    e.ui.setPanelPosition(
      "//ly.img.panel/inspector",
      n.position ?? InspectorPanelConfig.position
    );
  const s = zse(t.ui.elements?.panels?.assetLibrary);
  e.ui.setPanelFloating(
    "//ly.img.panel/assetLibrary",
    t?.ui?.elements?.libraries?.insert?.floating ?? false
  ),
    e.ui.setPanelFloating(
      "//ly.img.panel/assetLibrary.replace",
      t?.ui?.elements?.libraries?.replace?.floating ?? false
    ),
    e.ui.setPanelPosition(
      "//ly.img.panel/assetLibrary",
      s.position ?? AssetLibraryPanelConfig.position
    ),
    e.ui.setPanelPosition(
      "//ly.img.panel/assetLibrary.replace",
      s.position ?? AssetLibraryPanelConfig.position
    ),
    e.ui.setPanelFloating("//ly.img.panel/settings", false),
    e.ui.setPanelPosition("//ly.img.panel/settings", () =>
      "left" === e.ui.getPanelPosition("//ly.img.panel/inspector")
        ? "right"
        : "left"
    ),
    e.ui.setPanelFloating(
      "//ly.img.panel/inspector/placeholderSettings",
      false
    ),
    e.ui.setPanelPosition("//ly.img.panel/inspector/placeholderSettings", () =>
      e.ui.getPanelPosition("//ly.img.panel/inspector")
    ),
    e.ui.setPanelFloating("//ly.img.panel/inspector/editColor", true),
    e.ui.setPanelPosition("//ly.img.panel/inspector/editColor", () =>
      e.ui.getPanelPosition("//ly.img.panel/inspector")
    ),
    e.ui.setPanelFloating("//ly.img.panel/inspector/colorLibrary", false),
    e.ui.setPanelPosition("//ly.img.panel/inspector/colorLibrary", () =>
      e.ui.getPanelPosition("//ly.img.panel/inspector")
    );
};

export var hie = function ({ onIgorPissed: e }) {
  const t = (0, uie.useRef)(null),
    n = sN(t),
    [s, i] = (0, uie.useState)(false);
  (0, uie.useEffect)(() => {
    if (s) {
      const t = setTimeout(() => {
        e();
      }, 3e3);
      return () => {
        clearTimeout(t);
      };
    }
    return () => {};
  }, [s]);
  const o = { width: "45", height: "62" };
  let r = (0, fie.jsx)(lie, { ...o });
  return (
    n && !s
      ? (r = (0, fie.jsx)(rie, { ...o }))
      : s && (r = (0, fie.jsx)(iie, { ...o })),
    (0, fie.jsx)("div", {
      className: (0, cie.default)(die, { [pie]: s }),
      ref: t,
      onClick: () => {
        i(true);
      },
      children: r,
    })
  );
};
export var gie = function ({ show: e, onClose: t }) {
  const { t: n } = ZL();
  return (0, mie.jsx)(hx, {
    children: (0, mie.jsx)(Yw, {
      show: e,
      onClose: t,
      "aria-label": "Credits",
      footer: (0, mie.jsxs)(Yw.Footer, {
        children: [
          (0, mie.jsx)(CompCustomButton, {
            name: "credits-dialog-button-abort",
            "aria-label": n("common.close"),
            onClick: t,
            children: n("common.close"),
          }),
          (0, mie.jsxs)(CompCustomButton, {
            variant: "plain",
            name: "img.ly-link",
            "aria-label": n("common.close"),
            onClick: () => {
              window?.open("https://www.img.ly", "_blank")?.focus();
            },
            children: ["made by ", (0, mie.jsx)(Zse, { className: nie })],
          }),
        ],
      }),
      children: (0, mie.jsx)("div", {
        className: Wse,
        children: (0, mie.jsxs)("div", {
          className: Kse,
          children: [
            (0, mie.jsxs)("div", {
              className: Xse,
              children: [
                (0, mie.jsx)(Qse, { className: eie }),
                (0, mie.jsxs)("div", {
                  className: Yse,
                  children: ["Version ", "1.37.0"],
                }),
                (0, mie.jsx)("p", {
                  className: Jse,
                  children:
                    "Thanks for using CreativeEditor SDK! It was created with the help of many awesome people.",
                }),
              ],
            }),
            (0, mie.jsx)("div", {
              className: tie,
              children: e && (0, mie.jsx)(hie, { onIgorPissed: t }),
            }),
          ],
        }),
      }),
    }),
  });
};
export var xie = gie;

export var wie = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = YR(),
    { dockIconSize: n } = t;
  return (0, vie.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, vie.jsx)(CompCustomButton, {
        name: "select-normal-dock-icon-scaling",
        "aria-label": e("component.dockIconSizeSelect.normal.description"),
        onClick: _B(() => {
          t.dockIconSize = "normal";
        }),
        isActive: "normal" === n,
        className: yie,
        children: e("component.dockIconSizeSelect.normal"),
      }),
      (0, vie.jsx)(CompCustomButton, {
        name: "select-large-dock-icon-scaling",
        "aria-label": e("component.dockIconSizeSelect.large.description"),
        onClick: _B(() => {
          t.dockIconSize = "large";
        }),
        isActive: "large" === n,
        className: yie,
        children: e("component.dockIconSizeSelect.large"),
      }),
    ],
  });
});

export var jie = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = YR();
  return (0, Cie.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, Cie.jsx)(CompCustomButton, {
        name: "toggle-show-dock-label-visibility",
        "aria-label": e("component.dockLabelVisibilityToggle.show.description"),
        onClick: _B(() => {
          t.dockHideLabels = false;
        }),
        isActive: !t.dockHideLabels,
        className: kie,
        children: e("component.dockLabelVisibilityToggle.show"),
      }),
      (0, Cie.jsx)(CompCustomButton, {
        name: "toggle-hide-dock-label-visibility",
        "aria-label": e("component.dockLabelVisibilityToggle.hide.description"),
        onClick: _B(() => {
          t.dockHideLabels = true;
        }),
        isActive: t.dockHideLabels,
        className: kie,
        children: e("component.dockLabelVisibilityToggle.hide"),
      }),
    ],
  });
});
export var _ie = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = VO(),
    n = YR(),
    s = UQ("//ly.img.panel/assetLibrary"),
    i = NQ("//ly.img.panel/assetLibrary"),
    o = Nz();
  return (0, Sie.jsxs)(Qk, {
    title: e("component.settingsPanel.assetPanel"),
    headingLevel: 2,
    children: [
      (0, Sie.jsxs)(Yk, {
        children: [
          (0, Sie.jsx)(Sv, { children: e("common.position") }),
          (0, Sie.jsxs)(CompLayout1, {
            children: [
              (0, Sie.jsx)(CompCustomButton, {
                name: "select-assetlibrary-left",
                "aria-label": e(
                  "component.inspectorPositionSelect.left.description"
                ),
                onClick: () => {
                  t.ui.setPanelPosition("//ly.img.panel/assetLibrary", "left"),
                    t.ui.setPanelPosition(
                      "//ly.img.panel/assetLibrary.replace",
                      "left"
                    );
                },
                isActive: "left" === s,
                className: bie,
                disabled: o,
                children: e("component.inspectorPositionSelect.left"),
              }),
              (0, Sie.jsx)(CompCustomButton, {
                name: "select-assetlibrary-right",
                "aria-label": e(
                  "component.inspectorPositionSelect.right.description"
                ),
                onClick: () => {
                  t.ui.setPanelPosition("//ly.img.panel/assetLibrary", "right"),
                    t.ui.setPanelPosition(
                      "//ly.img.panel/assetLibrary.replace",
                      "right"
                    );
                },
                isActive: "right" === s,
                className: bie,
                disabled: o,
                children: e("component.inspectorPositionSelect.right"),
              }),
            ],
          }),
        ],
      }),
      (0, Sie.jsxs)(Yk, {
        children: [
          (0, Sie.jsx)(Sv, {
            children: e("component.assetPanelFloatingSettings"),
          }),
          (0, Sie.jsxs)(CompLayout1, {
            equalWidth: true,
            children: [
              (0, Sie.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-floating",
                "aria-label": e(
                  "component.assetPanelFloatingSettings.floating.description"
                ),
                onClick: () => {
                  t.ui.setPanelFloating("//ly.img.panel/assetLibrary", true);
                },
                isActive: i,
                className: bie,
                disabled: o,
                children: e("component.assetPanelFloatingSettings.floating"),
              }),
              (0, Sie.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-fixed",
                "aria-label": e(
                  "component.assetPanelFloatingSettings.fixed.description"
                ),
                onClick: () => {
                  t.ui.setPanelFloating("//ly.img.panel/assetLibrary", false);
                },
                isActive: !i,
                className: bie,
                disabled: o,
                children: e("component.assetPanelFloatingSettings.fixed"),
              }),
            ],
          }),
        ],
      }),
      (0, Sie.jsxs)(Yk, {
        children: [
          (0, Sie.jsx)(Sv, {
            children: e("component.assetPanelAutoCloseSettings"),
          }),
          (0, Sie.jsxs)(CompLayout1, {
            equalWidth: true,
            children: [
              (0, Sie.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-autoClose-true",
                "aria-label": e(
                  "component.assetPanelAutoCloseSettings.true.description"
                ),
                onClick: _B(() => {
                  n.assetLibraryPanelInsertAutoClose = () => true;
                }),
                isActive: n.assetLibraryPanelInsertAutoClose(),
                className: bie,
                children: e("component.assetPanelAutoCloseSettings.true"),
              }),
              (0, Sie.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-autoClose-false",
                "aria-label": e(
                  "component.assetPanelAutoCloseSettings.false.description"
                ),
                onClick: _B(() => {
                  n.assetLibraryPanelInsertAutoClose = () => false;
                }),
                isActive: !n.assetLibraryPanelInsertAutoClose(),
                className: bie,
                children: e("component.assetPanelAutoCloseSettings.false"),
              }),
            ],
          }),
        ],
      }),
      (0, Sie.jsxs)(Yk, {
        children: [
          (0, Sie.jsx)(Sv, { children: e("component.dockIconSizeSelect") }),
          (0, Sie.jsx)(wie, {}),
        ],
      }),
      (0, Sie.jsxs)(Yk, {
        children: [
          (0, Sie.jsx)(Sv, {
            children: e("component.dockLabelVisibilityToggle"),
          }),
          (0, Sie.jsx)(jie, {}),
        ],
      }),
    ],
  });
});
export var Aie = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = YR();
  return (0, Pie.jsx)(Qk, {
    title: e("component.assetSettings"),
    headingLevel: 2,
    children: (0, Pie.jsxs)(tb, {
      children: [
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "opacity",
            checked: t.blocksOpacityEnabled,
            onChange: _B((e) => {
              t.blocksOpacityEnabled = e;
            }),
            icon: (0, Pie.jsx)(RY, {}),
            label: e("component.assetSettings.opacity"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "transform",
            checked: t.blocksTransformEnabled,
            onChange: _B((e) => {
              t.blocksTransformEnabled = e;
            }),
            icon: (0, Pie.jsx)(Lie, {}),
            label: e("component.assetSettings.transform"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "text-advanced",
            checked: t.blocks["//ly.img.ubq/text"].advancedEnabled,
            onChange: _B((e) => {
              t.blocks["//ly.img.ubq/text"].advancedEnabled = e;
            }),
            icon: (0, Pie.jsx)(mY, {}),
            label: e("component.assetSettings.text.advanced"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "text-color",
            checked: t.blocks["//ly.img.ubq/text"].colorEnabled,
            onChange: _B((e) => {
              t.blocks["//ly.img.ubq/text"].colorEnabled = e;
            }),
            icon: (0, Pie.jsx)(IconFontT, {}),
            label: e("component.assetSettings.text.color"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "crop",
            checked:
              t.blocks["//ly.img.ubq/graphic"].cropEnabled &&
              t.blocks["//ly.img.ubq/page"].cropEnabled,
            onChange: _B((e) => {
              (t.blocks["//ly.img.ubq/graphic"].cropEnabled = e),
                (t.blocks["//ly.img.ubq/page"].cropEnabled = e);
            }),
            icon: (0, Pie.jsx)(wY, {}),
            label: e("component.assetSettings.crop"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "adjustments",
            checked:
              t.blocks["//ly.img.ubq/graphic"].adjustmentsEnabled &&
              t.blocks["//ly.img.ubq/page"].adjustmentsEnabled,
            onChange: _B((e) => {
              (t.blocks["//ly.img.ubq/graphic"].adjustmentsEnabled = e),
                (t.blocks["//ly.img.ubq/page"].adjustmentsEnabled = e);
            }),
            icon: (0, Pie.jsx)(mY, {}),
            label: e("component.assetSettings.adjustments"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "filters",
            checked:
              t.blocks["//ly.img.ubq/graphic"].filtersEnabled &&
              t.blocks["//ly.img.ubq/page"].filtersEnabled,
            onChange: _B((e) => {
              (t.blocks["//ly.img.ubq/graphic"].filtersEnabled = e),
                (t.blocks["//ly.img.ubq/page"].filtersEnabled = e);
            }),
            icon: (0, Pie.jsx)(PY, {}),
            label: e("component.assetSettings.filters"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "effects",
            checked:
              t.blocks["//ly.img.ubq/graphic"].effectsEnabled &&
              t.blocks["//ly.img.ubq/page"].effectsEnabled,
            onChange: _B((e) => {
              (t.blocks["//ly.img.ubq/graphic"].effectsEnabled = e),
                (t.blocks["//ly.img.ubq/page"].effectsEnabled = e);
            }),
            icon: (0, Pie.jsx)(EY, {}),
            label: e("component.assetSettings.effects"),
          }),
        }),
        (0, Pie.jsx)(tb.Item, {
          children: (0, Pie.jsx)(nb, {
            name: "blur",
            checked:
              t.blocks["//ly.img.ubq/graphic"].blurEnabled &&
              t.blocks["//ly.img.ubq/page"].blurEnabled,
            onChange: _B((e) => {
              (t.blocks["//ly.img.ubq/graphic"].blurEnabled = e),
                (t.blocks["//ly.img.ubq/page"].blurEnabled = e);
            }),
            icon: (0, Pie.jsx)(DK, {}),
            label: e("component.assetSettings.blur"),
          }),
        }),
      ],
    }),
  });
});
export var Mie = function ({
  name: e,
  propColor: t,
  designTokenBasis: n,
  onSetColor: s,
}) {
  const { t: i } = ZL(),
    { theme: o } = (0, Bie.useContext)(Sh.Context),
    [r, a] = (0, Bie.useState)(() => bh(n, { r: 0, g: 0, b: 0, a: 1 }));
  (0, Bie.useEffect)(() => {
    xh(n) !== t && a(bh(n, { r: 0, g: 0, b: 0, a: 1 }));
  }, [o]);
  const l =
      "accent" === e
        ? i("component.colorSchemeSelect.accent")
        : "active" === e
        ? i("component.colorSchemeSelect.active")
        : "background" === e
        ? i("component.colorSchemeSelect.background")
        : e,
    c =
      "accent" === e
        ? i("component.colorSchemeSelect.accent.description")
        : "active" === e
        ? i("component.colorSchemeSelect.active.description")
        : "background" === e
        ? i("component.colorSchemeSelect.background.description")
        : e;
  return (0, Tie.jsxs)(Tie.Fragment, {
    children: [
      (0, Tie.jsx)(Sv, { children: l }),
      (0, Tie.jsx)(wJ, {
        name: e,
        previewColor: t ?? xh(n),
        color: r,
        setColor: (e) => {
          a(e), s && s(wb(e, true));
        },
        label: l,
        "aria-label": c,
        hidePreviewLabel: true,
      }),
    ],
  });
};
export var Rie = mayBeUseMemp(function () {
  const e = YR();
  return (0, Oie.jsxs)(Oie.Fragment, {
    children: [
      (0, Oie.jsx)(Yk, {
        children: (0, Oie.jsx)(Mie, {
          name: "background",
          designTokenBasis: "--ubq-canvas",
          propColor: e.customBackgroundColor,
          onSetColor: _B((t) => {
            e.customBackgroundColor = t;
          }),
        }),
      }),
      (0, Oie.jsx)(Yk, {
        children: (0, Oie.jsx)(Mie, {
          name: "active",
          designTokenBasis: "--ubq-interactive-active-default",
          propColor: e.customActiveColor,
          onSetColor: _B((t) => {
            e.customActiveColor = t;
          }),
        }),
      }),
      (0, Oie.jsx)(Yk, {
        children: (0, Oie.jsx)(Mie, {
          name: "accent",
          propColor: e.customAccentColor,
          designTokenBasis: "--ubq-interactive-accent-default",
          onSetColor: _B((t) => {
            e.customAccentColor = t;
          }),
        }),
      }),
    ],
  });
});
export var Vie = mayBeUseMemp(function () {
  return null;
});

export var Hie = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = VO(),
    n = UQ("//ly.img.panel/inspector"),
    s = Nz();
  return (0, Iie.jsxs)(CompLayout1, {
    children: [
      (0, Iie.jsx)(CompCustomButton, {
        name: "select-inspector-left",
        "aria-label": e("component.inspectorPositionSelect.left.description"),
        onClick: () => {
          t.ui.setPanelPosition("//ly.img.panel/inspector", "left");
        },
        isActive: "left" === n,
        className: Fie,
        disabled: s,
        children: e("component.inspectorPositionSelect.left"),
      }),
      (0, Iie.jsx)(CompCustomButton, {
        name: "select-inspector-right",
        "aria-label": e("component.inspectorPositionSelect.right.description"),
        onClick: () => {
          t.ui.setPanelPosition("//ly.img.panel/inspector", "right");
        },
        isActive: "right" === n,
        className: Fie,
        disabled: s,
        children: e("component.inspectorPositionSelect.right"),
      }),
    ],
  });
});
export var Uie = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = VO(),
    n = NQ("//ly.img.panel/inspector"),
    s = Nz();
  return (0, Nie.jsxs)(Qk, {
    title: e("component.settingsPanel.inspectorPanel"),
    headingLevel: 2,
    children: [
      (0, Nie.jsxs)(Yk, {
        children: [
          (0, Nie.jsx)(Sv, {
            children: e("component.inspectorPositionSelect"),
          }),
          (0, Nie.jsx)(Hie, {}),
        ],
      }),
      (0, Nie.jsxs)(Yk, {
        children: [
          (0, Nie.jsx)(Sv, {
            children: e("component.inspectorPanelFloatingSettings"),
          }),
          (0, Nie.jsxs)(CompLayout1, {
            equalWidth: true,
            children: [
              (0, Nie.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-floating",
                "aria-label": e(
                  "component.inspectorPanelFloatingSettings.floating.description"
                ),
                onClick: () => {
                  t.ui.setPanelFloating("//ly.img.panel/inspector", true);
                },
                isActive: n,
                className: Die,
                disabled: s,
                children: e(
                  "component.inspectorPanelFloatingSettings.floating"
                ),
              }),
              (0, Nie.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-fixed",
                "aria-label": e(
                  "component.inspectorPanelFloatingSettings.fixed.description"
                ),
                onClick: () => {
                  t.ui.setPanelFloating("//ly.img.panel/inspector", false);
                },
                isActive: !n,
                className: Die,
                disabled: s,
                children: e("component.inspectorPanelFloatingSettings.fixed"),
              }),
            ],
          }),
        ],
      }),
    ],
  });
});

export var qie = mayBeUseMemp(function () {
  const { t: e, i18n: t } = ZL(),
    n = YR(),
    s = (t.options.supportedLngs || ["en", "de"]).filter((e) => "cimode" !== e),
    i = (n) =>
      t.getResource(n, "custom", "meta.currentLanguage") ||
      t.getResource(n, "cesdk", "meta.currentLanguage")
        ? e("meta.currentLanguage", { lng: n })
        : `${e("meta.currentLanguage")} (${n})`;
  return (0, $ie.jsxs)(bw, {
    children: [
      (n, { isOpen: s }) =>
        (0, $ie.jsxs)(CompCustomButton, {
          name: "languageSelect",
          "aria-label": e("component.languageSelect.description"),
          ...n,
          children: [
            i(t.language),
            s
              ? (0, $ie.jsx)(IconChevronDown, {})
              : (0, $ie.jsx)(IconChevronUp, {}),
          ],
        }),
      () =>
        (0, $ie.jsx)(bw.Options, {
          value: n.language,
          onChange: _B((e) => {
            n.language = e;
          }),
          children: s.map((e) =>
            (0, $ie.jsx)(
              bw.Option,
              {
                value: e,
                children: (0, $ie.jsx)("div", {
                  className: zie,
                  children: i(e),
                }),
              },
              e
            )
          ),
        }),
    ],
  });
});
export var Gie = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = YR();
  return (0, Qie.jsx)(Qk, {
    title: e("component.pageSettings"),
    headingLevel: 2,
    children: (0, Qie.jsxs)(tb, {
      children: [
        (0, Qie.jsx)(tb.Item, {
          children: (0, Qie.jsx)(nb, {
            name: "manage",
            checked: t.blocks["//ly.img.ubq/page"].manage,
            onChange: _B((e) => {
              t.blocks["//ly.img.ubq/page"].manage = e;
            }),
            icon: (0, Qie.jsx)(MY, {}),
            label: e("component.pageSettings.manage"),
          }),
        }),
        (0, Qie.jsx)(tb.Item, {
          children: (0, Qie.jsx)(nb, {
            name: "format",
            checked: t.blocks["//ly.img.ubq/page"].format,
            onChange: _B((e) => {
              t.blocks["//ly.img.ubq/page"].format = e;
            }),
            icon: (0, Qie.jsx)(gk, {}),
            label: e("component.pageSettings.format"),
          }),
        }),
      ],
    }),
  });
});

export var Kie = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = e.editor.getSettingBool("page/title/appendPageName"),
    s = e.editor.getSettingBool("page/title/show");
  return (0, Wie.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, Wie.jsx)(CompCustomButton, {
        name: "toggle-page-title-append-name-visibility",
        "aria-label": t(
          "component.pageTitleAppendPageNameToggle.show.description"
        ),
        onClick: () => {
          e.editor.setSettingBool("page/title/appendPageName", true);
        },
        isActive: n,
        isDisabled: !s,
        className: Zie,
        children: t("component.pageTitleAppendPageNameToggle.show"),
      }),
      (0, Wie.jsx)(CompCustomButton, {
        name: "toggle-page-title-not-append-name-visibility",
        "aria-label": t(
          "component.pageTitleAppendPageNameToggle.hide.description"
        ),
        onClick: () => {
          e.editor.setSettingBool("page/title/appendPageName", false);
        },
        isActive: !n,
        isDisabled: !s,
        className: Zie,
        children: t("component.pageTitleAppendPageNameToggle.hide"),
      }),
    ],
  });
});
export var Yie = Kie;
export var Xie =
  "UBQ_PageTitleDefaultTitleVisibilityToggle-module__button--q5EJU";
export var eoe = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = e.editor.getSettingBool("page/title/showPageTitleTemplate"),
    s = e.editor.getSettingBool("page/title/show");
  return (0, Jie.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, Jie.jsx)(CompCustomButton, {
        name: "toggle-show-default-page-title-visibility",
        "aria-label": t(
          "component.pageTitleDefaultTitleVisibilityToggle.show.description"
        ),
        onClick: () => {
          e.editor.setSettingBool("page/title/showPageTitleTemplate", true);
        },
        isActive: n,
        isDisabled: !s,
        className: Xie,
        children: t("component.pageTitleDefaultTitleVisibilityToggle.show"),
      }),
      (0, Jie.jsx)(CompCustomButton, {
        name: "toggle-hide-default-page-title-visibility",
        "aria-label": t(
          "component.pageTitleDefaultTitleVisibilityToggle.hide.description"
        ),
        onClick: () => {
          e.editor.setSettingBool("page/title/showPageTitleTemplate", false);
        },
        isActive: !n,
        isDisabled: !s,
        className: Xie,
        children: t("component.pageTitleDefaultTitleVisibilityToggle.hide"),
      }),
    ],
  });
});
export var toe = eoe;

export var ioe = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = e.editor.getSettingBool("page/title/showOnSinglePage"),
    s = e.editor.getSettingBool("page/title/show");
  return (0, soe.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, soe.jsx)(CompCustomButton, {
        name: "toggle-show-page-title-on-single-page-visibility",
        "aria-label": t(
          "component.pageTitleShowOnSinglePageToggle.show.description"
        ),
        onClick: () => {
          e.editor.setSettingBool("page/title/showOnSinglePage", true);
        },
        isActive: n,
        isDisabled: !s,
        className: noe,
        children: t("component.pageTitleShowOnSinglePageToggle.show"),
      }),
      (0, soe.jsx)(CompCustomButton, {
        name: "toggle-hide-page-title-on-single-page-visibility",
        "aria-label": t(
          "component.pageTitleShowOnSinglePageToggle.hide.description"
        ),
        onClick: () => {
          e.editor.setSettingBool("page/title/showOnSinglePage", false);
        },
        isActive: !n,
        isDisabled: !s,
        className: noe,
        children: t("component.pageTitleShowOnSinglePageToggle.hide"),
      }),
    ],
  });
});
export var ooe = ioe;

export var loe = WithEngineComp(function ({ engine: e }) {
  const { t: t } = ZL(),
    n = e.editor.getSettingBool("page/title/show");
  return (0, aoe.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, aoe.jsx)(CompCustomButton, {
        name: "toggle-show-page-title-visibility",
        "aria-label": t("component.pageTitleVisibilityToggle.show.description"),
        onClick: () => {
          e.editor.setSettingBool("page/title/show", true);
        },
        isActive: n,
        className: roe,
        children: t("component.pageTitleVisibilityToggle.show"),
      }),
      (0, aoe.jsx)(CompCustomButton, {
        name: "toggle-hide-page-title-visibility",
        "aria-label": t("component.pageTitleVisibilityToggle.hide.description"),
        onClick: () => {
          e.editor.setSettingBool("page/title/show", false);
        },
        isActive: !n,
        className: roe,
        children: t("component.pageTitleVisibilityToggle.hide"),
      }),
    ],
  });
});
export var coe = loe;

export var poe = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = VO(),
    n = YR(),
    s = NQ("//ly.img.panel/assetLibrary.replace"),
    i = Nz();
  return (0, doe.jsxs)(Qk, {
    title: e("component.settingsPanel.replacePanel"),
    headingLevel: 2,
    children: [
      (0, doe.jsxs)(Yk, {
        children: [
          (0, doe.jsx)(Sv, {
            children: e("component.replacePanelFloatingSettings"),
          }),
          (0, doe.jsxs)(CompLayout1, {
            equalWidth: true,
            children: [
              (0, doe.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-floating",
                className: uoe,
                "aria-label": e(
                  "component.replacePanelFloatingSettings.floating.description"
                ),
                onClick: () => {
                  t.ui.setPanelFloating(
                    "//ly.img.panel/assetLibrary.replace",
                    true
                  );
                },
                isActive: s,
                disabled: i,
                children: e("component.replacePanelFloatingSettings.floating"),
              }),
              (0, doe.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-fixed",
                className: uoe,
                "aria-label": e(
                  "component.replacePanelFloatingSettings.fixed.description"
                ),
                onClick: () => {
                  t.ui.setPanelFloating(
                    "//ly.img.panel/assetLibrary.replace",
                    false
                  );
                },
                isActive: !s,
                disabled: i,
                children: e("component.replacePanelFloatingSettings.fixed"),
              }),
            ],
          }),
        ],
      }),
      (0, doe.jsxs)(Yk, {
        children: [
          (0, doe.jsx)(Sv, {
            children: e("component.replacePanelAutoCloseSettings"),
          }),
          (0, doe.jsxs)(CompLayout1, {
            equalWidth: true,
            children: [
              (0, doe.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-autoClose-true",
                "aria-label": e(
                  "component.replacePanelAutoCloseSettings.true.description"
                ),
                onClick: _B(() => {
                  n.assetLibraryPanelReplaceAutoClose = () => true;
                }),
                isActive: n.assetLibraryPanelReplaceAutoClose(),
                className: uoe,
                children: e("component.replacePanelAutoCloseSettings.true"),
              }),
              (0, doe.jsx)(CompCustomButton, {
                name: "set-library-panel-insert-autoClose-false",
                "aria-label": e(
                  "component.replacePanelAutoCloseSettings.false.description"
                ),
                onClick: _B(() => {
                  n.assetLibraryPanelReplaceAutoClose = () => false;
                }),
                isActive: !n.assetLibraryPanelReplaceAutoClose(),
                className: uoe,
                children: e("component.replacePanelAutoCloseSettings.false"),
              }),
            ],
          }),
        ],
      }),
    ],
  });
});

export var moe = mayBeUseMemp(function () {
  const e = VO(),
    { t: t } = ZL(),
    [, { configuredRole: n, setConfiguredRole: s }] = KF(),
    i = ["Creator", "Adopter"];
  return (0, hoe.jsxs)(bw, {
    children: [
      (e, { isOpen: s }) =>
        (0, hoe.jsxs)(CompCustomButton, {
          name: "roleSelect",
          "aria-label": t("component.roleSelect.description"),
          ...e,
          children: [
            n,
            s
              ? (0, hoe.jsx)(IconChevronDown, {})
              : (0, hoe.jsx)(IconChevronUp, {}),
          ],
        }),
      () =>
        (0, hoe.jsx)(bw.Options, {
          value: n,
          onChange: (t) => {
            s(t), e.feature.enable("ly.img.preview", "Creator" === t);
          },
          children: i.map((e) =>
            (0, hoe.jsx)(
              bw.Option,
              {
                value: e,
                children: (0, hoe.jsx)("div", { className: foe, children: e }),
              },
              e
            )
          ),
        }),
    ],
  });
});
export function goe() {
  const e = YR(),
    { width: t } = iL("embedViewport"),
    { scale: n } = e;
  return "function" == typeof n
    ? n({ isTouch: ky, containerWidth: t })
    : "string" == typeof n
    ? n
    : ky
    ? "large"
    : "normal";
}
export var xoe = "UBQ_ScalingSelect-module__button--SuD4n";
export var yoe = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = YR(),
    n = goe();
  return (0, boe.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, boe.jsx)(CompCustomButton, {
        name: "select-normal-scaling",
        "aria-label": e("component.scalingSelect.normal.description"),
        onClick: _B(() => {
          t.scale = "normal";
        }),
        isActive: "normal" === n,
        className: xoe,
        children: e("component.scalingSelect.normal"),
      }),
      (0, boe.jsx)(CompCustomButton, {
        name: "select-large-scaling",
        "aria-label": e("component.scalingSelect.large.description"),
        onClick: _B(() => {
          t.scale = "large";
        }),
        isActive: "large" === n,
        className: xoe,
        children: e("component.scalingSelect.large"),
      }),
    ],
  });
});

export var koe = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = YR(),
    { theme: n } = t,
    { editor: s } = YF(),
    i = () => {
      setTimeout(() => {
        {
          const e = bh("--ubq-foreground-default", {
            r: 0,
            g: 0,
            b: 0,
            a: 1,
          });
          s.setSettingColor("page/title/color", e);
        }
        {
          const e = bh("--ubq-static-selection-frame", {
            r: 0,
            g: 0,
            b: 0,
            a: 1,
          });
          s.setSettingColor("highlightColor", e);
        }
        {
          const e = bh("--ubq-static-text-variable", {
            r: 0,
            g: 0,
            b: 0,
            a: 1,
          });
          s.setSettingColor("placeholderHighlightColor", e);
        }
        {
          const e = bh("--ubq-progress", { r: 0, g: 0, b: 0, a: 1 });
          s.setSettingColor("progressColor", e);
        }
        {
          const e = bh("--ubq-notice-error", { r: 0, g: 0, b: 0, a: 1 });
          s.setSettingColor("errorStateColor", e);
        }
      }, 200);
    };
  return (0, woe.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, woe.jsx)(CompCustomButton, {
        name: "select-dark-theme",
        "aria-label": e("component.themeSelect.dark.description"),
        onClick: _B(() => {
          (t.theme = "dark"), i();
        }),
        isActive: "dark" === n,
        className: voe,
        children: e("component.themeSelect.dark"),
      }),
      (0, woe.jsx)(CompCustomButton, {
        name: "select-light-theme",
        "aria-label": e("component.themeSelect.light.description"),
        onClick: _B(() => {
          (t.theme = "light"), i();
        }),
        isActive: "light" === n,
        className: voe,
        children: e("component.themeSelect.light"),
      }),
    ],
  });
});

export var Soe = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = YR(),
    { viewStyle: n } = t;
  return (0, joe.jsxs)(CompLayout1, {
    equalWidth: true,
    children: [
      (0, joe.jsx)(CompCustomButton, {
        name: "select-view-default",
        "aria-label": e("component.viewSelect.default.description"),
        onClick: _B(() => {
          t.viewStyle = "default";
        }),
        isActive: "default" === n,
        className: Coe,
        children: e("component.viewSelect.default"),
      }),
      (0, joe.jsx)(CompCustomButton, {
        name: "select-view-advanced",
        "aria-label": e("component.viewSelect.advanced.description"),
        onClick: _B(() => {
          t.viewStyle = "advanced";
        }),
        isActive: "advanced" === n,
        className: Coe,
        children: e("component.viewSelect.advanced"),
      }),
    ],
  });
});
export function Eoe({ onReset: e, isDisabled: t }) {
  const { t: n } = ZL();
  return (
    e &&
    (0, _oe.jsxs)(CompCustomButton, {
      name: "reset",
      onClick: e,
      "aria-label": n("common.reset"),
      "data-cy": "reset-settingspanel",
      variant: "plain",
      isDisabled: t,
      children: [n("common.reset"), (0, _oe.jsx)(FG, {})],
    })
  );
}
export var Loe = mayBeUseMemp(function () {
  const e = VO(),
    { t: t } = ZL(),
    n = YR(),
    [s, i] = (0, Use.useState)(""),
    [o, r] = (0, Use.useState)(false),
    a = FI(),
    { viewStyle: l } = n,
    c = Nz();
  return (0, _oe.jsxs)(WQ, {
    id: "//ly.img.panel/settings",
    "data-cy": "settings-panel",
    style: { zIndex: "advanced" === l && c ? Iz.SettingsPanel : undefined },
    children: [
      (0, _oe.jsx)(WQ.Header, {
        action: (0, _oe.jsx)(Eoe, {
          onReset: () => {
            n.resetSettings(), $se(e, a);
          },
          isDisabled: !n.isDifferentThanConfigured,
        }),
        children: (0, _oe.jsx)(WQ.Title, {
          children: t("component.settingsPanel.header"),
        }),
      }),
      (0, _oe.jsxs)(WQ.Content, {
        children: [
          (0, _oe.jsxs)(Qk, {
            title: t("component.settingsPanel.general"),
            headingLevel: 2,
            children: [
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, { children: t("component.roleSelect") }),
                  (0, _oe.jsx)(moe, {}),
                ],
              }),
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, { children: t("component.viewSelect") }),
                  (0, _oe.jsx)(Soe, {}),
                ],
              }),
              (0, _oe.jsx)(Yk, { children: (0, _oe.jsx)(Sw, {}) }),
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, {
                    children: t("component.languageSelect"),
                  }),
                  (0, _oe.jsx)(qie, {}),
                ],
              }),
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, {
                    children: t("component.scalingSelect"),
                  }),
                  (0, _oe.jsx)(yoe, {}),
                ],
              }),
            ],
          }),
          (0, _oe.jsxs)(Qk, {
            title: t("component.settingsPanel.pageLabel"),
            headingLevel: 2,
            children: [
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, {
                    children: t("component.pageTitleVisibilityToggle"),
                  }),
                  (0, _oe.jsx)(coe, {}),
                ],
              }),
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, {
                    children: t(
                      "component.pageTitleDefaultTitleVisibilityToggle"
                    ),
                  }),
                  (0, _oe.jsx)(toe, {}),
                ],
              }),
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, {
                    children: t("component.pageTitleAppendPageNameToggle"),
                  }),
                  (0, _oe.jsx)(Yie, {}),
                ],
              }),
              (0, _oe.jsx)(Yk, { children: (0, _oe.jsx)(Sw, {}) }),
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, {
                    children: t("component.pageTitleShowOnSinglePageToggle"),
                  }),
                  (0, _oe.jsx)(ooe, {}),
                ],
              }),
            ],
          }),
          (0, _oe.jsx)(_ie, {}),
          (0, _oe.jsx)(poe, {}),
          (0, _oe.jsx)(Uie, {}),
          (0, _oe.jsxs)(Qk, {
            title: t("component.settingsPanel.appearance"),
            headingLevel: 2,
            children: [
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, { children: t("component.themeSelect") }),
                  (0, _oe.jsx)(koe, {}),
                ],
              }),
              (0, _oe.jsx)(Rie, {}),
              (0, _oe.jsx)(Yk, { children: (0, _oe.jsx)(Sw, {}) }),
              (0, _oe.jsxs)(Yk, {
                children: [
                  (0, _oe.jsx)(Sv, { children: "" }),
                  (0, _oe.jsx)(CompCustomButton, {
                    name: "themeExport",
                    color: "accent",
                    onClick: () => {
                      i(
                        (function () {
                          let e = "";
                          return (
                            [
                              "--ubq-canvas",
                              "--ubq-elevation-1",
                              "--ubq-elevation-2",
                              "--ubq-elevation-3",
                              "--ubq-foreground-default",
                              "--ubq-foreground-light",
                              "--ubq-foreground-info",
                              "--ubq-foreground-active",
                              "--ubq-foreground-accent",
                              "--ubq-foreground-danger-default",
                              "--ubq-foreground-notice-default",
                              "--ubq-interactive-default",
                              "--ubq-interactive-hover",
                              "--ubq-interactive-pressed",
                              "--ubq-interactive-selected",
                              "--ubq-interactive-active-default",
                              "--ubq-interactive-active-hover",
                              "--ubq-interactive-active-pressed",
                              "--ubq-interactive-accent-default",
                              "--ubq-interactive-accent-hover",
                              "--ubq-interactive-accent-pressed",
                              "--ubq-interactive-danger-default",
                              "--ubq-interactive-danger-hover",
                              "--ubq-interactive-danger-pressed",
                              "--ubq-interactive-template-default",
                              "--ubq-interactive-template-hover",
                              "--ubq-interactive-template-pressed",
                              "--ubq-interactive-group-default",
                              "--ubq-interactive-group-hover",
                              "--ubq-interactive-group-active-default",
                              "--ubq-interactive-group-active-hover",
                              "--ubq-input-default",
                              "--ubq-input-hover",
                              "--ubq-border-default",
                              "--ubq-stroke-contrast-1",
                              "--ubq-stroke-contrast-2",
                              "--ubq-stroke-contrast-3",
                              "--ubq-focus-default",
                              "--ubq-focus-outline",
                              "--ubq-overlay",
                              "--ubq-notice-info",
                              "--ubq-notice-success",
                              "--ubq-notice-warning",
                              "--ubq-notice-error",
                              "--ubq-effect-shadow",
                              "--ubq-effect-focus",
                              "--ubq-progress",
                              "--ubq-static-selection-frame",
                              "--ubq-static-contrast-white",
                              "--ubq-static-contrast-black",
                              "--ubq-static-snapping",
                              "--ubq-static-bleed",
                              "--ubq-static-text-variable",
                              "--ubq-static-card-label-background",
                              "--ubq-static-card-background",
                            ].forEach((t) => {
                              const n = xh(t);
                              e += `  ${t}: ${n};\n`;
                            }),
                            `.${gh} {\n${e}}`
                          );
                        })()
                      );
                    },
                    children: t("component.themeSelect.generate"),
                  }),
                  (0, _oe.jsx)(hx, {
                    children: (0, _oe.jsxs)(Yw, {
                      show: "" !== s,
                      "aria-label": t(
                        "component.themeSelect.dialog.description"
                      ),
                      footer: (0, _oe.jsx)(Yw.Footer, {
                        children: (0, _oe.jsx)(CompCustomButton, {
                          name: t("common.close"),
                          "aria-label": t("common.close"),
                          onClick: () => i(""),
                          children: t("common.close"),
                        }),
                      }),
                      children: [
                        (0, _oe.jsx)(Ex, {
                          level: 1,
                          children: t("component.themeSelect.dialog"),
                        }),
                        (0, _oe.jsx)(cC, { value: s, readOnly: true }),
                      ],
                    }),
                  }),
                ],
              }),
            ],
          }),
          (0, _oe.jsx)(Aie, {}),
          (0, _oe.jsx)(Gie, {}),
          (0, _oe.jsx)(Vie, {}),
          (0, _oe.jsx)(Qk, {
            title: "CreativeEditor SDK",
            children: (0, _oe.jsxs)(Yk, {
              children: [
                (0, _oe.jsx)(xie, {
                  show: o,
                  onClose: () => {
                    r(false);
                  },
                }),
                (0, _oe.jsx)(CompCustomButton, {
                  name: "documentation",
                  "aria-label": "Documentation",
                  onClick: () => {
                    window
                      ?.open("https://img.ly/docs/cesdk/", "_blank")
                      ?.focus();
                  },
                  children: t("component.settingsPanel.documentation"),
                }),
                (0, _oe.jsx)(CompCustomButton, {
                  name: "credits",
                  "aria-label": "Credits",
                  onClick: () => {
                    r((e) => !e);
                  },
                  children: "Credits",
                }),
              ],
            }),
          }),
        ],
      }),
    ],
  });
});
export var Poe = Loe;
export var Toe = mayBeUseMemp(function ({ block: e }) {
  const t = YF(),
    n = NQ("//ly.img.panel/inspector"),
    s = UQ("//ly.img.panel/inspector"),
    i = Nz();
  return (
    (0, Aoe.useEffect)(() => {
      l0(t);
    }, [t]),
    (0, Boe.jsx)(WQ, {
      id: "//ly.img.panel/inspector/shadow",
      group: "subInspector",
      "data-cy": "shadow-subinspector-panel",
      floating: n,
      panelPosition: i ? "left" : s,
      children: (0, Boe.jsx)(P0.PanelContent, { block: e }),
    })
  );
});
export var Roe = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = IV(),
      [s, i] = (0, Moe.useState)(false),
      [o, r] = rI([uH, dH]),
      a = XR(),
      [, l] = BQ("//ly.img.panel/inspector/transform", a);
    (0, Moe.useEffect)(
      () =>
        e.block.onSelectionChanged(() => {
          0 === e.block.findAllSelected().length && l(false);
        }),
      [e.block, l]
    );
    const [c] = e.block.findAllSelected();
    if (null == c) return null;
    const u = rX(e.scene.getDesignUnit()),
      d = e.block.getFrameX(c),
      p = e.block.getFrameY(c),
      f = e.block.isTransformLocked(c),
      h = f || !o,
      m = f || !r,
      g = (e) => {
        null != e && n("action.block.move");
      },
      x = e.block.getFrameWidth(c),
      b = e.block.getFrameHeight(c),
      y = 0.1,
      v = (e) =>
        t("x" === e ? "common.width.inUnit" : "common.height.inUnit", {
          unit: u,
        });
    return (0, Ooe.jsxs)(Ooe.Fragment, {
      children: [
        (0, Ooe.jsx)(WQ.Header, {
          children: (0, Ooe.jsx)(WQ.Title, {
            children: t("common.transform"),
          }),
        }),
        (0, Ooe.jsx)(WQ.Content, {
          children: () =>
            (0, Ooe.jsxs)(Qk, {
              children: [
                (0, Ooe.jsxs)(Yk, {
                  children: [
                    (0, Ooe.jsx)(Pv, {
                      name: "transform-position-horizontal",
                      label: t("property.position", {
                        axis: t("common.axis.x"),
                      }),
                      isDisabled: h,
                      children: (n) =>
                        (0, Ooe.jsx)(zv, {
                          ...n,
                          unitLabel: u,
                          "aria-label": t("property.position.description", {
                            axis: t("common.axis.x"),
                          }),
                          tooltipLabel: t("property.position.description", {
                            axis: t("common.axis.x"),
                            unit: u,
                          }),
                          value: d,
                          onChange: (t) => {
                            null != t && e.block.setPositionX(c, t);
                          },
                          onRelease: g,
                          isDisabled: h,
                        }),
                    }),
                    (0, Ooe.jsx)(zK, {}),
                  ],
                }),
                (0, Ooe.jsxs)(Yk, {
                  children: [
                    (0, Ooe.jsx)(Pv, {
                      name: "transform-position-vertical",
                      label: t("property.position", {
                        axis: t("common.axis.y"),
                      }),
                      isDisabled: h,
                      children: (n) =>
                        (0, Ooe.jsx)(zv, {
                          ...n,
                          unitLabel: u,
                          "aria-label": t("property.position.description", {
                            axis: t("common.axis.y"),
                          }),
                          tooltipLabel: t("property.position.description", {
                            axis: t("common.axis.y"),
                            unit: u,
                          }),
                          value: p,
                          onChange: (t) => {
                            null != t && e.block.setPositionY(c, t);
                          },
                          onRelease: g,
                          isDisabled: h,
                        }),
                    }),
                    (0, Ooe.jsx)(zK, {}),
                  ],
                }),
                (0, Ooe.jsx)(Sw, {}),
                (0, Ooe.jsxs)(Yk, {
                  children: [
                    (0, Ooe.jsx)(Pv, {
                      name: "transform-dimension-width",
                      label: t("common.width"),
                      isDisabled: m,
                      children: (t) =>
                        (0, Ooe.jsx)(zv, {
                          ...t,
                          unitLabel: u,
                          "aria-label": v("x"),
                          tooltipLabel: v("x"),
                          value: x,
                          min: y,
                          step: "any",
                          onChange: (t) => {
                            if (null != t)
                              if (s) {
                                const n = t / (x / b);
                                t >= y &&
                                  n >= y &&
                                  (e.block.setWidth(c, t),
                                  e.block.setHeight(c, n));
                              } else
                                t >= y &&
                                  (e.block.setWidth(c, t),
                                  e.block.setHeight(c, b));
                          },
                          onRelease: (t) => {
                            if (null != t)
                              if ((n("action.block.resize"), s)) {
                                const n = t / (x / b);
                                t >= y &&
                                  n >= y &&
                                  (e.block.setWidth(c, t),
                                  e.block.setHeight(c, n));
                              } else
                                t >= y &&
                                  (e.block.setWidth(c, t),
                                  e.block.setHeight(c, b));
                          },
                          isDisabled: m,
                        }),
                    }),
                    (0, Ooe.jsx)(Z0, {
                      isLocked: s,
                      setIsLocked: i,
                      isDisabled: m,
                    }),
                  ],
                }),
                (0, Ooe.jsxs)(Yk, {
                  children: [
                    (0, Ooe.jsx)(Pv, {
                      name: "transform-dimension-height",
                      label: t("common.height"),
                      isDisabled: m,
                      children: (t) =>
                        (0, Ooe.jsx)(zv, {
                          ...t,
                          unitLabel: u,
                          "aria-label": v("y"),
                          tooltipLabel: v("y"),
                          value: b,
                          min: y,
                          step: "any",
                          onChange: (t) => {
                            if (null != t)
                              if (s) {
                                const n = t * (x / b);
                                n >= y &&
                                  t >= y &&
                                  (e.block.setWidth(c, n),
                                  e.block.setHeight(c, t));
                              } else
                                t >= y &&
                                  (e.block.setWidth(c, x),
                                  e.block.setHeight(c, t));
                          },
                          onRelease: (t) => {
                            if (null != t)
                              if ((n("action.block.resize"), s)) {
                                const n = t * (x / b);
                                n >= y &&
                                  t >= y &&
                                  (e.block.setWidth(c, n),
                                  e.block.setHeight(c, t));
                              } else
                                t >= y &&
                                  (e.block.setWidth(c, x),
                                  e.block.setHeight(c, t));
                          },
                          isDisabled: m,
                        }),
                    }),
                    (0, Ooe.jsx)(zK, {}),
                  ],
                }),
              ],
            }),
        }),
      ],
    });
  })
);
export var Voe = mayBeUseMemp(function () {
  const e = NQ("//ly.img.panel/inspector"),
    t = UQ("//ly.img.panel/inspector"),
    n = Nz();
  return (0,
  Ooe.jsx)(WQ, { id: "//ly.img.panel/inspector/transform", group: "subInspector", "data-cy": "transform-subinspector-panel", floating: e, panelPosition: n ? "left" : t, children: (0, Ooe.jsx)(Roe, {}) });
});
export var Ioe = mayBeUseMemp(function ({
  block: e,
  i18nBlockType: t,
  selectedBlock: n,
}) {
  const s = YF(),
    i = VO(),
    o = NQ("//ly.img.panel/inspector"),
    r = UQ("//ly.img.panel/inspector"),
    a = Nz(),
    l = XR(),
    [c] = BQ("//ly.img.panel/inspector/trim", l),
    u = "advanced" === l.viewStyle,
    { isOpen: d } = M5(e);
  return (
    (0, Doe.useEffect)(() => {
      c && "Trim" !== s.editor.getEditMode() && s.editor.setEditMode("Trim"),
        c ||
          "Trim" !== s.editor.getEditMode() ||
          s.editor.setEditMode("Transform");
    }, [e, s.editor, c]),
    (0, Doe.useEffect)(() => {
      u &&
        (d &&
          !i.ui.isPanelOpen("//ly.img.panel/inspector/trim") &&
          i.ui.openPanel("//ly.img.panel/inspector/trim"),
        !d &&
          i.ui.isPanelOpen("//ly.img.panel/inspector/trim") &&
          i.ui.closePanel("//ly.img.panel/inspector/trim"));
    }, [i.ui, u, d]),
    (0, Foe.jsx)(WQ, {
      id: "//ly.img.panel/inspector/trim",
      "data-cy": "trim-subinspector-panel",
      floating: o,
      panelPosition: a ? "left" : r,
      children: (0, Foe.jsx)(U5.PanelContent, {
        block: e,
        selectedBlock: n,
        i18nBlockType: t,
      }),
    })
  );
});
export var Uoe = mayBeUseMemp(function ({
  children: e,
  internalRenderTarget: t,
  configurationStore: n,
  i18n: s,
}) {
  return (
    (0, Hoe.useEffect)(() => {
      t.setAttribute("lang", n.language);
    }, [t, n.language]),
    (0, Noe.jsx)(ContextWrapper6, { i18n: s, children: e })
  );
});

export var Qoe = mayBeUseMemp(function ({
  children: e,
  config: { ui: t },
  internalRenderTarget: n,
  configurationStore: s,
  configuredRenderTarget: i,
  facade: o,
}) {
  const r = goe(),
    [a] = possibleHook3(o?.settings.roles.effectiveRole),
    [l] = possibleHook3(o?.settings.roles.previewRole);
  return (
    (0, zoe.useEffect)(() => {
      if (o?.engine) {
        const e =
            "Creator" === a || "Creator" === l
              ? "--ubq-static-text-variable"
              : "--ubq-static-selection-frame",
          { r: t, g: n, b: s, a: i } = bh(e, { r: 0, g: 0, b: 0, a: 1 });
        o?.engine.editor.setSettingColorRGBA(
          "placeholderHighlightColor",
          t,
          n,
          s,
          i
        );
      }
    }, [o?.engine, a, l]),
    (0, qoe.jsx)(Sh, {
      className: $oe,
      theme: s.theme,
      scale: r,
      contextContainer: n,
      renderTarget: i,
      assetPath: t.baseURL,
      disableFontInsertion: t.stylesheets?.disableFontInsertion,
      children: e,
    })
  );
});

export var Woe = mayBeUseMemp(function () {
  const e = XR();
  return (0,
  Zoe.jsx)("div", { className: Goe, "aria-hidden": "true", children: e.iconSets.map(({ id: e, svgSprite: t }) => (0, Zoe.jsx)("div", { dangerouslySetInnerHTML: { __html: t } }, e)) });
});
export var tre = {
  block: "UBQ_Editor-module__block--XnWXF",
  globalContainerQuery: "UBQ_Editor-module__globalContainerQuery--Jq7sz",
  navigation: "UBQ_Editor-module__navigation--x2yHa",
  bottom: "UBQ_Editor-module__bottom--tua5R",
  body: "UBQ_Editor-module__body--Pwi6o",
  verticalBodyLayout: "UBQ_Editor-module__verticalBodyLayout--0bAJc",
  dock: "UBQ_Editor-module__dock--DOhMf",
  canvasViewport: "UBQ_Editor-module__canvasViewport--URkpK",
  canvasContainer: "UBQ_Editor-module__canvasContainer--oG4y4",
  videoTimeline: "UBQ_Editor-module__videoTimeline--CUN-C",
  dialog: "UBQ_Editor-module__dialog--kJqRj",
  notifications: "UBQ_Editor-module__notifications--qaddH",
};
export var ContextWrapper15Memo = mayBeUseMemp(function ContextWrapper15({
  editorContainer: e,
  videoExportSupportState: t,
}) {
  const n = YR(),
    { t: s } = ZL(),
    i = oD(),
    {
      navigationEnabled: o,
      dockEnabled: r,
      navigationPosition: a,
      inspectorBarEnabled: l,
      viewStyle: c,
      hideUserInterface: u,
    } = n,
    d = UQ("//ly.img.panel/assetLibrary"),
    p = oI("editor/present"),
    f = Nz();
  !(function () {
    const e = YF(),
      t = YR(),
      n = oI("editor/managePages") && t.blocks["//ly.img.ubq/page"].manage,
      { canDuplicate: s, pageInSelection: i } = eI(e, () => {
        const t = e.block.findAllSelected(),
          n = t[0];
        return {
          canDuplicate: null != n && e.block.isAllowedByScope(n, AH),
          pageInSelection: t.some(
            (t) =>
              e.block.isValid(t) && "//ly.img.ubq/page" === e.block.getType(t)
          ),
        };
      }),
      o = (i && !n) || !s,
      r = DO().copyPasteHandlers;
    HE({ copy: o ? aV : r.copy, paste: r.paste });
  })(),
    Xy(["mod+."], () => {
      LB(() => {
        n.hideUserInterface = !u;
      });
    });
  const [h] = possibleHook3(i.scene.mode);
  return "Video" !== h || t.supported
    ? (0, nre.jsxs)(PI, {
        className: tre.block,
        scope: BI,
        label: s("editor.scope.global"),
        children: [
          !p &&
            o &&
            !u &&
            (0, nre.jsx)("div", {
              className: (0, dD.default)(tre.navigation, tre[a]),
              children: (0, nre.jsx)(R4, {}),
            }),
          (0, nre.jsxs)("div", {
            className: (0, dD.default)(tre.body, {
              [tre.verticalBodyLayout]: f,
            }),
            children: [
              r &&
                !u &&
                (f || "left" === d) &&
                (0, nre.jsx)(Nq, { className: tre.dock }),
              (0, nre.jsxs)(SizeProvider, {
                className: (0, dD.default)(tre.canvasViewport, {
                  [tre.verticalBodyLayout]: f,
                }),
                children: [
                  !u && (0, nre.jsx)(AQ, { panelPosition: "left" }),
                  (0, nre.jsxs)("div", {
                    className: tre.canvasContainer,
                    children: [
                      (0, nre.jsx)(U4, {
                        condition: (e) =>
                          !(!l || u) &&
                          ("default" === c ||
                            "Trim" === e.editor.getEditMode()),
                        children: (0, nre.jsx)(_4, {}),
                      }),
                      (0, nre.jsx)(eq, {
                        canvasControls: (0, nre.jsx)(cq, {}),
                        editorContainer: e,
                      }),
                    ],
                  }),
                  !u && (0, nre.jsx)(Cse, {}),
                  !u && (0, nre.jsx)(iX.Panel, {}),
                  !u && !f && (0, nre.jsx)(AQ, { panelPosition: "right" }),
                ],
              }),
              !u &&
                "Video" === h &&
                (0, nre.jsx)(P7, { className: tre.videoTimeline }),
              r &&
                !u &&
                !f &&
                "right" === d &&
                (0, nre.jsx)(Nq, { className: tre.dock }),
              !p &&
                (0, nre.jsx)(oj, {
                  children: (0, nre.jsx)("div", {
                    className: tre.notifications,
                    children: (0, nre.jsx)(H4, {}),
                  }),
                }),
              !p && (0, nre.jsx)(oj, { children: (0, nre.jsx)(pq, {}) }),
              !u &&
                (0, nre.jsxs)(nre.Fragment, {
                  children: [
                    (0, nre.jsx)(q7, {}),
                    (0, nre.jsx)(Nse, {}),
                    (0, nre.jsx)(Poe, {}),
                    (0, nre.jsx)(Fse, {}),
                    (0, nre.jsx)(o9, {}),
                    (0, nre.jsx)(Voe, {}),
                    (0, nre.jsx)(P0.SupportGuard, {
                      children: ({ block: e }) =>
                        (0, nre.jsx)(Toe, { block: e }),
                    }),
                    (0, nre.jsx)(pG.SupportGuard, {
                      children: ({ block: e }) =>
                        (0, nre.jsx)(pG, { block: e }),
                    }),
                    (0, nre.jsx)(p5.SupportGuard, {
                      children: ({ block: e }) =>
                        (0, nre.jsx)(a9, { block: e }),
                    }),
                    (0, nre.jsx)(W2.SupportGuard, {
                      children: ({ block: e }) =>
                        (0, nre.jsx)(p9, { block: e }),
                    }),
                    (0, nre.jsx)(i2.SupportGuard, {
                      children: ({ block: e }) =>
                        (0, nre.jsx)(G7, { block: e }),
                    }),
                    (0, nre.jsx)(j2.SupportGuard, {
                      children: ({ block: e }) =>
                        (0, nre.jsx)(T7, { block: e }),
                    }),
                    (0, nre.jsx)(y1.SupportGuard, {
                      children: ({ block: e }) =>
                        (0, nre.jsx)(K7, { block: e }),
                    }),
                    (0, nre.jsx)(U5.SupportGuard, {
                      children: (e) => (0, nre.jsx)(Ioe, { ...e }),
                    }),
                    (0, nre.jsx)(v4.SupportGuard, {
                      children: (e) => (0, nre.jsx)(u9, { ...e }),
                    }),
                    (0, nre.jsx)(oY.SupportGuard, {
                      children: () => (0, nre.jsx)(O7, {}),
                    }),
                  ],
                }),
            ],
          }),
          !u && (0, nre.jsx)(K4, {}),
          !u && (0, nre.jsx)(Woe, {}),
        ],
      })
    : (0, nre.jsx)("div", {
        className: tre.block,
        children: (0, nre.jsxs)(Yw, {
          show: true,
          className: tre.dialog,
          type: "error",
          "aria-label": s("component.video.unsupported"),
          children: [
            (0, nre.jsx)(Ex, {
              level: 1,
              children: s("component.video.unsupported"),
            }),
            (0, nre.jsx)(qL, {
              i18nKey: "component.video.unsupported.description",
            }),
          ],
        }),
      });
});
export function SomeKindOfErrorComponent({ error: e }) {
  return (0, nre.jsx)("div", {
    className: tre.block,
    style: { opacity: 0 },
    children: (0, nre.jsx)("div", {
      className: tre.body,
      children: e ? (0, nre.jsx)(sq, { error: e }) : (0, nre.jsx)(qH, {}),
    }),
  });
}
export var rre = function (e, t) {
  function n(e) {
    const t = e.scene.get();
    if (null == t || "Video" === e.scene.getMode()) return false;
    const n = e.block.getEnum(t, "scene/layout");
    return "VerticalStack" === n || "HorizontalStack" === n;
  }
  e.feature.enable("ly.img.navigate.back", () => !!t.actionEnabled.back),
    e.feature.enable("ly.img.navigate.close", () => !!t.actionEnabled.close),
    e.feature.enable("ly.img.delete", ({ engine: e }) => {
      const n = e.block
        .findAllSelected()
        .map((t) => e.block.getType(t))
        .filter((e) => "//ly.img.ubq/page" === e).length;
      if (n > 0) {
        if ("Video" === e.scene.getMode()) return false;
        if (e.block.findByType("//ly.img.ubq/page").length - n < 1)
          return false;
        if (!t.blocks["//ly.img.ubq/page"].manage) return false;
      }
      return true;
    }),
    e.feature.enable("ly.img.duplicate", ({ engine: e }) => {
      if (
        e.block
          .findAllSelected()
          .map((t) => e.block.getType(t))
          .includes("//ly.img.ubq/page")
      ) {
        if ("Video" === e.scene.getMode()) return false;
        if (!t.blocks["//ly.img.ubq/page"].manage) return false;
        if (!n(e)) return false;
      }
      return true;
    }),
    e.feature.enable("ly.img.placeholder", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = e.block.getType(t[0]);
      return KY.includes(n);
    }),
    e.feature.enable("ly.img.preview", "Creator" === e.engine.editor.getRole()),
    e.feature.enable("ly.img.page.move", ({ engine: e }) => {
      if (!n(e)) return false;
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      return "//ly.img.ubq/page" === e.block.getType(t[0]);
    }),
    e.feature.enable("ly.img.page.add", ({ engine: e }) => !!n(e)),
    e.feature.enable(
      "ly.img.group",
      ({ engine: e }) => "Video" !== e.scene.getMode()
    ),
    e.feature.enable("ly.img.replace", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = t[0];
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable("ly.img.text.edit", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = t[0];
      return "//ly.img.ubq/text" === e.block.getType(n);
    }),
    e.feature.enable("ly.img.text.typeface", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = t[0];
      return "//ly.img.ubq/text" === e.block.getType(n);
    }),
    e.feature.enable("ly.img.text.fontSize", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = t[0];
      return "//ly.img.ubq/text" === e.block.getType(n);
    }),
    e.feature.enable("ly.img.text.fontStyle", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = t[0];
      return "//ly.img.ubq/text" === e.block.getType(n);
    }),
    e.feature.enable("ly.img.text.alignment", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = t[0];
      return "//ly.img.ubq/text" === e.block.getType(n);
    }),
    e.feature.enable("ly.img.text.advanced", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = t[0];
      return "//ly.img.ubq/text" === e.block.getType(n);
    }),
    e.feature.enable("ly.img.adjustment", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const [n] = t;
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable("ly.img.filter", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const [n] = t;
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable("ly.img.effect", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const [n] = t;
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable("ly.img.blur", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const [n] = t;
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable("ly.img.shadow", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      return 1 === t.length && "//ly.img.ubq/page" !== e.block.getType(t[0]);
    }),
    e.feature.enable("ly.img.cutout", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      return "//ly.img.ubq/cutout" === e.block.getType(t[0]);
    }),
    e.feature.enable("ly.img.fill", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const [n] = t;
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable(
      "ly.img.shape.options",
      ({ engine: e }) => 1 === e.block.findAllSelected().length
    ),
    e.feature.enable(
      "ly.img.combine",
      ({ engine: e }) => !(e.block.findAllSelected().length < 2)
    ),
    e.feature.enable(
      "ly.img.trim",
      ({ engine: e }) =>
        1 === e.block.findAllSelected().length && "Video" === e.scene.getMode()
    ),
    e.feature.enable("ly.img.crop", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const [n] = t;
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable(
      "ly.img.volume",
      ({ engine: e }) =>
        1 === e.block.findAllSelected().length && "Video" === e.scene.getMode()
    ),
    e.feature.enable("ly.img.stroke", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const [n] = t;
      return !("sticker" === e.block.getKind(n));
    }),
    e.feature.enable("ly.img.position", ({ engine: e }) => {
      const t = e.block.findAllSelected(),
        [n] = t;
      return !(null != n && "//ly.img.ubq/page" === e.block.getType(n));
    }),
    e.feature.enable("ly.img.options", true),
    e.feature.enable("ly.img.animations", ({ engine: e }) => {
      const t = e.block.findAllSelected();
      if (1 !== t.length) return false;
      const n = e.block.getType(t[0]);
      return (
        "Video" === e.scene.getMode() &&
        ("//ly.img.ubq/graphic" === n || "//ly.img.ubq/text" === n)
      );
    });
};
export var lre = function (e, t) {
  const n = (function (e) {
    const t = e?.ui?.elements?.libraries?.insert?.entries;
    let n = (0, are.default)(MediaSourceIds);
    null != t &&
      ("function" == typeof t
        ? ((n = t(n, { selectedBlocks: [] })),
          console.warn(
            "\nThe use of 'library.entries.insert' is deprecated. Please use the\nAssetLibraryEntry & Dock API to control what is shown in the Dock.\nNote that this function is now (until it is removed) only called\nonce during the initialization of the editor and not repeatedly with\nthe currently selected blocks. If you rely on this behavior you must\nsubscribe on selection and change the order of the Dock via API.\n"
          ))
        : ((n = t),
          console.warn(
            "\nThe use of 'library.entries.insert' is deprecated. Please use the\nAssetLibraryEntry & Dock API to control what is shown in the Dock.\n"
          )));
    return n;
  })(t);
  n.forEach((t) => {
    e.ui.addAssetLibraryEntry(t);
  });
  const s = t.ui?.elements?.libraries?.insert
    ?.backgroundTrackLibraryEntries ?? ["ly.img.image", "ly.img.video"];
  return (
    e.ui.setBackgroundTrackAssetLibraryEntries(
      "function" == typeof s ? s(n) : s
    ),
    n
  );
};
export var ure = function (e) {
  switch (e.id) {
    case "ly.img.video.template":
    case "ly.img.template":
      return "@imgly/Template";
    case "ly.img.image":
      return "@imgly/Image";
    case "ly.img.video":
      return "@imgly/Video";
    case "ly.img.audio":
      return "@imgly/Audio";
    case "ly.img.text":
      return "@imgly/Text";
    case "ly.img.vectorpath":
      return "@imgly/Shapes";
    case "ly.img.sticker":
      return "@imgly/Sticker";
    case "ly.img.upload":
    case "ly.img.image.upload":
    case "ly.img.audio.upload":
    case "ly.img.video.upload":
      return "@imgly/Upload";
    default:
      return "@imgly/CustomLibrary";
  }
};
export var dre = [
  {
    id: "ly.img.template",
    entryIds: ["ly.img.template", "ly.img.video.template"],
  },
  { id: "ly.img.defaultGroup", showOverview: true },
];
export var pre = function (e, t, n) {
  const s = t?.ui?.elements?.dock?.defaultGroupId,
    i = t?.ui?.elements?.dock?.groups;
  (null == i && null == s) ||
    console.warn(
      "\nThe use of 'ui.elements.dock.groups' and 'ui.elements.dock.defaultGroupId' is deprecated. Please use the AssetLibraryEntry & Dock API to control what is shown in the Dock.\n"
    );
  const o = s ?? "ly.img.defaultGroup",
    r = i ?? dre;
  let a = [];
  a =
    "function" == typeof r
      ? (0, cre.default)(r((0, cre.default)(dre)))
      : (0, cre.default)(r);
  const l = [...n],
    c = a.map(({ entryIds: e, ...t }) => ({
      ...t,
      entries: (e ?? [])
        .map((e) => {
          const t = n.find((t) => t.id === e);
          if (null == t) return null;
          const s = l.findIndex(({ id: e }) => t.id === e);
          return l.splice(s, 1), t;
        })
        .filter(GK),
    }));
  if (l.length > 0 && null != o) {
    const e = a.findIndex((e) => e.id === o),
      t = c[e];
    t && t.entries.push(...l);
  }
  const u = c.reduce((e, t, n) => {
    const s = e.length;
    t.showOverview &&
      e.push({
        id: "ly.img.assetLibrary.dock",
        key: "ly.img.elements",
        icon: "@imgly/Library",
        label: "component.library.elements",
        entries: t.entries.map((e) => e.id),
      }),
      t.entries.forEach((t) => {
        const n = ure(t);
        e.push({
          id: "ly.img.assetLibrary.dock",
          key: t.id,
          icon: n,
          label: xG({ entry: t }),
          entries: [t.id],
        });
      });
    const i = e.length - s,
      o = n === c.length - 1;
    return i > 0 && !o && e.push("ly.img.separator"), e;
  }, []);
  e.ui.setDockOrder(u);
};
export var hre = new Set();
export var mre = function (e, t) {
  const n = (function (e, t) {
    const n = t?.ui?.elements?.libraries?.replace?.entries;
    if (null != n)
      return (
        console.warn(
          "\nThe use of 'library.entries.replace' is deprecated. Please use\n'cesdk.ui.setReplaceAssetLibraryEntries' to control what entries are available.\n\nUntil it is removed 'library.entries.replace' will be called and migrated to\nreturn ids of entries that should be available via the Asset Library Entry API. \nIf an entry is returned which id is not present in the store, it will be added.\nIf the entry returned differs from the store, a warning will be printed.\n"
        ),
        (t) => {
          let s = [];
          if ("function" == typeof n) {
            const { defaultEntryIds: i } = t,
              o = i.map((t) => e.ui.getAssetLibraryEntry(t)).filter(GK);
            s = n(o, { selectedBlocks: t.selectedBlocks });
          } else s = n;
          return s.map((t) => {
            const n = e.ui.getAssetLibraryEntry(t.id);
            return (
              null == n
                ? e.ui.addAssetLibraryEntry(t)
                : hre.has(t.id) ||
                  (0, fre.default)(n, t) ||
                  (hre.add(t.id),
                  console.warn(
                    `\nThe AssetLibraryEntry with id '${t.id}' is already present in the store, but\nit differs from the one returned by the 'library.entries.replace' function.\n`
                  )),
              t.id
            );
          });
        }
      );
  })(e, t);
  null != n && e.ui.setReplaceAssetLibraryEntries(n);
};

export var vre = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = DO(),
      n = VO(),
      { t: s } = ZL(),
      { blocks: i } = YR(),
      o = oI("editor/managePages"),
      r = n.feature.isEnabled("ly.img.page.add", { engine: e }),
      a = i["//ly.img.ubq/page"].manage;
    return o && a && r
      ? (0, yre.jsx)("div", {
          className: bre,
          children: (0, yre.jsx)(CompCustomButton, {
            icon: (0, yre.jsx)(xre, {}),
            name: "canvasControlsAddPage",
            "data-cy": "canvasControlsAddPage",
            onClick: () => t.addPage(),
            children: s("action.page.add"),
          }),
        })
      : null;
  })
);

export var Cre = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = VO(),
    { settingsPanelEnabled: n } = YR(),
    s = e("component.settings.toggle"),
    i = e("component.settings.toggle.description"),
    { width: o } = iL(),
    r = 0 !== o && o >= 480;
  return n
    ? (0, kre.jsx)("div", {
        className: wre,
        children: (0, kre.jsx)(CompCustomButton, {
          "aria-label": i,
          icon: (0, kre.jsx)(mY, {}),
          name: "show-settings",
          "data-cy": "show-settings",
          onClick: () => {
            t.ui.isPanelOpen("//ly.img.panel/settings")
              ? t.ui.closePanel("//ly.img.panel/settings")
              : t.ui.openPanel("//ly.img.panel/settings");
          },
          variant: "plain",
          children: r && s,
        }),
      })
    : null;
});
export var jre = function (e, t) {
  t.unstable_registerReactComponent("ly.img.settings.canvasBar", Cre),
    t.unstable_registerReactComponent("ly.img.page.add.canvasBar", vre);
};
export var _re = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      s = IV(),
      i = e.block.findAllSelected(),
      o = i.every((t) => e.block.isAllowedByScope(t, PH)),
      r = t.feature.isEnabled("ly.img.delete", { engine: e }),
      a = () => (
        o &&
          r &&
          (i.forEach((t) => {
            e.block.destroy(t);
          }),
          s("action.block.delete", { elements: i })),
        false
      );
    Xy(["del", "backspace"], a);
    const l = n("action.block.delete", { count: i?.length ?? 1 });
    return o && r
      ? (0, Sre.jsx)(Ly, {
          label: l,
          children: (0, Sre.jsx)(Wz, {
            "aria-label": l,
            name: "canvas-action-delete",
            onClick: a,
            icon: (0, Sre.jsx)(vZ, {}),
          }),
        })
      : null;
  })
);
export var Lre = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      { focusSelectedElement: s } = xI(),
      i = DO(),
      o = e.block
        .findAllSelected()
        .every((t) => e.block.isAllowedByScope(t, AH)),
      r = t.feature.isEnabled("ly.img.duplicate", { engine: e }),
      a = n("action.block.duplicate");
    return o && r
      ? (0, Ere.jsx)(Ly, {
          label: a,
          children: (0, Ere.jsx)(Wz, {
            "aria-label": a,
            name: "canvas-action-duplicate",
            onClick: async () => {
              const t = await i.duplicateSelectedDesignElements();
              s(),
                t.forEach((t) => {
                  e.block.setSelected(t, true);
                });
            },
            icon: (0, Ere.jsx)(SY, {}),
          }),
        })
      : null;
  })
);
export var Tre = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      s = DO(),
      { viewStyle: i } = YR(),
      { focusSelectedElement: o } = xI(),
      r = oI("ui/group") || "advanced" === i,
      a = t.feature.isEnabled("ly.img.group", { engine: e }),
      [l] = e.block.findAllSelected();
    return null != l && "//ly.img.ubq/group" === e.block.getType(l) && r && a
      ? (0, Bre.jsxs)(Wz, {
          name: "canvas-action-enter-group",
          onClick: () => {
            const [t] = e.block.findAllSelected();
            undefined !== t && (s.engine.block.enterGroup(t), o());
          },
          children: [(0, Bre.jsx)(Are, {}), n("action.enterGroup")],
        })
      : null;
  })
);
export var Fre = { up: "up", down: "down" };
export var Ire = { up: "left", down: "right" };
export var Hre = {
  VerticalStack: Fre,
  HorizontalStack: Ire,
  DepthStack: Ire,
  Free: Fre,
};
export var Nre = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, direction: t }) {
    const n = VO(),
      s = DO(),
      { t: i } = ZL(),
      { blocks: o } = YR(),
      r = o["//ly.img.ubq/page"].manage,
      a = oI("editor/managePages"),
      l = n.feature.isEnabled("ly.img.page.move", { engine: e });
    if (!r || !a || !l) return null;
    const [c] = e.block.findAllSelected(),
      u = e.scene.getPages(),
      d = u.indexOf(c),
      p = 0 === d,
      f = d === u.length - 1;
    if (p && "up" === t) return null;
    if (f && "down" === t) return null;
    const h = e.block.getEnum(e.scene.get(), "scene/layout"),
      m = Hre[h][t],
      g = i(
        "left" === m
          ? "action.pageMove.left"
          : "right" === m
          ? "action.pageMove.right"
          : "up" === m
          ? "action.pageMove.up"
          : "action.pageMove.down"
      );
    return (0, Dre.jsx)(Wz, {
      "aria-label": g,
      name: `canvas-action-manage-${t}`,
      onClick: () => {
        "up" === t
          ? s.moveSelectedPageUp()
          : "down" === t && s.moveSelectedPageDown();
      },
      icon: (0, Dre.jsxs)(Dre.Fragment, {
        children: [
          "up" === m && (0, Dre.jsx)(Vre, {}),
          "down" === m && (0, Dre.jsx)(Ore, {}),
          "left" === m && (0, Dre.jsx)(t3, {}),
          "right" === m && (0, Dre.jsx)(OW, {}),
        ],
      }),
      children: g,
    });
  })
);
export var zre = function () {
  return (0, Ure.jsx)(Nre, { direction: "down" });
};
export var qre = function () {
  return (0, $re.jsx)(Nre, { direction: "up" });
};
export var Gre = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      s = oI("ui/placeholder"),
      i = t.feature.isEnabled("ly.img.placeholder", { engine: e });
    return s && i
      ? (0, Qre.jsx)(Wz, {
          name: "canvas-action-placeholder-settings",
          withoutInput: true,
          children: ({ showLabel: e }) =>
            (0, Qre.jsx)(iX.Button, {
              variant: "plain",
              "data-cy": "canvas-action-placeholder-settings",
              children: e ? n("component.placeholder.create") : null,
            }),
        })
      : null;
  })
);
export var Wre = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      s = e.block.findAllSelected()[0];
    if (!t.feature.isEnabled("ly.img.replace", { engine: e }) || !s)
      return null;
    const i = e.block.getType(s),
      o = e.block.hasFill(s) ? e.block.getFill(s) : undefined,
      r = null != o && e.block.isValid(o) ? e.block.getType(o) : undefined,
      a = n("common.replace");
    let l;
    return (
      (l = n(
        "//ly.img.ubq/fill/video" === r
          ? "action.video.replace"
          : "//ly.img.ubq/audio" === i
          ? "action.audio.replace"
          : "//ly.img.ubq/fill/image" === r
          ? "action.image.replace"
          : "common.replace"
      )),
      (0, Zre.jsx)(g3, {
        children: ({
          replaceAssetLibraryPanelOpen: t,
          setReplaceAssetLibraryPanelOpen: n,
          canReplace: s,
        }) =>
          s
            ? (0, Zre.jsx)(Wz, {
                "aria-label": l,
                name: "canvas-action-replace",
                disabled: t,
                onClick: () => {
                  e.editor.setEditMode("Transform"), n(true);
                },
                icon: (0, Zre.jsx)(IY, {}),
                children: a,
              })
            : null,
      })
    );
  })
);
export var Jre = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      { focusSelectedElement: s } = xI(),
      i = t.feature.isEnabled("ly.img.group", { engine: e }),
      o = e.block.findAllSelected()[0],
      r = null != o ? e.block.getParent(o) : null,
      a = null != r && "//ly.img.ubq/group" === e.block.getType(r),
      l = rI(BH, r ?? undefined);
    return a && l && i
      ? (0, Xre.jsxs)(Wz, {
          name: "canvas-action-select-group",
          onClick: () => {
            null != r && (e.block.select(r), s());
          },
          children: [(0, Xre.jsx)(Yre, {}), n("action.selectGroup")],
        })
      : null;
  })
);
export var nae = {
  bold: ["ctrl+b", "command+b"],
  italic: ["ctrl+i", "command+i"],
};
export var sae = { bold: (0, tae.jsx)(rne, {}), italic: (0, tae.jsx)(lne, {}) };
export var iae = mayBeUseMemp(function ({ block: e, type: t }) {
  const n = YF(),
    { t: s } = ZL(),
    [i] = possibleHook3(e.textFontStyles),
    [o] = possibleHook3(e.textFontWeights),
    [r] = possibleHook3(e.canToggleBoldFont),
    [a] = possibleHook3(e.canToggleItalicFont),
    l = undefined !== o && "bold" === o[0],
    c = undefined !== i && "italic" === i[0],
    u = (!r && "bold" === t) || (!a && "italic" === t),
    d = "bold" === t ? l : c,
    p = () => {
      "bold" === t
        ? n.block.toggleBoldFont(e.id)
        : "italic" === t && n.block.toggleItalicFont(e.id);
    },
    f = (0, eae.useRef)(u);
  (0, eae.useEffect)(() => {
    f.current = u;
  }, [u]),
    Xy(nae[t], () => (f.current || p(), false), { global: true });
  const h = sae[t],
    m = s("bold" === t ? "typography.bold" : "typography.italic"),
    g = s("input.fontStyle.toggle", { style: m });
  return (0,
  tae.jsx)(Ly, { label: g, children: (0, tae.jsx)(Kz, { "aria-label": g, name: `canvas-action-text-run-${t}`, onClick: p, isDisabled: u, isActive: d, icon: h }) });
});
export var oae = iae;
export var aae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      n = O$();
    return rI(jH) && n && t.feature.isEnabled("ly.img.text.edit", { engine: e })
      ? (0, rae.jsx)(oae, { block: n, type: "bold" })
      : null;
  })
);
export var cae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      s = XR(),
      [i, o] = BQ("//ly.img.panel/inspector/fill/color", s);
    if (!rI(SH)) return null;
    if (!t.feature.isEnabled("ly.img.text.edit", { engine: e })) return null;
    const r = e.block.findAllSelected()[0],
      a = n("component.colorPicker.description"),
      l = PO(e.block.getTextColors(r), e.editor),
      c = Array.isArray(l) ? l[0] : l;
    return (0,
    lae.jsx)(Ly, { label: a, children: (0, lae.jsx)(Wz, { name: "color", "aria-label": a, "data-cy": "fill", onClick: () => o(!i), icon: (0, lae.jsx)(lb, { color: "object" == typeof c ? yb(c) : c }) }) });
  })
);
export var dae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = VO(),
      s = t("action.editText"),
      i = rI(CH),
      o = n.feature.isEnabled("ly.img.text.edit", { engine: e });
    return i && o
      ? (0, uae.jsx)(Wz, {
          "aria-label": s,
          name: "canvas-action-edit",
          onClick: () => {
            e.editor.setEditMode("Text"), e.editor._update();
          },
          icon: (0, uae.jsx)(gk, {}),
          children: s,
        })
      : null;
  })
);
export var fae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      n = O$();
    return rI(jH) && n && t.feature.isEnabled("ly.img.text.edit", { engine: e })
      ? (0, pae.jsx)(oae, { block: n, type: "italic" })
      : null;
  })
);
export var mae = {
  optionLabel: "UBQ_TextVariableAction-module__optionLabel--yRJ8W",
};
export var xae = mayBeUseMemp(function () {
  const { t: e } = ZL(),
    t = DO(),
    n = VO(),
    s = YF(),
    { placeholderChange: i } = KR(),
    o = (0, hae.useMemo)(
      () =>
        s.variable.findAll().map((t) => {
          const n = e(`variables.${t}.label`, { defaultValue: t });
          return { key: t, value: s.variable.getString(t), label: n };
        }),
      [s.variable, i]
    ),
    r = e("input.insertVariable");
  return 0 === o.length
    ? null
    : n.feature.isEnabled("ly.img.text.edit", { engine: s })
    ? (0, gae.jsx)(Kz, {
        name: "canvas-action-text-run-color",
        className: mae.block,
        withoutInput: true,
        children: ({ showLabel: e }) =>
          (0, gae.jsxs)(bw, {
            closeOnWheel: true,
            keyShortcutTrigger: ["ctrl+shift+l", "command+shift+l"],
            keyShortcutTriggerOptions: { preventDefault: true, global: true },
            doubleOffset: true,
            children: [
              (t) =>
                (0, gae.jsxs)(CompCustomButton, {
                  "aria-label": r,
                  name: "insert-variable",
                  variant: "plain",
                  ...t,
                  children: [(0, gae.jsx)(IconFontT, {}), e && r],
                }),
              () =>
                (0, gae.jsx)(bw.Options, {
                  value: null,
                  onChange: (e) => {
                    t.legacyApi.execute("ubq/inputs/keyboardkey", {
                      key: 0,
                      characters: `{{${e.key}}}`,
                      shiftIsHeld: false,
                      commandIsHeld: false,
                      optionIsHeld: false,
                      timestamp: Date.now(),
                    });
                  },
                  children: o.map((e) =>
                    (0, gae.jsx)(
                      bw.Option,
                      {
                        value: e,
                        children: (0, gae.jsx)("span", {
                          className: mae.optionLabel,
                          "data-cy": e.key,
                          children: e.label,
                        }),
                      },
                      e.value
                    )
                  ),
                }),
            ],
          }),
      })
    : null;
});
export var bae = xae;
export var yae = function (e, t) {
  t.unstable_registerReactComponent("ly.img.delete.canvasMenu", _re),
    t.unstable_registerReactComponent("ly.img.duplicate.canvasMenu", Lre),
    t.unstable_registerReactComponent("ly.img.placeholder.canvasMenu", Gre),
    t.unstable_registerReactComponent("ly.img.page.moveUp.canvasMenu", qre),
    t.unstable_registerReactComponent("ly.img.page.moveDown.canvasMenu", zre),
    t.unstable_registerReactComponent("ly.img.group.select.canvasMenu", Jre),
    t.unstable_registerReactComponent("ly.img.group.enter.canvasMenu", Tre),
    t.unstable_registerReactComponent("ly.img.replace.canvasMenu", Wre),
    t.unstable_registerReactComponent("ly.img.text.edit.canvasMenu", dae),
    t.unstable_registerReactComponent("ly.img.text.color.canvasMenu", cae),
    t.unstable_registerReactComponent("ly.img.text.bold.canvasMenu", aae),
    t.unstable_registerReactComponent("ly.img.text.italic.canvasMenu", fae),
    t.unstable_registerReactComponent("ly.img.text.variables.canvasMenu", bae);
};
export var vae = function (e, t) {
  e.ui.registerComponent(
    "ly.img.separator",
    ({ builder: { Separator: e } }) => {
      e("ly.img.separator");
    }
  ),
    t.unstable_registerReactComponent("ly.img.spacer", ek),
    e.ui.registerComponent(
      "ly.img.assetLibrary.dock",
      ({ builder: { Button: t }, engine: n, payload: s }) => {
        const i =
          "\n\nPlease provide a payload with entries, e.g. \n```\n{ id: 'ly.img.assetLibrary.dock', entries: ['ly.img.image', 'ly.img.video'] }\n```";
        if (!s || "ly.img.assetLibrary.dock" !== s.id)
          return void console.warn(
            `No payload found for 'ly.img.assetLibrary.dock'${i}`
          );
        const { id: o, key: r, label: a, icon: l, entries: c } = s;
        if (null == c || !Array.isArray(c))
          return void console.warn(
            `No valid entries value found for 'ly.img.assetLibrary.dock'${i}`
          );
        if (c.some((e) => "string" != typeof e))
          return void console.warn(
            `Entries value for 'ly.img.assetLibrary.dock' need to be all strings referring to asset library entries${i}`
          );
        null != a &&
          "string" != typeof a &&
          console.warn(
            "Label for 'ly.img.assetLibrary.dock' must be a string if provided"
          );
        const u = n.scene.getMode(),
          d = c.filter((t) => {
            const n = e.ui.getAssetLibraryEntry(t);
            return null != n && (null == n.sceneMode || n.sceneMode === u);
          });
        if (0 === d.length) return;
        let p = a;
        null == p && (p = `libraries.${o}.label`);
        const f = e.ui.isPanelOpen("//ly.img.panel/assetLibrary", {
            payload: { entries: d, title: p },
          }),
          h = e.ui.isPanelOpen("//ly.img.panel/assetLibrary.replace");
        let m = l;
        if (null == m && 1 === d.length) {
          const t = e.ui.getAssetLibraryEntry(d[0]);
          m = t?.icon;
        }
        t(r ?? o, {
          label: p,
          icon: m,
          isDisabled: h,
          isSelected: f,
          onClick: () => {
            f
              ? e.ui.closePanel("//ly.img.panel/assetLibrary")
              : e.ui.openPanel("//ly.img.panel/assetLibrary", {
                  payload: { entries: d, title: p },
                });
          },
        });
      }
    );
};
export var Sae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e, isDisabled: t }) {
    const n = VO(),
      { t: s } = ZL(),
      i = IV(),
      o = e.block.findAllSelected(),
      [r] = o,
      a = n.feature.isEnabled("ly.img.position", { engine: e }),
      l = rI(uH),
      c = oI("ui/fixLayers");
    if (null == r || !l || !a) return null;
    const u = e.block.isAlignable(o),
      d = e.block.isDistributable(o),
      p = 1 === o?.length,
      f = o?.length > 2,
      h = p && e.block.isAlwaysOnTop(r),
      m = p && e.block.isAlwaysOnBottom(r),
      g = (e) => ({
        name: e,
        scope: uH,
        tooltip: false,
        i18nKey: `action.${e}`,
        children: s(`action.${e}`),
        variant: "plain",
      }),
      x = (e) => ({ ...g(e), isDisabled: !u }),
      b = (e) => ({ ...g(e), isDisabled: !p }),
      y = (e) => ({ ...g(e), isDisabled: !d });
    function v() {
      null != r && (e.block.bringForward(r), i("action.arrange.bringForward"));
    }
    function w() {
      null != r && (e.block.bringToFront(r), i("action.arrange.toFront"));
    }
    function k() {
      null != r && (e.block.sendBackward(r), i("action.arrange.sendBackward"));
    }
    function C() {
      null != r && (e.block.sendToBack(r), i("action.arrange.toBack"));
    }
    return (0, jae.jsxs)(Cx, {
      children: [
        (e) =>
          (0, jae.jsx)(CompCustomButton, {
            name: "action.position",
            icon: (0, jae.jsx)(d6, {}),
            variant: "plain",
            isDisabled: !l || t,
            ...e,
            children: s("action.position"),
          }),
        () =>
          (0, jae.jsxs)(yC.Container, {
            children: [
              p &&
                (0, jae.jsxs)(jae.Fragment, {
                  children: [
                    (0, jae.jsx)(yC.Heading, {
                      level: 3,
                      children: s("action.arrange"),
                    }),
                    (0, jae.jsx)(yC.Item, {
                      children: (0, jae.jsx)(V9, {
                        ...b("arrange.toFront"),
                        icon: (0, jae.jsx)(q9, {}),
                        onClick: w,
                      }),
                    }),
                    (0, jae.jsx)(yC.Item, {
                      children: (0, jae.jsx)(V9, {
                        ...b("arrange.bringForward"),
                        icon: (0, jae.jsx)(a3, {}),
                        onClick: v,
                      }),
                    }),
                    (0, jae.jsx)(yC.Item, {
                      children: (0, jae.jsx)(V9, {
                        ...b("arrange.sendBackward"),
                        icon: (0, jae.jsx)(c3, {}),
                        onClick: k,
                      }),
                    }),
                    (0, jae.jsx)(yC.Item, {
                      children: (0, jae.jsx)(V9, {
                        ...b("arrange.toBack"),
                        icon: (0, jae.jsx)(f6, {}),
                        onClick: C,
                      }),
                    }),
                    c &&
                      (0, jae.jsxs)(jae.Fragment, {
                        children: [
                          (0, jae.jsx)(Sw, {}),
                          (0, jae.jsx)(yC.Item, {
                            children: (0, jae.jsx)(V9, {
                              name: "toggle-always_on_top",
                              icon: h
                                ? (0, jae.jsx)(IconCheckmark, {})
                                : (0, jae.jsx)(G9, {}),
                              i18nKey: "input.alwaysOnTop",
                              variant: "plain",
                              onClick: () => {
                                var t;
                                (t = !h), p && e.block.setAlwaysOnTop(r, t);
                              },
                              isDisabled: t || !l,
                              children: s("input.alwaysOnTop"),
                            }),
                          }),
                          (0, jae.jsx)(yC.Item, {
                            children: (0, jae.jsx)(V9, {
                              name: "toggle-always_on_bottom",
                              icon: m
                                ? (0, jae.jsx)(IconCheckmark, {})
                                : (0, jae.jsx)(G9, {}),
                              i18nKey: "input.alwaysOnBottom",
                              variant: "plain",
                              onClick: () => {
                                var t;
                                (t = !m), p && e.block.setAlwaysOnBottom(r, t);
                              },
                              isDisabled: t || !l,
                              children: s("input.alwaysOnBottom"),
                            }),
                          }),
                        ],
                      }),
                    (0, jae.jsx)(Sw, {}),
                  ],
                }),
              (0, jae.jsx)(yC.Heading, {
                level: 3,
                children: s(
                  p ? "action.align.toPage" : "action.align.elements"
                ),
              }),
              (0, jae.jsx)(yC.Item, {
                children: (0, jae.jsx)(V9, {
                  ...x("align.left"),
                  icon: (0, jae.jsx)(s6, {}),
                  onClick: () => {
                    e.block.alignHorizontally(o, "Left"),
                      i("action.align.left");
                  },
                }),
              }),
              (0, jae.jsx)(yC.Item, {
                children: (0, jae.jsx)(V9, {
                  ...x("align.horizontalCenter"),
                  icon: (0, jae.jsx)(t6, {}),
                  onClick: () => {
                    e.block.alignHorizontally(o, "Center"),
                      i("action.align.horizontalCenter");
                  },
                }),
              }),
              (0, jae.jsx)(yC.Item, {
                children: (0, jae.jsx)(V9, {
                  ...x("align.right"),
                  icon: (0, jae.jsx)(o6, {}),
                  onClick: () => {
                    e.block.alignHorizontally(o, "Right"),
                      i("action.align.right");
                  },
                }),
              }),
              (0, jae.jsx)(yC.Item, {
                children: (0, jae.jsx)(V9, {
                  ...x("align.top"),
                  icon: (0, jae.jsx)(a6, {}),
                  onClick: () => {
                    e.block.alignVertically(o, "Top"), i("action.align.top");
                  },
                }),
              }),
              (0, jae.jsx)(yC.Item, {
                children: (0, jae.jsx)(V9, {
                  ...x("align.verticalCenter"),
                  icon: (0, jae.jsx)(c6, {}),
                  onClick: () => {
                    e.block.alignVertically(o, "Center"),
                      i("action.align.verticalCenter");
                  },
                }),
              }),
              (0, jae.jsx)(yC.Item, {
                children: (0, jae.jsx)(V9, {
                  ...x("align.bottom"),
                  icon: (0, jae.jsx)(W9, {}),
                  onClick: () => {
                    e.block.alignVertically(o, "Bottom"),
                      i("action.align.bottom");
                  },
                }),
              }),
              f &&
                d &&
                (0, jae.jsxs)(jae.Fragment, {
                  children: [
                    (0, jae.jsx)(Sw, {}),
                    (0, jae.jsx)(yC.Heading, {
                      level: 3,
                      children: s("action.distribute"),
                    }),
                    (0, jae.jsx)(yC.Item, {
                      children: (0, jae.jsx)(V9, {
                        ...y("distribute.vertically"),
                        icon: (0, jae.jsx)(J9, {}),
                        onClick: () => {
                          e.block.distributeVertically(o),
                            i("action.distribute.vertically");
                        },
                      }),
                    }),
                    (0, jae.jsx)(yC.Item, {
                      children: (0, jae.jsx)(V9, {
                        ...y("distribute.horizontally"),
                        icon: (0, jae.jsx)(Y9, {}),
                        onClick: () => {
                          e.block.distributeHorizontally(o),
                            i("action.distribute.horizontally");
                        },
                      }),
                    }),
                  ],
                }),
            ],
          }),
      ],
    });
  })
);
export var Eae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = VO().feature.isEnabled("ly.img.replace", { engine: e }),
      [s] = e.block.findAllSelected();
    return null != s && "//ly.img.ubq/audio" === e.block.getType(s) && n
      ? (0, _ae.jsx)(g3, {
          children: ({
            replaceAssetLibraryPanelOpen: e,
            setReplaceAssetLibraryPanelOpen: n,
            canReplace: s,
          }) =>
            s
              ? (0, _ae.jsx)(CompCustomButton, {
                  variant: "plain",
                  "aria-label": t("action.audio.replace"),
                  name: "inspector-bar-replace",
                  disabled: e,
                  onClick: () => {
                    n(true);
                  },
                  icon: (0, _ae.jsx)(IY, {}),
                  children: t("common.replace"),
                })
              : null,
        })
      : null;
  })
);
export var Pae = {
  popoverContent: "UBQ_StrokeWidth-module__popoverContent--nObLJ",
  button: "UBQ_StrokeWidth-module__button--9tr3O",
};
export var Bae = function ({ isDisabled: e }) {
  const { t: t } = ZL(),
    n = rI(EH),
    s = X8(),
    i = oD(),
    [o] = possibleHook3(i.scene.designUnit),
    r = rX(o),
    a = O$(),
    [l] = possibleHook3(a?.hasStroke, false),
    [c] = possibleHook3(l && a?.strokeWidth, 0),
    u = parseFloat(c.toFixed(2)),
    d = t("property.strokeWidth.description");
  return s
    ? (0, Aae.jsxs)(Cx, {
        placement: "bottom",
        children: [
          (t, { isOpen: i }) =>
            (0, Aae.jsx)(Ly, {
              label: d,
              children: (0, Aae.jsxs)(CompCustomButton, {
                icon: (0, Aae.jsx)(GY, {}),
                name: "strokeWidth",
                "aria-label": d,
                variant: "plain",
                isDisabled: !n || !s || e,
                className: Pae.button,
                ...t,
                children: [
                  (0, Aae.jsxs)("span", {
                    className: (0, Lae.default)(Pae.label, Pae[r]),
                    children: [u, " ", r],
                  }),
                  i
                    ? (0, Aae.jsx)(IconChevronDown, {})
                    : (0, Aae.jsx)(IconChevronUp, {}),
                ],
              }),
            }),
          () =>
            (0, Aae.jsx)("div", {
              className: Pae.popoverContent,
              children: (0, Aae.jsx)(Yk, {
                children: (0, Aae.jsx)(wee.DefaultUI, {}),
              }),
            }),
        ],
      })
    : null;
};
export var Mae = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    deniedByScopeBehavior: t = "disable",
  }) {
    const n = VO(),
      s = YR().blocks["//ly.img.ubq/text"].colorEnabled,
      [i] = e.block.findAllSelected();
    if (null == i) return null;
    const o = n.feature.isEnabled("ly.img.stroke", { engine: e }),
      r = e.block.isAllowedByScope(i, EH);
    if (!o) return null;
    const a = e.block.getType(i),
      l = e.block.supportsShape(i) ? e.block.getShape(i) : undefined,
      c = null != l && e.block.isValid(l) ? e.block.getType(l) : undefined;
    return (!r && "hide" === t) ||
      "//ly.img.ubq/shape/line" === c ||
      ("//ly.img.ubq/text" === a && !s)
      ? null
      : (0, Tae.jsxs)(Tae.Fragment, {
          children: [
            (0, Tae.jsx)(w0.StrokeInBar, {
              panelId: "//ly.img.panel/inspector/stroke/color",
              groupId: "subInspector",
            }),
            (0, Tae.jsx)(Bae, {}),
            (0, Tae.jsx)(bee, {}),
            (0, Tae.jsx)(oee, {
              disablePositionControls: "//ly.img.ubq/text" === a,
            }),
          ],
        });
  })
);
export var Rae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO(),
      { t: n } = ZL(),
      {
        showBooleanOperations: s,
        operations: i,
        clickHandler: o,
        error: r,
        dismissError: a,
      } = ese();
    return t.feature.isEnabled("ly.img.combine", { engine: e }) && s
      ? (0, Oae.jsxs)(Oae.Fragment, {
          children: [
            (0, Oae.jsxs)(Cx, {
              children: [
                (e) =>
                  (0, Oae.jsx)(CompCustomButton, {
                    name: "booleanOperationsOptions",
                    icon: (0, Oae.jsx)($ne, {}),
                    variant: "plain",
                    ...e,
                    children: n("input.booleanoperations"),
                  }),
                ({ closePopover: e }) =>
                  (0, Oae.jsx)(yC.Container, {
                    children: i.map(({ operation: t, label: n, icon: s }) => {
                      const i = s;
                      return (0, Oae.jsx)(
                        yC.Item,
                        {
                          children: (0, Oae.jsx)(CompCustomButton, {
                            icon: (0, Oae.jsx)(i, {}),
                            name: t,
                            variant: "plain",
                            onClick: () => {
                              o(t, { selectAfter: true }), e();
                            },
                            children: n,
                          }),
                        },
                        t
                      );
                    }),
                  }),
              ],
            }),
            (0, Oae.jsx)(sse, { error: r, dismissError: a }),
          ],
        })
      : null;
  })
);

export var Fae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = t("input.cutoutSmoothing");
    return VO().feature.isEnabled("ly.img.cutout", { engine: e })
      ? (0, Dae.jsxs)(Cx, {
          children: [
            (e) =>
              (0, Dae.jsx)(Ly, {
                label: n,
                children: (0, Dae.jsx)(CompCustomButton, {
                  name: "cutoutSmoothingButton",
                  variant: "plain",
                  icon: (0, Dae.jsx)($8, {}),
                  ...e,
                  children: n,
                }),
              }),
            () =>
              (0, Dae.jsx)("div", {
                className: Vae,
                children: (0, Dae.jsx)(Kk, {
                  children: (0, Dae.jsx)(v8, {}),
                }),
              }),
          ],
        })
      : null;
  })
);
export var Iae = Fae;
export var Zae = {
  shortcutString: "UBQ_OptionsMenu-module__shortcutString--B9svW",
  optionsMenuRow: "UBQ_OptionsMenu-module__optionsMenuRow--J9DTY",
};
export function Kae({ shortcutKey: e }) {
  const { t: t } = ZL(),
    n = Nz(),
    s =
      "Mac OS" ===
      (function () {
        const { userAgent: e, platform: t } = window.navigator;
        let n = null;
        return (
          ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(t)
            ? (n = "Mac OS")
            : ["iPhone", "iPad", "iPod"].includes(t)
            ? (n = "iOS")
            : ["Win32", "Win64", "Windows", "WinCE"].includes(t)
            ? (n = "Windows")
            : /Android/.test(e)
            ? (n = "Android")
            : !n && /Linux/.test(t) && (n = "Linux"),
          n
        );
      })()
        ? (0, Wae.jsx)(Nae, {})
        : `${t("common.controlKey")} + `;
  return n
    ? null
    : (0, Wae.jsxs)("div", { className: Zae.shortcutString, children: [s, e] });
}
export function Yae({
  additionalActions: e,
  isDisabled: t,
  isCopyDisabled: n,
}) {
  const { t: s } = ZL(),
    i = DO(),
    o = YF(),
    r = VO(),
    a = XR(),
    { inspectorEnabled: l } = YR(),
    [, c] = BQ("//ly.img.panel/inspector", a),
    u = s("input.options.description"),
    { copy: d, paste: p } = i.copyPasteActions,
    f = rI(AH),
    h = r.feature.isEnabled("ly.img.duplicate", { engine: o }),
    m = f && h,
    g = [
      {
        name: "copyElement",
        label: s("action.block.copy"),
        icon: (0, Wae.jsx)(zae, {}),
        method: () => {
          d();
        },
        shortcutKey: "C",
        isDisabled: n || !m,
      },
      {
        name: "pasteElement",
        label: s("action.block.paste"),
        icon: (0, Wae.jsx)(qae, {}),
        method: () => {
          p();
        },
        shortcutKey: "V",
        isDisabled: false,
      },
    ];
  return (0, Wae.jsxs)(Cx, {
    children: [
      (e) =>
        (0, Wae.jsx)(Ly, {
          label: u,
          children: (0, Wae.jsx)(CompCustomButton, {
            name: "optionsMenu",
            "aria-label": u,
            variant: "plain",
            isDisabled: t,
            ...e,
            children: (0, Wae.jsxs)(Gb, {
              children: [(0, Wae.jsx)(CC, {}), (0, Wae.jsx)(wC, {})],
            }),
          }),
        }),
      ({ closePopover: t }) =>
        (0, Wae.jsxs)(yC.Container, {
          children: [
            e,
            !!e && (0, Wae.jsx)(Sw, {}),
            g.map(
              ({
                name: e,
                label: t,
                icon: n,
                method: s,
                shortcutKey: i,
                isDisabled: o,
              }) =>
                (0, Wae.jsx)(
                  yC.Item,
                  {
                    children: (0, Wae.jsxs)(CompCustomButton, {
                      icon: n,
                      name: e,
                      variant: "plain",
                      onClick: s,
                      isDisabled: o,
                      children: [t, (0, Wae.jsx)(Kae, { shortcutKey: i })],
                    }),
                  },
                  e
                )
            ),
            l &&
              (0, Wae.jsxs)(Wae.Fragment, {
                children: [
                  (0, Wae.jsx)(Sw, {}),
                  (0, Wae.jsx)(yC.Item, {
                    children: (0, Wae.jsx)(CompCustomButton, {
                      icon: (0, Wae.jsx)(Gae, {}),
                      name: "show-inspector",
                      variant: "plain",
                      onClick: () => {
                        t(), c(true);
                      },
                      children: s("action.showInspector"),
                    }),
                  }),
                ],
              }),
          ],
        }),
    ],
  });
}
export var Xae = mayBeUseMemp(({ ...e }) => {
  const t = rI(mH),
    n = rI(gH),
    { blocksOpacityEnabled: s } = YR();
  return (0, Wae.jsx)(Yae, {
    additionalActions:
      t || n
        ? (0, Wae.jsxs)(Wae.Fragment, {
            children: [
              s &&
                t &&
                (0, Wae.jsx)(
                  yC.Item,
                  {
                    children: (0, Wae.jsx)("div", {
                      className: Zae.optionsMenuRow,
                      children: (0, Wae.jsx)(y6, {}),
                    }),
                  },
                  "additionalActionsOpacity"
                ),
              n &&
                (0, Wae.jsx)(
                  yC.Item,
                  {
                    children: (0, Wae.jsx)("div", {
                      className: Zae.optionsMenuRow,
                      children: (0, Wae.jsx)(E6, {}),
                    }),
                  },
                  "additionalActionsBlendMode"
                ),
            ],
          })
        : null,
    ...e,
  });
});
export var Jae = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const t = VO().feature.isEnabled("ly.img.options", { engine: e }),
      n = YR(),
      s = !(oI("editor/managePages") && n.blocks["//ly.img.ubq/page"].manage),
      i = e.block.findAllSelected(),
      o = 0 === i.length,
      r = i.length > 1,
      [a] = i;
    if (!t) return null;
    if (r) return (0, Wae.jsx)(Yae, {});
    if (o) return (0, Wae.jsx)(Yae, { isCopyDisabled: true });
    switch (e.block.getType(a)) {
      case "//ly.img.ubq/text":
      case "//ly.img.ubq/group":
      case "//ly.img.ubq/graphic":
        return (0, Wae.jsx)(Xae, {});
      case "//ly.img.ubq/audio":
      case "//ly.img.ubq/cutout":
        return (0, Wae.jsx)(Yae, {});
      case "//ly.img.ubq/page":
        return (0, Wae.jsx)(Yae, { isCopyDisabled: s });
      default:
        return null;
    }
  })
);
export var ele =
  (mayBeUseMemp(Yae), "UBQ_ShapeOptions-module__shapePopoverContent--43lVm");
export var nle = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    deniedByScopeBehavior: t = "disable",
  }) {
    const { t: n } = ZL(),
      s = VO().feature.isEnabled("ly.img.shape.options", { engine: e }),
      [i] = e.block.findAllSelected();
    if (null == i || "sticker" === e.block.getKind(i)) return null;
    if (!(null != i && e.block.hasShape(i)) || !s) return null;
    const o = e.block.isAllowedByScope(i, LH),
      r = e.block.hasShape(i) ? e.block.getShape(i) : undefined,
      a = null != r && e.block.isValid(r) ? e.block.getType(r) : undefined;
    return (!o && "hide" === t) ||
      !(
        "//ly.img.ubq/shape/rect" === a ||
        "//ly.img.ubq/shape/line" === a ||
        "//ly.img.ubq/shape/star" === a ||
        "//ly.img.ubq/shape/polygon" === a
      )
      ? null
      : (0, tle.jsxs)(Cx, {
          placement: "bottom",
          disableFocusTrap: true,
          children: [
            (e, { isOpen: t }) =>
              (0, tle.jsx)(Ly, {
                label: n("input.shape.options"),
                children: (0, tle.jsxs)(CompCustomButton, {
                  icon: (0, tle.jsx)(IconShapes, {}),
                  name: "shapeOptions",
                  ...e,
                  variant: "plain",
                  children: [
                    n("input.shape"),
                    t
                      ? (0, tle.jsx)(IconChevronDown, {})
                      : (0, tle.jsx)(IconChevronUp, {}),
                  ],
                }),
              }),
            () =>
              (0, tle.jsxs)("div", {
                className: ele,
                children: [
                  (0, tle.jsx)(R8, {}),
                  (0, tle.jsx)(A8, {}),
                  (0, tle.jsx)(F8, {}),
                  (0, tle.jsx)(T8, {}),
                  (0, tle.jsx)(E8, {}),
                ],
              }),
          ],
        });
  })
);

export var rle = mayBeUseMemp(
  WithEngineComp(function ({
    engine: e,
    isDisabled: t,
    deniedByScopeBehavior: n = "disable",
  }) {
    const { t: s } = ZL(),
      i = VO().feature.isEnabled("ly.img.text.alignment", { engine: e }),
      o = rI(jH),
      [r] = e.block.findAllSelected();
    if (null == r || !i || (!o && "hide" === n)) return null;
    const a = e.block.getEnum(r, "text/horizontalAlignment"),
      l = [
        {
          name: "alignTextLeft",
          label: s("property.textAlignment.horizontal.left"),
          referenceValue: "Left",
          icon: (0, ole.jsx)(_te, {}),
        },
        {
          name: "alignTextHorizontalCenter",
          label: s("property.textAlignment.horizontal.center"),
          referenceValue: "Center",
          icon: (0, ole.jsx)(jte, {}),
        },
        {
          name: "alignTextRight",
          label: s("property.textAlignment.horizontal.right"),
          referenceValue: "Right",
          icon: (0, ole.jsx)(Lte, {}),
        },
      ],
      c = l.find((e) => e.referenceValue === a)?.icon,
      u = s("property.textAlignment.horizontal.description");
    return (0, ole.jsxs)(bw, {
      children: [
        (e) =>
          (0, ole.jsx)(Ly, {
            label: u,
            children: (0, ole.jsx)(CompCustomButton, {
              name: "textAlignmentSelect",
              "aria-label": u,
              variant: "plain",
              isDisabled: !o || t,
              ...e,
              children: (0, ole.jsxs)("div", {
                className: ile,
                children: [c, (0, ole.jsx)(wC, {})],
              }),
            }),
          }),
        () =>
          (0, ole.jsx)(bw.Options, {
            value: a,
            onChange: (t) => {
              var n;
              t && ((n = t), e.block.setEnum(r, "text/horizontalAlignment", n));
            },
            children: l.map(
              ({ referenceValue: e, icon: t, label: n, name: s }) =>
                (0, ole.jsx)(
                  bw.Option,
                  {
                    value: e,
                    children: (0, ole.jsxs)("div", {
                      className: sle,
                      children: [t, (0, ole.jsx)("span", { children: n })],
                    }),
                  },
                  s
                )
            ),
          }),
      ],
    });
  })
);
export var ale = rle;
export var lle = function (e, t) {
  t.unstable_registerReactComponent("ly.img.group.create.inspectorBar", () =>
    Cae.default.createElement(use, {})
  ),
    t.unstable_registerReactComponent("ly.img.group.ungroup.inspectorBar", () =>
      Cae.default.createElement(Bee, {})
    ),
    t.unstable_registerReactComponent("ly.img.adjustment.inspectorBar", () =>
      Cae.default.createElement(j2.ControlStack, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.filter.inspectorBar", () =>
      Cae.default.createElement(W2.ControlStack, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.effect.inspectorBar", () =>
      Cae.default.createElement(p5.ControlStack, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.blur.inspectorBar", () =>
      Cae.default.createElement(i2.Control, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.shadow.inspectorBar", () =>
      Cae.default.createElement(P0.Control, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.cutout.type.inspectorBar", () =>
      Cae.default.createElement(g8, { inBar: true })
    ),
    t.unstable_registerReactComponent("ly.img.cutout.offset.inspectorBar", () =>
      Cae.default.createElement(l8, {})
    ),
    t.unstable_registerReactComponent(
      "ly.img.cutout.smoothing.inspectorBar",
      () => Cae.default.createElement(Iae, {})
    ),
    t.unstable_registerReactComponent("ly.img.fill.inspectorBar", () =>
      Cae.default.createElement(
        Cae.default.Fragment,
        {},
        Cae.default.createElement(v4.Control, {
          inBar: true,
          deniedByScopeBehavior: "hide",
        }),
        Cae.default.createElement(Ote.InBar, {
          deniedByScopeBehavior: "hide",
        })
      )
    ),
    t.unstable_registerReactComponent("ly.img.text.typeFace.inspectorBar", () =>
      Cae.default.createElement(Sne, {
        buttonVariant: "plain",
        showIcon: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.text.fontSize.inspectorBar", () =>
      Cae.default.createElement($te, {
        inBar: true,
        inlineIcon: Cae.default.createElement(kae, {}),
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.shape.options.inspectorBar", () =>
      Cae.default.createElement(nle, { deniedByScopeBehavior: "hide" })
    ),
    t.unstable_registerReactComponent("ly.img.audio.replace.inspectorBar", () =>
      Cae.default.createElement(Eae, {})
    ),
    t.unstable_registerReactComponent("ly.img.text.bold.inspectorBar", () =>
      Cae.default.createElement(pne, {
        type: "bold",
        buttonProps: { variant: "plain" },
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.text.italic.inspectorBar", () =>
      Cae.default.createElement(pne, {
        type: "italic",
        buttonProps: { variant: "plain" },
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent(
      "ly.img.text.alignHorizontal.inspectorBar",
      () => Cae.default.createElement(ale, { deniedByScopeBehavior: "hide" })
    ),
    t.unstable_registerReactComponent("ly.img.combine.inspectorBar", () =>
      Cae.default.createElement(Rae, {})
    ),
    t.unstable_registerReactComponent("ly.img.trim.inspectorBar", () =>
      Cae.default.createElement(U5.Control, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.trimControls.inspectorBar", () =>
      Cae.default.createElement(U5.InBarInspector, {})
    ),
    t.unstable_registerReactComponent("ly.img.crop.inspectorBar", () =>
      Cae.default.createElement(y1.Control, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.cropControls.inspectorBar", () =>
      Cae.default.createElement(y1.InBarInspector, {
        deniedByScopeBehavior: "hide",
      })
    ),
    t.unstable_registerReactComponent("ly.img.volume.inspectorBar", () =>
      Cae.default.createElement(t4.InBar, { deniedByScopeBehavior: "hide" })
    ),
    t.unstable_registerReactComponent("ly.img.stroke.inspectorBar", () =>
      Cae.default.createElement(Mae, { deniedByScopeBehavior: "hide" })
    ),
    t.unstable_registerReactComponent("ly.img.position.inspectorBar", () =>
      Cae.default.createElement(Sae, {})
    ),
    t.unstable_registerReactComponent("ly.img.options.inspectorBar", () =>
      Cae.default.createElement(Jae, {})
    ),
    t.unstable_registerReactComponent("ly.img.animations.inspectorBar", () =>
      Cae.default.createElement(oY.Control, {
        inBar: true,
        deniedByScopeBehavior: "hide",
      })
    );
};
export var backNavigationComponent = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = VO(),
      s = FI(),
      {
        callbacks: { onBack: i },
      } = s,
      o = ax(),
      [r, a] = (0, cle.useState)("Idle"),
      l = (0, cle.useCallback)(async () => {
        if (null != i && "function" == typeof i) {
          a("Running");
          const e = i();
          e
            ? await e
                .then(() => {
                  o.current && a("Idle");
                })
                .catch(() => {
                  o.current && a("Failed");
                })
            : o.current && a("Idle");
        } else alert("Please configure the 'onBack' callback");
      }, [i, o]),
      c = t("component.topbar.back");
    return n.feature.isEnabled("ly.img.navigate.back", { engine: e })
      ? (0, ule.jsx)(CompCustomButton, {
          icon: (0, ule.jsx)(wQ, {}),
          name: "onBack",
          "data-cy": "tb-onBack",
          "aria-label": c,
          onClick: l,
          isLoading: "Idle" !== r,
          children: c,
        })
      : null;
  })
);

export var vle = (e, t) =>
  new Promise((n) => {
    const s = document.createElement("a");
    s.setAttribute("href", window.URL.createObjectURL(e)),
      s.setAttribute("download", t),
      (s.style.display = "none"),
      document.body.appendChild(s),
      s.click(),
      document.body.removeChild(s),
      n();
  });
export var wle = () => (e, t) =>
  vle(e, `cesdk-archive-${new Date().toISOString()}${t}`);
export var kle = () => {
  const e = FI(),
    { onDownload: t } = e.callbacks;
  return "download" === t
    ? (e) => {
        const t = new Blob([e], { type: "text/plain;charset=UTF-8" });
        return vle(t, `cesdk-${new Date().toISOString()}.scene`);
      }
    : t;
};
export var jle = {
  [MimeType.Png]: "png",
  [MimeType.Jpeg]: "jpeg",
  [MimeType.WebP]: "webp",
  [MimeType.Tga]: "tga",
  [MimeType.Wav]: "wav",
  [MimeType.Mp4]: "mp4",
  [MimeType.QuickTime]: "mov",
  [MimeType.Binary]: "bin",
  [MimeType.Pdf]: "pdf",
  [MimeType.Zip]: "zip",
};
export var Sle = (e, t) => {
  const n = `cesdk-${new Date().toISOString()}.${
    ((s = t.mimeType), jle[s] || "unknown")
  }`;
  var s;
  return vle(e[0], n);
};
export var _le = () => {
  const e = FI(),
    { onLoadArchive: t } = e.callbacks;
  return "uploadArchive" === t
    ? () => {
        const e = document.createElement("input");
        return (
          e.setAttribute("type", "file"),
          e.setAttribute("accept", ".zip"),
          (e.style.display = "none"),
          document.body.appendChild(e),
          new Promise((t, n) => {
            (e.onchange = (s) => {
              const i = s.target,
                o = i.files?.[0];
              if (undefined === o) n(new Error("No files selected"));
              else {
                const e = URL.createObjectURL(o);
                e ? t(e) : n(new Error("No valid archive could be read"));
              }
              (e.onchange = null), (e.value = "");
            }),
              e.click();
          })
        );
      }
    : t;
};
export var Ele = () => {
  const e = FI(),
    { onLoad: t } = e.callbacks;
  return "upload" === t
    ? () => {
        const e = document.createElement("input");
        return (
          e.setAttribute("type", "file"),
          e.setAttribute("accept", ".scene"),
          (e.style.display = "none"),
          document.body.appendChild(e),
          new Promise((t, n) => {
            (e.onchange = (s) => {
              const i = s.target,
                o = i.files?.[0];
              if (undefined === o) n(new Error("No files selected"));
              else {
                const e = new FileReader();
                e.readAsText(o, "UTF-8"),
                  (e.onload = (e) => {
                    const s = e.target?.result;
                    s && "string" == typeof s
                      ? t(s)
                      : n(new Error("No valid scene could be read"));
                  });
              }
              (e.onchange = null), (e.value = "");
            }),
              e.click();
          })
        );
      }
    : t;
};
export var Ple = function (e) {
  return (t) => {
    function n(n) {
      return (0, Lle.jsx)(U4, { ...e, children: (0, Lle.jsx)(t, { ...n }) });
    }
    return (n.displayName = `withRenderIf(${t.displayName || t.name})`), n;
  };
};

export var Tle = {
  default: (0, Ble.jsx)(IconPhoto, {}),
  download: (0, Ble.jsx)(fle, {}),
  upload: (0, Ble.jsx)(IconUpload, {}),
  save: (0, Ble.jsx)(mle, {}),
};
export var actionsNavigationComponent = Ple({
  condition: (e) => !!e.scene.getMode(),
})(
  mayBeUseMemp(
    WithEngineComp(function ({ engine: e }) {
      const { t: t } = ZL(),
        n = VO(),
        s = DO(),
        i = FI(),
        o = YR(),
        [, { previewRole: r }] = KF(),
        { callbacks: a } = i,
        { actionEnabled: l } = o,
        c = (function () {
          const {
            callbacks: { onExport: e },
          } = FI();
          return "download" === e ? Sle : e;
        })(),
        u = kle(),
        d = wle(),
        p = Ele(),
        f = _le(),
        h = e.scene.getMode(),
        m = t("component.fileOperation.importScene"),
        g = t("component.fileOperation.importArchive"),
        x = t("component.fileOperation.exportImage"),
        b = t("component.fileOperation.exportPDF"),
        y = t("component.fileOperation.exportVideo"),
        v = t("component.fileOperation.save"),
        w = t("component.fileOperation.archiveScene"),
        k = t("component.fileOperation.exportScene"),
        C = t("component.fileOperation.share"),
        j = t("component.fileOperation.more"),
        S = (0, yle.useRef)(true),
        [_, E] = (0, yle.useState)({ state: "Idle" }),
        L = "Saving" === _.state;
      function P(e, t, n) {
        const s = async (...s) => {
          if (null != t) {
            E({ name: e, state: "Saving" });
            try {
              await Promise.resolve(n && n(t, ...s)),
                requestAnimationFrame(() => {
                  S.current && E({ name: e, state: "Saved" });
                });
            } catch (t) {
              console.error(t), S.current && E({ name: e, state: "Failed" });
            }
          } else alert(`Please configure the ${e} callback`);
        };
        return (s.callbackName = e), s;
      }
      const A = P("onLoad", p, async (t) => {
          const n = t();
          n
            ? Promise.resolve(n)
                .then((t) => e.scene.loadFromString(t))
                .then(() => {
                  s.getUIEventEmitter().emit("action.scene.load");
                })
            : console.warn("onLoad did not return valid string or promise");
        }),
        B = P("onLoadArchive", f, async (t) => {
          const n = t();
          n
            ? Promise.resolve(n)
                .then((t) => e.scene.loadFromArchiveURL(t))
                .then(() => {
                  s.getUIEventEmitter().emit("action.scene.load");
                })
            : console.warn(
                "onLoadArchive did not return valid string or promise"
              );
        }),
        T = (e) =>
          P(`onExport_${e}`, c, async (t) => {
            let n;
            e === MimeType.Pdf && (n = s.getScene()),
              e === MimeType.Png &&
                (n = s.getPageManager().getSelectedOrCurrentPage());
            const i = { mimeType: e, block: n },
              o = await s.export(i);
            return t(o.blobs, o.options);
          }),
        M = (0, yle.useCallback)(async () => {
          const t = new AbortController(),
            i = {
              type: "loading",
              size: "large",
              content: {
                title: "dialog.export.title",
                message: "dialog.export.message",
              },
              actions: [
                {
                  label: "dialog.export.action",
                  onClick: ({ id: e }) => {
                    n.ui.updateDialog(e, { ...o });
                  },
                },
              ],
              cancel: undefined,
              clickOutsideToClose: false,
            },
            o = {
              content: {
                title: "dialog.export.abort.title",
                message: "dialog.export.abort.message",
              },
              actions: [
                {
                  label: "dialog.export.action",
                  color: "danger",
                  onClick: ({ id: e }) => {
                    n.ui.closeDialog(e),
                      t.abort(),
                      E({ name: "onVideoExport", state: "Idle" });
                  },
                },
              ],
              cancel: {
                label: "action.continue",
                onClick: ({ id: e }) => {
                  n.ui.updateDialog(e, i);
                },
              },
              clickOutsideToClose: false,
            },
            r = {
              type: "success",
              content: {
                title: "dialog.export.success.title",
                message: "dialog.export.success.message",
              },
              actions: [
                {
                  label: "common.close",
                  onClick: ({ id: e }) => {
                    n.ui.closeDialog(e);
                  },
                },
              ],
              cancel: undefined,
              clickOutsideToClose: true,
            },
            a = {
              type: "error",
              content: {
                title: "dialog.export.error.title",
                message: [
                  "dialog.export.error.message.1",
                  "dialog.export.error.message.2",
                ],
              },
              actions: [
                {
                  label: "common.close",
                  onClick: ({ id: e }) => {
                    n.ui.closeDialog(e);
                  },
                },
              ],
              cancel: undefined,
              clickOutsideToClose: true,
            },
            l = n.ui.showDialog({ ...i, progress: 0 });
          try {
            s.disableAllSoloPlayback();
            const i = e.scene.getCurrentPage();
            if (null === i || !e.block.isValid(i))
              throw new Error(
                "Can't export video without a page to be exported"
              );
            const o = await e.block.exportVideo(
              i,
              MimeType.Mp4,
              (e, t, s) => {
                n.ui.updateDialog(l, { progress: { value: e, max: s } });
              },
              { abortSignal: t.signal }
            );
            return n.ui.updateDialog(l, r), o;
          } catch (e) {
            n.ui.updateDialog(l, a);
          }
        }, [n.ui, e.block, e.scene, s]),
        O = P("onVideoExport", c, async (e) => {
          const t = await M();
          if (t) return e([t], { mimeType: MimeType.Mp4 });
        }),
        R = P("onDownload", u, async (t) => t(await e.scene.saveToString())),
        V = P("onSave", a.onSave, async (t) => t(await e.scene.saveToString())),
        D = P("onArchive", d, async (t) =>
          t(await e.scene.saveToArchive(), ".zip")
        ),
        F = P("onShare", a.onShare, async (t) =>
          t(await e.scene.saveToString())
        ),
        I = {
          show: l.load && null === r,
          name: A.callbackName,
          children: m,
          handler: A,
          icon: (0, Ble.jsx)(IconUpload, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === A.callbackName && "Saving" === _.state,
          "data-cy": "tb-loadScene",
        },
        H = {
          show: l.load && null === r,
          name: B.callbackName,
          children: g,
          handler: B,
          icon: (0, Ble.jsx)(IconUpload, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === B.callbackName && "Saving" === _.state,
          "data-cy": "tb-loadArchive",
        },
        N = {
          show: l.save && null === r,
          name: V.callbackName,
          children: v,
          handler: V,
          icon: (0, Ble.jsx)(mle, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === V.callbackName && "Saving" === _.state,
          "data-cy": "tb-saveScene",
        },
        U = {
          show: l.archive,
          name: D.callbackName,
          children: w,
          handler: D,
          icon: (0, Ble.jsx)(fle, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === D.callbackName && "Saving" === _.state,
          "data-cy": "tb-archiveScene",
        },
        z = {
          show: l.share,
          name: F.callbackName,
          children: C,
          handler: F,
          icon: (0, Ble.jsx)(xle, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === F.callbackName && "Saving" === _.state,
          "data-cy": "tb-shareScene",
        },
        $ = {
          show: l.download,
          name: R.callbackName,
          children: k,
          handler: R,
          icon: (0, Ble.jsx)(fle, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === R.callbackName && "Saving" === _.state,
          "data-cy": "tb-downloadScene",
        },
        q = T(MimeType.Png),
        Q = {
          show: "Design" === h && l.exportFormats.includes(MimeType.Png),
          name: q.callbackName,
          children: x,
          handler: q,
          icon: (0, Ble.jsx)(IconPhoto, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === q.callbackName && "Saving" === _.state,
          "data-cy": "tb-exportScene",
        },
        G = T(MimeType.Pdf),
        Z = {
          show: "Design" === h && l.exportFormats.includes(MimeType.Pdf),
          name: G.callbackName,
          children: b,
          handler: G,
          icon: (0, Ble.jsx)(IconPhoto, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === G.callbackName && "Saving" === _.state,
          "data-cy": "tb-exportPDFScene",
        },
        W = {
          show: "Video" === h && l.exportFormats.includes(MimeType.Mp4),
          name: O.callbackName,
          children: y,
          handler: O,
          icon: (0, Ble.jsx)(IconPlayOutline, {}),
          isDisabled: "Saving" === _.state,
          isLoading: _.name === O.callbackName && "Saving" === _.state,
          "data-cy": "tb-exportVideoScene",
        },
        K = [
          ...(i.ui?.elements?.navigation?.action?.custom?.map(
            (
              {
                callback: e = () => {},
                label: n = "UNDEFINED",
                iconName: s = "default",
              },
              i
            ) => {
              const o = `customAction-${n}-${s}`;
              return {
                show: true,
                name: o,
                children: t(n),
                handler: P(o, e, (e) => e()),
                icon: Tle[s],
                isDisabled: "Saving" === _.state,
                isLoading: _.name === o && "Saving" === _.state,
                "data-cy": `tb-customAction-${i}`,
              };
            }
          ) ?? []),
          N,
          Q,
          Z,
          W,
          z,
          $,
          U,
          I,
          H,
        ]
          .filter((e) => e.show)
          .map(({ show: e, ...t }) => t);
      if (0 === K.length) return null;
      const { handler: Y, ...X } = K[0];
      return (0, Ble.jsxs)(CompButtonGroup, {
        dataCy: "action-buttons",
        children: [
          (0, Ble.jsx)(CompCustomButton, {
            ...X,
            onClick: Y,
            color: "accent",
          }),
          K.length > 1 &&
            (0, Ble.jsxs)(Cx, {
              placement: "bottom",
              disableFocusTrap: L,
              children: [
                (e, { isOpen: t }) =>
                  (0, Ble.jsx)(Ly, {
                    label: j,
                    children: (0, Ble.jsx)(CompCustomButton, {
                      name: "ctaMore",
                      "data-cy": "ctaMore",
                      "aria-label": j,
                      isDisabled: L,
                      ...e,
                      color: "accent",
                      children: t
                        ? (0, Ble.jsx)(IconChevronDown, {})
                        : (0, Ble.jsx)(IconChevronUp, {}),
                    }),
                  }),
                ({ closePopover: e }) =>
                  (0, Ble.jsx)("ul", {
                    className: Ale,
                    children: K.slice(1).map(({ handler: t, ...n }) =>
                      (0, Ble.jsx)(
                        "li",
                        {
                          children: (0, Ble.jsx)(CompCustomButton, {
                            onClick: async () => {
                              await t(), e();
                            },
                            variant: "plain",
                            ...n,
                          }),
                        },
                        n.name
                      )
                    ),
                  }),
              ],
            }),
        ],
      });
    })
  )
);
export var closeNavigationComponent = mayBeUseMemp(
  WithEngineComp(function ({ engine: e }) {
    const { t: t } = ZL(),
      n = VO(),
      s = FI(),
      {
        callbacks: { onClose: i },
      } = s,
      o = ax(),
      [r, a] = (0, Ole.useState)("Idle"),
      l = (0, Ole.useCallback)(async () => {
        if (null != i && "function" == typeof i) {
          a("Running");
          const e = i();
          e
            ? await e
                .then(() => {
                  o.current && a("Idle");
                })
                .catch(() => {
                  o.current && a("Failed");
                })
            : o.current && a("Idle");
        } else alert("Please configure the 'onClose' callback");
      }, [i, o]),
      c = t("component.topbar.close");
    return n.feature.isEnabled("ly.img.navigate.close", { engine: e })
      ? (0, Rle.jsx)(CompCustomButton, {
          icon: (0, Rle.jsx)(mv, {}),
          name: "closeScene",
          "data-cy": "tb-closeScene",
          "aria-label": c,
          onClick: l,
          isLoading: "Idle" !== r,
          children: c,
        })
      : null;
  })
);
export var previewNavigationComponent = mayBeUseMemp(function () {
  const e = VO(),
    t = DO(),
    { t: n } = ZL(),
    s = Nz(),
    i = e.feature.isEnabled("ly.img.preview", { engine: t.engine }),
    o = XR(),
    [r, a] = BQ("//ly.img.panel/inspector/placeholderSettings", o),
    [, l] = BQ("//ly.img.panel/inspector", o),
    c = oD(),
    { scene: u } = c,
    [d, p] = possibleHook3(u.playing, false),
    [, { configuredRole: f, previewRole: h, setPreviewRole: m }] = KF(),
    g = null !== h,
    x = n("common.mode.preview"),
    b = (0, Nle.useRef)(null);
  return (
    (0, Nle.useEffect)(() =>
      t.engine.editor.onHistoryUpdated(() => {
        g ||
          null === b.current ||
          (t.engine.block.setPlaybackTime(t.engine.scene.get(), b.current),
          (b.current = null));
      })
    ),
    "Creator" === f && i && !s
      ? (0, Ule.jsx)(CompCustomButton, {
          icon: g ? (0, Ule.jsx)(Hle, {}) : (0, Ule.jsx)(Fle, {}),
          name: "previewButton",
          isActive: g,
          onClick: () => {
            d && p(false),
              LB(
                g
                  ? () => {
                      t.getUndoManager().deactivatePreviewUndoStack(), m(null);
                    }
                  : async () => {
                      m("Adopter"),
                        r &&
                          (a(false),
                          await new Promise((e) => {
                            window.setTimeout(e, 500);
                          })),
                        t.getUndoManager().activatePreviewUndoStack();
                      t.engine.block.isAllowedByScope(
                        t.engine.block.findAllSelected()[0] ?? t.getScene(),
                        BH
                      ) ||
                        (l(false),
                        t.engine.block
                          .findAllSelected()
                          .forEach((e) =>
                            t.engine.block.setSelected(e, false)
                          )),
                        t.engine.editor.setSettingEnum(
                          "doubleClickSelectionMode",
                          "Direct"
                        ),
                        (b.current = t.engine.block.getPlaybackTime(
                          t.engine.scene.get()
                        ));
                    }
              );
          },
          children: x,
        })
      : null
  );
});

export var undoRedoNavigationComponent = Ple({
  condition: (e) => null != e.scene.get(),
})(
  mayBeUseMemp(function () {
    const e = DO().getUndoManager(),
      { t: t } = ZL(),
      n = t("component.undo.undo"),
      s = t("component.undo.redo"),
      [i] = possibleHook3(e.canUndo, false),
      [o] = possibleHook3(e.canRedo, false);
    Xy(["ctrl+z", "command+z"], () => (e.undo(), false)),
      Xy(["ctrl+shift+z", "command+shift+z"], () => (e.redo(), false));
    const { width: r } = iL("embedViewport"),
      a = 0 !== r && r >= 480;
    return (0,
    Wle.jsx)("div", { className: Zle, "data-cy": "undo-redo-buttons", children: (0, Wle.jsxs)(CompButtonGroup, { children: [(0, Wle.jsx)(CompCustomButton, { icon: (0, Wle.jsx)(IconUndo, {}), name: "undo", isDisabled: !i, "aria-label": n, onClick: e.undo, children: a && n }), (0, Wle.jsx)(Ly, { label: s, children: (0, Wle.jsx)(CompCustomButton, { name: "redo", isDisabled: !o, "aria-label": s, onClick: e.redo, children: (0, Wle.jsx)(IconRedo, {}) }) })] }) });
  })
);
export var ice = {
  label: "UBQ_NavigationBarZoomControls-module__label--hxaR-",
  optionsMenu: "UBQ_NavigationBarZoomControls-module__optionsMenu--VYvd9",
  option: "UBQ_NavigationBarZoomControls-module__option--xgHwa",
  checkIcon: "UBQ_NavigationBarZoomControls-module__checkIcon--42pMU",
  shortcutContainer:
    "UBQ_NavigationBarZoomControls-module__shortcutContainer--nioUn",
};
export var rce = 0.125;
export var ace = 32;
export function cce({
  label: e,
  shortcut: t,
  shortcutLabel: n = "",
  onZoomChange: s,
  children: i,
  isDisabled: o,
  ...r
}) {
  return (0, oce.jsx)(CompCustomButton, {
    name: e,
    "aria-label": `${e} ${n}`,
    className: ice.option,
    variant: "plain",
    onClick: s,
    isDisabled: o,
    ...r,
    children: i ?? e,
  });
}
export var zoomNavigationComponent = function () {
  const e = FI();
  return oI("editor/zoom") && e ? (0, oce.jsx)(CanvasZooming, {}) : null;
};

export {
  // ConfigTypes as ConfigTypes,
  LogLevel as LogLevel,
  MimeType as MimeType,
  // UserInterfaceElements,
  CreativeEditorSDK as default,
  supportsBrowser as supportsBrowser,
  supportsVideo as supportsVideo,
  supportsVideoExport as supportsVideoExport,
  supportsWasm as supportsWasm,
};
export function eb({ children: e }) {
  return (0, Xx.jsx)("ul", { className: Kx, children: e });
}
